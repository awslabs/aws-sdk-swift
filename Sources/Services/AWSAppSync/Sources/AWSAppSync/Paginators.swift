//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AppSyncClient {
    /// Paginate over `[ListApiKeysOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApiKeysInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApiKeysOutput`
    public func listApiKeysPaginated(input: ListApiKeysInput) -> ClientRuntime.PaginatorSequence<ListApiKeysInput, ListApiKeysOutput> {
        return ClientRuntime.PaginatorSequence<ListApiKeysInput, ListApiKeysOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApiKeys(input:))
    }
}

extension ListApiKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApiKeysInput {
        return ListApiKeysInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListApiKeysInput, OperationStackOutput == ListApiKeysOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listApiKeysPaginated`
    /// to access the nested member `[AppSyncClientTypes.ApiKey]`
    /// - Returns: `[AppSyncClientTypes.ApiKey]`
    public func apiKeys() async throws -> [AppSyncClientTypes.ApiKey] {
        return try await self.asyncCompactMap { item in item.apiKeys }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListApisOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApisInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApisOutput`
    public func listApisPaginated(input: ListApisInput) -> ClientRuntime.PaginatorSequence<ListApisInput, ListApisOutput> {
        return ClientRuntime.PaginatorSequence<ListApisInput, ListApisOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApis(input:))
    }
}

extension ListApisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApisInput {
        return ListApisInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListApisInput, OperationStackOutput == ListApisOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listApisPaginated`
    /// to access the nested member `[AppSyncClientTypes.Api]`
    /// - Returns: `[AppSyncClientTypes.Api]`
    public func apis() async throws -> [AppSyncClientTypes.Api] {
        return try await self.asyncCompactMap { item in item.apis }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListChannelNamespacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChannelNamespacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChannelNamespacesOutput`
    public func listChannelNamespacesPaginated(input: ListChannelNamespacesInput) -> ClientRuntime.PaginatorSequence<ListChannelNamespacesInput, ListChannelNamespacesOutput> {
        return ClientRuntime.PaginatorSequence<ListChannelNamespacesInput, ListChannelNamespacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listChannelNamespaces(input:))
    }
}

extension ListChannelNamespacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChannelNamespacesInput {
        return ListChannelNamespacesInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListChannelNamespacesInput, OperationStackOutput == ListChannelNamespacesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChannelNamespacesPaginated`
    /// to access the nested member `[AppSyncClientTypes.ChannelNamespace]`
    /// - Returns: `[AppSyncClientTypes.ChannelNamespace]`
    public func channelNamespaces() async throws -> [AppSyncClientTypes.ChannelNamespace] {
        return try await self.asyncCompactMap { item in item.channelNamespaces }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListDataSourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutput`
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDataSourcesInput, OperationStackOutput == ListDataSourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSourcesPaginated`
    /// to access the nested member `[AppSyncClientTypes.DataSource]`
    /// - Returns: `[AppSyncClientTypes.DataSource]`
    public func dataSources() async throws -> [AppSyncClientTypes.DataSource] {
        return try await self.asyncCompactMap { item in item.dataSources }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListDomainNamesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDomainNamesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDomainNamesOutput`
    public func listDomainNamesPaginated(input: ListDomainNamesInput) -> ClientRuntime.PaginatorSequence<ListDomainNamesInput, ListDomainNamesOutput> {
        return ClientRuntime.PaginatorSequence<ListDomainNamesInput, ListDomainNamesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDomainNames(input:))
    }
}

extension ListDomainNamesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainNamesInput {
        return ListDomainNamesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDomainNamesInput, OperationStackOutput == ListDomainNamesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDomainNamesPaginated`
    /// to access the nested member `[AppSyncClientTypes.DomainNameConfig]`
    /// - Returns: `[AppSyncClientTypes.DomainNameConfig]`
    public func domainNameConfigs() async throws -> [AppSyncClientTypes.DomainNameConfig] {
        return try await self.asyncCompactMap { item in item.domainNameConfigs }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListFunctionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionsOutput`
    public func listFunctionsPaginated(input: ListFunctionsInput) -> ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFunctions(input:))
    }
}

extension ListFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionsInput {
        return ListFunctionsInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionsInput, OperationStackOutput == ListFunctionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionsPaginated`
    /// to access the nested member `[AppSyncClientTypes.FunctionConfiguration]`
    /// - Returns: `[AppSyncClientTypes.FunctionConfiguration]`
    public func functions() async throws -> [AppSyncClientTypes.FunctionConfiguration] {
        return try await self.asyncCompactMap { item in item.functions }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListGraphqlApisOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGraphqlApisInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGraphqlApisOutput`
    public func listGraphqlApisPaginated(input: ListGraphqlApisInput) -> ClientRuntime.PaginatorSequence<ListGraphqlApisInput, ListGraphqlApisOutput> {
        return ClientRuntime.PaginatorSequence<ListGraphqlApisInput, ListGraphqlApisOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGraphqlApis(input:))
    }
}

extension ListGraphqlApisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGraphqlApisInput {
        return ListGraphqlApisInput(
            apiType: self.apiType,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListGraphqlApisInput, OperationStackOutput == ListGraphqlApisOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGraphqlApisPaginated`
    /// to access the nested member `[AppSyncClientTypes.GraphqlApi]`
    /// - Returns: `[AppSyncClientTypes.GraphqlApi]`
    public func graphqlApis() async throws -> [AppSyncClientTypes.GraphqlApi] {
        return try await self.asyncCompactMap { item in item.graphqlApis }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListResolversOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolversInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolversOutput`
    public func listResolversPaginated(input: ListResolversInput) -> ClientRuntime.PaginatorSequence<ListResolversInput, ListResolversOutput> {
        return ClientRuntime.PaginatorSequence<ListResolversInput, ListResolversOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolvers(input:))
    }
}

extension ListResolversInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolversInput {
        return ListResolversInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token,
            typeName: self.typeName
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolversInput, OperationStackOutput == ListResolversOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolversPaginated`
    /// to access the nested member `[AppSyncClientTypes.Resolver]`
    /// - Returns: `[AppSyncClientTypes.Resolver]`
    public func resolvers() async throws -> [AppSyncClientTypes.Resolver] {
        return try await self.asyncCompactMap { item in item.resolvers }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListResolversByFunctionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolversByFunctionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolversByFunctionOutput`
    public func listResolversByFunctionPaginated(input: ListResolversByFunctionInput) -> ClientRuntime.PaginatorSequence<ListResolversByFunctionInput, ListResolversByFunctionOutput> {
        return ClientRuntime.PaginatorSequence<ListResolversByFunctionInput, ListResolversByFunctionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolversByFunction(input:))
    }
}

extension ListResolversByFunctionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolversByFunctionInput {
        return ListResolversByFunctionInput(
            apiId: self.apiId,
            functionId: self.functionId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolversByFunctionInput, OperationStackOutput == ListResolversByFunctionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolversByFunctionPaginated`
    /// to access the nested member `[AppSyncClientTypes.Resolver]`
    /// - Returns: `[AppSyncClientTypes.Resolver]`
    public func resolvers() async throws -> [AppSyncClientTypes.Resolver] {
        return try await self.asyncCompactMap { item in item.resolvers }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListSourceApiAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSourceApiAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSourceApiAssociationsOutput`
    public func listSourceApiAssociationsPaginated(input: ListSourceApiAssociationsInput) -> ClientRuntime.PaginatorSequence<ListSourceApiAssociationsInput, ListSourceApiAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListSourceApiAssociationsInput, ListSourceApiAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSourceApiAssociations(input:))
    }
}

extension ListSourceApiAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSourceApiAssociationsInput {
        return ListSourceApiAssociationsInput(
            apiId: self.apiId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSourceApiAssociationsInput, OperationStackOutput == ListSourceApiAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSourceApiAssociationsPaginated`
    /// to access the nested member `[AppSyncClientTypes.SourceApiAssociationSummary]`
    /// - Returns: `[AppSyncClientTypes.SourceApiAssociationSummary]`
    public func sourceApiAssociationSummaries() async throws -> [AppSyncClientTypes.SourceApiAssociationSummary] {
        return try await self.asyncCompactMap { item in item.sourceApiAssociationSummaries }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTypesOutput`
    public func listTypesPaginated(input: ListTypesInput) -> ClientRuntime.PaginatorSequence<ListTypesInput, ListTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListTypesInput, ListTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTypes(input:))
    }
}

extension ListTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTypesInput {
        return ListTypesInput(
            apiId: self.apiId,
            format: self.format,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListTypesInput, OperationStackOutput == ListTypesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTypesPaginated`
    /// to access the nested member `[AppSyncClientTypes.ModelType]`
    /// - Returns: `[AppSyncClientTypes.ModelType]`
    public func types() async throws -> [AppSyncClientTypes.ModelType] {
        return try await self.asyncCompactMap { item in item.types }
    }
}
extension AppSyncClient {
    /// Paginate over `[ListTypesByAssociationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTypesByAssociationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTypesByAssociationOutput`
    public func listTypesByAssociationPaginated(input: ListTypesByAssociationInput) -> ClientRuntime.PaginatorSequence<ListTypesByAssociationInput, ListTypesByAssociationOutput> {
        return ClientRuntime.PaginatorSequence<ListTypesByAssociationInput, ListTypesByAssociationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTypesByAssociation(input:))
    }
}

extension ListTypesByAssociationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTypesByAssociationInput {
        return ListTypesByAssociationInput(
            associationId: self.associationId,
            format: self.format,
            maxResults: self.maxResults,
            mergedApiIdentifier: self.mergedApiIdentifier,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListTypesByAssociationInput, OperationStackOutput == ListTypesByAssociationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTypesByAssociationPaginated`
    /// to access the nested member `[AppSyncClientTypes.ModelType]`
    /// - Returns: `[AppSyncClientTypes.ModelType]`
    public func types() async throws -> [AppSyncClientTypes.ModelType] {
        return try await self.asyncCompactMap { item in item.types }
    }
}
