//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You don't have access to perform this operation on this resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppSyncClientTypes {

    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case awsLambda
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .awsLambda,
                .openidConnect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .awsLambda: return "AWS_LAMBDA"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// A LambdaAuthorizerConfig specifies how to authorize AppSync API access when using the AWS_LAMBDA authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
    public struct LambdaAuthorizerConfig {
        /// The number of seconds a response should be cached for. The default is 0 seconds, which disables caching. If you don't specify a value for authorizerResultTtlInSeconds, the default value is used. The maximum value is one hour (3600 seconds). The Lambda function can override this by returning a ttlOverride key in its response.
        public var authorizerResultTtlInSeconds: Swift.Int
        /// The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or an alias ARN. Note: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following: aws lambda add-permission --function-name "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id "appsync" --principal appsync.amazonaws.com --action lambda:InvokeFunction
        /// This member is required.
        public var authorizerUri: Swift.String?
        /// A regular expression for validation of tokens before the Lambda function is called.
        public var identityValidationExpression: Swift.String?

        public init(
            authorizerResultTtlInSeconds: Swift.Int = 0,
            authorizerUri: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil
        )
        {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an OpenID Connect (OIDC) configuration.
    public struct OpenIDConnectConfig {
        /// The number of milliseconds that a token is valid after being authenticated.
        public var authTTL: Swift.Int
        /// The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.
        public var clientId: Swift.String?
        /// The number of milliseconds that a token is valid after it's issued to a user.
        public var iatTTL: Swift.Int
        /// The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        /// This member is required.
        public var issuer: Swift.String?

        public init(
            authTTL: Swift.Int = 0,
            clientId: Swift.String? = nil,
            iatTTL: Swift.Int = 0,
            issuer: Swift.String? = nil
        )
        {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct CognitoUserPoolConfig {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init(
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an additional authentication provider.
    public struct AdditionalAuthenticationProvider {
        /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The OIDC configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig?

        public init(
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            userPoolConfig: AppSyncClientTypes.CognitoUserPoolConfig? = nil
        )
        {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }
    }

}

extension AppSyncClientTypes {

    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .failed,
                .processing,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes an ApiAssociation object.
    public struct ApiAssociation {
        /// The API ID.
        public var apiId: Swift.String?
        /// Identifies the status of an association.
        ///
        /// * PROCESSING: The API association is being created. You cannot modify association requests during processing.
        ///
        /// * SUCCESS: The API association was successful. You can modify associations after success.
        ///
        /// * FAILED: The API association has failed. You can modify associations after failure.
        public var associationStatus: AppSyncClientTypes.AssociationStatus?
        /// Details about the last deployment status.
        public var deploymentDetail: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?

        public init(
            apiId: Swift.String? = nil,
            associationStatus: AppSyncClientTypes.AssociationStatus? = nil,
            deploymentDetail: Swift.String? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.associationStatus = associationStatus
            self.deploymentDetail = deploymentDetail
            self.domainName = domainName
        }
    }

}

extension AppSyncClientTypes {

    public enum ApiCachingBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullRequestCaching
        case perResolverCaching
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCachingBehavior] {
            return [
                .fullRequestCaching,
                .perResolverCaching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullRequestCaching: return "FULL_REQUEST_CACHING"
            case .perResolverCaching: return "PER_RESOLVER_CACHING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum CacheHealthMetricsConfig: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheHealthMetricsConfig] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum ApiCacheStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .modifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum ApiCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case large12x
        case large2x
        case large4x
        case large8x
        case medium
        case r42xlarge
        case r44xlarge
        case r48xlarge
        case r4Large
        case r4Xlarge
        case small
        case t2Medium
        case t2Small
        case xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiCacheType] {
            return [
                .large,
                .large12x,
                .large2x,
                .large4x,
                .large8x,
                .medium,
                .r42xlarge,
                .r44xlarge,
                .r48xlarge,
                .r4Large,
                .r4Xlarge,
                .small,
                .t2Medium,
                .t2Small,
                .xlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .large12x: return "LARGE_12X"
            case .large2x: return "LARGE_2X"
            case .large4x: return "LARGE_4X"
            case .large8x: return "LARGE_8X"
            case .medium: return "MEDIUM"
            case .r42xlarge: return "R4_2XLARGE"
            case .r44xlarge: return "R4_4XLARGE"
            case .r48xlarge: return "R4_8XLARGE"
            case .r4Large: return "R4_LARGE"
            case .r4Xlarge: return "R4_XLARGE"
            case .small: return "SMALL"
            case .t2Medium: return "T2_MEDIUM"
            case .t2Small: return "T2_SMALL"
            case .xlarge: return "XLARGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// The ApiCache object.
    public struct ApiCache {
        /// Caching behavior.
        ///
        /// * FULL_REQUEST_CACHING: All requests are fully cached.
        ///
        /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
        /// At-rest encryption flag for cache. You cannot update this setting after creation.
        public var atRestEncryptionEnabled: Swift.Bool
        /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:
        ///
        /// * NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.
        ///
        /// * EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.
        ///
        ///
        /// Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
        public var healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig?
        /// The cache instance status.
        ///
        /// * AVAILABLE: The instance is available for use.
        ///
        /// * CREATING: The instance is currently creating.
        ///
        /// * DELETING: The instance is currently deleting.
        ///
        /// * MODIFYING: The instance is currently modifying.
        ///
        /// * FAILED: The instance has failed creation.
        public var status: AppSyncClientTypes.ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
        public var transitEncryptionEnabled: Swift.Bool
        /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
        public var ttl: Swift.Int
        /// The cache instance type. Valid values are
        ///
        /// * SMALL
        ///
        /// * MEDIUM
        ///
        /// * LARGE
        ///
        /// * XLARGE
        ///
        /// * LARGE_2X
        ///
        /// * LARGE_4X
        ///
        /// * LARGE_8X (not available in all regions)
        ///
        /// * LARGE_12X
        ///
        ///
        /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
        ///
        /// * T2_SMALL: A t2.small instance type.
        ///
        /// * T2_MEDIUM: A t2.medium instance type.
        ///
        /// * R4_LARGE: A r4.large instance type.
        ///
        /// * R4_XLARGE: A r4.xlarge instance type.
        ///
        /// * R4_2XLARGE: A r4.2xlarge instance type.
        ///
        /// * R4_4XLARGE: A r4.4xlarge instance type.
        ///
        /// * R4_8XLARGE: A r4.8xlarge instance type.
        public var type: AppSyncClientTypes.ApiCacheType?

        public init(
            apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
            atRestEncryptionEnabled: Swift.Bool = false,
            healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig? = nil,
            status: AppSyncClientTypes.ApiCacheStatus? = nil,
            transitEncryptionEnabled: Swift.Bool = false,
            ttl: Swift.Int = 0,
            type: AppSyncClientTypes.ApiCacheType? = nil
        )
        {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.healthMetricsConfig = healthMetricsConfig
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an API key. Customers invoke AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions: da1: We introduced this version at launch in November 2017. These keys always expire after 7 days. Amazon DynamoDB TTL manages key expiration. These keys ceased to be valid after February 21, 2018, and they should no longer be used.
    ///
    /// * ListApiKeys returns the expiration time in milliseconds.
    ///
    /// * CreateApiKey returns the expiration time in milliseconds.
    ///
    /// * UpdateApiKey is not available for this key version.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we deleted these keys from the table on February 21, 2018.
    ///
    ///
    /// da2: We introduced this version in February 2018 when AppSync added support to extend key expiration.
    ///
    /// * ListApiKeys returns the expiration time and deletion time in seconds.
    ///
    /// * CreateApiKey returns the expiration time and deletion time in seconds and accepts a user-provided expiration time in seconds.
    ///
    /// * UpdateApiKey returns the expiration time and and deletion time in seconds and accepts a user-provided expiration time in seconds. Expired API keys are kept for 60 days after the expiration time. You can update the key expiration time as long as the key isn't deleted.
    ///
    /// * DeleteApiKey deletes the item from the table.
    ///
    /// * Expiration is stored in DynamoDB as seconds. After the expiration time, using the key to authenticate will fail. However, you can reinstate the key before deletion.
    ///
    /// * Deletion is stored in DynamoDB as seconds. The key is deleted after deletion time.
    public struct ApiKey {
        /// The time after which the API key is deleted. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var deletes: Swift.Int
        /// A description of the purpose of the API key.
        public var description: Swift.String?
        /// The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public var expires: Swift.Int
        /// The API key ID.
        public var id: Swift.String?

        public init(
            deletes: Swift.Int = 0,
            description: Swift.String? = nil,
            expires: Swift.Int = 0,
            id: Swift.String? = nil
        )
        {
            self.deletes = deletes
            self.description = description
            self.expires = expires
            self.id = id
        }
    }

}

/// The API key exceeded a limit. Try your request again.
public struct ApiKeyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiKeyLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The API key expiration must be set to a value between 1 and 365 days from creation (for CreateApiKey) or from update (for UpdateApiKey).
public struct ApiKeyValidityOutOfBoundsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiKeyValidityOutOfBoundsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The GraphQL API exceeded a limit. Try your request again.
public struct ApiLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ApiLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppSyncClientTypes {

    public enum RuntimeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appsyncJs
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeName] {
            return [
                .appsyncJs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appsyncJs: return "APPSYNC_JS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public struct AppSyncRuntime {
        /// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
        /// This member is required.
        public var name: AppSyncClientTypes.RuntimeName?
        /// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
        /// This member is required.
        public var runtimeVersion: Swift.String?

        public init(
            name: AppSyncClientTypes.RuntimeName? = nil,
            runtimeVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.runtimeVersion = runtimeVersion
        }
    }

}

extension AppSyncClientTypes {
    /// Describes the location of the error in a code sample.
    public struct CodeErrorLocation {
        /// The column number in the code. Defaults to 0 if unknown.
        public var column: Swift.Int
        /// The line number in the code. Defaults to 0 if unknown.
        public var line: Swift.Int
        /// The span/length of the error. Defaults to -1 if unknown.
        public var span: Swift.Int

        public init(
            column: Swift.Int = 0,
            line: Swift.Int = 0,
            span: Swift.Int = 0
        )
        {
            self.column = column
            self.line = line
            self.span = span
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an AppSync error.
    public struct CodeError {
        /// The type of code error. Examples include, but aren't limited to: LINT_ERROR, PARSER_ERROR.
        public var errorType: Swift.String?
        /// The line, column, and span location of the error in the code.
        public var location: AppSyncClientTypes.CodeErrorLocation?
        /// A user presentable error. Examples include, but aren't limited to: Parsing error: Unterminated string literal.
        public var value: Swift.String?

        public init(
            errorType: Swift.String? = nil,
            location: AppSyncClientTypes.CodeErrorLocation? = nil,
            value: Swift.String? = nil
        )
        {
            self.errorType = errorType
            self.location = location
            self.value = value
        }
    }

}

extension AppSyncClientTypes {
    /// Provides further details for the reason behind the bad request. For reason type CODE_ERROR, the detail will contain a list of code errors.
    public struct BadRequestDetail {
        /// Contains the list of errors in the request.
        public var codeErrors: [AppSyncClientTypes.CodeError]?

        public init(
            codeErrors: [AppSyncClientTypes.CodeError]? = nil
        )
        {
            self.codeErrors = codeErrors
        }
    }

}

extension AppSyncClientTypes {

    /// Provides context for the cause of the bad request. The only supported value is CODE_ERROR.
    public enum BadRequestReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case codeError
        case sdkUnknown(Swift.String)

        public static var allCases: [BadRequestReason] {
            return [
                .codeError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .codeError: return "CODE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request is not well formed. For example, a value is invalid or a required field is missing. Check the field values, and then try again.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Provides further details for the reason behind the bad request. For reason type CODE_ERROR, the detail will contain a list of code errors.
        public internal(set) var detail: AppSyncClientTypes.BadRequestDetail? = nil
        public internal(set) var message: Swift.String? = nil
        /// Provides context for the cause of the bad request. The only supported value is CODE_ERROR.
        public internal(set) var reason: AppSyncClientTypes.BadRequestReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        detail: AppSyncClientTypes.BadRequestDetail? = nil,
        message: Swift.String? = nil,
        reason: AppSyncClientTypes.BadRequestReason? = nil
    )
    {
        self.properties.detail = detail
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// An internal AppSync error occurred. Try your request again.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource specified in the request was not found. Check the resource, and then try again.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateApiInput {
    /// The API ID. Private APIs can not be associated with custom domains.
    /// This member is required.
    public var apiId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.domainName = domainName
    }
}

public struct AssociateApiOutput {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init(
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

/// Another modification is in progress at this time and it must complete before you can make your change.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeded a limit. Try your request again.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You aren't authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppSyncClientTypes {

    public enum MergeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoMerge
        case manualMerge
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeType] {
            return [
                .autoMerge,
                .manualMerge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoMerge: return "AUTO_MERGE"
            case .manualMerge: return "MANUAL_MERGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes properties used to specify configurations related to a source API.
    public struct SourceApiAssociationConfig {
        /// The property that indicates which merging option is enabled in the source API association. Valid merge types are MANUAL_MERGE (default) and AUTO_MERGE. Manual merges are the default behavior and require the user to trigger any changes from the source APIs to the merged API manually. Auto merges subscribe the merged API to the changes performed on the source APIs so that any change in the source APIs are also made to the merged API. Auto merges use MergedApiExecutionRoleArn to perform merge operations.
        public var mergeType: AppSyncClientTypes.MergeType?

        public init(
            mergeType: AppSyncClientTypes.MergeType? = nil
        )
        {
            self.mergeType = mergeType
        }
    }

}

public struct AssociateMergedGraphqlApiInput {
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

extension AppSyncClientTypes {

    public enum SourceApiAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoMergeScheduleFailed
        case deletionFailed
        case deletionInProgress
        case deletionScheduled
        case mergeFailed
        case mergeInProgress
        case mergeScheduled
        case mergeSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceApiAssociationStatus] {
            return [
                .autoMergeScheduleFailed,
                .deletionFailed,
                .deletionInProgress,
                .deletionScheduled,
                .mergeFailed,
                .mergeInProgress,
                .mergeScheduled,
                .mergeSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoMergeScheduleFailed: return "AUTO_MERGE_SCHEDULE_FAILED"
            case .deletionFailed: return "DELETION_FAILED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .deletionScheduled: return "DELETION_SCHEDULED"
            case .mergeFailed: return "MERGE_FAILED"
            case .mergeInProgress: return "MERGE_IN_PROGRESS"
            case .mergeScheduled: return "MERGE_SCHEDULED"
            case .mergeSuccess: return "MERGE_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes the configuration of a source API. A source API is a GraphQL API that is linked to a merged API. There can be multiple source APIs attached to each merged API. When linked to a merged API, the source API's schema, data sources, and resolvers will be combined with other linked source API data to form a new, singular API. Source APIs can originate from your account or from other accounts via Amazon Web Services Resource Access Manager. For more information about sharing resources from other accounts, see [What is Amazon Web Services Resource Access Manager?](https://docs.aws.amazon.com/ram/latest/userguide/what-is.html) in the Amazon Web Services Resource Access Manager guide.
    public struct SourceApiAssociation {
        /// The Amazon Resource Name (ARN) of the source API association.
        public var associationArn: Swift.String?
        /// The ID generated by the AppSync service for the source API association.
        public var associationId: Swift.String?
        /// The description field.
        public var description: Swift.String?
        /// The datetime value of the last successful merge of the source API association. The result will be in UTC format and your local time zone.
        public var lastSuccessfulMergeDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public var mergedApiArn: Swift.String?
        /// The ID of the AppSync Merged API.
        public var mergedApiId: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync source API.
        public var sourceApiArn: Swift.String?
        /// The SourceApiAssociationConfig object data.
        public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
        /// The state of the source API association.
        public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?
        /// The detailed message related to the current state of the source API association.
        public var sourceApiAssociationStatusDetail: Swift.String?
        /// The ID of the AppSync source API.
        public var sourceApiId: Swift.String?

        public init(
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastSuccessfulMergeDate: Foundation.Date? = nil,
            mergedApiArn: Swift.String? = nil,
            mergedApiId: Swift.String? = nil,
            sourceApiArn: Swift.String? = nil,
            sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
            sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil,
            sourceApiAssociationStatusDetail: Swift.String? = nil,
            sourceApiId: Swift.String? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.lastSuccessfulMergeDate = lastSuccessfulMergeDate
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
            self.sourceApiAssociationStatusDetail = sourceApiAssociationStatusDetail
            self.sourceApiId = sourceApiId
        }
    }

}

public struct AssociateMergedGraphqlApiOutput {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

public struct AssociateSourceGraphqlApiInput {
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

public struct AssociateSourceGraphqlApiOutput {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

extension AppSyncClientTypes {

    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// The Identity and Access Management (IAM) configuration.
    public struct AwsIamConfig {
        /// The signing Amazon Web Services Region for IAM authorization.
        public var signingRegion: Swift.String?
        /// The signing service name for IAM authorization.
        public var signingServiceName: Swift.String?

        public init(
            signingRegion: Swift.String? = nil,
            signingServiceName: Swift.String? = nil
        )
        {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }
    }

}

extension AppSyncClientTypes {
    /// The authorization configuration in case the HTTP endpoint requires authorization.
    public struct AuthorizationConfig {
        /// The authorization type that the HTTP endpoint requires.
        ///
        /// * AWS_IAM: The authorization type is Signature Version 4 (SigV4).
        /// This member is required.
        public var authorizationType: AppSyncClientTypes.AuthorizationType?
        /// The Identity and Access Management (IAM) settings.
        public var awsIamConfig: AppSyncClientTypes.AwsIamConfig?

        public init(
            authorizationType: AppSyncClientTypes.AuthorizationType? = nil,
            awsIamConfig: AppSyncClientTypes.AwsIamConfig? = nil
        )
        {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }
    }

}

/// Represents the input of a CreateApiCache operation.
public struct CreateApiCacheInput {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// At-rest encryption flag for cache. You cannot update this setting after creation.
    public var atRestEncryptionEnabled: Swift.Bool?
    /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:
    ///
    /// * NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.
    ///
    /// * EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.
    ///
    ///
    /// Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
    public var healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig?
    /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
    public var transitEncryptionEnabled: Swift.Bool?
    /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int?
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init(
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        atRestEncryptionEnabled: Swift.Bool? = false,
        healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig? = nil,
        transitEncryptionEnabled: Swift.Bool? = false,
        ttl: Swift.Int? = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.healthMetricsConfig = healthMetricsConfig
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

/// Represents the output of a CreateApiCache operation.
public struct CreateApiCacheOutput {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

public struct CreateApiKeyInput {
    /// The ID for your GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
    public var expires: Swift.Int?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int? = 0
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
    }
}

public struct CreateApiKeyOutput {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init(
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

extension AppSyncClientTypes {
    /// Describes a Delta Sync configuration.
    public struct DeltaSyncConfig {
        /// The number of minutes that an Item is stored in the data source.
        public var baseTableTTL: Swift.Int
        /// The Delta Sync table name.
        public var deltaSyncTableName: Swift.String?
        /// The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        public var deltaSyncTableTTL: Swift.Int

        public init(
            baseTableTTL: Swift.Int = 0,
            deltaSyncTableName: Swift.String? = nil,
            deltaSyncTableTTL: Swift.Int = 0
        )
        {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an Amazon DynamoDB data source configuration.
    public struct DynamodbDataSourceConfig {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The DeltaSyncConfig for a versioned data source.
        public var deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig?
        /// The table name.
        /// This member is required.
        public var tableName: Swift.String?
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public var useCallerCredentials: Swift.Bool
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public var versioned: Swift.Bool

        public init(
            awsRegion: Swift.String? = nil,
            deltaSyncConfig: AppSyncClientTypes.DeltaSyncConfig? = nil,
            tableName: Swift.String? = nil,
            useCallerCredentials: Swift.Bool = false,
            versioned: Swift.Bool = false
        )
        {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [OpenSearchServiceDataSourceConfig] to specify an OpenSearch data source.
    public struct ElasticsearchDataSourceConfig {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an Amazon EventBridge bus data source configuration.
    public struct EventBridgeDataSourceConfig {
        /// The ARN of the event bus. For more information about event buses, see [Amazon EventBridge event buses](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-bus.html).
        /// This member is required.
        public var eventBusArn: Swift.String?

        public init(
            eventBusArn: Swift.String? = nil
        )
        {
            self.eventBusArn = eventBusArn
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an HTTP data source configuration.
    public struct HttpDataSourceConfig {
        /// The authorization configuration in case the HTTP endpoint requires authorization.
        public var authorizationConfig: AppSyncClientTypes.AuthorizationConfig?
        /// The HTTP URL endpoint. You can specify either the domain name or IP, and port combination, and the URL scheme must be HTTP or HTTPS. If you don't specify the port, AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS endpoints.
        public var endpoint: Swift.String?

        public init(
            authorizationConfig: AppSyncClientTypes.AuthorizationConfig? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    /// Describes an Lambda data source configuration.
    public struct LambdaDataSourceConfig {
        /// The Amazon Resource Name (ARN) for the Lambda function.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?

        public init(
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension AppSyncClientTypes {

    public enum DataSourceLevelMetricsConfig: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceLevelMetricsConfig] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes an OpenSearch data source configuration.
    public struct OpenSearchServiceDataSourceConfig {
        /// The Amazon Web Services Region.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The endpoint.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }
    }

}

extension AppSyncClientTypes {
    /// The Amazon Relational Database Service (Amazon RDS) HTTP endpoint configuration.
    public struct RdsHttpEndpointConfig {
        /// Amazon Web Services Region for Amazon RDS HTTP endpoint.
        public var awsRegion: Swift.String?
        /// Amazon Web Services secret store Amazon Resource Name (ARN) for database credentials.
        public var awsSecretStoreArn: Swift.String?
        /// Logical database name.
        public var databaseName: Swift.String?
        /// Amazon RDS cluster Amazon Resource Name (ARN).
        public var dbClusterIdentifier: Swift.String?
        /// Logical schema name.
        public var schema: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            awsSecretStoreArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }
    }

}

extension AppSyncClientTypes {

    public enum RelationalDatabaseSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rdsHttpEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationalDatabaseSourceType] {
            return [
                .rdsHttpEndpoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rdsHttpEndpoint: return "RDS_HTTP_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes a relational database data source configuration.
    public struct RelationalDatabaseDataSourceConfig {
        /// Amazon RDS HTTP endpoint settings.
        public var rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig?
        /// Source type for the relational database.
        ///
        /// * RDS_HTTP_ENDPOINT: The relational database source type is an Amazon Relational Database Service (Amazon RDS) HTTP endpoint.
        public var relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType?

        public init(
            rdsHttpEndpointConfig: AppSyncClientTypes.RdsHttpEndpointConfig? = nil,
            relationalDatabaseSourceType: AppSyncClientTypes.RelationalDatabaseSourceType? = nil
        )
        {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }
    }

}

extension AppSyncClientTypes {

    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonDynamodb
        case amazonElasticsearch
        case amazonEventbridge
        case amazonOpensearchService
        case awsLambda
        case http
        case `none`
        case relationalDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .amazonDynamodb,
                .amazonElasticsearch,
                .amazonEventbridge,
                .amazonOpensearchService,
                .awsLambda,
                .http,
                .none,
                .relationalDatabase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonDynamodb: return "AMAZON_DYNAMODB"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonEventbridge: return "AMAZON_EVENTBRIDGE"
            case .amazonOpensearchService: return "AMAZON_OPENSEARCH_SERVICE"
            case .awsLambda: return "AWS_LAMBDA"
            case .http: return "HTTP"
            case .none: return "NONE"
            case .relationalDatabase: return "RELATIONAL_DATABASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDataSourceInput {
    /// The API ID for the GraphQL API for the DataSource.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the DataSource.
    public var description: Swift.String?
    /// Amazon DynamoDB settings.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// Amazon OpenSearch Service settings. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use [CreateDataSourceRequest$openSearchServiceConfig] to create an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// Amazon EventBridge settings.
    public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
    /// HTTP endpoint settings.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// Lambda settings.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
    public var metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig?
    /// A user-supplied name for the DataSource.
    /// This member is required.
    public var name: Swift.String?
    /// Amazon OpenSearch Service settings.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// Relational database settings.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
    public var serviceRoleArn: Swift.String?
    /// The type of the DataSource.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.eventBridgeConfig = eventBridgeConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.metricsConfig = metricsConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

extension AppSyncClientTypes {
    /// Describes a data source.
    public struct DataSource {
        /// The data source Amazon Resource Name (ARN).
        public var dataSourceArn: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// DynamoDB settings.
        public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings.
        public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
        /// Amazon EventBridge settings.
        public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
        /// HTTP endpoint settings.
        public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
        /// Lambda settings.
        public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
        /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
        public var metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig?
        /// The name of the data source.
        public var name: Swift.String?
        /// Amazon OpenSearch Service settings.
        public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
        public var serviceRoleArn: Swift.String?
        /// The type of the data source.
        ///
        /// * AWS_LAMBDA: The data source is an Lambda function.
        ///
        /// * AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.
        ///
        /// * AMAZON_ELASTICSEARCH: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * AMAZON_OPENSEARCH_SERVICE: The data source is an Amazon OpenSearch Service domain.
        ///
        /// * AMAZON_EVENTBRIDGE: The data source is an Amazon EventBridge configuration.
        ///
        /// * NONE: There is no data source. Use this type when you want to invoke a GraphQL operation without connecting to a data source, such as when you're performing data transformation with resolvers or invoking a subscription from a mutation.
        ///
        /// * HTTP: The data source is an HTTP endpoint.
        ///
        /// * RELATIONAL_DATABASE: The data source is a relational database.
        public var type: AppSyncClientTypes.DataSourceType?

        public init(
            dataSourceArn: Swift.String? = nil,
            description: Swift.String? = nil,
            dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
            elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
            eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
            httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
            lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
            metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig? = nil,
            name: Swift.String? = nil,
            openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
            relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
            serviceRoleArn: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceType? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.eventBridgeConfig = eventBridgeConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.metricsConfig = metricsConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }
    }

}

public struct CreateDataSourceOutput {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

public struct CreateDomainNameInput {
    /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
    /// This member is required.
    public var certificateArn: Swift.String?
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.description = description
        self.domainName = domainName
    }
}

extension AppSyncClientTypes {
    /// Describes a configuration for a custom domain.
    public struct DomainNameConfig {
        /// The domain name that AppSync provides.
        public var appsyncDomainName: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
        public var certificateArn: Swift.String?
        /// A description of the DomainName configuration.
        public var description: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?
        /// The ID of your Amazon Route 53 hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            appsyncDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.appsyncDomainName = appsyncDomainName
            self.certificateArn = certificateArn
            self.description = description
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

public struct CreateDomainNameOutput {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

extension AppSyncClientTypes {

    public enum ConflictDetectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictDetectionType] {
            return [
                .none,
                .version
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum ConflictHandlerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictHandlerType] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// The LambdaConflictHandlerConfig object when configuring LAMBDA as the Conflict Handler.
    public struct LambdaConflictHandlerConfig {
        /// The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
        public var lambdaConflictHandlerArn: Swift.String?

        public init(
            lambdaConflictHandlerArn: Swift.String? = nil
        )
        {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }
    }

}

extension AppSyncClientTypes {
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public struct SyncConfig {
        /// The Conflict Detection strategy to use.
        ///
        /// * VERSION: Detect conflicts based on object versions for this resolver.
        ///
        /// * NONE: Do not detect conflicts when invoking this resolver.
        public var conflictDetection: AppSyncClientTypes.ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.
        ///
        /// * OPTIMISTIC_CONCURRENCY: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.
        ///
        /// * AUTOMERGE: Resolve conflicts with the Automerge conflict resolution strategy.
        ///
        /// * LAMBDA: Resolve conflicts with an Lambda function supplied in the LambdaConflictHandlerConfig.
        public var conflictHandler: AppSyncClientTypes.ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
        public var lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig?

        public init(
            conflictDetection: AppSyncClientTypes.ConflictDetectionType? = nil,
            conflictHandler: AppSyncClientTypes.ConflictHandlerType? = nil,
            lambdaConflictHandlerConfig: AppSyncClientTypes.LambdaConflictHandlerConfig? = nil
        )
        {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }
    }

}

public struct CreateFunctionInput {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
    public var functionVersion: Swift.String?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The Function name. The function name does not have to be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init(
        apiId: Swift.String? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        maxBatchSize: Swift.Int? = 0,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.code = code
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionVersion = functionVersion
        self.maxBatchSize = maxBatchSize
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
    }
}

extension AppSyncClientTypes {
    /// A function is a reusable entity. You can use multiple functions to compose the resolver logic.
    public struct FunctionConfiguration {
        /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public var code: Swift.String?
        /// The name of the DataSource.
        public var dataSourceName: Swift.String?
        /// The Function description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the Function object.
        public var functionArn: Swift.String?
        /// A unique ID representing the Function object.
        public var functionId: Swift.String?
        /// The version of the request mapping template. Currently, only the 2018-05-29 version of the template is supported.
        public var functionVersion: Swift.String?
        /// The maximum batching size for a resolver.
        public var maxBatchSize: Swift.Int
        /// The name of the Function object.
        public var name: Swift.String?
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The Function response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
        public var runtime: AppSyncClientTypes.AppSyncRuntime?
        /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
        public var syncConfig: AppSyncClientTypes.SyncConfig?

        public init(
            code: Swift.String? = nil,
            dataSourceName: Swift.String? = nil,
            description: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionId: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            maxBatchSize: Swift.Int = 0,
            name: Swift.String? = nil,
            requestMappingTemplate: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil
        )
        {
            self.code = code
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.maxBatchSize = maxBatchSize
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
        }
    }

}

public struct CreateFunctionOutput {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

extension AppSyncClientTypes {

    public enum GraphQLApiType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case graphql
        case merged
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphQLApiType] {
            return [
                .graphql,
                .merged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .graphql: return "GRAPHQL"
            case .merged: return "MERGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum DataSourceLevelMetricsBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullRequestDataSourceMetrics
        case perDataSourceMetrics
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceLevelMetricsBehavior] {
            return [
                .fullRequestDataSourceMetrics,
                .perDataSourceMetrics
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullRequestDataSourceMetrics: return "FULL_REQUEST_DATA_SOURCE_METRICS"
            case .perDataSourceMetrics: return "PER_DATA_SOURCE_METRICS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum OperationLevelMetricsConfig: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationLevelMetricsConfig] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum ResolverLevelMetricsBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullRequestResolverMetrics
        case perResolverMetrics
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverLevelMetricsBehavior] {
            return [
                .fullRequestResolverMetrics,
                .perResolverMetrics
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullRequestResolverMetrics: return "FULL_REQUEST_RESOLVER_METRICS"
            case .perResolverMetrics: return "PER_RESOLVER_METRICS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Enables and controls the enhanced metrics feature. Enhanced metrics emit granular data on API usage and performance such as AppSync request and error counts, latency, and cache hits/misses. All enhanced metric data is sent to your CloudWatch account, and you can configure the types of data that will be sent. Enhanced metrics can be configured at the resolver, data source, and operation levels. EnhancedMetricsConfig contains three required parameters, each controlling one of these categories:
    ///
    /// * resolverLevelMetricsBehavior: Controls how resolver metrics will be emitted to CloudWatch. Resolver metrics include:
    ///
    /// * GraphQL errors: The number of GraphQL errors that occurred.
    ///
    /// * Requests: The number of invocations that occurred during a request.
    ///
    /// * Latency: The time to complete a resolver invocation.
    ///
    /// * Cache hits: The number of cache hits during a request.
    ///
    /// * Cache misses: The number of cache misses during a request.
    ///
    ///
    /// These metrics can be emitted to CloudWatch per resolver or for all resolvers in the request. Metrics will be recorded by API ID and resolver name. resolverLevelMetricsBehavior accepts one of these values at a time:
    ///
    /// * FULL_REQUEST_RESOLVER_METRICS: Records and emits metric data for all resolvers in the request.
    ///
    /// * PER_RESOLVER_METRICS: Records and emits metric data for resolvers that have the metricsConfig value set to ENABLED.
    ///
    ///
    ///
    ///
    /// * dataSourceLevelMetricsBehavior: Controls how data source metrics will be emitted to CloudWatch. Data source metrics include:
    ///
    /// * Requests: The number of invocations that occured during a request.
    ///
    /// * Latency: The time to complete a data source invocation.
    ///
    /// * Errors: The number of errors that occurred during a data source invocation.
    ///
    ///
    /// These metrics can be emitted to CloudWatch per data source or for all data sources in the request. Metrics will be recorded by API ID and data source name. dataSourceLevelMetricsBehavior accepts one of these values at a time:
    ///
    /// * FULL_REQUEST_DATA_SOURCE_METRICS: Records and emits metric data for all data sources in the request.
    ///
    /// * PER_DATA_SOURCE_METRICS: Records and emits metric data for data sources that have the metricsConfig value set to ENABLED.
    ///
    ///
    ///
    ///
    /// * operationLevelMetricsConfig: Controls how operation metrics will be emitted to CloudWatch. Operation metrics include:
    ///
    /// * Requests: The number of times a specified GraphQL operation was called.
    ///
    /// * GraphQL errors: The number of GraphQL errors that occurred during a specified GraphQL operation.
    ///
    ///
    /// Metrics will be recorded by API ID and operation name. You can set the value to ENABLED or DISABLED.
    public struct EnhancedMetricsConfig {
        /// Controls how data source metrics will be emitted to CloudWatch. Data source metrics include:
        ///
        /// * Requests: The number of invocations that occured during a request.
        ///
        /// * Latency: The time to complete a data source invocation.
        ///
        /// * Errors: The number of errors that occurred during a data source invocation.
        ///
        ///
        /// These metrics can be emitted to CloudWatch per data source or for all data sources in the request. Metrics will be recorded by API ID and data source name. dataSourceLevelMetricsBehavior accepts one of these values at a time:
        ///
        /// * FULL_REQUEST_DATA_SOURCE_METRICS: Records and emits metric data for all data sources in the request.
        ///
        /// * PER_DATA_SOURCE_METRICS: Records and emits metric data for data sources that have the metricsConfig value set to ENABLED.
        /// This member is required.
        public var dataSourceLevelMetricsBehavior: AppSyncClientTypes.DataSourceLevelMetricsBehavior?
        /// Controls how operation metrics will be emitted to CloudWatch. Operation metrics include:
        ///
        /// * Requests: The number of times a specified GraphQL operation was called.
        ///
        /// * GraphQL errors: The number of GraphQL errors that occurred during a specified GraphQL operation.
        ///
        ///
        /// Metrics will be recorded by API ID and operation name. You can set the value to ENABLED or DISABLED.
        /// This member is required.
        public var operationLevelMetricsConfig: AppSyncClientTypes.OperationLevelMetricsConfig?
        /// Controls how resolver metrics will be emitted to CloudWatch. Resolver metrics include:
        ///
        /// * GraphQL errors: The number of GraphQL errors that occurred.
        ///
        /// * Requests: The number of invocations that occurred during a request.
        ///
        /// * Latency: The time to complete a resolver invocation.
        ///
        /// * Cache hits: The number of cache hits during a request.
        ///
        /// * Cache misses: The number of cache misses during a request.
        ///
        ///
        /// These metrics can be emitted to CloudWatch per resolver or for all resolvers in the request. Metrics will be recorded by API ID and resolver name. resolverLevelMetricsBehavior accepts one of these values at a time:
        ///
        /// * FULL_REQUEST_RESOLVER_METRICS: Records and emits metric data for all resolvers in the request.
        ///
        /// * PER_RESOLVER_METRICS: Records and emits metric data for resolvers that have the metricsConfig value set to ENABLED.
        /// This member is required.
        public var resolverLevelMetricsBehavior: AppSyncClientTypes.ResolverLevelMetricsBehavior?

        public init(
            dataSourceLevelMetricsBehavior: AppSyncClientTypes.DataSourceLevelMetricsBehavior? = nil,
            operationLevelMetricsConfig: AppSyncClientTypes.OperationLevelMetricsConfig? = nil,
            resolverLevelMetricsBehavior: AppSyncClientTypes.ResolverLevelMetricsBehavior? = nil
        )
        {
            self.dataSourceLevelMetricsBehavior = dataSourceLevelMetricsBehavior
            self.operationLevelMetricsConfig = operationLevelMetricsConfig
            self.resolverLevelMetricsBehavior = resolverLevelMetricsBehavior
        }
    }

}

extension AppSyncClientTypes {

    public enum GraphQLApiIntrospectionConfig: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphQLApiIntrospectionConfig] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum FieldLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case debug
        case error
        case info
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldLogLevel] {
            return [
                .all,
                .debug,
                .error,
                .info,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// The Amazon CloudWatch Logs configuration.
    public struct LogConfig {
        /// The service role that AppSync assumes to publish to CloudWatch logs in your account.
        /// This member is required.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public var excludeVerboseContent: Swift.Bool
        /// The field logging level. Values can be NONE, ERROR, INFO, DEBUG, or ALL.
        ///
        /// * NONE: No field-level logs are captured.
        ///
        /// * ERROR: Logs the following information only for the fields that are in the error category:
        ///
        /// * The error section in the server response.
        ///
        /// * Field-level errors.
        ///
        /// * The generated request/response functions that got resolved for error fields.
        ///
        ///
        ///
        ///
        /// * INFO: Logs the following information only for the fields that are in the info and error categories:
        ///
        /// * Info-level messages.
        ///
        /// * The user messages sent through $util.log.info and console.log.
        ///
        /// * Field-level tracing and mapping logs are not shown.
        ///
        ///
        ///
        ///
        /// * DEBUG: Logs the following information only for the fields that are in the debug, info, and error categories:
        ///
        /// * Debug-level messages.
        ///
        /// * The user messages sent through $util.log.info, $util.log.debug, console.log, and console.debug.
        ///
        /// * Field-level tracing and mapping logs are not shown.
        ///
        ///
        ///
        ///
        /// * ALL: The following information is logged for all fields in the query:
        ///
        /// * Field-level tracing information.
        ///
        /// * The generated request/response functions that were resolved for each field.
        /// This member is required.
        public var fieldLogLevel: AppSyncClientTypes.FieldLogLevel?

        public init(
            cloudWatchLogsRoleArn: Swift.String? = nil,
            excludeVerboseContent: Swift.Bool = false,
            fieldLogLevel: AppSyncClientTypes.FieldLogLevel? = nil
        )
        {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }
    }

}

extension AppSyncClientTypes {

    public enum DefaultAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultAction] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// Describes an Amazon Cognito user pool configuration.
    public struct UserPoolConfig {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        /// This member is required.
        public var awsRegion: Swift.String?
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.
        /// This member is required.
        public var defaultAction: AppSyncClientTypes.DefaultAction?
        /// The user pool ID.
        /// This member is required.
        public var userPoolId: Swift.String?

        public init(
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            defaultAction: AppSyncClientTypes.DefaultAction? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }
    }

}

extension AppSyncClientTypes {

    public enum GraphQLApiVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case global
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [GraphQLApiVisibility] {
            return [
                .global,
                .private
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateGraphqlApiInput {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
    public var apiType: AppSyncClientTypes.GraphQLApiType?
    /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
    /// This member is required.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// The enhancedMetricsConfig object.
    public var enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig?
    /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see [GraphQL introspection](https://graphql.org/learn/introspection/).
    public var introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
    public var mergedApiExecutionRoleArn: Swift.String?
    /// A user-supplied name for the GraphqlApi.
    /// This member is required.
    public var name: Swift.String?
    /// The OIDC configuration.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
    public var ownerContact: Swift.String?
    /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
    public var queryDepthLimit: Swift.Int?
    /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
    public var resolverCountLimit: Swift.Int?
    /// A TagMap object.
    public var tags: [Swift.String: Swift.String]?
    /// The Amazon Cognito user pool configuration.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
    public var visibility: AppSyncClientTypes.GraphQLApiVisibility?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool?

    public init(
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiType: AppSyncClientTypes.GraphQLApiType? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig? = nil,
        introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        mergedApiExecutionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        ownerContact: Swift.String? = nil,
        queryDepthLimit: Swift.Int? = 0,
        resolverCountLimit: Swift.Int? = 0,
        tags: [Swift.String: Swift.String]? = nil,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        visibility: AppSyncClientTypes.GraphQLApiVisibility? = nil,
        xrayEnabled: Swift.Bool? = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiType = apiType
        self.authenticationType = authenticationType
        self.enhancedMetricsConfig = enhancedMetricsConfig
        self.introspectionConfig = introspectionConfig
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.ownerContact = ownerContact
        self.queryDepthLimit = queryDepthLimit
        self.resolverCountLimit = resolverCountLimit
        self.tags = tags
        self.userPoolConfig = userPoolConfig
        self.visibility = visibility
        self.xrayEnabled = xrayEnabled
    }
}

extension AppSyncClientTypes {
    /// Describes a GraphQL API.
    public struct GraphqlApi {
        /// A list of additional authentication providers for the GraphqlApi API.
        public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
        /// The API ID.
        public var apiId: Swift.String?
        /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
        public var apiType: AppSyncClientTypes.GraphQLApiType?
        /// The Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The authentication type.
        public var authenticationType: AppSyncClientTypes.AuthenticationType?
        /// The DNS records for the API.
        public var dns: [Swift.String: Swift.String]?
        /// The enhancedMetricsConfig object.
        public var enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig?
        /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see [GraphQL introspection](https://graphql.org/learn/introspection/).
        public var introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig?
        /// Configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public var logConfig: AppSyncClientTypes.LogConfig?
        /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
        public var mergedApiExecutionRoleArn: Swift.String?
        /// The API name.
        public var name: Swift.String?
        /// The OpenID Connect configuration.
        public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
        /// The account owner of the GraphQL API.
        public var owner: Swift.String?
        /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
        public var ownerContact: Swift.String?
        /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
        public var queryDepthLimit: Swift.Int
        /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
        public var resolverCountLimit: Swift.Int
        /// The tags.
        public var tags: [Swift.String: Swift.String]?
        /// The URIs.
        public var uris: [Swift.String: Swift.String]?
        /// The Amazon Cognito user pool configuration.
        public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
        /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
        public var visibility: AppSyncClientTypes.GraphQLApiVisibility?
        /// The ARN of the WAF access control list (ACL) associated with this GraphqlApi, if one exists.
        public var wafWebAclArn: Swift.String?
        /// A flag indicating whether to use X-Ray tracing for this GraphqlApi.
        public var xrayEnabled: Swift.Bool

        public init(
            additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
            apiId: Swift.String? = nil,
            apiType: AppSyncClientTypes.GraphQLApiType? = nil,
            arn: Swift.String? = nil,
            authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
            dns: [Swift.String: Swift.String]? = nil,
            enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig? = nil,
            introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig? = nil,
            lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
            logConfig: AppSyncClientTypes.LogConfig? = nil,
            mergedApiExecutionRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
            owner: Swift.String? = nil,
            ownerContact: Swift.String? = nil,
            queryDepthLimit: Swift.Int = 0,
            resolverCountLimit: Swift.Int = 0,
            tags: [Swift.String: Swift.String]? = nil,
            uris: [Swift.String: Swift.String]? = nil,
            userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
            visibility: AppSyncClientTypes.GraphQLApiVisibility? = nil,
            wafWebAclArn: Swift.String? = nil,
            xrayEnabled: Swift.Bool = false
        )
        {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.apiType = apiType
            self.arn = arn
            self.authenticationType = authenticationType
            self.dns = dns
            self.enhancedMetricsConfig = enhancedMetricsConfig
            self.introspectionConfig = introspectionConfig
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.owner = owner
            self.ownerContact = ownerContact
            self.queryDepthLimit = queryDepthLimit
            self.resolverCountLimit = resolverCountLimit
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.visibility = visibility
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }
    }

}

public struct CreateGraphqlApiOutput {
    /// The GraphqlApi.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

extension AppSyncClientTypes {
    /// The caching configuration for a resolver that has caching activated.
    public struct CachingConfig {
        /// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        public var cachingKeys: [Swift.String]?
        /// The TTL in seconds for a resolver that has caching activated. Valid values are 1–3,600 seconds.
        /// This member is required.
        public var ttl: Swift.Int

        public init(
            cachingKeys: [Swift.String]? = nil,
            ttl: Swift.Int = 0
        )
        {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }
    }

}

extension AppSyncClientTypes {

    public enum ResolverKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pipeline
        case unit
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverKind] {
            return [
                .pipeline,
                .unit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pipeline: return "PIPELINE"
            case .unit: return "UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {

    public enum ResolverLevelMetricsConfig: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverLevelMetricsConfig] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppSyncClientTypes {
    /// The pipeline configuration for a resolver of kind PIPELINE.
    public struct PipelineConfig {
        /// A list of Function objects.
        public var functions: [Swift.String]?

        public init(
            functions: [Swift.String]? = nil
        )
        {
            self.functions = functions
        }
    }

}

public struct CreateResolverInput {
    /// The ID for the GraphQL API for which the resolver is being created.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The name of the data source for which the resolver is being created.
    public var dataSourceName: Swift.String?
    /// The name of the field to attach the resolver to.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
    public var metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The mapping template to use for requests. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The mapping template to use for responses from the data source.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The name of the Type.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        maxBatchSize: Swift.Int? = 0,
        metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.code = code
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.maxBatchSize = maxBatchSize
        self.metricsConfig = metricsConfig
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

extension AppSyncClientTypes {
    /// Describes a resolver.
    public struct Resolver {
        /// The caching configuration for the resolver.
        public var cachingConfig: AppSyncClientTypes.CachingConfig?
        /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public var code: Swift.String?
        /// The resolver data source name.
        public var dataSourceName: Swift.String?
        /// The resolver field name.
        public var fieldName: Swift.String?
        /// The resolver type.
        ///
        /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
        ///
        /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public var kind: AppSyncClientTypes.ResolverKind?
        /// The maximum batching size for a resolver.
        public var maxBatchSize: Swift.Int
        /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
        public var metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig?
        /// The PipelineConfig.
        public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
        /// The request mapping template.
        public var requestMappingTemplate: Swift.String?
        /// The resolver Amazon Resource Name (ARN).
        public var resolverArn: Swift.String?
        /// The response mapping template.
        public var responseMappingTemplate: Swift.String?
        /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
        public var runtime: AppSyncClientTypes.AppSyncRuntime?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public var syncConfig: AppSyncClientTypes.SyncConfig?
        /// The resolver type name.
        public var typeName: Swift.String?

        public init(
            cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
            code: Swift.String? = nil,
            dataSourceName: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            kind: AppSyncClientTypes.ResolverKind? = nil,
            maxBatchSize: Swift.Int = 0,
            metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig? = nil,
            pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
            requestMappingTemplate: Swift.String? = nil,
            resolverArn: Swift.String? = nil,
            responseMappingTemplate: Swift.String? = nil,
            runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
            syncConfig: AppSyncClientTypes.SyncConfig? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.cachingConfig = cachingConfig
            self.code = code
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.maxBatchSize = maxBatchSize
            self.metricsConfig = metricsConfig
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
            self.typeName = typeName
        }
    }

}

public struct CreateResolverOutput {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

extension AppSyncClientTypes {

    public enum TypeDefinitionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeDefinitionFormat] {
            return [
                .json,
                .sdl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTypeInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    /// This member is required.
    public var definition: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?

    public init(
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
    }
}

extension AppSyncClientTypes {
    /// Describes a type.
    public struct ModelType {
        /// The type Amazon Resource Name (ARN).
        public var arn: Swift.String?
        /// The type definition.
        public var definition: Swift.String?
        /// The type description.
        public var description: Swift.String?
        /// The type format: SDL or JSON.
        public var format: AppSyncClientTypes.TypeDefinitionFormat?
        /// The type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            definition: Swift.String? = nil,
            description: Swift.String? = nil,
            format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }
    }

}

public struct CreateTypeOutput {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

/// Represents the input of a DeleteApiCache operation.
public struct DeleteApiCacheInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

/// Represents the output of a DeleteApiCache operation.
public struct DeleteApiCacheOutput {

    public init() { }
}

public struct DeleteApiKeyInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID for the API key.
    /// This member is required.
    public var id: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.id = id
    }
}

public struct DeleteApiKeyOutput {

    public init() { }
}

public struct DeleteDataSourceInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

public struct DeleteDataSourceOutput {

    public init() { }
}

public struct DeleteDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DeleteDomainNameOutput {

    public init() { }
}

public struct DeleteFunctionInput {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

public struct DeleteFunctionOutput {

    public init() { }
}

public struct DeleteGraphqlApiInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct DeleteGraphqlApiOutput {

    public init() { }
}

public struct DeleteResolverInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The name of the resolver type.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

public struct DeleteResolverOutput {

    public init() { }
}

public struct DeleteTypeInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.typeName = typeName
    }
}

public struct DeleteTypeOutput {

    public init() { }
}

public struct DisassociateApiInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DisassociateApiOutput {

    public init() { }
}

public struct DisassociateMergedGraphqlApiInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
    /// This member is required.
    public var sourceApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        sourceApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.sourceApiIdentifier = sourceApiIdentifier
    }
}

public struct DisassociateMergedGraphqlApiOutput {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

public struct DisassociateSourceGraphqlApiInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

public struct DisassociateSourceGraphqlApiOutput {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

public struct EvaluateCodeInput {
    /// The code definition to be evaluated. Note that code and runtime are both required for this action. The runtime value must be APPSYNC_JS.
    /// This member is required.
    public var code: Swift.String?
    /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
    /// This member is required.
    public var context: Swift.String?
    /// The function within the code to be evaluated. If provided, the valid values are request and response.
    public var function: Swift.String?
    /// The runtime to be used when evaluating the code. Currently, only the APPSYNC_JS runtime is supported.
    /// This member is required.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?

    public init(
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        function: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil
    )
    {
        self.code = code
        self.context = context
        self.function = function
        self.runtime = runtime
    }
}

extension AppSyncClientTypes {
    /// Contains the list of errors from a code evaluation response.
    public struct EvaluateCodeErrorDetail {
        /// Contains the list of CodeError objects.
        public var codeErrors: [AppSyncClientTypes.CodeError]?
        /// The error payload.
        public var message: Swift.String?

        public init(
            codeErrors: [AppSyncClientTypes.CodeError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.codeErrors = codeErrors
            self.message = message
        }
    }

}

public struct EvaluateCodeOutput {
    /// Contains the payload of the response error.
    public var error: AppSyncClientTypes.EvaluateCodeErrorDetail?
    /// The result of the evaluation operation.
    public var evaluationResult: Swift.String?
    /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
    public var logs: [Swift.String]?

    public init(
        error: AppSyncClientTypes.EvaluateCodeErrorDetail? = nil,
        evaluationResult: Swift.String? = nil,
        logs: [Swift.String]? = nil
    )
    {
        self.error = error
        self.evaluationResult = evaluationResult
        self.logs = logs
    }
}

public struct EvaluateMappingTemplateInput {
    /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
    /// This member is required.
    public var context: Swift.String?
    /// The mapping template; this can be a request or response template. A template is required for this action.
    /// This member is required.
    public var template: Swift.String?

    public init(
        context: Swift.String? = nil,
        template: Swift.String? = nil
    )
    {
        self.context = context
        self.template = template
    }
}

extension AppSyncClientTypes {
    /// Contains the list of errors generated. When using JavaScript, this will apply to the request or response function evaluation.
    public struct ErrorDetail {
        /// The error payload.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

public struct EvaluateMappingTemplateOutput {
    /// The ErrorDetail object.
    public var error: AppSyncClientTypes.ErrorDetail?
    /// The mapping template; this can be a request or response template.
    public var evaluationResult: Swift.String?
    /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
    public var logs: [Swift.String]?

    public init(
        error: AppSyncClientTypes.ErrorDetail? = nil,
        evaluationResult: Swift.String? = nil,
        logs: [Swift.String]? = nil
    )
    {
        self.error = error
        self.evaluationResult = evaluationResult
        self.logs = logs
    }
}

/// Represents the input of a FlushApiCache operation.
public struct FlushApiCacheInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

/// Represents the output of a FlushApiCache operation.
public struct FlushApiCacheOutput {

    public init() { }
}

public struct GetApiAssociationInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct GetApiAssociationOutput {
    /// The ApiAssociation object.
    public var apiAssociation: AppSyncClientTypes.ApiAssociation?

    public init(
        apiAssociation: AppSyncClientTypes.ApiAssociation? = nil
    )
    {
        self.apiAssociation = apiAssociation
    }
}

/// Represents the input of a GetApiCache operation.
public struct GetApiCacheInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

/// Represents the output of a GetApiCache operation.
public struct GetApiCacheOutput {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

public struct GetDataSourceInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

public struct GetDataSourceOutput {
    /// The DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

public struct GetDataSourceIntrospectionInput {
    /// A boolean flag that determines whether SDL should be generated for introspected types or not. If set to true, each model will contain an sdl property that contains the SDL for that type. The SDL only contains the type data and no additional metadata or directives.
    public var includeModelsSDL: Swift.Bool?
    /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
    /// This member is required.
    public var introspectionId: Swift.String?
    /// The maximum number of introspected types that will be returned in a single response.
    public var maxResults: Swift.Int?
    /// Determines the number of types to be returned in a single response before paginating. This value is typically taken from nextToken value from the previous response.
    public var nextToken: Swift.String?

    public init(
        includeModelsSDL: Swift.Bool? = false,
        introspectionId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.includeModelsSDL = includeModelsSDL
        self.introspectionId = introspectionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppSyncClientTypes {
    /// The index that was retrieved from the introspected data.
    public struct DataSourceIntrospectionModelIndex {
        /// The fields of the index.
        public var fields: [Swift.String]?
        /// The name of the index.
        public var name: Swift.String?

        public init(
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fields = fields
            self.name = name
        }
    }

}

extension AppSyncClientTypes {

    public enum DataSourceIntrospectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceIntrospectionStatus] {
            return [
                .failed,
                .processing,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct GetDomainNameOutput {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

public struct GetFunctionInput {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The Function ID.
    /// This member is required.
    public var functionId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

public struct GetFunctionOutput {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

public struct GetGraphqlApiInput {
    /// The API ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct GetGraphqlApiOutput {
    /// The GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

public struct GetGraphqlApiEnvironmentVariablesInput {
    /// The ID of the API from which the environmental variable list will be retrieved.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct GetGraphqlApiEnvironmentVariablesOutput {
    /// The payload containing each environmental variable in the "key" : "value" format.
    public var environmentVariables: [Swift.String: Swift.String]?

    public init(
        environmentVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.environmentVariables = environmentVariables
    }
}

/// The GraphQL schema is not valid.
public struct GraphQLSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GraphQLSchemaException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppSyncClientTypes {

    public enum OutputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case sdl
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputType] {
            return [
                .json,
                .sdl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .sdl: return "SDL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIntrospectionSchemaInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.OutputType?
    /// A flag that specifies whether the schema introspection should contain directives.
    public var includeDirectives: Swift.Bool?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.OutputType? = nil,
        includeDirectives: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.includeDirectives = includeDirectives
    }
}

public struct GetIntrospectionSchemaOutput {
    /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the [GraphQL SDL documentation](http://graphql.org/learn/schema/).
    public var schema: Foundation.Data?

    public init(
        schema: Foundation.Data? = nil
    )
    {
        self.schema = schema
    }
}

public struct GetResolverInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The resolver field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

public struct GetResolverOutput {
    /// The Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

public struct GetSchemaCreationStatusInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

extension AppSyncClientTypes {

    public enum SchemaStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case failed
        case notapplicable
        case processing
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .notapplicable,
                .processing,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notapplicable: return "NOT_APPLICABLE"
            case .processing: return "PROCESSING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaCreationStatusOutput {
    /// Detailed information about the status of the schema creation operation.
    public var details: Swift.String?
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init(
        details: Swift.String? = nil,
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.details = details
        self.status = status
    }
}

public struct GetSourceApiAssociationInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

public struct GetSourceApiAssociationOutput {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

public struct GetTypeInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.typeName = typeName
    }
}

public struct GetTypeOutput {
    /// The Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

public struct ListApiKeysInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApiKeysOutput {
    /// The ApiKey objects.
    public var apiKeys: [AppSyncClientTypes.ApiKey]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiKeys: [AppSyncClientTypes.ApiKey]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiKeys = apiKeys
        self.nextToken = nextToken
    }
}

public struct ListDataSourcesInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDataSourcesOutput {
    /// The DataSource objects.
    public var dataSources: [AppSyncClientTypes.DataSource]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        dataSources: [AppSyncClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

public struct ListDomainNamesInput {
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDomainNamesOutput {
    /// Lists configurations for multiple domain names.
    public var domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        domainNameConfigs: [AppSyncClientTypes.DomainNameConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainNameConfigs = domainNameConfigs
        self.nextToken = nextToken
    }
}

public struct ListFunctionsInput {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFunctionsOutput {
    /// A list of Function objects.
    public var functions: [AppSyncClientTypes.FunctionConfiguration]?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        functions: [AppSyncClientTypes.FunctionConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functions = functions
        self.nextToken = nextToken
    }
}

extension AppSyncClientTypes {

    public enum Ownership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case currentAccount
        case otherAccounts
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .currentAccount,
                .otherAccounts
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .currentAccount: return "CURRENT_ACCOUNT"
            case .otherAccounts: return "OTHER_ACCOUNTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListGraphqlApisInput {
    /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
    public var apiType: AppSyncClientTypes.GraphQLApiType?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The account owner of the GraphQL API.
    public var owner: AppSyncClientTypes.Ownership?

    public init(
        apiType: AppSyncClientTypes.GraphQLApiType? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        owner: AppSyncClientTypes.Ownership? = nil
    )
    {
        self.apiType = apiType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

public struct ListGraphqlApisOutput {
    /// The GraphqlApi objects.
    public var graphqlApis: [AppSyncClientTypes.GraphqlApi]?
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        graphqlApis: [AppSyncClientTypes.GraphqlApi]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphqlApis = graphqlApis
        self.nextToken = nextToken
    }
}

public struct ListResolversInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

public struct ListResolversOutput {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Resolver objects.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init(
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

public struct ListResolversByFunctionInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        functionId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolversByFunctionOutput {
    /// An identifier that you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The list of resolvers.
    public var resolvers: [AppSyncClientTypes.Resolver]?

    public init(
        nextToken: Swift.String? = nil,
        resolvers: [AppSyncClientTypes.Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

public struct ListSourceApiAssociationsInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppSyncClientTypes {
    /// Describes the ARNs and IDs of associations, Merged APIs, and source APIs.
    public struct SourceApiAssociationSummary {
        /// The Amazon Resource Name (ARN) of the source API association.
        public var associationArn: Swift.String?
        /// The ID generated by the AppSync service for the source API association.
        public var associationId: Swift.String?
        /// The description field.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public var mergedApiArn: Swift.String?
        /// The ID of the AppSync Merged API.
        public var mergedApiId: Swift.String?
        /// The Amazon Resource Name (ARN) of the AppSync Source API.
        public var sourceApiArn: Swift.String?
        /// The ID of the AppSync source API.
        public var sourceApiId: Swift.String?

        public init(
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            description: Swift.String? = nil,
            mergedApiArn: Swift.String? = nil,
            mergedApiId: Swift.String? = nil,
            sourceApiArn: Swift.String? = nil,
            sourceApiId: Swift.String? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiId = sourceApiId
        }
    }

}

public struct ListSourceApiAssociationsOutput {
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The SourceApiAssociationSummary object data.
    public var sourceApiAssociationSummaries: [AppSyncClientTypes.SourceApiAssociationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sourceApiAssociationSummaries: [AppSyncClientTypes.SourceApiAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sourceApiAssociationSummaries = sourceApiAssociationSummaries
    }
}

public struct ListTagsForResourceInput {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A TagMap object.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTypesInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTypesOutput {
    /// An identifier to pass in the next request to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init(
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

public struct ListTypesByAssociationInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The format type.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The maximum number of results that you want the request to return.
    public var maxResults: Swift.Int?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        maxResults: Swift.Int? = 0,
        mergedApiIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.format = format
        self.maxResults = maxResults
        self.mergedApiIdentifier = mergedApiIdentifier
        self.nextToken = nextToken
    }
}

public struct ListTypesByAssociationOutput {
    /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The Type objects.
    public var types: [AppSyncClientTypes.ModelType]?

    public init(
        nextToken: Swift.String? = nil,
        types: [AppSyncClientTypes.ModelType]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

public struct PutGraphqlApiEnvironmentVariablesInput {
    /// The ID of the API to which the environmental variable list will be written.
    /// This member is required.
    public var apiId: Swift.String?
    /// The list of environmental variables to add to the API. When creating an environmental variable key-value pair, it must follow the additional constraints below:
    ///
    /// * Keys must begin with a letter.
    ///
    /// * Keys must be at least two characters long.
    ///
    /// * Keys can only contain letters, numbers, and the underscore character (_).
    ///
    /// * Values can be up to 512 characters long.
    ///
    /// * You can configure up to 50 key-value pairs in a GraphQL API.
    ///
    ///
    /// You can create a list of environmental variables by adding it to the environmentVariables payload as a list in the format {"key1":"value1","key2":"value2", …}. Note that each call of the PutGraphqlApiEnvironmentVariables action will result in the overwriting of the existing environmental variable list of that API. This means the existing environmental variables will be lost. To avoid this, you must include all existing and new environmental variables in the list each time you call this action.
    /// This member is required.
    public var environmentVariables: [Swift.String: Swift.String]?

    public init(
        apiId: Swift.String? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.apiId = apiId
        self.environmentVariables = environmentVariables
    }
}

public struct PutGraphqlApiEnvironmentVariablesOutput {
    /// The payload containing each environmental variable in the "key" : "value" format.
    public var environmentVariables: [Swift.String: Swift.String]?

    public init(
        environmentVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.environmentVariables = environmentVariables
    }
}

extension AppSyncClientTypes {
    /// Contains the metadata required to introspect the RDS cluster.
    public struct RdsDataApiConfig {
        /// The name of the database in the cluster.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The resource ARN of the RDS cluster.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The secret's ARN that was obtained from Secrets Manager. A secret consists of secret information, the secret value, plus metadata about the secret. A secret value can be a string or binary. It typically includes the ARN, secret name and description, policies, tags, encryption key from the Key Management Service, and key rotation data.
        /// This member is required.
        public var secretArn: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.resourceArn = resourceArn
            self.secretArn = secretArn
        }
    }

}

public struct StartDataSourceIntrospectionInput {
    /// The rdsDataApiConfig object data.
    public var rdsDataApiConfig: AppSyncClientTypes.RdsDataApiConfig?

    public init(
        rdsDataApiConfig: AppSyncClientTypes.RdsDataApiConfig? = nil
    )
    {
        self.rdsDataApiConfig = rdsDataApiConfig
    }
}

public struct StartDataSourceIntrospectionOutput {
    /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
    public var introspectionId: Swift.String?
    /// The status of the introspection during creation. By default, when a new instrospection has been created, the status will be set to PROCESSING. Once the operation has been completed, the status will change to SUCCESS or FAILED depending on how the data was parsed. A FAILED operation will return an error and its details as an introspectionStatusDetail.
    public var introspectionStatus: AppSyncClientTypes.DataSourceIntrospectionStatus?
    /// The error detail field. When a FAILEDintrospectionStatus is returned, the introspectionStatusDetail will also return the exact error that was generated during the operation.
    public var introspectionStatusDetail: Swift.String?

    public init(
        introspectionId: Swift.String? = nil,
        introspectionStatus: AppSyncClientTypes.DataSourceIntrospectionStatus? = nil,
        introspectionStatusDetail: Swift.String? = nil
    )
    {
        self.introspectionId = introspectionId
        self.introspectionStatus = introspectionStatus
        self.introspectionStatusDetail = introspectionStatusDetail
    }
}

public struct StartSchemaCreationInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The schema definition, in GraphQL schema language format.
    /// This member is required.
    public var definition: Foundation.Data?

    public init(
        apiId: Swift.String? = nil,
        definition: Foundation.Data? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
    }
}

public struct StartSchemaCreationOutput {
    /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
    public var status: AppSyncClientTypes.SchemaStatus?

    public init(
        status: AppSyncClientTypes.SchemaStatus? = nil
    )
    {
        self.status = status
    }
}

public struct StartSchemaMergeInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.mergedApiIdentifier = mergedApiIdentifier
    }
}

public struct StartSchemaMergeOutput {
    /// The state of the source API association.
    public var sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus?

    public init(
        sourceApiAssociationStatus: AppSyncClientTypes.SourceApiAssociationStatus? = nil
    )
    {
        self.sourceApiAssociationStatus = sourceApiAssociationStatus
    }
}

public struct TagResourceInput {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A TagMap object.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The GraphqlApi Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of TagKey objects.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

/// Represents the input of a UpdateApiCache operation.
public struct UpdateApiCacheInput {
    /// Caching behavior.
    ///
    /// * FULL_REQUEST_CACHING: All requests are fully cached.
    ///
    /// * PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
    /// This member is required.
    public var apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior?
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:
    ///
    /// * NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.
    ///
    /// * EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.
    ///
    ///
    /// Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
    public var healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig?
    /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
    /// This member is required.
    public var ttl: Swift.Int?
    /// The cache instance type. Valid values are
    ///
    /// * SMALL
    ///
    /// * MEDIUM
    ///
    /// * LARGE
    ///
    /// * XLARGE
    ///
    /// * LARGE_2X
    ///
    /// * LARGE_4X
    ///
    /// * LARGE_8X (not available in all regions)
    ///
    /// * LARGE_12X
    ///
    ///
    /// Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:
    ///
    /// * T2_SMALL: A t2.small instance type.
    ///
    /// * T2_MEDIUM: A t2.medium instance type.
    ///
    /// * R4_LARGE: A r4.large instance type.
    ///
    /// * R4_XLARGE: A r4.xlarge instance type.
    ///
    /// * R4_2XLARGE: A r4.2xlarge instance type.
    ///
    /// * R4_4XLARGE: A r4.4xlarge instance type.
    ///
    /// * R4_8XLARGE: A r4.8xlarge instance type.
    /// This member is required.
    public var type: AppSyncClientTypes.ApiCacheType?

    public init(
        apiCachingBehavior: AppSyncClientTypes.ApiCachingBehavior? = nil,
        apiId: Swift.String? = nil,
        healthMetricsConfig: AppSyncClientTypes.CacheHealthMetricsConfig? = nil,
        ttl: Swift.Int? = 0,
        type: AppSyncClientTypes.ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.healthMetricsConfig = healthMetricsConfig
        self.ttl = ttl
        self.type = type
    }
}

/// Represents the output of a UpdateApiCache operation.
public struct UpdateApiCacheOutput {
    /// The ApiCache object.
    public var apiCache: AppSyncClientTypes.ApiCache?

    public init(
        apiCache: AppSyncClientTypes.ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

public struct UpdateApiKeyInput {
    /// The ID for the GraphQL API.
    /// This member is required.
    public var apiId: Swift.String?
    /// A description of the purpose of the API key.
    public var description: Swift.String?
    /// From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
    public var expires: Swift.Int?
    /// The API key ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        expires: Swift.Int? = 0,
        id: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
        self.id = id
    }
}

public struct UpdateApiKeyOutput {
    /// The API key.
    public var apiKey: AppSyncClientTypes.ApiKey?

    public init(
        apiKey: AppSyncClientTypes.ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

public struct UpdateDataSourceInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new description for the data source.
    public var description: Swift.String?
    /// The new Amazon DynamoDB configuration.
    public var dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig?
    /// The new OpenSearch configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. Instead, use [UpdateDataSourceRequest$openSearchServiceConfig] to update an OpenSearch data source.
    public var elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig?
    /// The new Amazon EventBridge settings.
    public var eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig?
    /// The new HTTP endpoint configuration.
    public var httpConfig: AppSyncClientTypes.HttpDataSourceConfig?
    /// The new Lambda configuration.
    public var lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig?
    /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
    public var metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig?
    /// The new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// The new OpenSearch configuration.
    public var openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?
    /// The new relational database configuration.
    public var relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?
    /// The new service role Amazon Resource Name (ARN) for the data source.
    public var serviceRoleArn: Swift.String?
    /// The new data source type.
    /// This member is required.
    public var type: AppSyncClientTypes.DataSourceType?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        dynamodbConfig: AppSyncClientTypes.DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: AppSyncClientTypes.ElasticsearchDataSourceConfig? = nil,
        eventBridgeConfig: AppSyncClientTypes.EventBridgeDataSourceConfig? = nil,
        httpConfig: AppSyncClientTypes.HttpDataSourceConfig? = nil,
        lambdaConfig: AppSyncClientTypes.LambdaDataSourceConfig? = nil,
        metricsConfig: AppSyncClientTypes.DataSourceLevelMetricsConfig? = nil,
        name: Swift.String? = nil,
        openSearchServiceConfig: AppSyncClientTypes.OpenSearchServiceDataSourceConfig? = nil,
        relationalDatabaseConfig: AppSyncClientTypes.RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: Swift.String? = nil,
        type: AppSyncClientTypes.DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.eventBridgeConfig = eventBridgeConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.metricsConfig = metricsConfig
        self.name = name
        self.openSearchServiceConfig = openSearchServiceConfig
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

public struct UpdateDataSourceOutput {
    /// The updated DataSource object.
    public var dataSource: AppSyncClientTypes.DataSource?

    public init(
        dataSource: AppSyncClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

public struct UpdateDomainNameInput {
    /// A description of the DomainName.
    public var description: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.description = description
        self.domainName = domainName
    }
}

public struct UpdateDomainNameOutput {
    /// The configuration for the DomainName.
    public var domainNameConfig: AppSyncClientTypes.DomainNameConfig?

    public init(
        domainNameConfig: AppSyncClientTypes.DomainNameConfig? = nil
    )
    {
        self.domainNameConfig = domainNameConfig
    }
}

public struct UpdateFunctionInput {
    /// The GraphQL API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The FunctionDataSource name.
    /// This member is required.
    public var dataSourceName: Swift.String?
    /// The Function description.
    public var description: Swift.String?
    /// The function ID.
    /// This member is required.
    public var functionId: Swift.String?
    /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
    public var functionVersion: Swift.String?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// The Function name.
    /// This member is required.
    public var name: Swift.String?
    /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
    public var requestMappingTemplate: Swift.String?
    /// The Function request mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
    public var syncConfig: AppSyncClientTypes.SyncConfig?

    public init(
        apiId: Swift.String? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        description: Swift.String? = nil,
        functionId: Swift.String? = nil,
        functionVersion: Swift.String? = nil,
        maxBatchSize: Swift.Int? = 0,
        name: Swift.String? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.code = code
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.maxBatchSize = maxBatchSize
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
    }
}

public struct UpdateFunctionOutput {
    /// The Function object.
    public var functionConfiguration: AppSyncClientTypes.FunctionConfiguration?

    public init(
        functionConfiguration: AppSyncClientTypes.FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

public struct UpdateGraphqlApiInput {
    /// A list of additional authentication providers for the GraphqlApi API.
    public var additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]?
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new authentication type for the GraphqlApi object.
    /// This member is required.
    public var authenticationType: AppSyncClientTypes.AuthenticationType?
    /// The enhancedMetricsConfig object.
    public var enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig?
    /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see [GraphQL introspection](https://graphql.org/learn/introspection/).
    public var introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig?
    /// Configuration for Lambda function authorization.
    public var lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig?
    /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
    public var logConfig: AppSyncClientTypes.LogConfig?
    /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
    public var mergedApiExecutionRoleArn: Swift.String?
    /// The new name for the GraphqlApi object.
    /// This member is required.
    public var name: Swift.String?
    /// The OpenID Connect configuration for the GraphqlApi object.
    public var openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig?
    /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
    public var ownerContact: Swift.String?
    /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
    public var queryDepthLimit: Swift.Int?
    /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
    public var resolverCountLimit: Swift.Int?
    /// The new Amazon Cognito user pool configuration for the ~GraphqlApi object.
    public var userPoolConfig: AppSyncClientTypes.UserPoolConfig?
    /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
    public var xrayEnabled: Swift.Bool?

    public init(
        additionalAuthenticationProviders: [AppSyncClientTypes.AdditionalAuthenticationProvider]? = nil,
        apiId: Swift.String? = nil,
        authenticationType: AppSyncClientTypes.AuthenticationType? = nil,
        enhancedMetricsConfig: AppSyncClientTypes.EnhancedMetricsConfig? = nil,
        introspectionConfig: AppSyncClientTypes.GraphQLApiIntrospectionConfig? = nil,
        lambdaAuthorizerConfig: AppSyncClientTypes.LambdaAuthorizerConfig? = nil,
        logConfig: AppSyncClientTypes.LogConfig? = nil,
        mergedApiExecutionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        openIDConnectConfig: AppSyncClientTypes.OpenIDConnectConfig? = nil,
        ownerContact: Swift.String? = nil,
        queryDepthLimit: Swift.Int? = 0,
        resolverCountLimit: Swift.Int? = 0,
        userPoolConfig: AppSyncClientTypes.UserPoolConfig? = nil,
        xrayEnabled: Swift.Bool? = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.authenticationType = authenticationType
        self.enhancedMetricsConfig = enhancedMetricsConfig
        self.introspectionConfig = introspectionConfig
        self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
        self.logConfig = logConfig
        self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.ownerContact = ownerContact
        self.queryDepthLimit = queryDepthLimit
        self.resolverCountLimit = resolverCountLimit
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

public struct UpdateGraphqlApiOutput {
    /// The updated GraphqlApi object.
    public var graphqlApi: AppSyncClientTypes.GraphqlApi?

    public init(
        graphqlApi: AppSyncClientTypes.GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

public struct UpdateResolverInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The caching configuration for the resolver.
    public var cachingConfig: AppSyncClientTypes.CachingConfig?
    /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
    public var code: Swift.String?
    /// The new data source name.
    public var dataSourceName: Swift.String?
    /// The new field name.
    /// This member is required.
    public var fieldName: Swift.String?
    /// The resolver type.
    ///
    /// * UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.
    ///
    /// * PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
    public var kind: AppSyncClientTypes.ResolverKind?
    /// The maximum batching size for a resolver.
    public var maxBatchSize: Swift.Int?
    /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value. metricsConfig can be ENABLED or DISABLED.
    public var metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig?
    /// The PipelineConfig.
    public var pipelineConfig: AppSyncClientTypes.PipelineConfig?
    /// The new request mapping template. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
    public var requestMappingTemplate: Swift.String?
    /// The new response mapping template.
    public var responseMappingTemplate: Swift.String?
    /// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
    public var runtime: AppSyncClientTypes.AppSyncRuntime?
    /// The SyncConfig for a resolver attached to a versioned data source.
    public var syncConfig: AppSyncClientTypes.SyncConfig?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        cachingConfig: AppSyncClientTypes.CachingConfig? = nil,
        code: Swift.String? = nil,
        dataSourceName: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        kind: AppSyncClientTypes.ResolverKind? = nil,
        maxBatchSize: Swift.Int? = 0,
        metricsConfig: AppSyncClientTypes.ResolverLevelMetricsConfig? = nil,
        pipelineConfig: AppSyncClientTypes.PipelineConfig? = nil,
        requestMappingTemplate: Swift.String? = nil,
        responseMappingTemplate: Swift.String? = nil,
        runtime: AppSyncClientTypes.AppSyncRuntime? = nil,
        syncConfig: AppSyncClientTypes.SyncConfig? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.code = code
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.maxBatchSize = maxBatchSize
        self.metricsConfig = metricsConfig
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.runtime = runtime
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

public struct UpdateResolverOutput {
    /// The updated Resolver object.
    public var resolver: AppSyncClientTypes.Resolver?

    public init(
        resolver: AppSyncClientTypes.Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

public struct UpdateSourceApiAssociationInput {
    /// The ID generated by the AppSync service for the source API association.
    /// This member is required.
    public var associationId: Swift.String?
    /// The description field.
    public var description: Swift.String?
    /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
    /// This member is required.
    public var mergedApiIdentifier: Swift.String?
    /// The SourceApiAssociationConfig object data.
    public var sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig?

    public init(
        associationId: Swift.String? = nil,
        description: Swift.String? = nil,
        mergedApiIdentifier: Swift.String? = nil,
        sourceApiAssociationConfig: AppSyncClientTypes.SourceApiAssociationConfig? = nil
    )
    {
        self.associationId = associationId
        self.description = description
        self.mergedApiIdentifier = mergedApiIdentifier
        self.sourceApiAssociationConfig = sourceApiAssociationConfig
    }
}

public struct UpdateSourceApiAssociationOutput {
    /// The SourceApiAssociation object data.
    public var sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation?

    public init(
        sourceApiAssociation: AppSyncClientTypes.SourceApiAssociation? = nil
    )
    {
        self.sourceApiAssociation = sourceApiAssociation
    }
}

public struct UpdateTypeInput {
    /// The API ID.
    /// This member is required.
    public var apiId: Swift.String?
    /// The new definition.
    public var definition: Swift.String?
    /// The new type format: SDL or JSON.
    /// This member is required.
    public var format: AppSyncClientTypes.TypeDefinitionFormat?
    /// The new type name.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        definition: Swift.String? = nil,
        format: AppSyncClientTypes.TypeDefinitionFormat? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
        self.typeName = typeName
    }
}

public struct UpdateTypeOutput {
    /// The updated Type object.
    public var type: AppSyncClientTypes.ModelType?

    public init(
        type: AppSyncClientTypes.ModelType? = nil
    )
    {
        self.type = type
    }
}

extension AppSyncClientTypes {
    /// Represents the type data for each field retrieved from the introspection.
    public struct DataSourceIntrospectionModelFieldType {
        /// Specifies the classification of data. For example, this could be set to values like Scalar or NonNull to indicate a fundamental property of the field. Valid values include:
        ///
        /// * Scalar: Indicates the value is a primitive type (scalar).
        ///
        /// * NonNull: Indicates the field cannot be null.
        ///
        /// * List: Indicates the field contains a list.
        public var kind: Swift.String?
        /// The name of the data type that represents the field. For example, String is a valid name value.
        public var name: Swift.String?
        /// The DataSourceIntrospectionModelFieldType object data. The type is only present if DataSourceIntrospectionModelFieldType.kind is set to NonNull or List. The type typically contains its own kind and name fields to represent the actual type data. For instance, type could contain a kind value of Scalar with a name value of String. The values Scalar and String will be collectively stored in the values field.
        @Indirect public var type: AppSyncClientTypes.DataSourceIntrospectionModelFieldType?
        /// The values of the type field. This field represents the AppSync data type equivalent of the introspected field.
        public var values: [Swift.String]?

        public init(
            kind: Swift.String? = nil,
            name: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceIntrospectionModelFieldType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.kind = kind
            self.name = name
            self.type = type
            self.values = values
        }
    }

}

extension AppSyncClientTypes {
    /// Represents the fields that were retrieved from the introspected data.
    public struct DataSourceIntrospectionModelField {
        /// The length value of the introspected field.
        public var length: Swift.Int
        /// The name of the field that was retrieved from the introspected data.
        public var name: Swift.String?
        /// The DataSourceIntrospectionModelFieldType object data.
        public var type: AppSyncClientTypes.DataSourceIntrospectionModelFieldType?

        public init(
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            type: AppSyncClientTypes.DataSourceIntrospectionModelFieldType? = nil
        )
        {
            self.length = length
            self.name = name
            self.type = type
        }
    }

}

extension AppSyncClientTypes {
    /// Contains the introspected data that was retrieved from the data source.
    public struct DataSourceIntrospectionModel {
        /// The DataSourceIntrospectionModelField object data.
        public var fields: [AppSyncClientTypes.DataSourceIntrospectionModelField]?
        /// The array of DataSourceIntrospectionModelIndex objects.
        public var indexes: [AppSyncClientTypes.DataSourceIntrospectionModelIndex]?
        /// The name of the model. For example, this could be the name of a single table in a database.
        public var name: Swift.String?
        /// The primary key stored as a DataSourceIntrospectionModelIndex object.
        public var primaryKey: AppSyncClientTypes.DataSourceIntrospectionModelIndex?
        /// Contains the output of the SDL that was generated from the introspected types. This is controlled by the includeModelsSDL parameter of the GetDataSourceIntrospection operation.
        public var sdl: Swift.String?

        public init(
            fields: [AppSyncClientTypes.DataSourceIntrospectionModelField]? = nil,
            indexes: [AppSyncClientTypes.DataSourceIntrospectionModelIndex]? = nil,
            name: Swift.String? = nil,
            primaryKey: AppSyncClientTypes.DataSourceIntrospectionModelIndex? = nil,
            sdl: Swift.String? = nil
        )
        {
            self.fields = fields
            self.indexes = indexes
            self.name = name
            self.primaryKey = primaryKey
            self.sdl = sdl
        }
    }

}

extension AppSyncClientTypes {
    /// Represents the output of a DataSourceIntrospectionResult. This is the populated result of a GetDataSourceIntrospection operation.
    public struct DataSourceIntrospectionResult {
        /// The array of DataSourceIntrospectionModel objects.
        public var models: [AppSyncClientTypes.DataSourceIntrospectionModel]?
        /// Determines the number of types to be returned in a single response before paginating. This value is typically taken from nextToken value from the previous response.
        public var nextToken: Swift.String?

        public init(
            models: [AppSyncClientTypes.DataSourceIntrospectionModel]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.models = models
            self.nextToken = nextToken
        }
    }

}

public struct GetDataSourceIntrospectionOutput {
    /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
    public var introspectionId: Swift.String?
    /// The DataSourceIntrospectionResult object data.
    public var introspectionResult: AppSyncClientTypes.DataSourceIntrospectionResult?
    /// The status of the introspection during retrieval. By default, when a new instrospection is being retrieved, the status will be set to PROCESSING. Once the operation has been completed, the status will change to SUCCESS or FAILED depending on how the data was parsed. A FAILED operation will return an error and its details as an introspectionStatusDetail.
    public var introspectionStatus: AppSyncClientTypes.DataSourceIntrospectionStatus?
    /// The error detail field. When a FAILEDintrospectionStatus is returned, the introspectionStatusDetail will also return the exact error that was generated during the operation.
    public var introspectionStatusDetail: Swift.String?

    public init(
        introspectionId: Swift.String? = nil,
        introspectionResult: AppSyncClientTypes.DataSourceIntrospectionResult? = nil,
        introspectionStatus: AppSyncClientTypes.DataSourceIntrospectionStatus? = nil,
        introspectionStatusDetail: Swift.String? = nil
    )
    {
        self.introspectionId = introspectionId
        self.introspectionResult = introspectionResult
        self.introspectionStatus = introspectionStatus
        self.introspectionStatusDetail = introspectionStatusDetail
    }
}

extension AssociateApiInput {

    static func urlPathProvider(_ value: AssociateApiInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

extension AssociateMergedGraphqlApiInput {

    static func urlPathProvider(_ value: AssociateMergedGraphqlApiInput) -> Swift.String? {
        guard let sourceApiIdentifier = value.sourceApiIdentifier else {
            return nil
        }
        return "/v1/sourceApis/\(sourceApiIdentifier.urlPercentEncoding())/mergedApiAssociations"
    }
}

extension AssociateSourceGraphqlApiInput {

    static func urlPathProvider(_ value: AssociateSourceGraphqlApiInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations"
    }
}

extension CreateApiCacheInput {

    static func urlPathProvider(_ value: CreateApiCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

extension CreateApiKeyInput {

    static func urlPathProvider(_ value: CreateApiKeyInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

extension CreateDomainNameInput {

    static func urlPathProvider(_ value: CreateDomainNameInput) -> Swift.String? {
        return "/v1/domainnames"
    }
}

extension CreateFunctionInput {

    static func urlPathProvider(_ value: CreateFunctionInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

extension CreateGraphqlApiInput {

    static func urlPathProvider(_ value: CreateGraphqlApiInput) -> Swift.String? {
        return "/v1/apis"
    }
}

extension CreateResolverInput {

    static func urlPathProvider(_ value: CreateResolverInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

extension CreateTypeInput {

    static func urlPathProvider(_ value: CreateTypeInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

extension DeleteApiCacheInput {

    static func urlPathProvider(_ value: DeleteApiCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

extension DeleteApiKeyInput {

    static func urlPathProvider(_ value: DeleteApiKeyInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

extension DeleteDomainNameInput {

    static func urlPathProvider(_ value: DeleteDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func urlPathProvider(_ value: DeleteFunctionInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let functionId = value.functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

extension DeleteGraphqlApiInput {

    static func urlPathProvider(_ value: DeleteGraphqlApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

extension DeleteResolverInput {

    static func urlPathProvider(_ value: DeleteResolverInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        guard let fieldName = value.fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

extension DeleteTypeInput {

    static func urlPathProvider(_ value: DeleteTypeInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

extension DisassociateApiInput {

    static func urlPathProvider(_ value: DisassociateApiInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

extension DisassociateMergedGraphqlApiInput {

    static func urlPathProvider(_ value: DisassociateMergedGraphqlApiInput) -> Swift.String? {
        guard let sourceApiIdentifier = value.sourceApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/sourceApis/\(sourceApiIdentifier.urlPercentEncoding())/mergedApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

extension DisassociateSourceGraphqlApiInput {

    static func urlPathProvider(_ value: DisassociateSourceGraphqlApiInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

extension EvaluateCodeInput {

    static func urlPathProvider(_ value: EvaluateCodeInput) -> Swift.String? {
        return "/v1/dataplane-evaluatecode"
    }
}

extension EvaluateMappingTemplateInput {

    static func urlPathProvider(_ value: EvaluateMappingTemplateInput) -> Swift.String? {
        return "/v1/dataplane-evaluatetemplate"
    }
}

extension FlushApiCacheInput {

    static func urlPathProvider(_ value: FlushApiCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/FlushCache"
    }
}

extension GetApiAssociationInput {

    static func urlPathProvider(_ value: GetApiAssociationInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())/apiassociation"
    }
}

extension GetApiCacheInput {

    static func urlPathProvider(_ value: GetApiCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches"
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

extension GetDataSourceIntrospectionInput {

    static func urlPathProvider(_ value: GetDataSourceIntrospectionInput) -> Swift.String? {
        guard let introspectionId = value.introspectionId else {
            return nil
        }
        return "/v1/datasources/introspections/\(introspectionId.urlPercentEncoding())"
    }
}

extension GetDataSourceIntrospectionInput {

    static func queryItemProvider(_ value: GetDataSourceIntrospectionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeModelsSDL = value.includeModelsSDL {
            let includeModelsSDLQueryItem = Smithy.URIQueryItem(name: "includeModelsSDL".urlPercentEncoding(), value: Swift.String(includeModelsSDL).urlPercentEncoding())
            items.append(includeModelsSDLQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDomainNameInput {

    static func urlPathProvider(_ value: GetDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func urlPathProvider(_ value: GetFunctionInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let functionId = value.functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

extension GetGraphqlApiInput {

    static func urlPathProvider(_ value: GetGraphqlApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

extension GetGraphqlApiEnvironmentVariablesInput {

    static func urlPathProvider(_ value: GetGraphqlApiEnvironmentVariablesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/environmentVariables"
    }
}

extension GetIntrospectionSchemaInput {

    static func urlPathProvider(_ value: GetIntrospectionSchemaInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schema"
    }
}

extension GetIntrospectionSchemaInput {

    static func queryItemProvider(_ value: GetIntrospectionSchemaInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeDirectives = value.includeDirectives {
            let includeDirectivesQueryItem = Smithy.URIQueryItem(name: "includeDirectives".urlPercentEncoding(), value: Swift.String(includeDirectives).urlPercentEncoding())
            items.append(includeDirectivesQueryItem)
        }
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        return items
    }
}

extension GetResolverInput {

    static func urlPathProvider(_ value: GetResolverInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        guard let fieldName = value.fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

extension GetSchemaCreationStatusInput {

    static func urlPathProvider(_ value: GetSchemaCreationStatusInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

extension GetSourceApiAssociationInput {

    static func urlPathProvider(_ value: GetSourceApiAssociationInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

extension GetTypeInput {

    static func urlPathProvider(_ value: GetTypeInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

extension GetTypeInput {

    static func queryItemProvider(_ value: GetTypeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        return items
    }
}

extension ListApiKeysInput {

    static func urlPathProvider(_ value: ListApiKeysInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys"
    }
}

extension ListApiKeysInput {

    static func queryItemProvider(_ value: ListApiKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources"
    }
}

extension ListDataSourcesInput {

    static func queryItemProvider(_ value: ListDataSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainNamesInput {

    static func urlPathProvider(_ value: ListDomainNamesInput) -> Swift.String? {
        return "/v1/domainnames"
    }
}

extension ListDomainNamesInput {

    static func queryItemProvider(_ value: ListDomainNamesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput {

    static func urlPathProvider(_ value: ListFunctionsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions"
    }
}

extension ListFunctionsInput {

    static func queryItemProvider(_ value: ListFunctionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGraphqlApisInput {

    static func urlPathProvider(_ value: ListGraphqlApisInput) -> Swift.String? {
        return "/v1/apis"
    }
}

extension ListGraphqlApisInput {

    static func queryItemProvider(_ value: ListGraphqlApisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let owner = value.owner {
            let ownerQueryItem = Smithy.URIQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner.rawValue).urlPercentEncoding())
            items.append(ownerQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let apiType = value.apiType {
            let apiTypeQueryItem = Smithy.URIQueryItem(name: "apiType".urlPercentEncoding(), value: Swift.String(apiType.rawValue).urlPercentEncoding())
            items.append(apiTypeQueryItem)
        }
        return items
    }
}

extension ListResolversInput {

    static func urlPathProvider(_ value: ListResolversInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers"
    }
}

extension ListResolversInput {

    static func queryItemProvider(_ value: ListResolversInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResolversByFunctionInput {

    static func urlPathProvider(_ value: ListResolversByFunctionInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let functionId = value.functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())/resolvers"
    }
}

extension ListResolversByFunctionInput {

    static func queryItemProvider(_ value: ListResolversByFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSourceApiAssociationsInput {

    static func urlPathProvider(_ value: ListSourceApiAssociationsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/sourceApiAssociations"
    }
}

extension ListSourceApiAssociationsInput {

    static func queryItemProvider(_ value: ListSourceApiAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTypesInput {

    static func urlPathProvider(_ value: ListTypesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types"
    }
}

extension ListTypesInput {

    static func queryItemProvider(_ value: ListTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        return items
    }
}

extension ListTypesByAssociationInput {

    static func urlPathProvider(_ value: ListTypesByAssociationInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())/types"
    }
}

extension ListTypesByAssociationInput {

    static func queryItemProvider(_ value: ListTypesByAssociationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        return items
    }
}

extension PutGraphqlApiEnvironmentVariablesInput {

    static func urlPathProvider(_ value: PutGraphqlApiEnvironmentVariablesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/environmentVariables"
    }
}

extension StartDataSourceIntrospectionInput {

    static func urlPathProvider(_ value: StartDataSourceIntrospectionInput) -> Swift.String? {
        return "/v1/datasources/introspections"
    }
}

extension StartSchemaCreationInput {

    static func urlPathProvider(_ value: StartSchemaCreationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/schemacreation"
    }
}

extension StartSchemaMergeInput {

    static func urlPathProvider(_ value: StartSchemaMergeInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())/merge"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApiCacheInput {

    static func urlPathProvider(_ value: UpdateApiCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/ApiCaches/update"
    }
}

extension UpdateApiKeyInput {

    static func urlPathProvider(_ value: UpdateApiKeyInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/apikeys/\(id.urlPercentEncoding())"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/datasources/\(name.urlPercentEncoding())"
    }
}

extension UpdateDomainNameInput {

    static func urlPathProvider(_ value: UpdateDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v1/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateFunctionInput {

    static func urlPathProvider(_ value: UpdateFunctionInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let functionId = value.functionId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/functions/\(functionId.urlPercentEncoding())"
    }
}

extension UpdateGraphqlApiInput {

    static func urlPathProvider(_ value: UpdateGraphqlApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())"
    }
}

extension UpdateResolverInput {

    static func urlPathProvider(_ value: UpdateResolverInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        guard let fieldName = value.fieldName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())/resolvers/\(fieldName.urlPercentEncoding())"
    }
}

extension UpdateSourceApiAssociationInput {

    static func urlPathProvider(_ value: UpdateSourceApiAssociationInput) -> Swift.String? {
        guard let mergedApiIdentifier = value.mergedApiIdentifier else {
            return nil
        }
        guard let associationId = value.associationId else {
            return nil
        }
        return "/v1/mergedApis/\(mergedApiIdentifier.urlPercentEncoding())/sourceApiAssociations/\(associationId.urlPercentEncoding())"
    }
}

extension UpdateTypeInput {

    static func urlPathProvider(_ value: UpdateTypeInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let typeName = value.typeName else {
            return nil
        }
        return "/v1/apis/\(apiId.urlPercentEncoding())/types/\(typeName.urlPercentEncoding())"
    }
}

extension AssociateApiInput {

    static func write(value: AssociateApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
    }
}

extension AssociateMergedGraphqlApiInput {

    static func write(value: AssociateMergedGraphqlApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["mergedApiIdentifier"].write(value.mergedApiIdentifier)
        try writer["sourceApiAssociationConfig"].write(value.sourceApiAssociationConfig, with: AppSyncClientTypes.SourceApiAssociationConfig.write(value:to:))
    }
}

extension AssociateSourceGraphqlApiInput {

    static func write(value: AssociateSourceGraphqlApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["sourceApiAssociationConfig"].write(value.sourceApiAssociationConfig, with: AppSyncClientTypes.SourceApiAssociationConfig.write(value:to:))
        try writer["sourceApiIdentifier"].write(value.sourceApiIdentifier)
    }
}

extension CreateApiCacheInput {

    static func write(value: CreateApiCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiCachingBehavior"].write(value.apiCachingBehavior)
        try writer["atRestEncryptionEnabled"].write(value.atRestEncryptionEnabled)
        try writer["healthMetricsConfig"].write(value.healthMetricsConfig)
        try writer["transitEncryptionEnabled"].write(value.transitEncryptionEnabled)
        try writer["ttl"].write(value.ttl)
        try writer["type"].write(value.type)
    }
}

extension CreateApiKeyInput {

    static func write(value: CreateApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["expires"].write(value.expires)
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["dynamodbConfig"].write(value.dynamodbConfig, with: AppSyncClientTypes.DynamodbDataSourceConfig.write(value:to:))
        try writer["elasticsearchConfig"].write(value.elasticsearchConfig, with: AppSyncClientTypes.ElasticsearchDataSourceConfig.write(value:to:))
        try writer["eventBridgeConfig"].write(value.eventBridgeConfig, with: AppSyncClientTypes.EventBridgeDataSourceConfig.write(value:to:))
        try writer["httpConfig"].write(value.httpConfig, with: AppSyncClientTypes.HttpDataSourceConfig.write(value:to:))
        try writer["lambdaConfig"].write(value.lambdaConfig, with: AppSyncClientTypes.LambdaDataSourceConfig.write(value:to:))
        try writer["metricsConfig"].write(value.metricsConfig)
        try writer["name"].write(value.name)
        try writer["openSearchServiceConfig"].write(value.openSearchServiceConfig, with: AppSyncClientTypes.OpenSearchServiceDataSourceConfig.write(value:to:))
        try writer["relationalDatabaseConfig"].write(value.relationalDatabaseConfig, with: AppSyncClientTypes.RelationalDatabaseDataSourceConfig.write(value:to:))
        try writer["serviceRoleArn"].write(value.serviceRoleArn)
        try writer["type"].write(value.type)
    }
}

extension CreateDomainNameInput {

    static func write(value: CreateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["description"].write(value.description)
        try writer["domainName"].write(value.domainName)
    }
}

extension CreateFunctionInput {

    static func write(value: CreateFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["dataSourceName"].write(value.dataSourceName)
        try writer["description"].write(value.description)
        try writer["functionVersion"].write(value.functionVersion)
        try writer["maxBatchSize"].write(value.maxBatchSize)
        try writer["name"].write(value.name)
        try writer["requestMappingTemplate"].write(value.requestMappingTemplate)
        try writer["responseMappingTemplate"].write(value.responseMappingTemplate)
        try writer["runtime"].write(value.runtime, with: AppSyncClientTypes.AppSyncRuntime.write(value:to:))
        try writer["syncConfig"].write(value.syncConfig, with: AppSyncClientTypes.SyncConfig.write(value:to:))
    }
}

extension CreateGraphqlApiInput {

    static func write(value: CreateGraphqlApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAuthenticationProviders"].writeList(value.additionalAuthenticationProviders, memberWritingClosure: AppSyncClientTypes.AdditionalAuthenticationProvider.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["apiType"].write(value.apiType)
        try writer["authenticationType"].write(value.authenticationType)
        try writer["enhancedMetricsConfig"].write(value.enhancedMetricsConfig, with: AppSyncClientTypes.EnhancedMetricsConfig.write(value:to:))
        try writer["introspectionConfig"].write(value.introspectionConfig)
        try writer["lambdaAuthorizerConfig"].write(value.lambdaAuthorizerConfig, with: AppSyncClientTypes.LambdaAuthorizerConfig.write(value:to:))
        try writer["logConfig"].write(value.logConfig, with: AppSyncClientTypes.LogConfig.write(value:to:))
        try writer["mergedApiExecutionRoleArn"].write(value.mergedApiExecutionRoleArn)
        try writer["name"].write(value.name)
        try writer["openIDConnectConfig"].write(value.openIDConnectConfig, with: AppSyncClientTypes.OpenIDConnectConfig.write(value:to:))
        try writer["ownerContact"].write(value.ownerContact)
        try writer["queryDepthLimit"].write(value.queryDepthLimit)
        try writer["resolverCountLimit"].write(value.resolverCountLimit)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["userPoolConfig"].write(value.userPoolConfig, with: AppSyncClientTypes.UserPoolConfig.write(value:to:))
        try writer["visibility"].write(value.visibility)
        try writer["xrayEnabled"].write(value.xrayEnabled)
    }
}

extension CreateResolverInput {

    static func write(value: CreateResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cachingConfig"].write(value.cachingConfig, with: AppSyncClientTypes.CachingConfig.write(value:to:))
        try writer["code"].write(value.code)
        try writer["dataSourceName"].write(value.dataSourceName)
        try writer["fieldName"].write(value.fieldName)
        try writer["kind"].write(value.kind)
        try writer["maxBatchSize"].write(value.maxBatchSize)
        try writer["metricsConfig"].write(value.metricsConfig)
        try writer["pipelineConfig"].write(value.pipelineConfig, with: AppSyncClientTypes.PipelineConfig.write(value:to:))
        try writer["requestMappingTemplate"].write(value.requestMappingTemplate)
        try writer["responseMappingTemplate"].write(value.responseMappingTemplate)
        try writer["runtime"].write(value.runtime, with: AppSyncClientTypes.AppSyncRuntime.write(value:to:))
        try writer["syncConfig"].write(value.syncConfig, with: AppSyncClientTypes.SyncConfig.write(value:to:))
    }
}

extension CreateTypeInput {

    static func write(value: CreateTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["format"].write(value.format)
    }
}

extension EvaluateCodeInput {

    static func write(value: EvaluateCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["context"].write(value.context)
        try writer["function"].write(value.function)
        try writer["runtime"].write(value.runtime, with: AppSyncClientTypes.AppSyncRuntime.write(value:to:))
    }
}

extension EvaluateMappingTemplateInput {

    static func write(value: EvaluateMappingTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["context"].write(value.context)
        try writer["template"].write(value.template)
    }
}

extension PutGraphqlApiEnvironmentVariablesInput {

    static func write(value: PutGraphqlApiEnvironmentVariablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartDataSourceIntrospectionInput {

    static func write(value: StartDataSourceIntrospectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rdsDataApiConfig"].write(value.rdsDataApiConfig, with: AppSyncClientTypes.RdsDataApiConfig.write(value:to:))
    }
}

extension StartSchemaCreationInput {

    static func write(value: StartSchemaCreationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApiCacheInput {

    static func write(value: UpdateApiCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiCachingBehavior"].write(value.apiCachingBehavior)
        try writer["healthMetricsConfig"].write(value.healthMetricsConfig)
        try writer["ttl"].write(value.ttl)
        try writer["type"].write(value.type)
    }
}

extension UpdateApiKeyInput {

    static func write(value: UpdateApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["expires"].write(value.expires)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["dynamodbConfig"].write(value.dynamodbConfig, with: AppSyncClientTypes.DynamodbDataSourceConfig.write(value:to:))
        try writer["elasticsearchConfig"].write(value.elasticsearchConfig, with: AppSyncClientTypes.ElasticsearchDataSourceConfig.write(value:to:))
        try writer["eventBridgeConfig"].write(value.eventBridgeConfig, with: AppSyncClientTypes.EventBridgeDataSourceConfig.write(value:to:))
        try writer["httpConfig"].write(value.httpConfig, with: AppSyncClientTypes.HttpDataSourceConfig.write(value:to:))
        try writer["lambdaConfig"].write(value.lambdaConfig, with: AppSyncClientTypes.LambdaDataSourceConfig.write(value:to:))
        try writer["metricsConfig"].write(value.metricsConfig)
        try writer["openSearchServiceConfig"].write(value.openSearchServiceConfig, with: AppSyncClientTypes.OpenSearchServiceDataSourceConfig.write(value:to:))
        try writer["relationalDatabaseConfig"].write(value.relationalDatabaseConfig, with: AppSyncClientTypes.RelationalDatabaseDataSourceConfig.write(value:to:))
        try writer["serviceRoleArn"].write(value.serviceRoleArn)
        try writer["type"].write(value.type)
    }
}

extension UpdateDomainNameInput {

    static func write(value: UpdateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateFunctionInput {

    static func write(value: UpdateFunctionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["dataSourceName"].write(value.dataSourceName)
        try writer["description"].write(value.description)
        try writer["functionVersion"].write(value.functionVersion)
        try writer["maxBatchSize"].write(value.maxBatchSize)
        try writer["name"].write(value.name)
        try writer["requestMappingTemplate"].write(value.requestMappingTemplate)
        try writer["responseMappingTemplate"].write(value.responseMappingTemplate)
        try writer["runtime"].write(value.runtime, with: AppSyncClientTypes.AppSyncRuntime.write(value:to:))
        try writer["syncConfig"].write(value.syncConfig, with: AppSyncClientTypes.SyncConfig.write(value:to:))
    }
}

extension UpdateGraphqlApiInput {

    static func write(value: UpdateGraphqlApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAuthenticationProviders"].writeList(value.additionalAuthenticationProviders, memberWritingClosure: AppSyncClientTypes.AdditionalAuthenticationProvider.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authenticationType"].write(value.authenticationType)
        try writer["enhancedMetricsConfig"].write(value.enhancedMetricsConfig, with: AppSyncClientTypes.EnhancedMetricsConfig.write(value:to:))
        try writer["introspectionConfig"].write(value.introspectionConfig)
        try writer["lambdaAuthorizerConfig"].write(value.lambdaAuthorizerConfig, with: AppSyncClientTypes.LambdaAuthorizerConfig.write(value:to:))
        try writer["logConfig"].write(value.logConfig, with: AppSyncClientTypes.LogConfig.write(value:to:))
        try writer["mergedApiExecutionRoleArn"].write(value.mergedApiExecutionRoleArn)
        try writer["name"].write(value.name)
        try writer["openIDConnectConfig"].write(value.openIDConnectConfig, with: AppSyncClientTypes.OpenIDConnectConfig.write(value:to:))
        try writer["ownerContact"].write(value.ownerContact)
        try writer["queryDepthLimit"].write(value.queryDepthLimit)
        try writer["resolverCountLimit"].write(value.resolverCountLimit)
        try writer["userPoolConfig"].write(value.userPoolConfig, with: AppSyncClientTypes.UserPoolConfig.write(value:to:))
        try writer["xrayEnabled"].write(value.xrayEnabled)
    }
}

extension UpdateResolverInput {

    static func write(value: UpdateResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cachingConfig"].write(value.cachingConfig, with: AppSyncClientTypes.CachingConfig.write(value:to:))
        try writer["code"].write(value.code)
        try writer["dataSourceName"].write(value.dataSourceName)
        try writer["kind"].write(value.kind)
        try writer["maxBatchSize"].write(value.maxBatchSize)
        try writer["metricsConfig"].write(value.metricsConfig)
        try writer["pipelineConfig"].write(value.pipelineConfig, with: AppSyncClientTypes.PipelineConfig.write(value:to:))
        try writer["requestMappingTemplate"].write(value.requestMappingTemplate)
        try writer["responseMappingTemplate"].write(value.responseMappingTemplate)
        try writer["runtime"].write(value.runtime, with: AppSyncClientTypes.AppSyncRuntime.write(value:to:))
        try writer["syncConfig"].write(value.syncConfig, with: AppSyncClientTypes.SyncConfig.write(value:to:))
    }
}

extension UpdateSourceApiAssociationInput {

    static func write(value: UpdateSourceApiAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["sourceApiAssociationConfig"].write(value.sourceApiAssociationConfig, with: AppSyncClientTypes.SourceApiAssociationConfig.write(value:to:))
    }
}

extension UpdateTypeInput {

    static func write(value: UpdateTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["format"].write(value.format)
    }
}

extension AssociateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateApiOutput()
        value.apiAssociation = try reader["apiAssociation"].readIfPresent(with: AppSyncClientTypes.ApiAssociation.read(from:))
        return value
    }
}

extension AssociateMergedGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMergedGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateMergedGraphqlApiOutput()
        value.sourceApiAssociation = try reader["sourceApiAssociation"].readIfPresent(with: AppSyncClientTypes.SourceApiAssociation.read(from:))
        return value
    }
}

extension AssociateSourceGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSourceGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateSourceGraphqlApiOutput()
        value.sourceApiAssociation = try reader["sourceApiAssociation"].readIfPresent(with: AppSyncClientTypes.SourceApiAssociation.read(from:))
        return value
    }
}

extension CreateApiCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiCacheOutput()
        value.apiCache = try reader["apiCache"].readIfPresent(with: AppSyncClientTypes.ApiCache.read(from:))
        return value
    }
}

extension CreateApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiKeyOutput()
        value.apiKey = try reader["apiKey"].readIfPresent(with: AppSyncClientTypes.ApiKey.read(from:))
        return value
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: AppSyncClientTypes.DataSource.read(from:))
        return value
    }
}

extension CreateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainNameOutput()
        value.domainNameConfig = try reader["domainNameConfig"].readIfPresent(with: AppSyncClientTypes.DomainNameConfig.read(from:))
        return value
    }
}

extension CreateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionOutput()
        value.functionConfiguration = try reader["functionConfiguration"].readIfPresent(with: AppSyncClientTypes.FunctionConfiguration.read(from:))
        return value
    }
}

extension CreateGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGraphqlApiOutput()
        value.graphqlApi = try reader["graphqlApi"].readIfPresent(with: AppSyncClientTypes.GraphqlApi.read(from:))
        return value
    }
}

extension CreateResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResolverOutput()
        value.resolver = try reader["resolver"].readIfPresent(with: AppSyncClientTypes.Resolver.read(from:))
        return value
    }
}

extension CreateTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTypeOutput()
        value.type = try reader["type"].readIfPresent(with: AppSyncClientTypes.ModelType.read(from:))
        return value
    }
}

extension DeleteApiCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiCacheOutput {
        return DeleteApiCacheOutput()
    }
}

extension DeleteApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiKeyOutput {
        return DeleteApiKeyOutput()
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        return DeleteDataSourceOutput()
    }
}

extension DeleteDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainNameOutput {
        return DeleteDomainNameOutput()
    }
}

extension DeleteFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionOutput {
        return DeleteFunctionOutput()
    }
}

extension DeleteGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGraphqlApiOutput {
        return DeleteGraphqlApiOutput()
    }
}

extension DeleteResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResolverOutput {
        return DeleteResolverOutput()
    }
}

extension DeleteTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTypeOutput {
        return DeleteTypeOutput()
    }
}

extension DisassociateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApiOutput {
        return DisassociateApiOutput()
    }
}

extension DisassociateMergedGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMergedGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateMergedGraphqlApiOutput()
        value.sourceApiAssociationStatus = try reader["sourceApiAssociationStatus"].readIfPresent()
        return value
    }
}

extension DisassociateSourceGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSourceGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateSourceGraphqlApiOutput()
        value.sourceApiAssociationStatus = try reader["sourceApiAssociationStatus"].readIfPresent()
        return value
    }
}

extension EvaluateCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluateCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluateCodeOutput()
        value.error = try reader["error"].readIfPresent(with: AppSyncClientTypes.EvaluateCodeErrorDetail.read(from:))
        value.evaluationResult = try reader["evaluationResult"].readIfPresent()
        value.logs = try reader["logs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvaluateMappingTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluateMappingTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluateMappingTemplateOutput()
        value.error = try reader["error"].readIfPresent(with: AppSyncClientTypes.ErrorDetail.read(from:))
        value.evaluationResult = try reader["evaluationResult"].readIfPresent()
        value.logs = try reader["logs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FlushApiCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FlushApiCacheOutput {
        return FlushApiCacheOutput()
    }
}

extension GetApiAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiAssociationOutput()
        value.apiAssociation = try reader["apiAssociation"].readIfPresent(with: AppSyncClientTypes.ApiAssociation.read(from:))
        return value
    }
}

extension GetApiCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiCacheOutput()
        value.apiCache = try reader["apiCache"].readIfPresent(with: AppSyncClientTypes.ApiCache.read(from:))
        return value
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: AppSyncClientTypes.DataSource.read(from:))
        return value
    }
}

extension GetDataSourceIntrospectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceIntrospectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceIntrospectionOutput()
        value.introspectionId = try reader["introspectionId"].readIfPresent()
        value.introspectionResult = try reader["introspectionResult"].readIfPresent(with: AppSyncClientTypes.DataSourceIntrospectionResult.read(from:))
        value.introspectionStatus = try reader["introspectionStatus"].readIfPresent()
        value.introspectionStatusDetail = try reader["introspectionStatusDetail"].readIfPresent()
        return value
    }
}

extension GetDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNameOutput()
        value.domainNameConfig = try reader["domainNameConfig"].readIfPresent(with: AppSyncClientTypes.DomainNameConfig.read(from:))
        return value
    }
}

extension GetFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionOutput()
        value.functionConfiguration = try reader["functionConfiguration"].readIfPresent(with: AppSyncClientTypes.FunctionConfiguration.read(from:))
        return value
    }
}

extension GetGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGraphqlApiOutput()
        value.graphqlApi = try reader["graphqlApi"].readIfPresent(with: AppSyncClientTypes.GraphqlApi.read(from:))
        return value
    }
}

extension GetGraphqlApiEnvironmentVariablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGraphqlApiEnvironmentVariablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGraphqlApiEnvironmentVariablesOutput()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetIntrospectionSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntrospectionSchemaOutput {
        var value = GetIntrospectionSchemaOutput()
        switch httpResponse.body {
        case .data(let data):
            value.schema = data
        case .stream(let stream):
            value.schema = try stream.readToEnd()
        case .noStream:
            value.schema = nil
        }
        return value
    }
}

extension GetResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverOutput()
        value.resolver = try reader["resolver"].readIfPresent(with: AppSyncClientTypes.Resolver.read(from:))
        return value
    }
}

extension GetSchemaCreationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaCreationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaCreationStatusOutput()
        value.details = try reader["details"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetSourceApiAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSourceApiAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSourceApiAssociationOutput()
        value.sourceApiAssociation = try reader["sourceApiAssociation"].readIfPresent(with: AppSyncClientTypes.SourceApiAssociation.read(from:))
        return value
    }
}

extension GetTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTypeOutput()
        value.type = try reader["type"].readIfPresent(with: AppSyncClientTypes.ModelType.read(from:))
        return value
    }
}

extension ListApiKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApiKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApiKeysOutput()
        value.apiKeys = try reader["apiKeys"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.ApiKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSources = try reader["dataSources"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainNamesOutput()
        value.domainNameConfigs = try reader["domainNameConfigs"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.DomainNameConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsOutput()
        value.functions = try reader["functions"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.FunctionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGraphqlApisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGraphqlApisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGraphqlApisOutput()
        value.graphqlApis = try reader["graphqlApis"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.GraphqlApi.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListResolversOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolversOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolversOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resolvers = try reader["resolvers"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.Resolver.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolversByFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolversByFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolversByFunctionOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resolvers = try reader["resolvers"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.Resolver.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSourceApiAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSourceApiAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSourceApiAssociationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sourceApiAssociationSummaries = try reader["sourceApiAssociationSummaries"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.SourceApiAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTypesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.ModelType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTypesByAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTypesByAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTypesByAssociationOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.ModelType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutGraphqlApiEnvironmentVariablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutGraphqlApiEnvironmentVariablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutGraphqlApiEnvironmentVariablesOutput()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartDataSourceIntrospectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataSourceIntrospectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataSourceIntrospectionOutput()
        value.introspectionId = try reader["introspectionId"].readIfPresent()
        value.introspectionStatus = try reader["introspectionStatus"].readIfPresent()
        value.introspectionStatusDetail = try reader["introspectionStatusDetail"].readIfPresent()
        return value
    }
}

extension StartSchemaCreationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSchemaCreationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSchemaCreationOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension StartSchemaMergeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSchemaMergeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSchemaMergeOutput()
        value.sourceApiAssociationStatus = try reader["sourceApiAssociationStatus"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApiCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiCacheOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiCacheOutput()
        value.apiCache = try reader["apiCache"].readIfPresent(with: AppSyncClientTypes.ApiCache.read(from:))
        return value
    }
}

extension UpdateApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiKeyOutput()
        value.apiKey = try reader["apiKey"].readIfPresent(with: AppSyncClientTypes.ApiKey.read(from:))
        return value
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: AppSyncClientTypes.DataSource.read(from:))
        return value
    }
}

extension UpdateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainNameOutput()
        value.domainNameConfig = try reader["domainNameConfig"].readIfPresent(with: AppSyncClientTypes.DomainNameConfig.read(from:))
        return value
    }
}

extension UpdateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionOutput()
        value.functionConfiguration = try reader["functionConfiguration"].readIfPresent(with: AppSyncClientTypes.FunctionConfiguration.read(from:))
        return value
    }
}

extension UpdateGraphqlApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGraphqlApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGraphqlApiOutput()
        value.graphqlApi = try reader["graphqlApi"].readIfPresent(with: AppSyncClientTypes.GraphqlApi.read(from:))
        return value
    }
}

extension UpdateResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverOutput()
        value.resolver = try reader["resolver"].readIfPresent(with: AppSyncClientTypes.Resolver.read(from:))
        return value
    }
}

extension UpdateSourceApiAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSourceApiAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSourceApiAssociationOutput()
        value.sourceApiAssociation = try reader["sourceApiAssociation"].readIfPresent(with: AppSyncClientTypes.SourceApiAssociation.read(from:))
        return value
    }
}

extension UpdateTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTypeOutput()
        value.type = try reader["type"].readIfPresent(with: AppSyncClientTypes.ModelType.read(from:))
        return value
    }
}

enum AssociateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMergedGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateSourceGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApiCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApiKeyLimitExceededException": return try ApiKeyLimitExceededException.makeError(baseError: baseError)
            case "ApiKeyValidityOutOfBoundsException": return try ApiKeyValidityOutOfBoundsException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApiLimitExceededException": return try ApiLimitExceededException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMergedGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSourceGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluateCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluateMappingTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FlushApiCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceIntrospectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGraphqlApiEnvironmentVariablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntrospectionSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "GraphQLSchemaException": return try GraphQLSchemaException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaCreationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSourceApiAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApiKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGraphqlApisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolversOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolversByFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSourceApiAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTypesByAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutGraphqlApiEnvironmentVariablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataSourceIntrospectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSchemaCreationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSchemaMergeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ApiKeyValidityOutOfBoundsException": return try ApiKeyValidityOutOfBoundsException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGraphqlApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSourceApiAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.detail = try reader["detail"].readIfPresent(with: AppSyncClientTypes.BadRequestDetail.read(from:))
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApiKeyLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ApiKeyLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ApiKeyLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApiKeyValidityOutOfBoundsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ApiKeyValidityOutOfBoundsException {
        let reader = baseError.errorBodyReader
        var value = ApiKeyValidityOutOfBoundsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApiLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ApiLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ApiLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GraphQLSchemaException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GraphQLSchemaException {
        let reader = baseError.errorBodyReader
        var value = GraphQLSchemaException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppSyncClientTypes.ApiAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ApiAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ApiAssociation()
        value.domainName = try reader["domainName"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.associationStatus = try reader["associationStatus"].readIfPresent()
        value.deploymentDetail = try reader["deploymentDetail"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.SourceApiAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.SourceApiAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.SourceApiAssociation()
        value.associationId = try reader["associationId"].readIfPresent()
        value.associationArn = try reader["associationArn"].readIfPresent()
        value.sourceApiId = try reader["sourceApiId"].readIfPresent()
        value.sourceApiArn = try reader["sourceApiArn"].readIfPresent()
        value.mergedApiArn = try reader["mergedApiArn"].readIfPresent()
        value.mergedApiId = try reader["mergedApiId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.sourceApiAssociationConfig = try reader["sourceApiAssociationConfig"].readIfPresent(with: AppSyncClientTypes.SourceApiAssociationConfig.read(from:))
        value.sourceApiAssociationStatus = try reader["sourceApiAssociationStatus"].readIfPresent()
        value.sourceApiAssociationStatusDetail = try reader["sourceApiAssociationStatusDetail"].readIfPresent()
        value.lastSuccessfulMergeDate = try reader["lastSuccessfulMergeDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppSyncClientTypes.SourceApiAssociationConfig {

    static func write(value: AppSyncClientTypes.SourceApiAssociationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mergeType"].write(value.mergeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.SourceApiAssociationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.SourceApiAssociationConfig()
        value.mergeType = try reader["mergeType"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.ApiCache {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ApiCache {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ApiCache()
        value.ttl = try reader["ttl"].readIfPresent() ?? 0
        value.apiCachingBehavior = try reader["apiCachingBehavior"].readIfPresent()
        value.transitEncryptionEnabled = try reader["transitEncryptionEnabled"].readIfPresent() ?? false
        value.atRestEncryptionEnabled = try reader["atRestEncryptionEnabled"].readIfPresent() ?? false
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.healthMetricsConfig = try reader["healthMetricsConfig"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.ApiKey {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ApiKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ApiKey()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.expires = try reader["expires"].readIfPresent() ?? 0
        value.deletes = try reader["deletes"].readIfPresent() ?? 0
        return value
    }
}

extension AppSyncClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSource()
        value.dataSourceArn = try reader["dataSourceArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.serviceRoleArn = try reader["serviceRoleArn"].readIfPresent()
        value.dynamodbConfig = try reader["dynamodbConfig"].readIfPresent(with: AppSyncClientTypes.DynamodbDataSourceConfig.read(from:))
        value.lambdaConfig = try reader["lambdaConfig"].readIfPresent(with: AppSyncClientTypes.LambdaDataSourceConfig.read(from:))
        value.elasticsearchConfig = try reader["elasticsearchConfig"].readIfPresent(with: AppSyncClientTypes.ElasticsearchDataSourceConfig.read(from:))
        value.openSearchServiceConfig = try reader["openSearchServiceConfig"].readIfPresent(with: AppSyncClientTypes.OpenSearchServiceDataSourceConfig.read(from:))
        value.httpConfig = try reader["httpConfig"].readIfPresent(with: AppSyncClientTypes.HttpDataSourceConfig.read(from:))
        value.relationalDatabaseConfig = try reader["relationalDatabaseConfig"].readIfPresent(with: AppSyncClientTypes.RelationalDatabaseDataSourceConfig.read(from:))
        value.eventBridgeConfig = try reader["eventBridgeConfig"].readIfPresent(with: AppSyncClientTypes.EventBridgeDataSourceConfig.read(from:))
        value.metricsConfig = try reader["metricsConfig"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.EventBridgeDataSourceConfig {

    static func write(value: AppSyncClientTypes.EventBridgeDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventBusArn"].write(value.eventBusArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.EventBridgeDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.EventBridgeDataSourceConfig()
        value.eventBusArn = try reader["eventBusArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppSyncClientTypes.RelationalDatabaseDataSourceConfig {

    static func write(value: AppSyncClientTypes.RelationalDatabaseDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rdsHttpEndpointConfig"].write(value.rdsHttpEndpointConfig, with: AppSyncClientTypes.RdsHttpEndpointConfig.write(value:to:))
        try writer["relationalDatabaseSourceType"].write(value.relationalDatabaseSourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.RelationalDatabaseDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.RelationalDatabaseDataSourceConfig()
        value.relationalDatabaseSourceType = try reader["relationalDatabaseSourceType"].readIfPresent()
        value.rdsHttpEndpointConfig = try reader["rdsHttpEndpointConfig"].readIfPresent(with: AppSyncClientTypes.RdsHttpEndpointConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.RdsHttpEndpointConfig {

    static func write(value: AppSyncClientTypes.RdsHttpEndpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsRegion"].write(value.awsRegion)
        try writer["awsSecretStoreArn"].write(value.awsSecretStoreArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["dbClusterIdentifier"].write(value.dbClusterIdentifier)
        try writer["schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.RdsHttpEndpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.RdsHttpEndpointConfig()
        value.awsRegion = try reader["awsRegion"].readIfPresent()
        value.dbClusterIdentifier = try reader["dbClusterIdentifier"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        value.awsSecretStoreArn = try reader["awsSecretStoreArn"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.HttpDataSourceConfig {

    static func write(value: AppSyncClientTypes.HttpDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizationConfig"].write(value.authorizationConfig, with: AppSyncClientTypes.AuthorizationConfig.write(value:to:))
        try writer["endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.HttpDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.HttpDataSourceConfig()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.authorizationConfig = try reader["authorizationConfig"].readIfPresent(with: AppSyncClientTypes.AuthorizationConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.AuthorizationConfig {

    static func write(value: AppSyncClientTypes.AuthorizationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizationType"].write(value.authorizationType)
        try writer["awsIamConfig"].write(value.awsIamConfig, with: AppSyncClientTypes.AwsIamConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.AuthorizationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.AuthorizationConfig()
        value.authorizationType = try reader["authorizationType"].readIfPresent() ?? .sdkUnknown("")
        value.awsIamConfig = try reader["awsIamConfig"].readIfPresent(with: AppSyncClientTypes.AwsIamConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.AwsIamConfig {

    static func write(value: AppSyncClientTypes.AwsIamConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["signingRegion"].write(value.signingRegion)
        try writer["signingServiceName"].write(value.signingServiceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.AwsIamConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.AwsIamConfig()
        value.signingRegion = try reader["signingRegion"].readIfPresent()
        value.signingServiceName = try reader["signingServiceName"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.OpenSearchServiceDataSourceConfig {

    static func write(value: AppSyncClientTypes.OpenSearchServiceDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsRegion"].write(value.awsRegion)
        try writer["endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.OpenSearchServiceDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.OpenSearchServiceDataSourceConfig()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.awsRegion = try reader["awsRegion"].readIfPresent() ?? ""
        return value
    }
}

extension AppSyncClientTypes.ElasticsearchDataSourceConfig {

    static func write(value: AppSyncClientTypes.ElasticsearchDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsRegion"].write(value.awsRegion)
        try writer["endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ElasticsearchDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ElasticsearchDataSourceConfig()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.awsRegion = try reader["awsRegion"].readIfPresent() ?? ""
        return value
    }
}

extension AppSyncClientTypes.LambdaDataSourceConfig {

    static func write(value: AppSyncClientTypes.LambdaDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaFunctionArn"].write(value.lambdaFunctionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.LambdaDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.LambdaDataSourceConfig()
        value.lambdaFunctionArn = try reader["lambdaFunctionArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppSyncClientTypes.DynamodbDataSourceConfig {

    static func write(value: AppSyncClientTypes.DynamodbDataSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsRegion"].write(value.awsRegion)
        try writer["deltaSyncConfig"].write(value.deltaSyncConfig, with: AppSyncClientTypes.DeltaSyncConfig.write(value:to:))
        try writer["tableName"].write(value.tableName)
        try writer["useCallerCredentials"].write(value.useCallerCredentials)
        try writer["versioned"].write(value.versioned)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DynamodbDataSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DynamodbDataSourceConfig()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.awsRegion = try reader["awsRegion"].readIfPresent() ?? ""
        value.useCallerCredentials = try reader["useCallerCredentials"].readIfPresent() ?? false
        value.deltaSyncConfig = try reader["deltaSyncConfig"].readIfPresent(with: AppSyncClientTypes.DeltaSyncConfig.read(from:))
        value.versioned = try reader["versioned"].readIfPresent() ?? false
        return value
    }
}

extension AppSyncClientTypes.DeltaSyncConfig {

    static func write(value: AppSyncClientTypes.DeltaSyncConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseTableTTL"].write(value.baseTableTTL)
        try writer["deltaSyncTableName"].write(value.deltaSyncTableName)
        try writer["deltaSyncTableTTL"].write(value.deltaSyncTableTTL)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DeltaSyncConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DeltaSyncConfig()
        value.baseTableTTL = try reader["baseTableTTL"].readIfPresent() ?? 0
        value.deltaSyncTableName = try reader["deltaSyncTableName"].readIfPresent()
        value.deltaSyncTableTTL = try reader["deltaSyncTableTTL"].readIfPresent() ?? 0
        return value
    }
}

extension AppSyncClientTypes.DomainNameConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DomainNameConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DomainNameConfig()
        value.domainName = try reader["domainName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.appsyncDomainName = try reader["appsyncDomainName"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.FunctionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.FunctionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.FunctionConfiguration()
        value.functionId = try reader["functionId"].readIfPresent()
        value.functionArn = try reader["functionArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dataSourceName = try reader["dataSourceName"].readIfPresent()
        value.requestMappingTemplate = try reader["requestMappingTemplate"].readIfPresent()
        value.responseMappingTemplate = try reader["responseMappingTemplate"].readIfPresent()
        value.functionVersion = try reader["functionVersion"].readIfPresent()
        value.syncConfig = try reader["syncConfig"].readIfPresent(with: AppSyncClientTypes.SyncConfig.read(from:))
        value.maxBatchSize = try reader["maxBatchSize"].readIfPresent() ?? 0
        value.runtime = try reader["runtime"].readIfPresent(with: AppSyncClientTypes.AppSyncRuntime.read(from:))
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.AppSyncRuntime {

    static func write(value: AppSyncClientTypes.AppSyncRuntime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["runtimeVersion"].write(value.runtimeVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.AppSyncRuntime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.AppSyncRuntime()
        value.name = try reader["name"].readIfPresent() ?? .sdkUnknown("")
        value.runtimeVersion = try reader["runtimeVersion"].readIfPresent() ?? ""
        return value
    }
}

extension AppSyncClientTypes.SyncConfig {

    static func write(value: AppSyncClientTypes.SyncConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conflictDetection"].write(value.conflictDetection)
        try writer["conflictHandler"].write(value.conflictHandler)
        try writer["lambdaConflictHandlerConfig"].write(value.lambdaConflictHandlerConfig, with: AppSyncClientTypes.LambdaConflictHandlerConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.SyncConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.SyncConfig()
        value.conflictHandler = try reader["conflictHandler"].readIfPresent()
        value.conflictDetection = try reader["conflictDetection"].readIfPresent()
        value.lambdaConflictHandlerConfig = try reader["lambdaConflictHandlerConfig"].readIfPresent(with: AppSyncClientTypes.LambdaConflictHandlerConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.LambdaConflictHandlerConfig {

    static func write(value: AppSyncClientTypes.LambdaConflictHandlerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaConflictHandlerArn"].write(value.lambdaConflictHandlerArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.LambdaConflictHandlerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.LambdaConflictHandlerConfig()
        value.lambdaConflictHandlerArn = try reader["lambdaConflictHandlerArn"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.GraphqlApi {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.GraphqlApi {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.GraphqlApi()
        value.name = try reader["name"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.authenticationType = try reader["authenticationType"].readIfPresent()
        value.logConfig = try reader["logConfig"].readIfPresent(with: AppSyncClientTypes.LogConfig.read(from:))
        value.userPoolConfig = try reader["userPoolConfig"].readIfPresent(with: AppSyncClientTypes.UserPoolConfig.read(from:))
        value.openIDConnectConfig = try reader["openIDConnectConfig"].readIfPresent(with: AppSyncClientTypes.OpenIDConnectConfig.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.uris = try reader["uris"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalAuthenticationProviders = try reader["additionalAuthenticationProviders"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.AdditionalAuthenticationProvider.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.xrayEnabled = try reader["xrayEnabled"].readIfPresent() ?? false
        value.wafWebAclArn = try reader["wafWebAclArn"].readIfPresent()
        value.lambdaAuthorizerConfig = try reader["lambdaAuthorizerConfig"].readIfPresent(with: AppSyncClientTypes.LambdaAuthorizerConfig.read(from:))
        value.dns = try reader["dns"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.visibility = try reader["visibility"].readIfPresent()
        value.apiType = try reader["apiType"].readIfPresent()
        value.mergedApiExecutionRoleArn = try reader["mergedApiExecutionRoleArn"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.ownerContact = try reader["ownerContact"].readIfPresent()
        value.introspectionConfig = try reader["introspectionConfig"].readIfPresent()
        value.queryDepthLimit = try reader["queryDepthLimit"].readIfPresent() ?? 0
        value.resolverCountLimit = try reader["resolverCountLimit"].readIfPresent() ?? 0
        value.enhancedMetricsConfig = try reader["enhancedMetricsConfig"].readIfPresent(with: AppSyncClientTypes.EnhancedMetricsConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.EnhancedMetricsConfig {

    static func write(value: AppSyncClientTypes.EnhancedMetricsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSourceLevelMetricsBehavior"].write(value.dataSourceLevelMetricsBehavior)
        try writer["operationLevelMetricsConfig"].write(value.operationLevelMetricsConfig)
        try writer["resolverLevelMetricsBehavior"].write(value.resolverLevelMetricsBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.EnhancedMetricsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.EnhancedMetricsConfig()
        value.resolverLevelMetricsBehavior = try reader["resolverLevelMetricsBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.dataSourceLevelMetricsBehavior = try reader["dataSourceLevelMetricsBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.operationLevelMetricsConfig = try reader["operationLevelMetricsConfig"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppSyncClientTypes.LambdaAuthorizerConfig {

    static func write(value: AppSyncClientTypes.LambdaAuthorizerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.LambdaAuthorizerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.LambdaAuthorizerConfig()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent() ?? 0
        value.authorizerUri = try reader["authorizerUri"].readIfPresent() ?? ""
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.AdditionalAuthenticationProvider {

    static func write(value: AppSyncClientTypes.AdditionalAuthenticationProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationType"].write(value.authenticationType)
        try writer["lambdaAuthorizerConfig"].write(value.lambdaAuthorizerConfig, with: AppSyncClientTypes.LambdaAuthorizerConfig.write(value:to:))
        try writer["openIDConnectConfig"].write(value.openIDConnectConfig, with: AppSyncClientTypes.OpenIDConnectConfig.write(value:to:))
        try writer["userPoolConfig"].write(value.userPoolConfig, with: AppSyncClientTypes.CognitoUserPoolConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.AdditionalAuthenticationProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.AdditionalAuthenticationProvider()
        value.authenticationType = try reader["authenticationType"].readIfPresent()
        value.openIDConnectConfig = try reader["openIDConnectConfig"].readIfPresent(with: AppSyncClientTypes.OpenIDConnectConfig.read(from:))
        value.userPoolConfig = try reader["userPoolConfig"].readIfPresent(with: AppSyncClientTypes.CognitoUserPoolConfig.read(from:))
        value.lambdaAuthorizerConfig = try reader["lambdaAuthorizerConfig"].readIfPresent(with: AppSyncClientTypes.LambdaAuthorizerConfig.read(from:))
        return value
    }
}

extension AppSyncClientTypes.CognitoUserPoolConfig {

    static func write(value: AppSyncClientTypes.CognitoUserPoolConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIdClientRegex"].write(value.appIdClientRegex)
        try writer["awsRegion"].write(value.awsRegion)
        try writer["userPoolId"].write(value.userPoolId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.CognitoUserPoolConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.CognitoUserPoolConfig()
        value.userPoolId = try reader["userPoolId"].readIfPresent() ?? ""
        value.awsRegion = try reader["awsRegion"].readIfPresent() ?? ""
        value.appIdClientRegex = try reader["appIdClientRegex"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.OpenIDConnectConfig {

    static func write(value: AppSyncClientTypes.OpenIDConnectConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authTTL"].write(value.authTTL)
        try writer["clientId"].write(value.clientId)
        try writer["iatTTL"].write(value.iatTTL)
        try writer["issuer"].write(value.issuer)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.OpenIDConnectConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.OpenIDConnectConfig()
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.clientId = try reader["clientId"].readIfPresent()
        value.iatTTL = try reader["iatTTL"].readIfPresent() ?? 0
        value.authTTL = try reader["authTTL"].readIfPresent() ?? 0
        return value
    }
}

extension AppSyncClientTypes.UserPoolConfig {

    static func write(value: AppSyncClientTypes.UserPoolConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIdClientRegex"].write(value.appIdClientRegex)
        try writer["awsRegion"].write(value.awsRegion)
        try writer["defaultAction"].write(value.defaultAction)
        try writer["userPoolId"].write(value.userPoolId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.UserPoolConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.UserPoolConfig()
        value.userPoolId = try reader["userPoolId"].readIfPresent() ?? ""
        value.awsRegion = try reader["awsRegion"].readIfPresent() ?? ""
        value.defaultAction = try reader["defaultAction"].readIfPresent() ?? .sdkUnknown("")
        value.appIdClientRegex = try reader["appIdClientRegex"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.LogConfig {

    static func write(value: AppSyncClientTypes.LogConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsRoleArn"].write(value.cloudWatchLogsRoleArn)
        try writer["excludeVerboseContent"].write(value.excludeVerboseContent)
        try writer["fieldLogLevel"].write(value.fieldLogLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.LogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.LogConfig()
        value.fieldLogLevel = try reader["fieldLogLevel"].readIfPresent() ?? .sdkUnknown("")
        value.cloudWatchLogsRoleArn = try reader["cloudWatchLogsRoleArn"].readIfPresent() ?? ""
        value.excludeVerboseContent = try reader["excludeVerboseContent"].readIfPresent() ?? false
        return value
    }
}

extension AppSyncClientTypes.Resolver {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.Resolver {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.Resolver()
        value.typeName = try reader["typeName"].readIfPresent()
        value.fieldName = try reader["fieldName"].readIfPresent()
        value.dataSourceName = try reader["dataSourceName"].readIfPresent()
        value.resolverArn = try reader["resolverArn"].readIfPresent()
        value.requestMappingTemplate = try reader["requestMappingTemplate"].readIfPresent()
        value.responseMappingTemplate = try reader["responseMappingTemplate"].readIfPresent()
        value.kind = try reader["kind"].readIfPresent()
        value.pipelineConfig = try reader["pipelineConfig"].readIfPresent(with: AppSyncClientTypes.PipelineConfig.read(from:))
        value.syncConfig = try reader["syncConfig"].readIfPresent(with: AppSyncClientTypes.SyncConfig.read(from:))
        value.cachingConfig = try reader["cachingConfig"].readIfPresent(with: AppSyncClientTypes.CachingConfig.read(from:))
        value.maxBatchSize = try reader["maxBatchSize"].readIfPresent() ?? 0
        value.runtime = try reader["runtime"].readIfPresent(with: AppSyncClientTypes.AppSyncRuntime.read(from:))
        value.code = try reader["code"].readIfPresent()
        value.metricsConfig = try reader["metricsConfig"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.CachingConfig {

    static func write(value: AppSyncClientTypes.CachingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cachingKeys"].writeList(value.cachingKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ttl"].write(value.ttl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.CachingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.CachingConfig()
        value.ttl = try reader["ttl"].readIfPresent() ?? 0
        value.cachingKeys = try reader["cachingKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.PipelineConfig {

    static func write(value: AppSyncClientTypes.PipelineConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["functions"].writeList(value.functions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.PipelineConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.PipelineConfig()
        value.functions = try reader["functions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.ModelType {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ModelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ModelType()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.EvaluateCodeErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.EvaluateCodeErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.EvaluateCodeErrorDetail()
        value.message = try reader["message"].readIfPresent()
        value.codeErrors = try reader["codeErrors"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.CodeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.CodeError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.CodeError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.CodeError()
        value.errorType = try reader["errorType"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: AppSyncClientTypes.CodeErrorLocation.read(from:))
        return value
    }
}

extension AppSyncClientTypes.CodeErrorLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.CodeErrorLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.CodeErrorLocation()
        value.line = try reader["line"].readIfPresent() ?? 0
        value.column = try reader["column"].readIfPresent() ?? 0
        value.span = try reader["span"].readIfPresent() ?? 0
        return value
    }
}

extension AppSyncClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.ErrorDetail()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.DataSourceIntrospectionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSourceIntrospectionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSourceIntrospectionResult()
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.DataSourceIntrospectionModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.DataSourceIntrospectionModel {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSourceIntrospectionModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSourceIntrospectionModel()
        value.name = try reader["name"].readIfPresent()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.DataSourceIntrospectionModelField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.primaryKey = try reader["primaryKey"].readIfPresent(with: AppSyncClientTypes.DataSourceIntrospectionModelIndex.read(from:))
        value.indexes = try reader["indexes"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.DataSourceIntrospectionModelIndex.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sdl = try reader["sdl"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.DataSourceIntrospectionModelIndex {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSourceIntrospectionModelIndex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSourceIntrospectionModelIndex()
        value.name = try reader["name"].readIfPresent()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.DataSourceIntrospectionModelField {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSourceIntrospectionModelField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSourceIntrospectionModelField()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: AppSyncClientTypes.DataSourceIntrospectionModelFieldType.read(from:))
        value.length = try reader["length"].readIfPresent() ?? 0
        return value
    }
}

extension AppSyncClientTypes.DataSourceIntrospectionModelFieldType {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.DataSourceIntrospectionModelFieldType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.DataSourceIntrospectionModelFieldType()
        value.kind = try reader["kind"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: AppSyncClientTypes.DataSourceIntrospectionModelFieldType.read(from:))
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.SourceApiAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.SourceApiAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.SourceApiAssociationSummary()
        value.associationId = try reader["associationId"].readIfPresent()
        value.associationArn = try reader["associationArn"].readIfPresent()
        value.sourceApiId = try reader["sourceApiId"].readIfPresent()
        value.sourceApiArn = try reader["sourceApiArn"].readIfPresent()
        value.mergedApiId = try reader["mergedApiId"].readIfPresent()
        value.mergedApiArn = try reader["mergedApiArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension AppSyncClientTypes.BadRequestDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AppSyncClientTypes.BadRequestDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppSyncClientTypes.BadRequestDetail()
        value.codeErrors = try reader["codeErrors"].readListIfPresent(memberReadingClosure: AppSyncClientTypes.CodeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppSyncClientTypes.RdsDataApiConfig {

    static func write(value: AppSyncClientTypes.RdsDataApiConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["secretArn"].write(value.secretArn)
    }
}

public enum AppSyncClientTypes {}
