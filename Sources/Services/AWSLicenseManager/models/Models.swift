// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

extension AcceptGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init(
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct AcceptGrantInputBody: Swift.Equatable {
    let grantArn: Swift.String?
}

extension AcceptGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension AcceptGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct AcceptGrantOutput: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct AcceptGrantOutputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let status: LicenseManagerClientTypes.GrantStatus?
    let version: Swift.String?
}

extension AcceptGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum AcceptGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to resource denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceAccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum ActivationOverrideBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allGrantsPermittedByIssuer
        case distributedGrantsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationOverrideBehavior] {
            return [
                .allGrantsPermittedByIssuer,
                .distributedGrantsOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allGrantsPermittedByIssuer: return "ALL_GRANTS_PERMITTED_BY_ISSUER"
            case .distributedGrantsOnly: return "DISTRIBUTED_GRANTS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivationOverrideBehavior(rawValue: rawValue) ?? ActivationOverrideBehavior.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum AllowedOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checkoutBorrowLicense
        case checkoutLicense
        case checkInLicense
        case createGrant
        case createToken
        case extendConsumptionLicense
        case listPurchasedLicenses
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowedOperation] {
            return [
                .checkoutBorrowLicense,
                .checkoutLicense,
                .checkInLicense,
                .createGrant,
                .createToken,
                .extendConsumptionLicense,
                .listPurchasedLicenses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checkoutBorrowLicense: return "CheckoutBorrowLicense"
            case .checkoutLicense: return "CheckoutLicense"
            case .checkInLicense: return "CheckInLicense"
            case .createGrant: return "CreateGrant"
            case .createToken: return "CreateToken"
            case .extendConsumptionLicense: return "ExtendConsumptionLicense"
            case .listPurchasedLicenses: return "ListPurchasedLicenses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowedOperation(rawValue: rawValue) ?? AllowedOperation.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthorizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Web Services user account does not have permission to perform the action. Check the IAM policy associated with this account.
public struct AuthorizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationFailure" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AuthorizationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.AutomatedDiscoveryInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastRunTime = "LastRunTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastRunTime = self.lastRunTime {
            try encodeContainer.encodeTimestamp(lastRunTime, format: .epochSeconds, forKey: .lastRunTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastRunTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRunTime)
        lastRunTime = lastRunTimeDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes automated discovery.
    public struct AutomatedDiscoveryInformation: Swift.Equatable {
        /// Time that automated discovery last ran.
        public var lastRunTime: ClientRuntime.Date?

        public init(
            lastRunTime: ClientRuntime.Date? = nil
        )
        {
            self.lastRunTime = lastRunTime
        }
    }

}

extension LicenseManagerClientTypes.BorrowConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowEarlyCheckIn = "AllowEarlyCheckIn"
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowEarlyCheckIn = self.allowEarlyCheckIn {
            try encodeContainer.encode(allowEarlyCheckIn, forKey: .allowEarlyCheckIn)
        }
        if let maxTimeToLiveInMinutes = self.maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowEarlyCheckInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowEarlyCheckIn)
        allowEarlyCheckIn = allowEarlyCheckInDecoded
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about a borrow configuration.
    public struct BorrowConfiguration: Swift.Equatable {
        /// Indicates whether early check-ins are allowed.
        /// This member is required.
        public var allowEarlyCheckIn: Swift.Bool?
        /// Maximum time for the borrow configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init(
            allowEarlyCheckIn: Swift.Bool? = nil,
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.allowEarlyCheckIn = allowEarlyCheckIn
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

extension CheckInLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = self.beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let licenseConsumptionToken = self.licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

extension CheckInLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CheckInLicenseInput: Swift.Equatable {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init(
        beneficiary: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct CheckInLicenseInputBody: Swift.Equatable {
    let licenseConsumptionToken: Swift.String?
    let beneficiary: Swift.String?
}

extension CheckInLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
    }
}

extension CheckInLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CheckInLicenseOutput: Swift.Equatable {

    public init() { }
}

enum CheckInLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CheckoutBorrowLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkoutMetadata = checkoutMetadata {
            var checkoutMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkoutMetadata)
            for metadata0 in checkoutMetadata {
                try checkoutMetadataContainer.encode(metadata0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let digitalSignatureMethod = self.digitalSignatureMethod {
            try encodeContainer.encode(digitalSignatureMethod.rawValue, forKey: .digitalSignatureMethod)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdata0 in entitlements {
                try entitlementsContainer.encode(entitlementdata0)
            }
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

extension CheckoutBorrowLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CheckoutBorrowLicenseInput: Swift.Equatable {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Digital signature method. The possible value is JSON Web Signature (JWS) algorithm PS384. For more information, see [RFC 7518 Digital Signature with RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5).
    /// This member is required.
    public var digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod?
    /// License entitlements. Partial checkouts are not supported.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Amazon Resource Name (ARN) of the license. The license must use the borrow consumption configuration.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?

    public init(
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        clientToken: Swift.String? = nil,
        digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        licenseArn: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.clientToken = clientToken
        self.digitalSignatureMethod = digitalSignatureMethod
        self.entitlements = entitlements
        self.licenseArn = licenseArn
        self.nodeId = nodeId
    }
}

struct CheckoutBorrowLicenseInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let entitlements: [LicenseManagerClientTypes.EntitlementData]?
    let digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod?
    let nodeId: Swift.String?
    let checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    let clientToken: Swift.String?
}

extension CheckoutBorrowLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let digitalSignatureMethodDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DigitalSignatureMethod.self, forKey: .digitalSignatureMethod)
        digitalSignatureMethod = digitalSignatureMethodDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CheckoutBorrowLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CheckoutBorrowLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkoutMetadata = output.checkoutMetadata
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseArn = output.licenseArn
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutMetadata = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseArn = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutBorrowLicenseOutput: Swift.Equatable {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init(
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutBorrowLicenseOutputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let licenseConsumptionToken: Swift.String?
    let entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    let nodeId: Swift.String?
    let signedToken: Swift.String?
    let issuedAt: Swift.String?
    let expiration: Swift.String?
    let checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
}

extension CheckoutBorrowLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseArn = "LicenseArn"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let signedTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
    }
}

enum CheckoutBorrowLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EntitlementNotAllowedException": return try await EntitlementNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoEntitlementsAllowedException": return try await NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedDigitalSignatureMethodException": return try await UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CheckoutLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = self.beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let checkoutType = self.checkoutType {
            try encodeContainer.encode(checkoutType.rawValue, forKey: .checkoutType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdata0 in entitlements {
                try entitlementsContainer.encode(entitlementdata0)
            }
        }
        if let keyFingerprint = self.keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let productSKU = self.productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
    }
}

extension CheckoutLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CheckoutLicenseInput: Swift.Equatable {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// Checkout type.
    /// This member is required.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Key fingerprint identifying the license.
    /// This member is required.
    public var keyFingerprint: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?

    public init(
        beneficiary: Swift.String? = nil,
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        clientToken: Swift.String? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        keyFingerprint: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        productSKU: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.checkoutType = checkoutType
        self.clientToken = clientToken
        self.entitlements = entitlements
        self.keyFingerprint = keyFingerprint
        self.nodeId = nodeId
        self.productSKU = productSKU
    }
}

struct CheckoutLicenseInputBody: Swift.Equatable {
    let productSKU: Swift.String?
    let checkoutType: LicenseManagerClientTypes.CheckoutType?
    let keyFingerprint: Swift.String?
    let entitlements: [LicenseManagerClientTypes.EntitlementData]?
    let clientToken: Swift.String?
    let beneficiary: Swift.String?
    let nodeId: Swift.String?
}

extension CheckoutLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension CheckoutLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CheckoutLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkoutType = output.checkoutType
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseArn = output.licenseArn
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutType = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseArn = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutLicenseOutput: Swift.Equatable {
    /// Checkout type.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the checkout license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init(
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutType = checkoutType
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutLicenseOutputBody: Swift.Equatable {
    let checkoutType: LicenseManagerClientTypes.CheckoutType?
    let licenseConsumptionToken: Swift.String?
    let entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    let signedToken: Swift.String?
    let nodeId: Swift.String?
    let issuedAt: Swift.String?
    let expiration: Swift.String?
    let licenseArn: Swift.String?
}

extension CheckoutLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutType = "CheckoutType"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseArn = "LicenseArn"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let signedTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
    }
}

enum CheckoutLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoEntitlementsAllowedException": return try await NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedDigitalSignatureMethodException": return try await UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum CheckoutType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case perpetual
        case provisional
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckoutType] {
            return [
                .perpetual,
                .provisional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .perpetual: return "PERPETUAL"
            case .provisional: return "PROVISIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CheckoutType(rawValue: rawValue) ?? CheckoutType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.ConsumedLicenseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedLicenses = "ConsumedLicenses"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedLicenses = self.consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about license consumption.
    public struct ConsumedLicenseSummary: Swift.Equatable {
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Resource type of the resource consuming a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            consumedLicenses: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.consumedLicenses = consumedLicenses
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.ConsumptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case borrowConfiguration = "BorrowConfiguration"
        case provisionalConfiguration = "ProvisionalConfiguration"
        case renewType = "RenewType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let borrowConfiguration = self.borrowConfiguration {
            try encodeContainer.encode(borrowConfiguration, forKey: .borrowConfiguration)
        }
        if let provisionalConfiguration = self.provisionalConfiguration {
            try encodeContainer.encode(provisionalConfiguration, forKey: .provisionalConfiguration)
        }
        if let renewType = self.renewType {
            try encodeContainer.encode(renewType.rawValue, forKey: .renewType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renewTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.RenewType.self, forKey: .renewType)
        renewType = renewTypeDecoded
        let provisionalConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ProvisionalConfiguration.self, forKey: .provisionalConfiguration)
        provisionalConfiguration = provisionalConfigurationDecoded
        let borrowConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.BorrowConfiguration.self, forKey: .borrowConfiguration)
        borrowConfiguration = borrowConfigurationDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about a consumption configuration.
    public struct ConsumptionConfiguration: Swift.Equatable {
        /// Details about a borrow configuration.
        public var borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration?
        /// Details about a provisional configuration.
        public var provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration?
        /// Renewal frequency.
        public var renewType: LicenseManagerClientTypes.RenewType?

        public init(
            borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration? = nil,
            provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration? = nil,
            renewType: LicenseManagerClientTypes.RenewType? = nil
        )
        {
            self.borrowConfiguration = borrowConfiguration
            self.provisionalConfiguration = provisionalConfiguration
            self.renewType = renewType
        }
    }

}

extension CreateGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperation0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperation0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantName = self.grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for arn0 in principals {
                try principalsContainer.encode(arn0)
            }
        }
    }
}

extension CreateGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGrantInput: Swift.Equatable {
    /// Allowed operations for the grant.
    /// This member is required.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Grant name.
    /// This member is required.
    public var grantName: Swift.String?
    /// Home Region of the grant.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// The grant principals. You can specify one of the following as an Amazon Resource Name (ARN):
    ///
    /// * An Amazon Web Services account, which includes only the account specified.
    ///
    ///
    ///
    ///
    /// * An organizational unit (OU), which includes all accounts in the OU.
    ///
    ///
    ///
    ///
    /// * An organization, which will include all accounts across your organization.
    /// This member is required.
    public var principals: [Swift.String]?

    public init(
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantName: Swift.String? = nil,
        homeRegion: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantName = grantName
        self.homeRegion = homeRegion
        self.licenseArn = licenseArn
        self.principals = principals
    }
}

struct CreateGrantInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let grantName: Swift.String?
    let licenseArn: Swift.String?
    let principals: [Swift.String]?
    let homeRegion: Swift.String?
    let allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
}

extension CreateGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for enum0 in allowedOperationsContainer {
                if let enum0 = enum0 {
                    allowedOperationsDecoded0?.append(enum0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension CreateGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantOutput: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantOutputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let status: LicenseManagerClientTypes.GrantStatus?
    let version: Swift.String?
}

extension CreateGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGrantVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case options = "Options"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperation0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperation0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = self.grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }
}

extension CreateGrantVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGrantVersionInput: Swift.Equatable {
    /// Allowed operations for the grant.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant name.
    public var grantName: Swift.String?
    /// The options specified for the grant.
    public var options: LicenseManagerClientTypes.Options?
    /// Current version of the grant.
    public var sourceVersion: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant status reason.
    public var statusReason: Swift.String?

    public init(
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantArn: Swift.String? = nil,
        grantName: Swift.String? = nil,
        options: LicenseManagerClientTypes.Options? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantArn = grantArn
        self.grantName = grantName
        self.options = options
        self.sourceVersion = sourceVersion
        self.status = status
        self.statusReason = statusReason
    }
}

struct CreateGrantVersionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let grantArn: Swift.String?
    let grantName: Swift.String?
    let allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    let status: LicenseManagerClientTypes.GrantStatus?
    let statusReason: Swift.String?
    let sourceVersion: Swift.String?
    let options: LicenseManagerClientTypes.Options?
}

extension CreateGrantVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case options = "Options"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for enum0 in allowedOperationsContainer {
                if let enum0 = enum0 {
                    allowedOperationsDecoded0?.append(enum0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Options.self, forKey: .options)
        options = optionsDecoded
    }
}

extension CreateGrantVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGrantVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantVersionOutput: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// New version of the grant.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantVersionOutputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let status: LicenseManagerClientTypes.GrantStatus?
    let version: Swift.String?
}

extension CreateGrantVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateGrantVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = self.disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseCount = self.licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = self.licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = self.licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for string0 in licenseRules {
                try licenseRulesContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformation0 in productInformationList {
                try productInformationListContainer.encode(productinformation0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLicenseConfigurationInput: Swift.Equatable {
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension used to track the license inventory.
    /// This member is required.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.
    ///
    /// * Cores dimension: allowedTenancy | licenseAffinityToHost | maximumCores | minimumCores
    ///
    /// * Instances dimension: allowedTenancy | maximumCores | minimumCores | maximumSockets | minimumSockets | maximumVcpus | minimumVcpus
    ///
    /// * Sockets dimension: allowedTenancy | licenseAffinityToHost | maximumSockets | minimumSockets
    ///
    /// * vCPUs dimension: allowedTenancy | honorVcpuOptimization | maximumVcpus | minimumVcpus
    ///
    ///
    /// The unit for licenseAffinityToHost is days and the range is 1 to 180. The possible values for allowedTenancy are EC2-Default, EC2-DedicatedHost, and EC2-DedicatedInstance. The possible values for honorVcpuOptimization are True and False.
    public var licenseRules: [Swift.String]?
    /// Name of the license configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// Tags to add to the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
        self.tags = tags
    }
}

struct CreateLicenseConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    let licenseCount: Swift.Int?
    let licenseCountHardLimit: Swift.Bool?
    let licenseRules: [Swift.String]?
    let tags: [LicenseManagerClientTypes.Tag]?
    let disassociateWhenNotFound: Swift.Bool?
    let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
}

extension CreateLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
    }
}

extension CreateLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationArn = output.licenseConfigurationArn
        } else {
            self.licenseConfigurationArn = nil
        }
    }
}

public struct CreateLicenseConfigurationOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct CreateLicenseConfigurationOutputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
}

extension CreateLicenseConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

enum CreateLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLicenseConversionTaskForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationLicenseContext = self.destinationLicenseContext {
            try encodeContainer.encode(destinationLicenseContext, forKey: .destinationLicenseContext)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceLicenseContext = self.sourceLicenseContext {
            try encodeContainer.encode(sourceLicenseContext, forKey: .sourceLicenseContext)
        }
    }
}

extension CreateLicenseConversionTaskForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLicenseConversionTaskForResourceInput: Swift.Equatable {
    /// Information that identifies the license type you are converting to. For the structure of the destination license, see [Convert a license type using the CLI ](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Amazon Resource Name (ARN) of the resource you are converting the license type for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information that identifies the license type you are converting from. For the structure of the source license, see [Convert a license type using the CLI ](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?

    public init(
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
    }
}

struct CreateLicenseConversionTaskForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    let destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
}

extension CreateLicenseConversionTaskForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
    }
}

extension CreateLicenseConversionTaskForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseConversionTaskForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConversionTaskId = output.licenseConversionTaskId
        } else {
            self.licenseConversionTaskId = nil
        }
    }
}

public struct CreateLicenseConversionTaskForResourceOutput: Swift.Equatable {
    /// The ID of the created license type conversion task.
    public var licenseConversionTaskId: Swift.String?

    public init(
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

struct CreateLicenseConversionTaskForResourceOutputBody: Swift.Equatable {
    let licenseConversionTaskId: Swift.String?
}

extension CreateLicenseConversionTaskForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
    }
}

enum CreateLicenseConversionTaskForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = self.beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = self.consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlement0 in entitlements {
                try entitlementsContainer.encode(entitlement0)
            }
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadata0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadata0)
            }
        }
        if let licenseName = self.licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = self.productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLicenseInput: Swift.Equatable {
    /// License beneficiary.
    /// This member is required.
    public var beneficiary: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region for the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init(
        beneficiary: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        productSKU: Swift.String? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.beneficiary = beneficiary
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.validity = validity
    }
}

struct CreateLicenseInputBody: Swift.Equatable {
    let licenseName: Swift.String?
    let productName: Swift.String?
    let productSKU: Swift.String?
    let issuer: LicenseManagerClientTypes.Issuer?
    let homeRegion: Swift.String?
    let validity: LicenseManagerClientTypes.DatetimeRange?
    let entitlements: [LicenseManagerClientTypes.Entitlement]?
    let beneficiary: Swift.String?
    let consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    let licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    let clientToken: Swift.String?
}

extension CreateLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateLicenseManagerReportGeneratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let reportContext = self.reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = self.reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttype0 in type {
                try typeContainer.encode(reporttype0.rawValue)
            }
        }
    }
}

extension CreateLicenseManagerReportGeneratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Defines the type of license configuration the report generator tracks.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated. Reports can be generated daily, monthly, or weekly.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Tags to add to the report generator.
    public var tags: [LicenseManagerClientTypes.Tag]?
    /// Type of reports to generate. The following report types an be generated:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.tags = tags
        self.type = type
    }
}

struct CreateLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    let reportGeneratorName: Swift.String?
    let type: [LicenseManagerClientTypes.ReportType]?
    let reportContext: LicenseManagerClientTypes.ReportContext?
    let reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    let clientToken: Swift.String?
    let description: Swift.String?
    let tags: [LicenseManagerClientTypes.Tag]?
}

extension CreateLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .type)
        var typeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for enum0 in typeContainer {
                if let enum0 = enum0 {
                    typeDecoded0?.append(enum0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLicenseManagerReportGeneratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseManagerReportGeneratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseManagerReportGeneratorArn = output.licenseManagerReportGeneratorArn
        } else {
            self.licenseManagerReportGeneratorArn = nil
        }
    }
}

public struct CreateLicenseManagerReportGeneratorOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new report generator.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct CreateLicenseManagerReportGeneratorOutputBody: Swift.Equatable {
    let licenseManagerReportGeneratorArn: Swift.String?
}

extension CreateLicenseManagerReportGeneratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

enum CreateLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// License version.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseOutputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let status: LicenseManagerClientTypes.LicenseStatus?
    let version: Swift.String?
}

extension CreateLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLicenseVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = self.consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlement0 in entitlements {
                try entitlementsContainer.encode(entitlement0)
            }
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadata0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadata0)
            }
        }
        if let licenseName = self.licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateLicenseVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLicenseVersionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region of the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Current version of the license.
    public var sourceVersion: Swift.String?
    /// License status.
    /// This member is required.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init(
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseArn: Swift.String? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.sourceVersion = sourceVersion
        self.status = status
        self.validity = validity
    }
}

struct CreateLicenseVersionInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let licenseName: Swift.String?
    let productName: Swift.String?
    let issuer: LicenseManagerClientTypes.Issuer?
    let homeRegion: Swift.String?
    let validity: LicenseManagerClientTypes.DatetimeRange?
    let licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    let entitlements: [LicenseManagerClientTypes.Entitlement]?
    let consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    let status: LicenseManagerClientTypes.LicenseStatus?
    let clientToken: Swift.String?
    let sourceVersion: Swift.String?
}

extension CreateLicenseVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CreateLicenseVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLicenseVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseVersionOutput: Swift.Equatable {
    /// License ARN.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// New version of the license.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseVersionOutputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let version: Swift.String?
    let status: LicenseManagerClientTypes.LicenseStatus?
}

extension CreateLicenseVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateLicenseVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let expirationInDays = self.expirationInDays {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arn0 in roleArns {
                try roleArnsContainer.encode(arn0)
            }
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for string0 in tokenProperties {
                try tokenPropertiesContainer.encode(string0)
            }
        }
    }
}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// Idempotency token, valid for 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Token expiration, in days, counted from token creation. The default is 365 days.
    public var expirationInDays: Swift.Int?
    /// Amazon Resource Name (ARN) of the license. The ARN is mapped to the aud claim of the JWT token.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Amazon Resource Name (ARN) of the IAM roles to embed in the token. License Manager does not check whether the roles are in use.
    public var roleArns: [Swift.String]?
    /// Data specified by the caller to be included in the JWT token. The data is mapped to the amr claim of the JWT token.
    public var tokenProperties: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        expirationInDays: Swift.Int? = nil,
        licenseArn: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInDays = expirationInDays
        self.licenseArn = licenseArn
        self.roleArns = roleArns
        self.tokenProperties = tokenProperties
    }
}

struct CreateTokenInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let roleArns: [Swift.String]?
    let expirationInDays: Swift.Int?
    let tokenProperties: [Swift.String]?
    let clientToken: Swift.String?
}

extension CreateTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.token = output.token
            self.tokenId = output.tokenId
            self.tokenType = output.tokenType
        } else {
            self.token = nil
            self.tokenId = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutput: Swift.Equatable {
    /// Refresh token, encoded as a JWT token.
    public var token: Swift.String?
    /// Token ID.
    public var tokenId: Swift.String?
    /// Token type.
    public var tokenType: LicenseManagerClientTypes.TokenType?

    public init(
        token: Swift.String? = nil,
        tokenId: Swift.String? = nil,
        tokenType: LicenseManagerClientTypes.TokenType? = nil
    )
    {
        self.token = token
        self.tokenId = tokenId
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputBody: Swift.Equatable {
    let tokenId: Swift.String?
    let tokenType: LicenseManagerClientTypes.TokenType?
    let token: Swift.String?
}

extension CreateTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenId = "TokenId"
        case tokenType = "TokenType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.TokenType.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

enum CreateTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes.DatetimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case begin = "Begin"
        case end = "End"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let begin = self.begin {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes a time range, in ISO8601-UTC format.
    public struct DatetimeRange: Swift.Equatable {
        /// Start of the time range.
        /// This member is required.
        public var begin: Swift.String?
        /// End of the time range.
        public var end: Swift.String?

        public init(
            begin: Swift.String? = nil,
            end: Swift.String? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension DeleteGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension DeleteGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// The Status reason for the delete request.
    public var statusReason: Swift.String?
    /// Current version of the grant.
    /// This member is required.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        statusReason: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.statusReason = statusReason
        self.version = version
    }
}

struct DeleteGrantInputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let statusReason: Swift.String?
    let version: Swift.String?
}

extension DeleteGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DeleteGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct DeleteGrantOutput: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct DeleteGrantOutputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let status: LicenseManagerClientTypes.GrantStatus?
    let version: Swift.String?
}

extension DeleteGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum DeleteGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

extension DeleteLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLicenseConfigurationInput: Swift.Equatable {
    /// ID of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct DeleteLicenseConfigurationInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
}

extension DeleteLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension DeleteLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLicenseConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

extension DeleteLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLicenseInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Current version of the license.
    /// This member is required.
    public var sourceVersion: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.sourceVersion = sourceVersion
    }
}

struct DeleteLicenseInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let sourceVersion: Swift.String?
}

extension DeleteLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension DeleteLicenseManagerReportGeneratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = self.licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

extension DeleteLicenseManagerReportGeneratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the report generator to be deleted.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct DeleteLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    let licenseManagerReportGeneratorArn: Swift.String?
}

extension DeleteLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension DeleteLicenseManagerReportGeneratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLicenseManagerReportGeneratorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletionDate = output.deletionDate
            self.status = output.status
        } else {
            self.deletionDate = nil
            self.status = nil
        }
    }
}

public struct DeleteLicenseOutput: Swift.Equatable {
    /// Date when the license is deleted.
    public var deletionDate: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseDeletionStatus?

    public init(
        deletionDate: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseDeletionStatus? = nil
    )
    {
        self.deletionDate = deletionDate
        self.status = status
    }
}

struct DeleteLicenseOutputBody: Swift.Equatable {
    let status: LicenseManagerClientTypes.LicenseDeletionStatus?
    let deletionDate: Swift.String?
}

extension DeleteLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionDate = "DeletionDate"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

enum DeleteLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tokenId = "TokenId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tokenId = self.tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }
}

extension DeleteTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTokenInput: Swift.Equatable {
    /// Token ID.
    /// This member is required.
    public var tokenId: Swift.String?

    public init(
        tokenId: Swift.String? = nil
    )
    {
        self.tokenId = tokenId
    }
}

struct DeleteTokenInputBody: Swift.Equatable {
    let tokenId: Swift.String?
}

extension DeleteTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tokenId = "TokenId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
    }
}

extension DeleteTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTokenOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RedirectException": return try await RedirectException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum DigitalSignatureMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jwtPs384
        case sdkUnknown(Swift.String)

        public static var allCases: [DigitalSignatureMethod] {
            return [
                .jwtPs384,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jwtPs384: return "JWT_PS384"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DigitalSignatureMethod(rawValue: rawValue) ?? DigitalSignatureMethod.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.Entitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCheckIn = "AllowCheckIn"
        case maxCount = "MaxCount"
        case name = "Name"
        case overage = "Overage"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCheckIn = self.allowCheckIn {
            try encodeContainer.encode(allowCheckIn, forKey: .allowCheckIn)
        }
        if let maxCount = self.maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overage = self.overage {
            try encodeContainer.encode(overage, forKey: .overage)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let overageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overage)
        overage = overageDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementUnit.self, forKey: .unit)
        unit = unitDecoded
        let allowCheckInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCheckIn)
        allowCheckIn = allowCheckInDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes a resource entitled for use with a license.
    public struct Entitlement: Swift.Equatable {
        /// Indicates whether check-ins are allowed.
        public var allowCheckIn: Swift.Bool?
        /// Maximum entitlement count. Use if the unit is not None.
        public var maxCount: Swift.Int?
        /// Entitlement name.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether overages are allowed.
        public var overage: Swift.Bool?
        /// Entitlement unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementUnit?
        /// Entitlement resource. Use only if the unit is None.
        public var value: Swift.String?

        public init(
            allowCheckIn: Swift.Bool? = nil,
            maxCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            overage: Swift.Bool? = nil,
            unit: LicenseManagerClientTypes.EntitlementUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowCheckIn = allowCheckIn
            self.maxCount = maxCount
            self.name = name
            self.overage = overage
            self.unit = unit
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes.EntitlementData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Data associated with an entitlement resource.
    public struct EntitlementData: Swift.Equatable {
        /// Entitlement data name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement data unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?
        /// Entitlement data value.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.unit = unit
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum EntitlementDataUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementDataUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementDataUnit(rawValue: rawValue) ?? EntitlementDataUnit.sdkUnknown(rawValue)
        }
    }
}

extension EntitlementNotAllowedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EntitlementNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The entitlement is not allowed.
public struct EntitlementNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementNotAllowedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EntitlementNotAllowedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntitlementNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum EntitlementUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementUnit(rawValue: rawValue) ?? EntitlementUnit.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.EntitlementUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedValue = "ConsumedValue"
        case maxCount = "MaxCount"
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedValue = self.consumedValue {
            try encodeContainer.encode(consumedValue, forKey: .consumedValue)
        }
        if let maxCount = self.maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let consumedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumedValue)
        consumedValue = consumedValueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Usage associated with an entitlement resource.
    public struct EntitlementUsage: Swift.Equatable {
        /// Resource usage consumed.
        /// This member is required.
        public var consumedValue: Swift.String?
        /// Maximum entitlement usage count.
        public var maxCount: Swift.String?
        /// Entitlement usage name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement usage unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?

        public init(
            consumedValue: Swift.String? = nil,
            maxCount: Swift.String? = nil,
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil
        )
        {
            self.consumedValue = consumedValue
            self.maxCount = maxCount
            self.name = name
            self.unit = unit
        }
    }

}

extension ExtendLicenseConsumptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let licenseConsumptionToken = self.licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

extension ExtendLicenseConsumptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExtendLicenseConsumptionInput: Swift.Equatable {
    /// Checks whether you have the required permissions for the action, without actually making the request. Provides an error response if you do not have the required permissions.
    public var dryRun: Swift.Bool?
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init(
        dryRun: Swift.Bool? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionInputBody: Swift.Equatable {
    let licenseConsumptionToken: Swift.String?
    let dryRun: Swift.Bool?
}

extension ExtendLicenseConsumptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ExtendLicenseConsumptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExtendLicenseConsumptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.expiration = output.expiration
            self.licenseConsumptionToken = output.licenseConsumptionToken
        } else {
            self.expiration = nil
            self.licenseConsumptionToken = nil
        }
    }
}

public struct ExtendLicenseConsumptionOutput: Swift.Equatable {
    /// Date and time at which the license consumption expires.
    public var expiration: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?

    public init(
        expiration: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.expiration = expiration
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionOutputBody: Swift.Equatable {
    let licenseConsumptionToken: Swift.String?
    let expiration: Swift.String?
}

extension ExtendLicenseConsumptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiration = "Expiration"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum ExtendLicenseConsumptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FailedDependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A dependency required to run the API is missing.
public struct FailedDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailedDependency" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct FailedDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: Swift.String?
}

extension FailedDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension LicenseManagerClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// Name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The value of the filter, which is case-sensitive. You can only specify one value for the filter.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension FilterLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FilterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request uses too many filters or too many filter values.
public struct FilterLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilterLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FilterLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FilterLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAccessTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for string0 in tokenProperties {
                try tokenPropertiesContainer.encode(string0)
            }
        }
    }
}

extension GetAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessTokenInput: Swift.Equatable {
    /// Refresh token, encoded as a JWT token.
    /// This member is required.
    public var token: Swift.String?
    /// Token properties to validate against those present in the JWT token.
    public var tokenProperties: [Swift.String]?

    public init(
        token: Swift.String? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.token = token
        self.tokenProperties = tokenProperties
    }
}

struct GetAccessTokenInputBody: Swift.Equatable {
    let token: Swift.String?
    let tokenProperties: [Swift.String]?
}

extension GetAccessTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
    }
}

extension GetAccessTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
        } else {
            self.accessToken = nil
        }
    }
}

public struct GetAccessTokenOutput: Swift.Equatable {
    /// Temporary access token.
    public var accessToken: Swift.String?

    public init(
        accessToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct GetAccessTokenOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
}

extension GetAccessTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken = "AccessToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

enum GetAccessTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension GetGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.version = version
    }
}

struct GetGrantInputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let version: Swift.String?
}

extension GetGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grant = output.grant
        } else {
            self.grant = nil
        }
    }
}

public struct GetGrantOutput: Swift.Equatable {
    /// Grant details.
    public var grant: LicenseManagerClientTypes.Grant?

    public init(
        grant: LicenseManagerClientTypes.Grant? = nil
    )
    {
        self.grant = grant
    }
}

struct GetGrantOutputBody: Swift.Equatable {
    let grant: LicenseManagerClientTypes.Grant?
}

extension GetGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grant = "Grant"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

enum GetGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

extension GetLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLicenseConfigurationInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct GetLicenseConfigurationInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
}

extension GetLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension GetLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.automatedDiscoveryInformation = output.automatedDiscoveryInformation
            self.consumedLicenseSummaryList = output.consumedLicenseSummaryList
            self.consumedLicenses = output.consumedLicenses
            self.description = output.description
            self.disassociateWhenNotFound = output.disassociateWhenNotFound
            self.licenseConfigurationArn = output.licenseConfigurationArn
            self.licenseConfigurationId = output.licenseConfigurationId
            self.licenseCount = output.licenseCount
            self.licenseCountHardLimit = output.licenseCountHardLimit
            self.licenseCountingType = output.licenseCountingType
            self.licenseRules = output.licenseRules
            self.managedResourceSummaryList = output.managedResourceSummaryList
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.productInformationList = output.productInformationList
            self.status = output.status
            self.tags = output.tags
        } else {
            self.automatedDiscoveryInformation = nil
            self.consumedLicenseSummaryList = nil
            self.consumedLicenses = nil
            self.description = nil
            self.disassociateWhenNotFound = nil
            self.licenseConfigurationArn = nil
            self.licenseConfigurationId = nil
            self.licenseCount = nil
            self.licenseCountHardLimit = nil
            self.licenseCountingType = nil
            self.licenseRules = nil
            self.managedResourceSummaryList = nil
            self.name = nil
            self.ownerAccountId = nil
            self.productInformationList = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetLicenseConfigurationOutput: Swift.Equatable {
    /// Automated discovery information.
    public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
    /// Summaries of the licenses consumed by resources.
    public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
    /// Number of licenses assigned to resources.
    public var consumedLicenses: Swift.Int?
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?
    /// Unique ID for the license configuration.
    public var licenseConfigurationId: Swift.String?
    /// Number of available licenses.
    public var licenseCount: Swift.Int?
    /// Sets the number of available licenses as a hard limit.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension for which the licenses are counted.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules.
    public var licenseRules: [Swift.String]?
    /// Summaries of the managed resources.
    public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
    /// Name of the license configuration.
    public var name: Swift.String?
    /// Account ID of the owner of the license configuration.
    public var ownerAccountId: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// License configuration status.
    public var status: Swift.String?
    /// Tags for the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
        consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
        consumedLicenses: Swift.Int? = nil,
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationId: Swift.String? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        status: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.automatedDiscoveryInformation = automatedDiscoveryInformation
        self.consumedLicenseSummaryList = consumedLicenseSummaryList
        self.consumedLicenses = consumedLicenses
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationId = licenseConfigurationId
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.managedResourceSummaryList = managedResourceSummaryList
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.productInformationList = productInformationList
        self.status = status
        self.tags = tags
    }
}

struct GetLicenseConfigurationOutputBody: Swift.Equatable {
    let licenseConfigurationId: Swift.String?
    let licenseConfigurationArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    let licenseRules: [Swift.String]?
    let licenseCount: Swift.Int?
    let licenseCountHardLimit: Swift.Bool?
    let consumedLicenses: Swift.Int?
    let status: Swift.String?
    let ownerAccountId: Swift.String?
    let consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
    let managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
    let tags: [LicenseManagerClientTypes.Tag]?
    let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    let automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
    let disassociateWhenNotFound: Swift.Bool?
}

extension GetLicenseConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [LicenseManagerClientTypes.ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[LicenseManagerClientTypes.ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [LicenseManagerClientTypes.ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

enum GetLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseConversionTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConversionTaskId = self.licenseConversionTaskId {
            try encodeContainer.encode(licenseConversionTaskId, forKey: .licenseConversionTaskId)
        }
    }
}

extension GetLicenseConversionTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLicenseConversionTaskInput: Swift.Equatable {
    /// ID of the license type conversion task to retrieve information on.
    /// This member is required.
    public var licenseConversionTaskId: Swift.String?

    public init(
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

struct GetLicenseConversionTaskInputBody: Swift.Equatable {
    let licenseConversionTaskId: Swift.String?
}

extension GetLicenseConversionTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
    }
}

extension GetLicenseConversionTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseConversionTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationLicenseContext = output.destinationLicenseContext
            self.endTime = output.endTime
            self.licenseConversionTaskId = output.licenseConversionTaskId
            self.licenseConversionTime = output.licenseConversionTime
            self.resourceArn = output.resourceArn
            self.sourceLicenseContext = output.sourceLicenseContext
            self.startTime = output.startTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.destinationLicenseContext = nil
            self.endTime = nil
            self.licenseConversionTaskId = nil
            self.licenseConversionTime = nil
            self.resourceArn = nil
            self.sourceLicenseContext = nil
            self.startTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetLicenseConversionTaskOutput: Swift.Equatable {
    /// Information about the license type converted to.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was completed.
    public var endTime: ClientRuntime.Date?
    /// ID of the license type conversion task.
    public var licenseConversionTaskId: Swift.String?
    /// Amount of time to complete the license type conversion.
    public var licenseConversionTime: ClientRuntime.Date?
    /// Amazon Resource Names (ARN) of the resources the license conversion task is associated with.
    public var resourceArn: Swift.String?
    /// Information about the license type converted from.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was started .
    public var startTime: ClientRuntime.Date?
    /// Status of the license type conversion task.
    public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
    /// The status message for the conversion task.
    public var statusMessage: Swift.String?

    public init(
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        endTime: ClientRuntime.Date? = nil,
        licenseConversionTaskId: Swift.String? = nil,
        licenseConversionTime: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.endTime = endTime
        self.licenseConversionTaskId = licenseConversionTaskId
        self.licenseConversionTime = licenseConversionTime
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetLicenseConversionTaskOutputBody: Swift.Equatable {
    let licenseConversionTaskId: Swift.String?
    let resourceArn: Swift.String?
    let sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    let destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    let statusMessage: Swift.String?
    let status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
    let startTime: ClientRuntime.Date?
    let licenseConversionTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension GetLicenseConversionTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case endTime = "EndTime"
        case licenseConversionTaskId = "LicenseConversionTaskId"
        case licenseConversionTime = "LicenseConversionTime"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let licenseConversionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .licenseConversionTime)
        licenseConversionTime = licenseConversionTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

enum GetLicenseConversionTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension GetLicenseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLicenseInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// License version.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.version = version
    }
}

struct GetLicenseInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let version: Swift.String?
}

extension GetLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetLicenseManagerReportGeneratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = self.licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

extension GetLicenseManagerReportGeneratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the report generator.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct GetLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    let licenseManagerReportGeneratorArn: Swift.String?
}

extension GetLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension GetLicenseManagerReportGeneratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseManagerReportGeneratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportGenerator = output.reportGenerator
        } else {
            self.reportGenerator = nil
        }
    }
}

public struct GetLicenseManagerReportGeneratorOutput: Swift.Equatable {
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerator: LicenseManagerClientTypes.ReportGenerator?

    public init(
        reportGenerator: LicenseManagerClientTypes.ReportGenerator? = nil
    )
    {
        self.reportGenerator = reportGenerator
    }
}

struct GetLicenseManagerReportGeneratorOutputBody: Swift.Equatable {
    let reportGenerator: LicenseManagerClientTypes.ReportGenerator?
}

extension GetLicenseManagerReportGeneratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGenerator = "ReportGenerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportGenerator.self, forKey: .reportGenerator)
        reportGenerator = reportGeneratorDecoded
    }
}

enum GetLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseOutputBody = try responseDecoder.decode(responseBody: data)
            self.license = output.license
        } else {
            self.license = nil
        }
    }
}

public struct GetLicenseOutput: Swift.Equatable {
    /// License details.
    public var license: LicenseManagerClientTypes.License?

    public init(
        license: LicenseManagerClientTypes.License? = nil
    )
    {
        self.license = license
    }
}

struct GetLicenseOutputBody: Swift.Equatable {
    let license: LicenseManagerClientTypes.License?
}

extension GetLicenseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case license = "License"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.License.self, forKey: .license)
        license = licenseDecoded
    }
}

enum GetLicenseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLicenseUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
    }
}

extension GetLicenseUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLicenseUsageInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?

    public init(
        licenseArn: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
    }
}

struct GetLicenseUsageInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
}

extension GetLicenseUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
    }
}

extension GetLicenseUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLicenseUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseUsage = output.licenseUsage
        } else {
            self.licenseUsage = nil
        }
    }
}

public struct GetLicenseUsageOutput: Swift.Equatable {
    /// License usage details.
    public var licenseUsage: LicenseManagerClientTypes.LicenseUsage?

    public init(
        licenseUsage: LicenseManagerClientTypes.LicenseUsage? = nil
    )
    {
        self.licenseUsage = licenseUsage
    }
}

struct GetLicenseUsageOutputBody: Swift.Equatable {
    let licenseUsage: LicenseManagerClientTypes.LicenseUsage?
}

extension GetLicenseUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseUsage = "LicenseUsage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseUsageDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseUsage.self, forKey: .licenseUsage)
        licenseUsage = licenseUsageDecoded
    }
}

enum GetLicenseUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServiceSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetServiceSettingsInputBody: Swift.Equatable {
}

extension GetServiceSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.enableCrossAccountsDiscovery = output.enableCrossAccountsDiscovery
            self.licenseManagerResourceShareArn = output.licenseManagerResourceShareArn
            self.organizationConfiguration = output.organizationConfiguration
            self.s3BucketArn = output.s3BucketArn
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.enableCrossAccountsDiscovery = nil
            self.licenseManagerResourceShareArn = nil
            self.organizationConfiguration = nil
            self.s3BucketArn = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetServiceSettingsOutput: Swift.Equatable {
    /// Indicates whether cross-account discovery is enabled.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Amazon Resource Name (ARN) of the resource share. The License Manager management account provides member accounts with access to this share.
    public var licenseManagerResourceShareArn: Swift.String?
    /// Indicates whether Organizations is integrated with License Manager for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Regional S3 bucket path for storing reports, license trail event data, discovery data, and so on.
    public var s3BucketArn: Swift.String?
    /// SNS topic configured to receive notifications from License Manager.
    public var snsTopicArn: Swift.String?

    public init(
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        licenseManagerResourceShareArn: Swift.String? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.licenseManagerResourceShareArn = licenseManagerResourceShareArn
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct GetServiceSettingsOutputBody: Swift.Equatable {
    let s3BucketArn: Swift.String?
    let snsTopicArn: Swift.String?
    let organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    let enableCrossAccountsDiscovery: Swift.Bool?
    let licenseManagerResourceShareArn: Swift.String?
}

extension GetServiceSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case licenseManagerResourceShareArn = "LicenseManagerResourceShareArn"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
        let licenseManagerResourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerResourceShareArn)
        licenseManagerResourceShareArn = licenseManagerResourceShareArnDecoded
    }
}

enum GetServiceSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes.Grant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case grantStatus = "GrantStatus"
        case grantedOperations = "GrantedOperations"
        case granteePrincipalArn = "GranteePrincipalArn"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case options = "Options"
        case parentArn = "ParentArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = self.grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let grantStatus = self.grantStatus {
            try encodeContainer.encode(grantStatus.rawValue, forKey: .grantStatus)
        }
        if let grantedOperations = grantedOperations {
            var grantedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantedOperations)
            for allowedoperation0 in grantedOperations {
                try grantedOperationsContainer.encode(allowedoperation0.rawValue)
            }
        }
        if let granteePrincipalArn = self.granteePrincipalArn {
            try encodeContainer.encode(granteePrincipalArn, forKey: .granteePrincipalArn)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let parentArn = self.parentArn {
            try encodeContainer.encode(parentArn, forKey: .parentArn)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let parentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentArn)
        parentArn = parentArnDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let granteePrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteePrincipalArn)
        granteePrincipalArn = granteePrincipalArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let grantStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .grantStatus)
        grantStatus = grantStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let grantedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .grantedOperations)
        var grantedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let grantedOperationsContainer = grantedOperationsContainer {
            grantedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for enum0 in grantedOperationsContainer {
                if let enum0 = enum0 {
                    grantedOperationsDecoded0?.append(enum0)
                }
            }
        }
        grantedOperations = grantedOperationsDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Options.self, forKey: .options)
        options = optionsDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes a grant.
    public struct Grant: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the grant.
        /// This member is required.
        public var grantArn: Swift.String?
        /// Grant name.
        /// This member is required.
        public var grantName: Swift.String?
        /// Grant status.
        /// This member is required.
        public var grantStatus: LicenseManagerClientTypes.GrantStatus?
        /// Granted operations.
        /// This member is required.
        public var grantedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// The grantee principal ARN.
        /// This member is required.
        public var granteePrincipalArn: Swift.String?
        /// Home Region of the grant.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// License ARN.
        /// This member is required.
        public var licenseArn: Swift.String?
        /// The options specified for the grant.
        public var options: LicenseManagerClientTypes.Options?
        /// Parent ARN.
        /// This member is required.
        public var parentArn: Swift.String?
        /// Grant status reason.
        public var statusReason: Swift.String?
        /// Grant version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            grantArn: Swift.String? = nil,
            grantName: Swift.String? = nil,
            grantStatus: LicenseManagerClientTypes.GrantStatus? = nil,
            grantedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            granteePrincipalArn: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            options: LicenseManagerClientTypes.Options? = nil,
            parentArn: Swift.String? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.grantArn = grantArn
            self.grantName = grantName
            self.grantStatus = grantStatus
            self.grantedOperations = grantedOperations
            self.granteePrincipalArn = granteePrincipalArn
            self.homeRegion = homeRegion
            self.licenseArn = licenseArn
            self.options = options
            self.parentArn = parentArn
            self.statusReason = statusReason
            self.version = version
        }
    }

}

extension LicenseManagerClientTypes {
    public enum GrantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingDelete
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [GrantStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingDelete,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingDelete: return "PENDING_DELETE"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrantStatus(rawValue: rawValue) ?? GrantStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.GrantedLicense: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case receivedMetadata = "ReceivedMetadata"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = self.beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = self.consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlement0 in entitlements {
                try entitlementsContainer.encode(entitlement0)
            }
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadata0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadata0)
            }
        }
        if let licenseName = self.licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = self.productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let receivedMetadata = self.receivedMetadata {
            try encodeContainer.encode(receivedMetadata, forKey: .receivedMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let receivedMetadataDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReceivedMetadata.self, forKey: .receivedMetadata)
        receivedMetadata = receivedMetadataDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes a license that is granted to a grantee.
    public struct GrantedLicense: Swift.Equatable {
        /// Granted license beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// Creation time of the granted license.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the granted license.
        public var homeRegion: Swift.String?
        /// Granted license issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Granted license metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// Granted license received metadata.
        public var receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata?
        /// Granted license status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the granted license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// Version of the granted license.
        public var version: Swift.String?

        public init(
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.receivedMetadata = receivedMetadata
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueProvided" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// License Manager cannot allocate a license to a resource because of its state. For example, you cannot allocate a license to an instance in the process of shutting down.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.InventoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.InventoryFilterCondition.self, forKey: .condition)
        condition = conditionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes {
    /// An inventory filter.
    public struct InventoryFilter: Swift.Equatable {
        /// Condition of the filter.
        /// This member is required.
        public var condition: LicenseManagerClientTypes.InventoryFilterCondition?
        /// Name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init(
            condition: LicenseManagerClientTypes.InventoryFilterCondition? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum InventoryFilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case contains
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryFilterCondition] {
            return [
                .beginsWith,
                .contains,
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryFilterCondition(rawValue: rawValue) ?? InventoryFilterCondition.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.Issuer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = self.signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signKey)
        signKey = signKeyDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about the issuer of a license.
    public struct Issuer: Swift.Equatable {
        /// Issuer name.
        /// This member is required.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init(
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes.IssuerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyFingerprint = "KeyFingerprint"
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyFingerprint = self.keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = self.signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signKey)
        signKey = signKeyDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details associated with the issuer of a license.
    public struct IssuerDetails: Swift.Equatable {
        /// Issuer key fingerprint.
        public var keyFingerprint: Swift.String?
        /// Issuer name.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init(
            keyFingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.keyFingerprint = keyFingerprint
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes.License: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = self.beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = self.consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlement0 in entitlements {
                try entitlementsContainer.encode(entitlement0)
            }
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadata0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadata0)
            }
        }
        if let licenseName = self.licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = self.productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Software license that is managed in License Manager.
    public struct License: Swift.Equatable {
        /// License beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// License creation time.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the license.
        public var homeRegion: Swift.String?
        /// License issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// License metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// License status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// License version.
        public var version: Swift.String?

        public init(
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

extension LicenseManagerClientTypes.LicenseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedDiscoveryInformation = self.automatedDiscoveryInformation {
            try encodeContainer.encode(automatedDiscoveryInformation, forKey: .automatedDiscoveryInformation)
        }
        if let consumedLicenseSummaryList = consumedLicenseSummaryList {
            var consumedLicenseSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .consumedLicenseSummaryList)
            for consumedlicensesummary0 in consumedLicenseSummaryList {
                try consumedLicenseSummaryListContainer.encode(consumedlicensesummary0)
            }
        }
        if let consumedLicenses = self.consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = self.disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationId = self.licenseConfigurationId {
            try encodeContainer.encode(licenseConfigurationId, forKey: .licenseConfigurationId)
        }
        if let licenseCount = self.licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = self.licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = self.licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for string0 in licenseRules {
                try licenseRulesContainer.encode(string0)
            }
        }
        if let managedResourceSummaryList = managedResourceSummaryList {
            var managedResourceSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedResourceSummaryList)
            for managedresourcesummary0 in managedResourceSummaryList {
                try managedResourceSummaryListContainer.encode(managedresourcesummary0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformation0 in productInformationList {
                try productInformationListContainer.encode(productinformation0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [LicenseManagerClientTypes.ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[LicenseManagerClientTypes.ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [LicenseManagerClientTypes.ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
    }
}

extension LicenseManagerClientTypes {
    /// A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), host affinity (how long a VM must be associated with a host), and the number of licenses purchased and used.
    public struct LicenseConfiguration: Swift.Equatable {
        /// Automated discovery information.
        public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
        /// Summaries for licenses consumed by various resources.
        public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
        /// Number of licenses consumed.
        public var consumedLicenses: Swift.Int?
        /// Description of the license configuration.
        public var description: Swift.String?
        /// When true, disassociates a resource when software is uninstalled.
        public var disassociateWhenNotFound: Swift.Bool?
        /// Amazon Resource Name (ARN) of the license configuration.
        public var licenseConfigurationArn: Swift.String?
        /// Unique ID of the license configuration.
        public var licenseConfigurationId: Swift.String?
        /// Number of licenses managed by the license configuration.
        public var licenseCount: Swift.Int?
        /// Number of available licenses as a hard limit.
        public var licenseCountHardLimit: Swift.Bool?
        /// Dimension to use to track the license inventory.
        public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
        /// License rules.
        public var licenseRules: [Swift.String]?
        /// Summaries for managed resources.
        public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
        /// Name of the license configuration.
        public var name: Swift.String?
        /// Account ID of the license configuration's owner.
        public var ownerAccountId: Swift.String?
        /// Product information.
        public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
        /// Status of the license configuration.
        public var status: Swift.String?

        public init(
            automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
            consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
            consumedLicenses: Swift.Int? = nil,
            description: Swift.String? = nil,
            disassociateWhenNotFound: Swift.Bool? = nil,
            licenseConfigurationArn: Swift.String? = nil,
            licenseConfigurationId: Swift.String? = nil,
            licenseCount: Swift.Int? = nil,
            licenseCountHardLimit: Swift.Bool? = nil,
            licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
            licenseRules: [Swift.String]? = nil,
            managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
            status: Swift.String? = nil
        )
        {
            self.automatedDiscoveryInformation = automatedDiscoveryInformation
            self.consumedLicenseSummaryList = consumedLicenseSummaryList
            self.consumedLicenses = consumedLicenses
            self.description = description
            self.disassociateWhenNotFound = disassociateWhenNotFound
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationId = licenseConfigurationId
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.managedResourceSummaryList = managedResourceSummaryList
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.productInformationList = productInformationList
            self.status = status
        }
    }

}

extension LicenseManagerClientTypes.LicenseConfigurationAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case associationTime = "AssociationTime"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = self.amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let associationTime = self.associationTime {
            try encodeContainer.encodeTimestamp(associationTime, format: .epochSeconds, forKey: .associationTime)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = self.resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes an association with a license configuration.
    public struct LicenseConfigurationAssociation: Swift.Equatable {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Time when the license configuration was associated with the resource.
        public var associationTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource consuming licenses.
        public var resourceOwnerId: Swift.String?
        /// Type of server resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            amiAssociationScope: Swift.String? = nil,
            associationTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.associationTime = associationTime
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConfigurationStatus] {
            return [
                .available,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseConfigurationStatus(rawValue: rawValue) ?? LicenseConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTime = "AssociationTime"
        case consumedLicenses = "ConsumedLicenses"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceStatus = "ResourceStatus"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTime = self.associationTime {
            try encodeContainer.encodeTimestamp(associationTime, format: .epochSeconds, forKey: .associationTime)
        }
        if let consumedLicenses = self.consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = self.resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceStatus = self.resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about the usage of a resource associated with a license configuration.
    public struct LicenseConfigurationUsage: Swift.Equatable {
        /// Time when the license configuration was initially associated with the resource.
        public var associationTime: ClientRuntime.Date?
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Status of the resource.
        public var resourceStatus: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            associationTime: ClientRuntime.Date? = nil,
            consumedLicenses: Swift.Int? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceStatus: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationTime = associationTime
            self.consumedLicenses = consumedLicenses
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceStatus = resourceStatus
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.LicenseConversionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageOperation = "UsageOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageOperation = self.usageOperation {
            try encodeContainer.encode(usageOperation, forKey: .usageOperation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionContext: Swift.Equatable {
        /// The Usage operation value that corresponds to the license type you are converting your resource from. For more information about which platforms correspond to which usage operation values see [Sample data: usage operation by platform ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html#billing-info)
        public var usageOperation: Swift.String?

        public init(
            usageOperation: Swift.String? = nil
        )
        {
            self.usageOperation = usageOperation
        }
    }

}

extension LicenseManagerClientTypes.LicenseConversionTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case endTime = "EndTime"
        case licenseConversionTaskId = "LicenseConversionTaskId"
        case licenseConversionTime = "LicenseConversionTime"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationLicenseContext = self.destinationLicenseContext {
            try encodeContainer.encode(destinationLicenseContext, forKey: .destinationLicenseContext)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let licenseConversionTaskId = self.licenseConversionTaskId {
            try encodeContainer.encode(licenseConversionTaskId, forKey: .licenseConversionTaskId)
        }
        if let licenseConversionTime = self.licenseConversionTime {
            try encodeContainer.encodeTimestamp(licenseConversionTime, format: .epochSeconds, forKey: .licenseConversionTime)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceLicenseContext = self.sourceLicenseContext {
            try encodeContainer.encode(sourceLicenseContext, forKey: .sourceLicenseContext)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let licenseConversionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .licenseConversionTime)
        licenseConversionTime = licenseConversionTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionTask: Swift.Equatable {
        /// Information about the license type this conversion task converted to.
        public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was completed.
        public var endTime: ClientRuntime.Date?
        /// The ID of the license type conversion task.
        public var licenseConversionTaskId: Swift.String?
        /// The time the usage operation value of the resource was changed.
        public var licenseConversionTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource associated with the license type conversion task.
        public var resourceArn: Swift.String?
        /// Information about the license type this conversion task converted from.
        public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was started at.
        public var startTime: ClientRuntime.Date?
        /// The status of the conversion task.
        public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
        /// The status message for the conversion task.
        public var statusMessage: Swift.String?

        public init(
            destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            endTime: ClientRuntime.Date? = nil,
            licenseConversionTaskId: Swift.String? = nil,
            licenseConversionTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.destinationLicenseContext = destinationLicenseContext
            self.endTime = endTime
            self.licenseConversionTaskId = licenseConversionTaskId
            self.licenseConversionTime = licenseConversionTime
            self.resourceArn = resourceArn
            self.sourceLicenseContext = sourceLicenseContext
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseConversionTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConversionTaskStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseConversionTaskStatus(rawValue: rawValue) ?? LicenseConversionTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum LicenseCountingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case core
        case instance
        case socket
        case vcpu
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseCountingType] {
            return [
                .core,
                .instance,
                .socket,
                .vcpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .core: return "Core"
            case .instance: return "Instance"
            case .socket: return "Socket"
            case .vcpu: return "vCPU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseCountingType(rawValue: rawValue) ?? LicenseCountingType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum LicenseDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case pendingDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseDeletionStatus] {
            return [
                .deleted,
                .pendingDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .pendingDelete: return "PENDING_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseDeletionStatus(rawValue: rawValue) ?? LicenseDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseOperationFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case failureTime = "FailureTime"
        case metadataList = "MetadataList"
        case operationName = "OperationName"
        case operationRequestedBy = "OperationRequestedBy"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failureTime = self.failureTime {
            try encodeContainer.encodeTimestamp(failureTime, format: .epochSeconds, forKey: .failureTime)
        }
        if let metadataList = metadataList {
            var metadataListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadataList)
            for metadata0 in metadataList {
                try metadataListContainer.encode(metadata0)
            }
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let operationRequestedBy = self.operationRequestedBy {
            try encodeContainer.encode(operationRequestedBy, forKey: .operationRequestedBy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = self.resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let failureTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .failureTime)
        failureTime = failureTimeDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let operationRequestedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationRequestedBy)
        operationRequestedBy = operationRequestedByDecoded
        let metadataListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .metadataList)
        var metadataListDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let metadataListContainer = metadataListContainer {
            metadataListDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in metadataListContainer {
                if let structure0 = structure0 {
                    metadataListDecoded0?.append(structure0)
                }
            }
        }
        metadataList = metadataListDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Describes the failure of a license operation.
    public struct LicenseOperationFailure: Swift.Equatable {
        /// Error message.
        public var errorMessage: Swift.String?
        /// Failure time.
        public var failureTime: ClientRuntime.Date?
        /// Reserved.
        public var metadataList: [LicenseManagerClientTypes.Metadata]?
        /// Name of the operation.
        public var operationName: Swift.String?
        /// The requester is "License Manager Automated Discovery".
        public var operationRequestedBy: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Resource type.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            errorMessage: Swift.String? = nil,
            failureTime: ClientRuntime.Date? = nil,
            metadataList: [LicenseManagerClientTypes.Metadata]? = nil,
            operationName: Swift.String? = nil,
            operationRequestedBy: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.errorMessage = errorMessage
            self.failureTime = failureTime
            self.metadataList = metadataList
            self.operationName = operationName
            self.operationRequestedBy = operationRequestedBy
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.LicenseSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = self.amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details for associating a license configuration with a resource.
    public struct LicenseSpecification: Swift.Equatable {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Amazon Resource Name (ARN) of the license configuration.
        /// This member is required.
        public var licenseConfigurationArn: Swift.String?

        public init(
            amiAssociationScope: Swift.String? = nil,
            licenseConfigurationArn: Swift.String? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deactivated
        case deleted
        case expired
        case pendingAvailable
        case pendingDelete
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseStatus] {
            return [
                .available,
                .deactivated,
                .deleted,
                .expired,
                .pendingAvailable,
                .pendingDelete,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deactivated: return "DEACTIVATED"
            case .deleted: return "DELETED"
            case .expired: return "EXPIRED"
            case .pendingAvailable: return "PENDING_AVAILABLE"
            case .pendingDelete: return "PENDING_DELETE"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseStatus(rawValue: rawValue) ?? LicenseStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementUsages = "EntitlementUsages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlementUsages = entitlementUsages {
            var entitlementUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlementUsages)
            for entitlementusage0 in entitlementUsages {
                try entitlementUsagesContainer.encode(entitlementusage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementUsagesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementUsage?].self, forKey: .entitlementUsages)
        var entitlementUsagesDecoded0:[LicenseManagerClientTypes.EntitlementUsage]? = nil
        if let entitlementUsagesContainer = entitlementUsagesContainer {
            entitlementUsagesDecoded0 = [LicenseManagerClientTypes.EntitlementUsage]()
            for structure0 in entitlementUsagesContainer {
                if let structure0 = structure0 {
                    entitlementUsagesDecoded0?.append(structure0)
                }
            }
        }
        entitlementUsages = entitlementUsagesDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Describes the entitlement usage associated with a license.
    public struct LicenseUsage: Swift.Equatable {
        /// License entitlement usages.
        public var entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]?

        public init(
            entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]? = nil
        )
        {
            self.entitlementUsages = entitlementUsages
        }
    }

}

extension LicenseUsageException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LicenseUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have enough licenses available to support a new resource launch.
public struct LicenseUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LicenseUsageFailure" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LicenseUsageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LicenseUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAssociationsForLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssociationsForLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociationsForLicenseConfigurationInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of a license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAssociationsForLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsForLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociationsForLicenseConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationAssociations = output.licenseConfigurationAssociations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsForLicenseConfigurationOutput: Swift.Equatable {
    /// Information about the associations for the license configuration.
    public var licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationAssociations = licenseConfigurationAssociations
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationOutputBody: Swift.Equatable {
    let licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]?
    let nextToken: Swift.String?
}

extension ListAssociationsForLicenseConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationAssociations = "LicenseConfigurationAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationAssociationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfigurationAssociation?].self, forKey: .licenseConfigurationAssociations)
        var licenseConfigurationAssociationsDecoded0:[LicenseManagerClientTypes.LicenseConfigurationAssociation]? = nil
        if let licenseConfigurationAssociationsContainer = licenseConfigurationAssociationsContainer {
            licenseConfigurationAssociationsDecoded0 = [LicenseManagerClientTypes.LicenseConfigurationAssociation]()
            for structure0 in licenseConfigurationAssociationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationAssociations = licenseConfigurationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociationsForLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilterLimitExceeded": return try await FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDistributedGrantsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arn0 in grantArns {
                try grantArnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDistributedGrantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDistributedGrantsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranteePrincipalARN
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsInputBody: Swift.Equatable {
    let grantArns: [Swift.String]?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDistributedGrantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[Swift.String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [Swift.String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDistributedGrantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDistributedGrantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListDistributedGrantsOutput: Swift.Equatable {
    /// Distributed grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsOutputBody: Swift.Equatable {
    let grants: [LicenseManagerClientTypes.Grant]?
    let nextToken: Swift.String?
}

extension ListDistributedGrantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Grant?].self, forKey: .grants)
        var grantsDecoded0:[LicenseManagerClientTypes.Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [LicenseManagerClientTypes.Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDistributedGrantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFailuresForLicenseConfigurationOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFailuresForLicenseConfigurationOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInput: Swift.Equatable {
    /// Amazon Resource Name of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFailuresForLicenseConfigurationOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFailuresForLicenseConfigurationOperationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseOperationFailureList = output.licenseOperationFailureList
            self.nextToken = output.nextToken
        } else {
            self.licenseOperationFailureList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFailuresForLicenseConfigurationOperationsOutput: Swift.Equatable {
    /// License configuration operations that failed.
    public var licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseOperationFailureList = licenseOperationFailureList
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsOutputBody: Swift.Equatable {
    let licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]?
    let nextToken: Swift.String?
}

extension ListFailuresForLicenseConfigurationOperationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseOperationFailureList = "LicenseOperationFailureList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseOperationFailureListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseOperationFailure?].self, forKey: .licenseOperationFailureList)
        var licenseOperationFailureListDecoded0:[LicenseManagerClientTypes.LicenseOperationFailure]? = nil
        if let licenseOperationFailureListContainer = licenseOperationFailureListContainer {
            licenseOperationFailureListDecoded0 = [LicenseManagerClientTypes.LicenseOperationFailure]()
            for structure0 in licenseOperationFailureListContainer {
                if let structure0 = structure0 {
                    licenseOperationFailureListDecoded0?.append(structure0)
                }
            }
        }
        licenseOperationFailureList = licenseOperationFailureListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFailuresForLicenseConfigurationOperationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for string0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(string0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLicenseConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicenseConfigurationsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * licenseCountingType - The dimension for which licenses are counted. Possible values are vCPU | Instance | Core | Socket. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * enforceLicenseCount - A Boolean value that indicates whether hard license enforcement is used. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * usagelimitExceeded - A Boolean value that indicates whether the available licenses have been exceeded. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARN) of the license configurations.
    public var licenseConfigurationArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArns = licenseConfigurationArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsInputBody: Swift.Equatable {
    let licenseConfigurationArns: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListLicenseConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLicenseConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurations = output.licenseConfigurations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseConfigurationsOutput: Swift.Equatable {
    /// Information about the license configurations.
    public var licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurations = licenseConfigurations
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsOutputBody: Swift.Equatable {
    let licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]?
    let nextToken: Swift.String?
}

extension ListLicenseConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurations = "LicenseConfigurations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfiguration?].self, forKey: .licenseConfigurations)
        var licenseConfigurationsDecoded0:[LicenseManagerClientTypes.LicenseConfiguration]? = nil
        if let licenseConfigurationsContainer = licenseConfigurationsContainer {
            licenseConfigurationsDecoded0 = [LicenseManagerClientTypes.LicenseConfiguration]()
            for structure0 in licenseConfigurationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurations = licenseConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilterLimitExceeded": return try await FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseConversionTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLicenseConversionTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicenseConversionTasksInput: Swift.Equatable {
    /// Filters to scope the results. Valid filters are ResourceArns and Status.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseConversionTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListLicenseConversionTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLicenseConversionTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseConversionTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConversionTasks = output.licenseConversionTasks
            self.nextToken = output.nextToken
        } else {
            self.licenseConversionTasks = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseConversionTasksOutput: Swift.Equatable {
    /// Information about the license configuration tasks for your account.
    public var licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConversionTasks = licenseConversionTasks
        self.nextToken = nextToken
    }
}

struct ListLicenseConversionTasksOutputBody: Swift.Equatable {
    let licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]?
    let nextToken: Swift.String?
}

extension ListLicenseConversionTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTasks = "LicenseConversionTasks"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTasksContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConversionTask?].self, forKey: .licenseConversionTasks)
        var licenseConversionTasksDecoded0:[LicenseManagerClientTypes.LicenseConversionTask]? = nil
        if let licenseConversionTasksContainer = licenseConversionTasksContainer {
            licenseConversionTasksDecoded0 = [LicenseManagerClientTypes.LicenseConversionTask]()
            for structure0 in licenseConversionTasksContainer {
                if let structure0 = structure0 {
                    licenseConversionTasksDecoded0?.append(structure0)
                }
            }
        }
        licenseConversionTasks = licenseConversionTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseConversionTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseManagerReportGeneratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLicenseManagerReportGeneratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicenseManagerReportGeneratorsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseConfigurationArn
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseManagerReportGeneratorsInputBody: Swift.Equatable {
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListLicenseManagerReportGeneratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseManagerReportGeneratorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseManagerReportGeneratorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportGenerators = output.reportGenerators
        } else {
            self.nextToken = nil
            self.reportGenerators = nil
        }
    }
}

public struct ListLicenseManagerReportGeneratorsOutput: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerators: [LicenseManagerClientTypes.ReportGenerator]?

    public init(
        nextToken: Swift.String? = nil,
        reportGenerators: [LicenseManagerClientTypes.ReportGenerator]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGenerators = reportGenerators
    }
}

struct ListLicenseManagerReportGeneratorsOutputBody: Swift.Equatable {
    let reportGenerators: [LicenseManagerClientTypes.ReportGenerator]?
    let nextToken: Swift.String?
}

extension ListLicenseManagerReportGeneratorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportGenerators = "ReportGenerators"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportGenerator?].self, forKey: .reportGenerators)
        var reportGeneratorsDecoded0:[LicenseManagerClientTypes.ReportGenerator]? = nil
        if let reportGeneratorsContainer = reportGeneratorsContainer {
            reportGeneratorsDecoded0 = [LicenseManagerClientTypes.ReportGenerator]()
            for structure0 in reportGeneratorsContainer {
                if let structure0 = structure0 {
                    reportGeneratorsDecoded0?.append(structure0)
                }
            }
        }
        reportGenerators = reportGeneratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseManagerReportGeneratorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseSpecificationsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListLicenseSpecificationsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicenseSpecificationsForResourceInput: Swift.Equatable {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) of a resource that has an associated license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListLicenseSpecificationsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLicenseSpecificationsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLicenseSpecificationsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseSpecificationsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseSpecifications = output.licenseSpecifications
            self.nextToken = output.nextToken
        } else {
            self.licenseSpecifications = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseSpecificationsForResourceOutput: Swift.Equatable {
    /// License configurations associated with a resource.
    public var licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseSpecifications = licenseSpecifications
        self.nextToken = nextToken
    }
}

struct ListLicenseSpecificationsForResourceOutputBody: Swift.Equatable {
    let licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    let nextToken: Swift.String?
}

extension ListLicenseSpecificationsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseSpecifications = "LicenseSpecifications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .licenseSpecifications)
        var licenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let licenseSpecificationsContainer = licenseSpecificationsContainer {
            licenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in licenseSpecificationsContainer {
                if let structure0 = structure0 {
                    licenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        licenseSpecifications = licenseSpecificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseSpecificationsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicenseVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLicenseVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicenseVersionsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListLicenseVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicenseVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseVersionsOutput: Swift.Equatable {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsOutputBody: Swift.Equatable {
    let licenses: [LicenseManagerClientTypes.License]?
    let nextToken: Swift.String?
}

extension ListLicenseVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.License?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicenseVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLicensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arn0 in licenseArns {
                try licenseArnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLicensesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLicensesInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * Beneficiary
    ///
    /// * ProductSKU
    ///
    /// * Fingerprint
    ///
    /// * Status
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicensesInputBody: Swift.Equatable {
    let licenseArns: [Swift.String]?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListLicensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[Swift.String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [Swift.String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicensesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLicensesOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicensesOutput: Swift.Equatable {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicensesOutputBody: Swift.Equatable {
    let licenses: [LicenseManagerClientTypes.License]?
    let nextToken: Swift.String?
}

extension ListLicensesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.License?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLicensesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReceivedGrantsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListReceivedGrantsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReceivedGrantsForOrganizationInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ParentArn
    ///
    /// * GranteePrincipalArn
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the received license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsForOrganizationInputBody: Swift.Equatable {
    let licenseArn: Swift.String?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReceivedGrantsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedGrantsForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReceivedGrantsForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedGrantsForOrganizationOutput: Swift.Equatable {
    /// Lists the grants the organization has received.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsForOrganizationOutputBody: Swift.Equatable {
    let grants: [LicenseManagerClientTypes.Grant]?
    let nextToken: Swift.String?
}

extension ListReceivedGrantsForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Grant?].self, forKey: .grants)
        var grantsDecoded0:[LicenseManagerClientTypes.Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [LicenseManagerClientTypes.Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReceivedGrantsForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReceivedGrantsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arn0 in grantArns {
                try grantArnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListReceivedGrantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReceivedGrantsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranterAccountId
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsInputBody: Swift.Equatable {
    let grantArns: [Swift.String]?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReceivedGrantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[Swift.String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [Swift.String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedGrantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReceivedGrantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedGrantsOutput: Swift.Equatable {
    /// Received grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsOutputBody: Swift.Equatable {
    let grants: [LicenseManagerClientTypes.Grant]?
    let nextToken: Swift.String?
}

extension ListReceivedGrantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Grant?].self, forKey: .grants)
        var grantsDecoded0:[LicenseManagerClientTypes.Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [LicenseManagerClientTypes.Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReceivedGrantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReceivedLicensesForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListReceivedLicensesForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReceivedLicensesForOrganizationInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * Beneficiary
    ///
    /// * ProductSKU
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesForOrganizationInputBody: Swift.Equatable {
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReceivedLicensesForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedLicensesForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReceivedLicensesForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedLicensesForOrganizationOutput: Swift.Equatable {
    /// Lists the licenses the organization has received.
    public var licenses: [LicenseManagerClientTypes.GrantedLicense]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.GrantedLicense]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesForOrganizationOutputBody: Swift.Equatable {
    let licenses: [LicenseManagerClientTypes.GrantedLicense]?
    let nextToken: Swift.String?
}

extension ListReceivedLicensesForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.GrantedLicense?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.GrantedLicense]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.GrantedLicense]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReceivedLicensesForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReceivedLicensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arn0 in licenseArns {
                try licenseArnsContainer.encode(arn0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListReceivedLicensesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListReceivedLicensesInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * Status
    ///
    /// * Fingerprint
    ///
    /// * IssuerName
    ///
    /// * Beneficiary
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesInputBody: Swift.Equatable {
    let licenseArns: [Swift.String]?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReceivedLicensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[Swift.String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [Swift.String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedLicensesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReceivedLicensesOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedLicensesOutput: Swift.Equatable {
    /// Received license details.
    public var licenses: [LicenseManagerClientTypes.GrantedLicense]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.GrantedLicense]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesOutputBody: Swift.Equatable {
    let licenses: [LicenseManagerClientTypes.GrantedLicense]?
    let nextToken: Swift.String?
}

extension ListReceivedLicensesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.GrantedLicense?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.GrantedLicense]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.GrantedLicense]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReceivedLicensesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceInventoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilter0 in filters {
                try filtersContainer.encode(inventoryfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourceInventoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceInventoryInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * account_id - The ID of the Amazon Web Services account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * application_name - The name of the application. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * license_included - The type of license included. Logical operators are EQUALS | NOT_EQUALS. Possible values are sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
    ///
    /// * platform - The platform of the resource. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * resource_id - The ID of the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * tag: - The key/value combination of a tag assigned to the resource. Logical operators are EQUALS (single account) or EQUALS | NOT_EQUALS (cross account).
    public var filters: [LicenseManagerClientTypes.InventoryFilter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceInventoryInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [LicenseManagerClientTypes.InventoryFilter]?
}

extension ListResourceInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResourceInventoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceInventoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceInventoryList = output.resourceInventoryList
        } else {
            self.nextToken = nil
            self.resourceInventoryList = nil
        }
    }
}

public struct ListResourceInventoryOutput: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the resources.
    public var resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]?

    public init(
        nextToken: Swift.String? = nil,
        resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInventoryList = resourceInventoryList
    }
}

struct ListResourceInventoryOutputBody: Swift.Equatable {
    let resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]?
    let nextToken: Swift.String?
}

extension ListResourceInventoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceInventoryList = "ResourceInventoryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInventoryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ResourceInventory?].self, forKey: .resourceInventoryList)
        var resourceInventoryListDecoded0:[LicenseManagerClientTypes.ResourceInventory]? = nil
        if let resourceInventoryListContainer = resourceInventoryListContainer {
            resourceInventoryListDecoded0 = [LicenseManagerClientTypes.ResourceInventory]()
            for structure0 in resourceInventoryListContainer {
                if let structure0 = structure0 {
                    resourceInventoryListDecoded0?.append(structure0)
                }
            }
        }
        resourceInventoryList = resourceInventoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourceInventoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FailedDependency": return try await FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilterLimitExceeded": return try await FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Information about the tags.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [LicenseManagerClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTokensInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tokenIds = tokenIds {
            var tokenIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenIds)
            for string0 in tokenIds {
                try tokenIdsContainer.encode(string0)
            }
        }
    }
}

extension ListTokensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTokensInput: Swift.Equatable {
    /// Filters to scope the results. The following filter is supported:
    ///
    /// * LicenseArns
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Token IDs.
    public var tokenIds: [Swift.String]?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tokenIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tokenIds = tokenIds
    }
}

struct ListTokensInputBody: Swift.Equatable {
    let tokenIds: [Swift.String]?
    let filters: [LicenseManagerClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTokensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenIds)
        var tokenIdsDecoded0:[Swift.String]? = nil
        if let tokenIdsContainer = tokenIdsContainer {
            tokenIdsDecoded0 = [Swift.String]()
            for string0 in tokenIdsContainer {
                if let string0 = string0 {
                    tokenIdsDecoded0?.append(string0)
                }
            }
        }
        tokenIds = tokenIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTokensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTokensOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tokens = output.tokens
        } else {
            self.nextToken = nil
            self.tokens = nil
        }
    }
}

public struct ListTokensOutput: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Received token details.
    public var tokens: [LicenseManagerClientTypes.TokenData]?

    public init(
        nextToken: Swift.String? = nil,
        tokens: [LicenseManagerClientTypes.TokenData]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokens = tokens
    }
}

struct ListTokensOutputBody: Swift.Equatable {
    let tokens: [LicenseManagerClientTypes.TokenData]?
    let nextToken: Swift.String?
}

extension ListTokensOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tokens = "Tokens"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokensContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.TokenData?].self, forKey: .tokens)
        var tokensDecoded0:[LicenseManagerClientTypes.TokenData]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [LicenseManagerClientTypes.TokenData]()
            for structure0 in tokensContainer {
                if let structure0 = structure0 {
                    tokensDecoded0?.append(structure0)
                }
            }
        }
        tokens = tokensDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTokensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsageForLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUsageForLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsageForLicenseConfigurationInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * resourceArn - The ARN of the license configuration resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceType - The resource type (EC2_INSTANCE | EC2_HOST | EC2_AMI | SYSTEMS_MANAGER_MANAGED_INSTANCE). Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceAccount - The ID of the account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListUsageForLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsageForLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsageForLicenseConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationUsageList = output.licenseConfigurationUsageList
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationUsageList = nil
            self.nextToken = nil
        }
    }
}

public struct ListUsageForLicenseConfigurationOutput: Swift.Equatable {
    /// Information about the license configurations.
    public var licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationUsageList = licenseConfigurationUsageList
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationOutputBody: Swift.Equatable {
    let licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]?
    let nextToken: Swift.String?
}

extension ListUsageForLicenseConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationUsageList = "LicenseConfigurationUsageList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationUsageListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfigurationUsage?].self, forKey: .licenseConfigurationUsageList)
        var licenseConfigurationUsageListDecoded0:[LicenseManagerClientTypes.LicenseConfigurationUsage]? = nil
        if let licenseConfigurationUsageListContainer = licenseConfigurationUsageListContainer {
            licenseConfigurationUsageListDecoded0 = [LicenseManagerClientTypes.LicenseConfigurationUsage]()
            for structure0 in licenseConfigurationUsageListContainer {
                if let structure0 = structure0 {
                    licenseConfigurationUsageListDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationUsageList = licenseConfigurationUsageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsageForLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FilterLimitExceeded": return try await FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes.ManagedResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationCount = "AssociationCount"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationCount = self.associationCount {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationCount)
        associationCount = associationCountDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Summary information about a managed resource.
    public struct ManagedResourceSummary: Swift.Equatable {
        /// Number of resources associated with licenses.
        public var associationCount: Swift.Int?
        /// Type of resource associated with a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            associationCount: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationCount = associationCount
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.Metadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes key/value pairs.
    public struct Metadata: Swift.Equatable {
        /// The key name.
        public var name: Swift.String?
        /// The value.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NoEntitlementsAllowedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoEntitlementsAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are no entitlements found for this license, or the entitlement maximum count is reached.
public struct NoEntitlementsAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoEntitlementsAllowedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoEntitlementsAllowedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoEntitlementsAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.Options: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationOverrideBehavior = "ActivationOverrideBehavior"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationOverrideBehavior = self.activationOverrideBehavior {
            try encodeContainer.encode(activationOverrideBehavior.rawValue, forKey: .activationOverrideBehavior)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationOverrideBehaviorDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ActivationOverrideBehavior.self, forKey: .activationOverrideBehavior)
        activationOverrideBehavior = activationOverrideBehaviorDecoded
    }
}

extension LicenseManagerClientTypes {
    /// The options you can specify when you create a new version of a grant, such as activation override behavior. For more information, see [Granted licenses in License Manager](https://docs.aws.amazon.com/license-manager/latest/userguide/granted-licenses.html) in the License Manager User Guide.
    public struct Options: Swift.Equatable {
        /// An activation option for your grant that determines the behavior of activating a grant. Activation options can only be used with granted licenses sourced from the Amazon Web Services Marketplace. Additionally, the operation must specify the value of ACTIVE for the Status parameter.
        ///
        /// * As a license administrator, you can optionally specify an ActivationOverrideBehavior when activating a grant.
        ///
        /// * As a grantor, you can optionally specify an ActivationOverrideBehavior when you activate a grant for a grantee account in your organization.
        ///
        /// * As a grantee, if the grantor creating the distributed grant doesn’t specify an ActivationOverrideBehavior, you can optionally specify one when you are activating the grant.
        ///
        ///
        /// DISTRIBUTED_GRANTS_ONLY Use this value to activate a grant without replacing any member account’s active grants for the same product. ALL_GRANTS_PERMITTED_BY_ISSUER Use this value to activate a grant and disable other active grants in any member accounts for the same product. This action will also replace their previously activated grants with this activated grant.
        public var activationOverrideBehavior: LicenseManagerClientTypes.ActivationOverrideBehavior?

        public init(
            activationOverrideBehavior: LicenseManagerClientTypes.ActivationOverrideBehavior? = nil
        )
        {
            self.activationOverrideBehavior = activationOverrideBehavior
        }
    }

}

extension LicenseManagerClientTypes.OrganizationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableIntegration = "EnableIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableIntegration != false {
            try encodeContainer.encode(enableIntegration, forKey: .enableIntegration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableIntegrationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIntegration) ?? false
        enableIntegration = enableIntegrationDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Configuration information for Organizations.
    public struct OrganizationConfiguration: Swift.Equatable {
        /// Enables Organizations integration.
        /// This member is required.
        public var enableIntegration: Swift.Bool

        public init(
            enableIntegration: Swift.Bool = false
        )
        {
            self.enableIntegration = enableIntegration
        }
    }

}

extension LicenseManagerClientTypes.ProductInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productInformationFilterList = "ProductInformationFilterList"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterList = productInformationFilterList {
            var productInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterList)
            for productinformationfilter0 in productInformationFilterList {
                try productInformationFilterListContainer.encode(productinformationfilter0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let productInformationFilterListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformationFilter?].self, forKey: .productInformationFilterList)
        var productInformationFilterListDecoded0:[LicenseManagerClientTypes.ProductInformationFilter]? = nil
        if let productInformationFilterListContainer = productInformationFilterListContainer {
            productInformationFilterListDecoded0 = [LicenseManagerClientTypes.ProductInformationFilter]()
            for structure0 in productInformationFilterListContainer {
                if let structure0 = structure0 {
                    productInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        productInformationFilterList = productInformationFilterListDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Describes product information for a license configuration.
    public struct ProductInformation: Swift.Equatable {
        /// A Product information filter consists of a ProductInformationFilterComparator which is a logical operator, a ProductInformationFilterName which specifies the type of filter being declared, and a ProductInformationFilterValue that specifies the value to filter on. Accepted values for ProductInformationFilterName are listed here along with descriptions and valid options for ProductInformationFilterComparator. The following filters and are supported when the resource type is SSM_MANAGED:
        ///
        /// * Application Name - The name of the application. Logical operator is EQUALS.
        ///
        /// * Application Publisher - The publisher of the application. Logical operator is EQUALS.
        ///
        /// * Application Version - The version of the application. Logical operator is EQUALS.
        ///
        /// * Platform Name - The name of the platform. Logical operator is EQUALS.
        ///
        /// * Platform Type - The platform type. Logical operator is EQUALS.
        ///
        /// * Tag:key - The key of a tag attached to an Amazon Web Services resource you wish to exclude from automated discovery. Logical operator is NOT_EQUALS. The key for your tag must be appended to Tag: following the example: Tag:name-of-your-key. ProductInformationFilterValue is optional if you are not using values for the key.
        ///
        /// * AccountId - The 12-digit ID of an Amazon Web Services account you wish to exclude from automated discovery. Logical operator is NOT_EQUALS.
        ///
        /// * License Included - The type of license included. Logical operators are EQUALS and NOT_EQUALS. Possible values are: sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
        ///
        ///
        /// The following filters and logical operators are supported when the resource type is RDS:
        ///
        /// * Engine Edition - The edition of the database engine. Logical operator is EQUALS. Possible values are: oracle-ee | oracle-se | oracle-se1 | oracle-se2.
        ///
        /// * License Pack - The license pack. Logical operator is EQUALS. Possible values are: data guard | diagnostic pack sqlt | tuning pack sqlt | ols | olap.
        /// This member is required.
        public var productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]?
        /// Resource type. The possible values are SSM_MANAGED | RDS.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.productInformationFilterList = productInformationFilterList
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.ProductInformationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productInformationFilterComparator = "ProductInformationFilterComparator"
        case productInformationFilterName = "ProductInformationFilterName"
        case productInformationFilterValue = "ProductInformationFilterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterComparator = self.productInformationFilterComparator {
            try encodeContainer.encode(productInformationFilterComparator, forKey: .productInformationFilterComparator)
        }
        if let productInformationFilterName = self.productInformationFilterName {
            try encodeContainer.encode(productInformationFilterName, forKey: .productInformationFilterName)
        }
        if let productInformationFilterValue = productInformationFilterValue {
            var productInformationFilterValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterValue)
            for string0 in productInformationFilterValue {
                try productInformationFilterValueContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productInformationFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productInformationFilterName)
        productInformationFilterName = productInformationFilterNameDecoded
        let productInformationFilterValueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .productInformationFilterValue)
        var productInformationFilterValueDecoded0:[Swift.String]? = nil
        if let productInformationFilterValueContainer = productInformationFilterValueContainer {
            productInformationFilterValueDecoded0 = [Swift.String]()
            for string0 in productInformationFilterValueContainer {
                if let string0 = string0 {
                    productInformationFilterValueDecoded0?.append(string0)
                }
            }
        }
        productInformationFilterValue = productInformationFilterValueDecoded0
        let productInformationFilterComparatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productInformationFilterComparator)
        productInformationFilterComparator = productInformationFilterComparatorDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes product information filters.
    public struct ProductInformationFilter: Swift.Equatable {
        /// Logical operator.
        /// This member is required.
        public var productInformationFilterComparator: Swift.String?
        /// Filter name.
        /// This member is required.
        public var productInformationFilterName: Swift.String?
        /// Filter value.
        public var productInformationFilterValue: [Swift.String]?

        public init(
            productInformationFilterComparator: Swift.String? = nil,
            productInformationFilterName: Swift.String? = nil,
            productInformationFilterValue: [Swift.String]? = nil
        )
        {
            self.productInformationFilterComparator = productInformationFilterComparator
            self.productInformationFilterName = productInformationFilterName
            self.productInformationFilterValue = productInformationFilterValue
        }
    }

}

extension LicenseManagerClientTypes.ProvisionalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxTimeToLiveInMinutes = self.maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about a provisional configuration.
    public struct ProvisionalConfiguration: Swift.Equatable {
        /// Maximum time for the provisional configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init(
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

extension RateLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many requests have been submitted. Try again after a brief wait.
public struct RateLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RateLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RateLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.ReceivedMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case receivedStatus = "ReceivedStatus"
        case receivedStatusReason = "ReceivedStatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperation0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperation0.rawValue)
            }
        }
        if let receivedStatus = self.receivedStatus {
            try encodeContainer.encode(receivedStatus.rawValue, forKey: .receivedStatus)
        }
        if let receivedStatusReason = self.receivedStatusReason {
            try encodeContainer.encode(receivedStatusReason, forKey: .receivedStatusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let receivedStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReceivedStatus.self, forKey: .receivedStatus)
        receivedStatus = receivedStatusDecoded
        let receivedStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receivedStatusReason)
        receivedStatusReason = receivedStatusReasonDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for enum0 in allowedOperationsContainer {
                if let enum0 = enum0 {
                    allowedOperationsDecoded0?.append(enum0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Metadata associated with received licenses and grants.
    public struct ReceivedMetadata: Swift.Equatable {
        /// Allowed operations.
        public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// Received status.
        public var receivedStatus: LicenseManagerClientTypes.ReceivedStatus?
        /// Received status reason.
        public var receivedStatusReason: Swift.String?

        public init(
            allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            receivedStatus: LicenseManagerClientTypes.ReceivedStatus? = nil,
            receivedStatusReason: Swift.String? = nil
        )
        {
            self.allowedOperations = allowedOperations
            self.receivedStatus = receivedStatus
            self.receivedStatusReason = receivedStatusReason
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReceivedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceivedStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReceivedStatus(rawValue: rawValue) ?? ReceivedStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedirectException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.properties.location = locationHeaderValue
        } else {
            self.properties.location = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RedirectExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This is not the correct Region for the resource. Try again.
public struct RedirectException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var location: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RedirectException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        location: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.location = location
        self.properties.message = message
    }
}

struct RedirectExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RedirectExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RejectGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = self.grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

extension RejectGrantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init(
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct RejectGrantInputBody: Swift.Equatable {
    let grantArn: Swift.String?
}

extension RejectGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension RejectGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct RejectGrantOutput: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct RejectGrantOutputBody: Swift.Equatable {
    let grantArn: Swift.String?
    let status: LicenseManagerClientTypes.GrantStatus?
    let version: Swift.String?
}

extension RejectGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum RejectGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum RenewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case monthly
        case `none`
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [RenewType] {
            return [
                .monthly,
                .none,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "Monthly"
            case .none: return "None"
            case .weekly: return "Weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenewType(rawValue: rawValue) ?? RenewType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ReportContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for arn0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Details of the license configuration that this generator reports on.
    public struct ReportContext: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the license configuration that this generator reports on.
        /// This member is required.
        public var licenseConfigurationArns: [Swift.String]?

        public init(
            licenseConfigurationArns: [Swift.String]? = nil
        )
        {
            self.licenseConfigurationArns = licenseConfigurationArns
        }
    }

}

extension LicenseManagerClientTypes.ReportFrequency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case period
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let periodDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequencyType.self, forKey: .period)
        period = periodDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about how frequently reports are generated.
    public struct ReportFrequency: Swift.Equatable {
        /// Time period between each report. The period can be daily, weekly, or monthly.
        public var period: LicenseManagerClientTypes.ReportFrequencyType?
        /// Number of times within the frequency period that a report is generated. The only supported value is 1.
        public var value: Swift.Int?

        public init(
            period: LicenseManagerClientTypes.ReportFrequencyType? = nil,
            value: Swift.Int? = nil
        )
        {
            self.period = period
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReportFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequencyType] {
            return [
                .day,
                .month,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFrequencyType(rawValue: rawValue) ?? ReportFrequencyType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ReportGenerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case lastReportGenerationTime = "LastReportGenerationTime"
        case lastRunFailureReason = "LastRunFailureReason"
        case lastRunStatus = "LastRunStatus"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportCreatorAccount = "ReportCreatorAccount"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case reportType = "ReportType"
        case s3Location = "S3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastReportGenerationTime = self.lastReportGenerationTime {
            try encodeContainer.encode(lastReportGenerationTime, forKey: .lastReportGenerationTime)
        }
        if let lastRunFailureReason = self.lastRunFailureReason {
            try encodeContainer.encode(lastRunFailureReason, forKey: .lastRunFailureReason)
        }
        if let lastRunStatus = self.lastRunStatus {
            try encodeContainer.encode(lastRunStatus, forKey: .lastRunStatus)
        }
        if let licenseManagerReportGeneratorArn = self.licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = self.reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportCreatorAccount = self.reportCreatorAccount {
            try encodeContainer.encode(reportCreatorAccount, forKey: .reportCreatorAccount)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = self.reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let reportType = reportType {
            var reportTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportType)
            for reporttype0 in reportType {
                try reportTypeContainer.encode(reporttype0.rawValue)
            }
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let reportTypeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .reportType)
        var reportTypeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let reportTypeContainer = reportTypeContainer {
            reportTypeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for enum0 in reportTypeContainer {
                if let enum0 = enum0 {
                    reportTypeDecoded0?.append(enum0)
                }
            }
        }
        reportType = reportTypeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRunFailureReason)
        lastRunFailureReason = lastRunFailureReasonDecoded
        let lastReportGenerationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastReportGenerationTime)
        lastReportGenerationTime = lastReportGenerationTimeDecoded
        let reportCreatorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportCreatorAccount)
        reportCreatorAccount = reportCreatorAccountDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LicenseManagerClientTypes {
    /// Describe the details of a report generator.
    public struct ReportGenerator: Swift.Equatable {
        /// Time the report was created.
        public var createTime: Swift.String?
        /// Description of the report generator.
        public var description: Swift.String?
        /// Time the last report was generated at.
        public var lastReportGenerationTime: Swift.String?
        /// Failure message for the last report generation attempt.
        public var lastRunFailureReason: Swift.String?
        /// Status of the last report generation attempt.
        public var lastRunStatus: Swift.String?
        /// Amazon Resource Name (ARN) of the report generator.
        public var licenseManagerReportGeneratorArn: Swift.String?
        /// License configuration type for this generator.
        public var reportContext: LicenseManagerClientTypes.ReportContext?
        /// The Amazon Web Services account ID used to create the report generator.
        public var reportCreatorAccount: Swift.String?
        /// Details about how frequently reports are generated.
        public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
        /// Name of the report generator.
        public var reportGeneratorName: Swift.String?
        /// Type of reports that are generated.
        public var reportType: [LicenseManagerClientTypes.ReportType]?
        /// Details of the S3 bucket that report generator reports are published to.
        public var s3Location: LicenseManagerClientTypes.S3Location?
        /// Tags associated with the report generator.
        public var tags: [LicenseManagerClientTypes.Tag]?

        public init(
            createTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastReportGenerationTime: Swift.String? = nil,
            lastRunFailureReason: Swift.String? = nil,
            lastRunStatus: Swift.String? = nil,
            licenseManagerReportGeneratorArn: Swift.String? = nil,
            reportContext: LicenseManagerClientTypes.ReportContext? = nil,
            reportCreatorAccount: Swift.String? = nil,
            reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
            reportGeneratorName: Swift.String? = nil,
            reportType: [LicenseManagerClientTypes.ReportType]? = nil,
            s3Location: LicenseManagerClientTypes.S3Location? = nil,
            tags: [LicenseManagerClientTypes.Tag]? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.lastReportGenerationTime = lastReportGenerationTime
            self.lastRunFailureReason = lastRunFailureReason
            self.lastRunStatus = lastRunStatus
            self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
            self.reportContext = reportContext
            self.reportCreatorAccount = reportCreatorAccount
            self.reportFrequency = reportFrequency
            self.reportGeneratorName = reportGeneratorName
            self.reportType = reportType
            self.s3Location = s3Location
            self.tags = tags
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case licenseConfigurationSummaryReport
        case licenseConfigurationUsageReport
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .licenseConfigurationSummaryReport,
                .licenseConfigurationUsageReport,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .licenseConfigurationSummaryReport: return "LicenseConfigurationSummaryReport"
            case .licenseConfigurationUsageReport: return "LicenseConfigurationUsageReport"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ResourceInventory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case platformVersion = "PlatformVersion"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceOwningAccountId = "ResourceOwningAccountId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let platformVersion = self.platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceOwningAccountId = self.resourceOwningAccountId {
            try encodeContainer.encode(resourceOwningAccountId, forKey: .resourceOwningAccountId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let resourceOwningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwningAccountId)
        resourceOwningAccountId = resourceOwningAccountIdDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about a resource.
    public struct ResourceInventory: Swift.Equatable {
        /// Platform of the resource.
        public var platform: Swift.String?
        /// Platform version of the resource in the inventory.
        public var platformVersion: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the resource.
        public var resourceId: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwningAccountId: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            platform: Swift.String? = nil,
            platformVersion: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceOwningAccountId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.platform = platform
            self.platformVersion = platformVersion
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceOwningAccountId = resourceOwningAccountId
            self.resourceType = resourceType
        }
    }

}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResource.NotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2Ami
        case ec2Host
        case ec2Instance
        case rds
        case systemsManagerManagedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ec2Ami,
                .ec2Host,
                .ec2Instance,
                .rds,
                .systemsManagerManagedInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2Ami: return "EC2_AMI"
            case .ec2Host: return "EC2_HOST"
            case .ec2Instance: return "EC2_INSTANCE"
            case .rds: return "RDS"
            case .systemsManagerManagedInstance: return "SYSTEMS_MANAGER_MANAGED_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = self.keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details of the S3 bucket that report generator reports are published to.
    public struct S3Location: Swift.Equatable {
        /// Name of the S3 bucket reports are published to.
        public var bucket: Swift.String?
        /// Prefix of the S3 bucket reports are published to.
        public var keyPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
        }
    }

}

extension ServerInternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Details about a tag for a license configuration.
    public struct Tag: Swift.Equatable {
        /// Tag key.
        public var key: Swift.String?
        /// Tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [LicenseManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerClientTypes.TokenData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationTime = "ExpirationTime"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case status = "Status"
        case tokenId = "TokenId"
        case tokenProperties = "TokenProperties"
        case tokenType = "TokenType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationTime = self.expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let licenseArn = self.licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arn0 in roleArns {
                try roleArnsContainer.encode(arn0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tokenId = self.tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for string0 in tokenProperties {
                try tokenPropertiesContainer.encode(string0)
            }
        }
        if let tokenType = self.tokenType {
            try encodeContainer.encode(tokenType, forKey: .tokenType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension LicenseManagerClientTypes {
    /// Describes a token.
    public struct TokenData: Swift.Equatable {
        /// Token expiration time, in ISO8601-UTC format.
        public var expirationTime: Swift.String?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Amazon Resource Names (ARN) of the roles included in the token.
        public var roleArns: [Swift.String]?
        /// Token status. The possible values are AVAILABLE and DELETED.
        public var status: Swift.String?
        /// Token ID.
        public var tokenId: Swift.String?
        /// Data specified by the caller.
        public var tokenProperties: [Swift.String]?
        /// Type of token generated. The supported value is REFRESH_TOKEN.
        public var tokenType: Swift.String?

        public init(
            expirationTime: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            roleArns: [Swift.String]? = nil,
            status: Swift.String? = nil,
            tokenId: Swift.String? = nil,
            tokenProperties: [Swift.String]? = nil,
            tokenType: Swift.String? = nil
        )
        {
            self.expirationTime = expirationTime
            self.licenseArn = licenseArn
            self.roleArns = roleArns
            self.status = status
            self.tokenId = tokenId
            self.tokenProperties = tokenProperties
            self.tokenType = tokenType
        }
    }

}

extension LicenseManagerClientTypes {
    public enum TokenType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case refreshToken
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenType] {
            return [
                .refreshToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .refreshToken: return "REFRESH_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TokenType(rawValue: rawValue) ?? TokenType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedDigitalSignatureMethodException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedDigitalSignatureMethodExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The digital signature method is unsupported. Try your request again.
public struct UnsupportedDigitalSignatureMethodException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedDigitalSignatureMethodException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedDigitalSignatureMethodExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedDigitalSignatureMethodExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys identifying the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLicenseConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = self.disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationStatus = self.licenseConfigurationStatus {
            try encodeContainer.encode(licenseConfigurationStatus.rawValue, forKey: .licenseConfigurationStatus)
        }
        if let licenseCount = self.licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = self.licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for string0 in licenseRules {
                try licenseRulesContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformation0 in productInformationList {
                try productInformationListContainer.encode(productinformation0)
            }
        }
    }
}

extension UpdateLicenseConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLicenseConfigurationInput: Swift.Equatable {
    /// New description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// New status of the license configuration.
    public var licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus?
    /// New number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// New hard limit of the number of available licenses.
    public var licenseCountHardLimit: Swift.Bool?
    /// New license rule. The only rule that you can add after you create a license configuration is licenseAffinityToHost.
    public var licenseRules: [Swift.String]?
    /// New name of the license configuration.
    public var name: Swift.String?
    /// New product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?

    public init(
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationStatus = licenseConfigurationStatus
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
    }
}

struct UpdateLicenseConfigurationInputBody: Swift.Equatable {
    let licenseConfigurationArn: Swift.String?
    let licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus?
    let licenseRules: [Swift.String]?
    let licenseCount: Swift.Int?
    let licenseCountHardLimit: Swift.Bool?
    let name: Swift.String?
    let description: Swift.String?
    let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    let disassociateWhenNotFound: Swift.Bool?
}

extension UpdateLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let licenseConfigurationStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConfigurationStatus.self, forKey: .licenseConfigurationStatus)
        licenseConfigurationStatus = licenseConfigurationStatusDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

extension UpdateLicenseConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLicenseConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLicenseConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLicenseManagerReportGeneratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseManagerReportGeneratorArn = self.licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = self.reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = self.reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttype0 in type {
                try typeContainer.encode(reporttype0.rawValue)
            }
        }
    }
}

extension UpdateLicenseManagerReportGeneratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Amazon Resource Name (ARN) of the report generator to update.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?
    /// The report context.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Type of reports to generate. The following report types are supported:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        licenseManagerReportGeneratorArn: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.type = type
    }
}

struct UpdateLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    let licenseManagerReportGeneratorArn: Swift.String?
    let reportGeneratorName: Swift.String?
    let type: [LicenseManagerClientTypes.ReportType]?
    let reportContext: LicenseManagerClientTypes.ReportContext?
    let reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    let clientToken: Swift.String?
    let description: Swift.String?
}

extension UpdateLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .type)
        var typeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for enum0 in typeContainer {
                if let enum0 = enum0 {
                    typeDecoded0?.append(enum0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateLicenseManagerReportGeneratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLicenseManagerReportGeneratorOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceeded": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResource.NotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLicenseSpecificationsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addLicenseSpecifications = addLicenseSpecifications {
            var addLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addLicenseSpecifications)
            for licensespecification0 in addLicenseSpecifications {
                try addLicenseSpecificationsContainer.encode(licensespecification0)
            }
        }
        if let removeLicenseSpecifications = removeLicenseSpecifications {
            var removeLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeLicenseSpecifications)
            for licensespecification0 in removeLicenseSpecifications {
                try removeLicenseSpecificationsContainer.encode(licensespecification0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension UpdateLicenseSpecificationsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLicenseSpecificationsForResourceInput: Swift.Equatable {
    /// ARNs of the license configurations to add.
    public var addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// ARNs of the license configurations to remove.
    public var removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Amazon Resource Name (ARN) of the Amazon Web Services resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.addLicenseSpecifications = addLicenseSpecifications
        self.removeLicenseSpecifications = removeLicenseSpecifications
        self.resourceArn = resourceArn
    }
}

struct UpdateLicenseSpecificationsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    let removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
}

extension UpdateLicenseSpecificationsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let addLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .addLicenseSpecifications)
        var addLicenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let addLicenseSpecificationsContainer = addLicenseSpecificationsContainer {
            addLicenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in addLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    addLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        addLicenseSpecifications = addLicenseSpecificationsDecoded0
        let removeLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .removeLicenseSpecifications)
        var removeLicenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let removeLicenseSpecificationsContainer = removeLicenseSpecificationsContainer {
            removeLicenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in removeLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    removeLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        removeLicenseSpecifications = removeLicenseSpecificationsDecoded0
    }
}

extension UpdateLicenseSpecificationsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLicenseSpecificationsForResourceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLicenseSpecificationsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceState": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LicenseUsageFailure": return try await LicenseUsageException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableCrossAccountsDiscovery = self.enableCrossAccountsDiscovery {
            try encodeContainer.encode(enableCrossAccountsDiscovery, forKey: .enableCrossAccountsDiscovery)
        }
        if let organizationConfiguration = self.organizationConfiguration {
            try encodeContainer.encode(organizationConfiguration, forKey: .organizationConfiguration)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

extension UpdateServiceSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceSettingsInput: Swift.Equatable {
    /// Activates cross-account discovery.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Enables integration with Organizations for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.
    public var s3BucketArn: Swift.String?
    /// Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.
    public var snsTopicArn: Swift.String?

    public init(
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct UpdateServiceSettingsInputBody: Swift.Equatable {
    let s3BucketArn: Swift.String?
    let snsTopicArn: Swift.String?
    let organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    let enableCrossAccountsDiscovery: Swift.Bool?
}

extension UpdateServiceSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
    }
}

extension UpdateServiceSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateServiceSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServiceSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ServiceAccessDenied": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AuthorizationFailure": return try await AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueProvided": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RateLimitExceeded": return try await RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
