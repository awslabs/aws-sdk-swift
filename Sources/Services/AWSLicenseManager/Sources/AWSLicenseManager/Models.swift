//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Access to resource denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Web Services user account does not have permission to perform the action. Check the IAM policy associated with this account.
public struct AuthorizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationFailure" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueProvided" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Too many requests have been submitted. Try again after a brief wait.
public struct RateLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RateLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AcceptGrantInput {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init(
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

extension LicenseManagerClientTypes {

    public enum GrantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingDelete
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [GrantStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingDelete,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingDelete: return "PENDING_DELETE"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AcceptGrantOutput {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

extension LicenseManagerClientTypes {

    public enum ActivationOverrideBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allGrantsPermittedByIssuer
        case distributedGrantsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationOverrideBehavior] {
            return [
                .allGrantsPermittedByIssuer,
                .distributedGrantsOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allGrantsPermittedByIssuer: return "ALL_GRANTS_PERMITTED_BY_ISSUER"
            case .distributedGrantsOnly: return "DISTRIBUTED_GRANTS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {

    public enum AllowedOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case checkoutBorrowLicense
        case checkoutLicense
        case checkInLicense
        case createGrant
        case createToken
        case extendConsumptionLicense
        case listPurchasedLicenses
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowedOperation] {
            return [
                .checkoutBorrowLicense,
                .checkoutLicense,
                .checkInLicense,
                .createGrant,
                .createToken,
                .extendConsumptionLicense,
                .listPurchasedLicenses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .checkoutBorrowLicense: return "CheckoutBorrowLicense"
            case .checkoutLicense: return "CheckoutLicense"
            case .checkInLicense: return "CheckInLicense"
            case .createGrant: return "CreateGrant"
            case .createToken: return "CreateToken"
            case .extendConsumptionLicense: return "ExtendConsumptionLicense"
            case .listPurchasedLicenses: return "ListPurchasedLicenses"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Describes automated discovery.
    public struct AutomatedDiscoveryInformation {
        /// Time that automated discovery last ran.
        public var lastRunTime: Foundation.Date?

        public init(
            lastRunTime: Foundation.Date? = nil
        )
        {
            self.lastRunTime = lastRunTime
        }
    }

}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResource.NotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CheckInLicenseInput {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init(
        beneficiary: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

public struct CheckInLicenseOutput {

    public init() { }
}

/// The entitlement is not allowed.
public struct EntitlementNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitlementNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There are no entitlements found for this license, or the entitlement maximum count is reached.
public struct NoEntitlementsAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoEntitlementsAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This is not the correct Region for the resource. Try again.
public struct RedirectException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var location: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RedirectException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        location: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.location = location
        self.properties.message = message
    }
}

/// The digital signature method is unsupported. Try your request again.
public struct UnsupportedDigitalSignatureMethodException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedDigitalSignatureMethodException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LicenseManagerClientTypes {
    /// Describes key/value pairs.
    public struct Metadata {
        /// The key name.
        public var name: Swift.String?
        /// The value.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {

    public enum DigitalSignatureMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jwtPs384
        case sdkUnknown(Swift.String)

        public static var allCases: [DigitalSignatureMethod] {
            return [
                .jwtPs384
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jwtPs384: return "JWT_PS384"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {

    public enum EntitlementDataUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementDataUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Data associated with an entitlement resource.
    public struct EntitlementData {
        /// Entitlement data name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement data unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?
        /// Entitlement data value.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.unit = unit
            self.value = value
        }
    }

}

public struct CheckoutBorrowLicenseInput {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Digital signature method. The possible value is JSON Web Signature (JWS) algorithm PS384. For more information, see [RFC 7518 Digital Signature with RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5).
    /// This member is required.
    public var digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod?
    /// License entitlements. Partial checkouts are not supported.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Amazon Resource Name (ARN) of the license. The license must use the borrow consumption configuration.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?

    public init(
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        clientToken: Swift.String? = nil,
        digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        licenseArn: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.clientToken = clientToken
        self.digitalSignatureMethod = digitalSignatureMethod
        self.entitlements = entitlements
        self.licenseArn = licenseArn
        self.nodeId = nodeId
    }
}

public struct CheckoutBorrowLicenseOutput {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init(
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

extension LicenseManagerClientTypes {

    public enum CheckoutType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case perpetual
        case provisional
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckoutType] {
            return [
                .perpetual,
                .provisional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .perpetual: return "PERPETUAL"
            case .provisional: return "PROVISIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckoutLicenseInput {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// Checkout type.
    /// This member is required.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Key fingerprint identifying the license.
    /// This member is required.
    public var keyFingerprint: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?

    public init(
        beneficiary: Swift.String? = nil,
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        clientToken: Swift.String? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        keyFingerprint: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        productSKU: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.checkoutType = checkoutType
        self.clientToken = clientToken
        self.entitlements = entitlements
        self.keyFingerprint = keyFingerprint
        self.nodeId = nodeId
        self.productSKU = productSKU
    }
}

public struct CheckoutLicenseOutput {
    /// Checkout type.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the checkout license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init(
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutType = checkoutType
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

public struct CreateGrantInput {
    /// Allowed operations for the grant.
    /// This member is required.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Grant name.
    /// This member is required.
    public var grantName: Swift.String?
    /// Home Region of the grant.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// The grant principals. You can specify one of the following as an Amazon Resource Name (ARN):
    ///
    /// * An Amazon Web Services account, which includes only the account specified.
    ///
    ///
    ///
    ///
    /// * An organizational unit (OU), which includes all accounts in the OU.
    ///
    ///
    ///
    ///
    /// * An organization, which will include all accounts across your organization.
    /// This member is required.
    public var principals: [Swift.String]?

    public init(
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantName: Swift.String? = nil,
        homeRegion: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantName = grantName
        self.homeRegion = homeRegion
        self.licenseArn = licenseArn
        self.principals = principals
    }
}

public struct CreateGrantOutput {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

extension LicenseManagerClientTypes {
    /// The options you can specify when you create a new version of a grant, such as activation override behavior. For more information, see [Granted licenses in License Manager](https://docs.aws.amazon.com/license-manager/latest/userguide/granted-licenses.html) in the License Manager User Guide.
    public struct Options {
        /// An activation option for your grant that determines the behavior of activating a grant. Activation options can only be used with granted licenses sourced from the Amazon Web Services Marketplace. Additionally, the operation must specify the value of ACTIVE for the Status parameter.
        ///
        /// * As a license administrator, you can optionally specify an ActivationOverrideBehavior when activating a grant.
        ///
        /// * As a grantor, you can optionally specify an ActivationOverrideBehavior when you activate a grant for a grantee account in your organization.
        ///
        /// * As a grantee, if the grantor creating the distributed grant doesn’t specify an ActivationOverrideBehavior, you can optionally specify one when you are activating the grant.
        ///
        ///
        /// DISTRIBUTED_GRANTS_ONLY Use this value to activate a grant without replacing any member account’s active grants for the same product. ALL_GRANTS_PERMITTED_BY_ISSUER Use this value to activate a grant and disable other active grants in any member accounts for the same product. This action will also replace their previously activated grants with this activated grant.
        public var activationOverrideBehavior: LicenseManagerClientTypes.ActivationOverrideBehavior?

        public init(
            activationOverrideBehavior: LicenseManagerClientTypes.ActivationOverrideBehavior? = nil
        )
        {
            self.activationOverrideBehavior = activationOverrideBehavior
        }
    }

}

public struct CreateGrantVersionInput {
    /// Allowed operations for the grant.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant name.
    public var grantName: Swift.String?
    /// The options specified for the grant.
    public var options: LicenseManagerClientTypes.Options?
    /// Current version of the grant.
    public var sourceVersion: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant status reason.
    public var statusReason: Swift.String?

    public init(
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantArn: Swift.String? = nil,
        grantName: Swift.String? = nil,
        options: LicenseManagerClientTypes.Options? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantArn = grantArn
        self.grantName = grantName
        self.options = options
        self.sourceVersion = sourceVersion
        self.status = status
        self.statusReason = statusReason
    }
}

public struct CreateGrantVersionOutput {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// New version of the grant.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

extension LicenseManagerClientTypes {
    /// Details about a borrow configuration.
    public struct BorrowConfiguration {
        /// Indicates whether early check-ins are allowed.
        /// This member is required.
        public var allowEarlyCheckIn: Swift.Bool?
        /// Maximum time for the borrow configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init(
            allowEarlyCheckIn: Swift.Bool? = nil,
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.allowEarlyCheckIn = allowEarlyCheckIn
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

extension LicenseManagerClientTypes {
    /// Details about a provisional configuration.
    public struct ProvisionalConfiguration {
        /// Maximum time for the provisional configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init(
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

extension LicenseManagerClientTypes {

    public enum RenewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case monthly
        case `none`
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [RenewType] {
            return [
                .monthly,
                .none,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "Monthly"
            case .none: return "None"
            case .weekly: return "Weekly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Details about a consumption configuration.
    public struct ConsumptionConfiguration {
        /// Details about a borrow configuration.
        public var borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration?
        /// Details about a provisional configuration.
        public var provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration?
        /// Renewal frequency.
        public var renewType: LicenseManagerClientTypes.RenewType?

        public init(
            borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration? = nil,
            provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration? = nil,
            renewType: LicenseManagerClientTypes.RenewType? = nil
        )
        {
            self.borrowConfiguration = borrowConfiguration
            self.provisionalConfiguration = provisionalConfiguration
            self.renewType = renewType
        }
    }

}

extension LicenseManagerClientTypes {

    public enum EntitlementUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Describes a resource entitled for use with a license.
    public struct Entitlement {
        /// Indicates whether check-ins are allowed.
        public var allowCheckIn: Swift.Bool?
        /// Maximum entitlement count. Use if the unit is not None.
        public var maxCount: Swift.Int?
        /// Entitlement name.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether overages are allowed.
        public var overage: Swift.Bool?
        /// Entitlement unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementUnit?
        /// Entitlement resource. Use only if the unit is None.
        public var value: Swift.String?

        public init(
            allowCheckIn: Swift.Bool? = nil,
            maxCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            overage: Swift.Bool? = nil,
            unit: LicenseManagerClientTypes.EntitlementUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowCheckIn = allowCheckIn
            self.maxCount = maxCount
            self.name = name
            self.overage = overage
            self.unit = unit
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    /// Details about the issuer of a license.
    public struct Issuer {
        /// Issuer name.
        /// This member is required.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init(
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes {
    /// Describes a time range, in ISO8601-UTC format.
    public struct DatetimeRange {
        /// Start of the time range.
        /// This member is required.
        public var begin: Swift.String?
        /// End of the time range.
        public var end: Swift.String?

        public init(
            begin: Swift.String? = nil,
            end: Swift.String? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

public struct CreateLicenseInput {
    /// License beneficiary.
    /// This member is required.
    public var beneficiary: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region for the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init(
        beneficiary: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        productSKU: Swift.String? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.beneficiary = beneficiary
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.validity = validity
    }
}

extension LicenseManagerClientTypes {

    public enum LicenseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deactivated
        case deleted
        case expired
        case pendingAvailable
        case pendingDelete
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseStatus] {
            return [
                .available,
                .deactivated,
                .deleted,
                .expired,
                .pendingAvailable,
                .pendingDelete,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deactivated: return "DEACTIVATED"
            case .deleted: return "DELETED"
            case .expired: return "EXPIRED"
            case .pendingAvailable: return "PENDING_AVAILABLE"
            case .pendingDelete: return "PENDING_DELETE"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLicenseOutput {
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// License version.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

extension LicenseManagerClientTypes {

    public enum LicenseCountingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case core
        case instance
        case socket
        case vcpu
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseCountingType] {
            return [
                .core,
                .instance,
                .socket,
                .vcpu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .core: return "Core"
            case .instance: return "Instance"
            case .socket: return "Socket"
            case .vcpu: return "vCPU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Describes product information filters.
    public struct ProductInformationFilter {
        /// Logical operator.
        /// This member is required.
        public var productInformationFilterComparator: Swift.String?
        /// Filter name.
        /// This member is required.
        public var productInformationFilterName: Swift.String?
        /// Filter value.
        public var productInformationFilterValue: [Swift.String]?

        public init(
            productInformationFilterComparator: Swift.String? = nil,
            productInformationFilterName: Swift.String? = nil,
            productInformationFilterValue: [Swift.String]? = nil
        )
        {
            self.productInformationFilterComparator = productInformationFilterComparator
            self.productInformationFilterName = productInformationFilterName
            self.productInformationFilterValue = productInformationFilterValue
        }
    }

}

extension LicenseManagerClientTypes {
    /// Describes product information for a license configuration.
    public struct ProductInformation {
        /// A Product information filter consists of a ProductInformationFilterComparator which is a logical operator, a ProductInformationFilterName which specifies the type of filter being declared, and a ProductInformationFilterValue that specifies the value to filter on. Accepted values for ProductInformationFilterName are listed here along with descriptions and valid options for ProductInformationFilterComparator. The following filters and are supported when the resource type is SSM_MANAGED:
        ///
        /// * Application Name - The name of the application. Logical operator is EQUALS.
        ///
        /// * Application Publisher - The publisher of the application. Logical operator is EQUALS.
        ///
        /// * Application Version - The version of the application. Logical operator is EQUALS.
        ///
        /// * Platform Name - The name of the platform. Logical operator is EQUALS.
        ///
        /// * Platform Type - The platform type. Logical operator is EQUALS.
        ///
        /// * Tag:key - The key of a tag attached to an Amazon Web Services resource you wish to exclude from automated discovery. Logical operator is NOT_EQUALS. The key for your tag must be appended to Tag: following the example: Tag:name-of-your-key. ProductInformationFilterValue is optional if you are not using values for the key.
        ///
        /// * AccountId - The 12-digit ID of an Amazon Web Services account you wish to exclude from automated discovery. Logical operator is NOT_EQUALS.
        ///
        /// * License Included - The type of license included. Logical operators are EQUALS and NOT_EQUALS. Possible values are: sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
        ///
        ///
        /// The following filters and logical operators are supported when the resource type is RDS:
        ///
        /// * Engine Edition - The edition of the database engine. Logical operator is EQUALS. Possible values are: oracle-ee | oracle-se | oracle-se1 | oracle-se2.
        ///
        /// * License Pack - The license pack. Logical operator is EQUALS. Possible values are: data guard | diagnostic pack sqlt | tuning pack sqlt | ols | olap.
        /// This member is required.
        public var productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]?
        /// Resource type. The possible values are SSM_MANAGED | RDS.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.productInformationFilterList = productInformationFilterList
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes {
    /// Details about a tag for a license configuration.
    public struct Tag {
        /// Tag key.
        public var key: Swift.String?
        /// Tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateLicenseConfigurationInput {
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension used to track the license inventory.
    /// This member is required.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.
    ///
    /// * Cores dimension: allowedTenancy | licenseAffinityToHost | maximumCores | minimumCores
    ///
    /// * Instances dimension: allowedTenancy | maximumCores | minimumCores | maximumSockets | minimumSockets | maximumVcpus | minimumVcpus
    ///
    /// * Sockets dimension: allowedTenancy | licenseAffinityToHost | maximumSockets | minimumSockets
    ///
    /// * vCPUs dimension: allowedTenancy | honorVcpuOptimization | maximumVcpus | minimumVcpus
    ///
    ///
    /// The unit for licenseAffinityToHost is days and the range is 1 to 180. The possible values for allowedTenancy are EC2-Default, EC2-DedicatedHost, and EC2-DedicatedInstance. The possible values for honorVcpuOptimization are True and False.
    public var licenseRules: [Swift.String]?
    /// Name of the license configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// Tags to add to the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
        self.tags = tags
    }
}

public struct CreateLicenseConfigurationOutput {
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionContext {
        /// The Usage operation value that corresponds to the license type you are converting your resource from. For more information about which platforms correspond to which usage operation values see [Sample data: usage operation by platform ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html#billing-info)
        public var usageOperation: Swift.String?

        public init(
            usageOperation: Swift.String? = nil
        )
        {
            self.usageOperation = usageOperation
        }
    }

}

public struct CreateLicenseConversionTaskForResourceInput {
    /// Information that identifies the license type you are converting to. For the structure of the destination license, see [Convert a license type using the CLI ](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Amazon Resource Name (ARN) of the resource you are converting the license type for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information that identifies the license type you are converting from. For the structure of the source license, see [Convert a license type using the CLI ](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?

    public init(
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
    }
}

public struct CreateLicenseConversionTaskForResourceOutput {
    /// The ID of the created license type conversion task.
    public var licenseConversionTaskId: Swift.String?

    public init(
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

extension LicenseManagerClientTypes {
    /// Details of the license configuration that this generator reports on.
    public struct ReportContext {
        /// Amazon Resource Name (ARN) of the license configuration that this generator reports on.
        /// This member is required.
        public var licenseConfigurationArns: [Swift.String]?

        public init(
            licenseConfigurationArns: [Swift.String]? = nil
        )
        {
            self.licenseConfigurationArns = licenseConfigurationArns
        }
    }

}

extension LicenseManagerClientTypes {

    public enum ReportFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequencyType] {
            return [
                .day,
                .month,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Details about how frequently reports are generated.
    public struct ReportFrequency {
        /// Time period between each report. The period can be daily, weekly, or monthly.
        public var period: LicenseManagerClientTypes.ReportFrequencyType?
        /// Number of times within the frequency period that a report is generated. The only supported value is 1.
        public var value: Swift.Int?

        public init(
            period: LicenseManagerClientTypes.ReportFrequencyType? = nil,
            value: Swift.Int? = nil
        )
        {
            self.period = period
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {

    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case licenseConfigurationSummaryReport
        case licenseConfigurationUsageReport
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .licenseConfigurationSummaryReport,
                .licenseConfigurationUsageReport
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .licenseConfigurationSummaryReport: return "LicenseConfigurationSummaryReport"
            case .licenseConfigurationUsageReport: return "LicenseConfigurationUsageReport"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLicenseManagerReportGeneratorInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Defines the type of license configuration the report generator tracks.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated. Reports can be generated daily, monthly, or weekly.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Tags to add to the report generator.
    public var tags: [LicenseManagerClientTypes.Tag]?
    /// Type of reports to generate. The following report types an be generated:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.tags = tags
        self.type = type
    }
}

public struct CreateLicenseManagerReportGeneratorOutput {
    /// The Amazon Resource Name (ARN) of the new report generator.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

public struct CreateLicenseVersionInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region of the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Current version of the license.
    public var sourceVersion: Swift.String?
    /// License status.
    /// This member is required.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init(
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseArn: Swift.String? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.sourceVersion = sourceVersion
        self.status = status
        self.validity = validity
    }
}

public struct CreateLicenseVersionOutput {
    /// License ARN.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// New version of the license.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

public struct CreateTokenInput {
    /// Idempotency token, valid for 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Token expiration, in days, counted from token creation. The default is 365 days.
    public var expirationInDays: Swift.Int?
    /// Amazon Resource Name (ARN) of the license. The ARN is mapped to the aud claim of the JWT token.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Amazon Resource Name (ARN) of the IAM roles to embed in the token. License Manager does not check whether the roles are in use.
    public var roleArns: [Swift.String]?
    /// Data specified by the caller to be included in the JWT token. The data is mapped to the amr claim of the JWT token.
    public var tokenProperties: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        expirationInDays: Swift.Int? = nil,
        licenseArn: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInDays = expirationInDays
        self.licenseArn = licenseArn
        self.roleArns = roleArns
        self.tokenProperties = tokenProperties
    }
}

extension LicenseManagerClientTypes {

    public enum TokenType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case refreshToken
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenType] {
            return [
                .refreshToken
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .refreshToken: return "REFRESH_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTokenOutput {
    /// Refresh token, encoded as a JWT token.
    public var token: Swift.String?
    /// Token ID.
    public var tokenId: Swift.String?
    /// Token type.
    public var tokenType: LicenseManagerClientTypes.TokenType?

    public init(
        token: Swift.String? = nil,
        tokenId: Swift.String? = nil,
        tokenType: LicenseManagerClientTypes.TokenType? = nil
    )
    {
        self.token = token
        self.tokenId = tokenId
        self.tokenType = tokenType
    }
}

public struct DeleteGrantInput {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// The Status reason for the delete request.
    public var statusReason: Swift.String?
    /// Current version of the grant.
    /// This member is required.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        statusReason: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.statusReason = statusReason
        self.version = version
    }
}

public struct DeleteGrantOutput {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

public struct DeleteLicenseInput {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Current version of the license.
    /// This member is required.
    public var sourceVersion: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.sourceVersion = sourceVersion
    }
}

extension LicenseManagerClientTypes {

    public enum LicenseDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case pendingDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseDeletionStatus] {
            return [
                .deleted,
                .pendingDelete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .pendingDelete: return "PENDING_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteLicenseOutput {
    /// Date when the license is deleted.
    public var deletionDate: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseDeletionStatus?

    public init(
        deletionDate: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseDeletionStatus? = nil
    )
    {
        self.deletionDate = deletionDate
        self.status = status
    }
}

public struct DeleteLicenseConfigurationInput {
    /// ID of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

public struct DeleteLicenseConfigurationOutput {

    public init() { }
}

public struct DeleteLicenseManagerReportGeneratorInput {
    /// Amazon Resource Name (ARN) of the report generator to be deleted.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

public struct DeleteLicenseManagerReportGeneratorOutput {

    public init() { }
}

public struct DeleteTokenInput {
    /// Token ID.
    /// This member is required.
    public var tokenId: Swift.String?

    public init(
        tokenId: Swift.String? = nil
    )
    {
        self.tokenId = tokenId
    }
}

public struct DeleteTokenOutput {

    public init() { }
}

public struct ExtendLicenseConsumptionInput {
    /// Checks whether you have the required permissions for the action, without actually making the request. Provides an error response if you do not have the required permissions.
    public var dryRun: Swift.Bool?
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init(
        dryRun: Swift.Bool? = false,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

public struct ExtendLicenseConsumptionOutput {
    /// Date and time at which the license consumption expires.
    public var expiration: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?

    public init(
        expiration: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.expiration = expiration
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

public struct GetAccessTokenInput {
    /// Refresh token, encoded as a JWT token.
    /// This member is required.
    public var token: Swift.String?
    /// Token properties to validate against those present in the JWT token.
    public var tokenProperties: [Swift.String]?

    public init(
        token: Swift.String? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.token = token
        self.tokenProperties = tokenProperties
    }
}

public struct GetAccessTokenOutput {
    /// Temporary access token.
    public var accessToken: Swift.String?

    public init(
        accessToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

public struct GetGrantInput {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.version = version
    }
}

extension LicenseManagerClientTypes {
    /// Describes a grant.
    public struct Grant {
        /// Amazon Resource Name (ARN) of the grant.
        /// This member is required.
        public var grantArn: Swift.String?
        /// Grant name.
        /// This member is required.
        public var grantName: Swift.String?
        /// Grant status.
        /// This member is required.
        public var grantStatus: LicenseManagerClientTypes.GrantStatus?
        /// Granted operations.
        /// This member is required.
        public var grantedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// The grantee principal ARN.
        /// This member is required.
        public var granteePrincipalArn: Swift.String?
        /// Home Region of the grant.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// License ARN.
        /// This member is required.
        public var licenseArn: Swift.String?
        /// The options specified for the grant.
        public var options: LicenseManagerClientTypes.Options?
        /// Parent ARN.
        /// This member is required.
        public var parentArn: Swift.String?
        /// Grant status reason.
        public var statusReason: Swift.String?
        /// Grant version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            grantArn: Swift.String? = nil,
            grantName: Swift.String? = nil,
            grantStatus: LicenseManagerClientTypes.GrantStatus? = nil,
            grantedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            granteePrincipalArn: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            options: LicenseManagerClientTypes.Options? = nil,
            parentArn: Swift.String? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.grantArn = grantArn
            self.grantName = grantName
            self.grantStatus = grantStatus
            self.grantedOperations = grantedOperations
            self.granteePrincipalArn = granteePrincipalArn
            self.homeRegion = homeRegion
            self.licenseArn = licenseArn
            self.options = options
            self.parentArn = parentArn
            self.statusReason = statusReason
            self.version = version
        }
    }

}

public struct GetGrantOutput {
    /// Grant details.
    public var grant: LicenseManagerClientTypes.Grant?

    public init(
        grant: LicenseManagerClientTypes.Grant? = nil
    )
    {
        self.grant = grant
    }
}

public struct GetLicenseInput {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// License version.
    public var version: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.version = version
    }
}

extension LicenseManagerClientTypes {
    /// Details associated with the issuer of a license.
    public struct IssuerDetails {
        /// Issuer key fingerprint.
        public var keyFingerprint: Swift.String?
        /// Issuer name.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init(
            keyFingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.keyFingerprint = keyFingerprint
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes {
    /// Software license that is managed in License Manager.
    public struct License {
        /// License beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// License creation time.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the license.
        public var homeRegion: Swift.String?
        /// License issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// License metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// License status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// License version.
        public var version: Swift.String?

        public init(
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

public struct GetLicenseOutput {
    /// License details.
    public var license: LicenseManagerClientTypes.License?

    public init(
        license: LicenseManagerClientTypes.License? = nil
    )
    {
        self.license = license
    }
}

public struct GetLicenseConfigurationInput {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

extension LicenseManagerClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2Ami
        case ec2Host
        case ec2Instance
        case rds
        case systemsManagerManagedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ec2Ami,
                .ec2Host,
                .ec2Instance,
                .rds,
                .systemsManagerManagedInstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2Ami: return "EC2_AMI"
            case .ec2Host: return "EC2_HOST"
            case .ec2Instance: return "EC2_INSTANCE"
            case .rds: return "RDS"
            case .systemsManagerManagedInstance: return "SYSTEMS_MANAGER_MANAGED_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Details about license consumption.
    public struct ConsumedLicenseSummary {
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Resource type of the resource consuming a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            consumedLicenses: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.consumedLicenses = consumedLicenses
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes {
    /// Summary information about a managed resource.
    public struct ManagedResourceSummary {
        /// Number of resources associated with licenses.
        public var associationCount: Swift.Int?
        /// Type of resource associated with a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            associationCount: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationCount = associationCount
            self.resourceType = resourceType
        }
    }

}

public struct GetLicenseConfigurationOutput {
    /// Automated discovery information.
    public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
    /// Summaries of the licenses consumed by resources.
    public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
    /// Number of licenses assigned to resources.
    public var consumedLicenses: Swift.Int?
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?
    /// Unique ID for the license configuration.
    public var licenseConfigurationId: Swift.String?
    /// Number of available licenses.
    public var licenseCount: Swift.Int?
    /// Sets the number of available licenses as a hard limit.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension for which the licenses are counted.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules.
    public var licenseRules: [Swift.String]?
    /// Summaries of the managed resources.
    public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
    /// Name of the license configuration.
    public var name: Swift.String?
    /// Account ID of the owner of the license configuration.
    public var ownerAccountId: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// License configuration status.
    public var status: Swift.String?
    /// Tags for the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
        consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
        consumedLicenses: Swift.Int? = nil,
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationId: Swift.String? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        status: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.automatedDiscoveryInformation = automatedDiscoveryInformation
        self.consumedLicenseSummaryList = consumedLicenseSummaryList
        self.consumedLicenses = consumedLicenses
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationId = licenseConfigurationId
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.managedResourceSummaryList = managedResourceSummaryList
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.productInformationList = productInformationList
        self.status = status
        self.tags = tags
    }
}

public struct GetLicenseConversionTaskInput {
    /// ID of the license type conversion task to retrieve information on.
    /// This member is required.
    public var licenseConversionTaskId: Swift.String?

    public init(
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

extension LicenseManagerClientTypes {

    public enum LicenseConversionTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConversionTaskStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetLicenseConversionTaskOutput {
    /// Information about the license type converted to.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was completed.
    public var endTime: Foundation.Date?
    /// ID of the license type conversion task.
    public var licenseConversionTaskId: Swift.String?
    /// Amount of time to complete the license type conversion.
    public var licenseConversionTime: Foundation.Date?
    /// Amazon Resource Names (ARN) of the resources the license conversion task is associated with.
    public var resourceArn: Swift.String?
    /// Information about the license type converted from.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was started .
    public var startTime: Foundation.Date?
    /// Status of the license type conversion task.
    public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
    /// The status message for the conversion task.
    public var statusMessage: Swift.String?

    public init(
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        endTime: Foundation.Date? = nil,
        licenseConversionTaskId: Swift.String? = nil,
        licenseConversionTime: Foundation.Date? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        startTime: Foundation.Date? = nil,
        status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.endTime = endTime
        self.licenseConversionTaskId = licenseConversionTaskId
        self.licenseConversionTime = licenseConversionTime
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct GetLicenseManagerReportGeneratorInput {
    /// Amazon Resource Name (ARN) of the report generator.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init(
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

extension LicenseManagerClientTypes {
    /// Details of the S3 bucket that report generator reports are published to.
    public struct S3Location {
        /// Name of the S3 bucket reports are published to.
        public var bucket: Swift.String?
        /// Prefix of the S3 bucket reports are published to.
        public var keyPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
        }
    }

}

extension LicenseManagerClientTypes {
    /// Describe the details of a report generator.
    public struct ReportGenerator {
        /// Time the report was created.
        public var createTime: Swift.String?
        /// Description of the report generator.
        public var description: Swift.String?
        /// Time the last report was generated at.
        public var lastReportGenerationTime: Swift.String?
        /// Failure message for the last report generation attempt.
        public var lastRunFailureReason: Swift.String?
        /// Status of the last report generation attempt.
        public var lastRunStatus: Swift.String?
        /// Amazon Resource Name (ARN) of the report generator.
        public var licenseManagerReportGeneratorArn: Swift.String?
        /// License configuration type for this generator.
        public var reportContext: LicenseManagerClientTypes.ReportContext?
        /// The Amazon Web Services account ID used to create the report generator.
        public var reportCreatorAccount: Swift.String?
        /// Details about how frequently reports are generated.
        public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
        /// Name of the report generator.
        public var reportGeneratorName: Swift.String?
        /// Type of reports that are generated.
        public var reportType: [LicenseManagerClientTypes.ReportType]?
        /// Details of the S3 bucket that report generator reports are published to.
        public var s3Location: LicenseManagerClientTypes.S3Location?
        /// Tags associated with the report generator.
        public var tags: [LicenseManagerClientTypes.Tag]?

        public init(
            createTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastReportGenerationTime: Swift.String? = nil,
            lastRunFailureReason: Swift.String? = nil,
            lastRunStatus: Swift.String? = nil,
            licenseManagerReportGeneratorArn: Swift.String? = nil,
            reportContext: LicenseManagerClientTypes.ReportContext? = nil,
            reportCreatorAccount: Swift.String? = nil,
            reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
            reportGeneratorName: Swift.String? = nil,
            reportType: [LicenseManagerClientTypes.ReportType]? = nil,
            s3Location: LicenseManagerClientTypes.S3Location? = nil,
            tags: [LicenseManagerClientTypes.Tag]? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.lastReportGenerationTime = lastReportGenerationTime
            self.lastRunFailureReason = lastRunFailureReason
            self.lastRunStatus = lastRunStatus
            self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
            self.reportContext = reportContext
            self.reportCreatorAccount = reportCreatorAccount
            self.reportFrequency = reportFrequency
            self.reportGeneratorName = reportGeneratorName
            self.reportType = reportType
            self.s3Location = s3Location
            self.tags = tags
        }
    }

}

public struct GetLicenseManagerReportGeneratorOutput {
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerator: LicenseManagerClientTypes.ReportGenerator?

    public init(
        reportGenerator: LicenseManagerClientTypes.ReportGenerator? = nil
    )
    {
        self.reportGenerator = reportGenerator
    }
}

public struct GetLicenseUsageInput {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?

    public init(
        licenseArn: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
    }
}

extension LicenseManagerClientTypes {
    /// Usage associated with an entitlement resource.
    public struct EntitlementUsage {
        /// Resource usage consumed.
        /// This member is required.
        public var consumedValue: Swift.String?
        /// Maximum entitlement usage count.
        public var maxCount: Swift.String?
        /// Entitlement usage name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement usage unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?

        public init(
            consumedValue: Swift.String? = nil,
            maxCount: Swift.String? = nil,
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil
        )
        {
            self.consumedValue = consumedValue
            self.maxCount = maxCount
            self.name = name
            self.unit = unit
        }
    }

}

extension LicenseManagerClientTypes {
    /// Describes the entitlement usage associated with a license.
    public struct LicenseUsage {
        /// License entitlement usages.
        public var entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]?

        public init(
            entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]? = nil
        )
        {
            self.entitlementUsages = entitlementUsages
        }
    }

}

public struct GetLicenseUsageOutput {
    /// License usage details.
    public var licenseUsage: LicenseManagerClientTypes.LicenseUsage?

    public init(
        licenseUsage: LicenseManagerClientTypes.LicenseUsage? = nil
    )
    {
        self.licenseUsage = licenseUsage
    }
}

public struct GetServiceSettingsInput {

    public init() { }
}

extension LicenseManagerClientTypes {
    /// Configuration information for Organizations.
    public struct OrganizationConfiguration {
        /// Enables Organizations integration.
        /// This member is required.
        public var enableIntegration: Swift.Bool

        public init(
            enableIntegration: Swift.Bool = false
        )
        {
            self.enableIntegration = enableIntegration
        }
    }

}

public struct GetServiceSettingsOutput {
    /// Indicates whether cross-account discovery is enabled.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Amazon Resource Name (ARN) of the resource share. The License Manager management account provides member accounts with access to this share.
    public var licenseManagerResourceShareArn: Swift.String?
    /// Indicates whether Organizations is integrated with License Manager for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Regional S3 bucket path for storing reports, license trail event data, discovery data, and so on.
    public var s3BucketArn: Swift.String?
    /// SNS topic configured to receive notifications from License Manager.
    public var snsTopicArn: Swift.String?

    public init(
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        licenseManagerResourceShareArn: Swift.String? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.licenseManagerResourceShareArn = licenseManagerResourceShareArn
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

/// The request uses too many filters or too many filter values.
public struct FilterLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilterLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListAssociationsForLicenseConfigurationInput {
    /// Amazon Resource Name (ARN) of a license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// Describes an association with a license configuration.
    public struct LicenseConfigurationAssociation {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Time when the license configuration was associated with the resource.
        public var associationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource consuming licenses.
        public var resourceOwnerId: Swift.String?
        /// Type of server resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            amiAssociationScope: Swift.String? = nil,
            associationTime: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.associationTime = associationTime
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

public struct ListAssociationsForLicenseConfigurationOutput {
    /// Information about the associations for the license configuration.
    public var licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationAssociations = licenseConfigurationAssociations
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter {
        /// Name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The value of the filter, which is case-sensitive. You can only specify one value for the filter.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

public struct ListDistributedGrantsInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranteePrincipalARN
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDistributedGrantsOutput {
    /// Distributed grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInput {
    /// Amazon Resource Name of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// Describes the failure of a license operation.
    public struct LicenseOperationFailure {
        /// Error message.
        public var errorMessage: Swift.String?
        /// Failure time.
        public var failureTime: Foundation.Date?
        /// Reserved.
        public var metadataList: [LicenseManagerClientTypes.Metadata]?
        /// Name of the operation.
        public var operationName: Swift.String?
        /// The requester is "License Manager Automated Discovery".
        public var operationRequestedBy: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Resource type.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            errorMessage: Swift.String? = nil,
            failureTime: Foundation.Date? = nil,
            metadataList: [LicenseManagerClientTypes.Metadata]? = nil,
            operationName: Swift.String? = nil,
            operationRequestedBy: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.errorMessage = errorMessage
            self.failureTime = failureTime
            self.metadataList = metadataList
            self.operationName = operationName
            self.operationRequestedBy = operationRequestedBy
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

public struct ListFailuresForLicenseConfigurationOperationsOutput {
    /// License configuration operations that failed.
    public var licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseOperationFailureList = licenseOperationFailureList
        self.nextToken = nextToken
    }
}

public struct ListLicenseConfigurationsInput {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * licenseCountingType - The dimension for which licenses are counted. Possible values are vCPU | Instance | Core | Socket. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * enforceLicenseCount - A Boolean value that indicates whether hard license enforcement is used. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * usagelimitExceeded - A Boolean value that indicates whether the available licenses have been exceeded. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARN) of the license configurations.
    public var licenseConfigurationArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArns = licenseConfigurationArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), host affinity (how long a VM must be associated with a host), and the number of licenses purchased and used.
    public struct LicenseConfiguration {
        /// Automated discovery information.
        public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
        /// Summaries for licenses consumed by various resources.
        public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
        /// Number of licenses consumed.
        public var consumedLicenses: Swift.Int?
        /// Description of the license configuration.
        public var description: Swift.String?
        /// When true, disassociates a resource when software is uninstalled.
        public var disassociateWhenNotFound: Swift.Bool?
        /// Amazon Resource Name (ARN) of the license configuration.
        public var licenseConfigurationArn: Swift.String?
        /// Unique ID of the license configuration.
        public var licenseConfigurationId: Swift.String?
        /// Number of licenses managed by the license configuration.
        public var licenseCount: Swift.Int?
        /// Number of available licenses as a hard limit.
        public var licenseCountHardLimit: Swift.Bool?
        /// Dimension to use to track the license inventory.
        public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
        /// License rules.
        public var licenseRules: [Swift.String]?
        /// Summaries for managed resources.
        public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
        /// Name of the license configuration.
        public var name: Swift.String?
        /// Account ID of the license configuration's owner.
        public var ownerAccountId: Swift.String?
        /// Product information.
        public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
        /// Status of the license configuration.
        public var status: Swift.String?

        public init(
            automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
            consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
            consumedLicenses: Swift.Int? = nil,
            description: Swift.String? = nil,
            disassociateWhenNotFound: Swift.Bool? = nil,
            licenseConfigurationArn: Swift.String? = nil,
            licenseConfigurationId: Swift.String? = nil,
            licenseCount: Swift.Int? = nil,
            licenseCountHardLimit: Swift.Bool? = nil,
            licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
            licenseRules: [Swift.String]? = nil,
            managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
            status: Swift.String? = nil
        )
        {
            self.automatedDiscoveryInformation = automatedDiscoveryInformation
            self.consumedLicenseSummaryList = consumedLicenseSummaryList
            self.consumedLicenses = consumedLicenses
            self.description = description
            self.disassociateWhenNotFound = disassociateWhenNotFound
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationId = licenseConfigurationId
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.managedResourceSummaryList = managedResourceSummaryList
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.productInformationList = productInformationList
            self.status = status
        }
    }

}

public struct ListLicenseConfigurationsOutput {
    /// Information about the license configurations.
    public var licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurations = licenseConfigurations
        self.nextToken = nextToken
    }
}

public struct ListLicenseConversionTasksInput {
    /// Filters to scope the results. Valid filters are ResourceArns and Status.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionTask {
        /// Information about the license type this conversion task converted to.
        public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was completed.
        public var endTime: Foundation.Date?
        /// The ID of the license type conversion task.
        public var licenseConversionTaskId: Swift.String?
        /// The time the usage operation value of the resource was changed.
        public var licenseConversionTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the resource associated with the license type conversion task.
        public var resourceArn: Swift.String?
        /// Information about the license type this conversion task converted from.
        public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was started at.
        public var startTime: Foundation.Date?
        /// The status of the conversion task.
        public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
        /// The status message for the conversion task.
        public var statusMessage: Swift.String?

        public init(
            destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            endTime: Foundation.Date? = nil,
            licenseConversionTaskId: Swift.String? = nil,
            licenseConversionTime: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            startTime: Foundation.Date? = nil,
            status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.destinationLicenseContext = destinationLicenseContext
            self.endTime = endTime
            self.licenseConversionTaskId = licenseConversionTaskId
            self.licenseConversionTime = licenseConversionTime
            self.resourceArn = resourceArn
            self.sourceLicenseContext = sourceLicenseContext
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct ListLicenseConversionTasksOutput {
    /// Information about the license configuration tasks for your account.
    public var licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConversionTasks = licenseConversionTasks
        self.nextToken = nextToken
    }
}

public struct ListLicenseManagerReportGeneratorsInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseConfigurationArn
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLicenseManagerReportGeneratorsOutput {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerators: [LicenseManagerClientTypes.ReportGenerator]?

    public init(
        nextToken: Swift.String? = nil,
        reportGenerators: [LicenseManagerClientTypes.ReportGenerator]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGenerators = reportGenerators
    }
}

public struct ListLicensesInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * Beneficiary
    ///
    /// * ProductSKU
    ///
    /// * Fingerprint
    ///
    /// * Status
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLicensesOutput {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

public struct ListLicenseSpecificationsForResourceInput {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) of a resource that has an associated license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension LicenseManagerClientTypes {
    /// Details for associating a license configuration with a resource.
    public struct LicenseSpecification {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Amazon Resource Name (ARN) of the license configuration.
        /// This member is required.
        public var licenseConfigurationArn: Swift.String?

        public init(
            amiAssociationScope: Swift.String? = nil,
            licenseConfigurationArn: Swift.String? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }

}

public struct ListLicenseSpecificationsForResourceOutput {
    /// License configurations associated with a resource.
    public var licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseSpecifications = licenseSpecifications
        self.nextToken = nextToken
    }
}

public struct ListLicenseVersionsInput {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLicenseVersionsOutput {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

public struct ListReceivedGrantsInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranterAccountId
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReceivedGrantsOutput {
    /// Received grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

public struct ListReceivedGrantsForOrganizationInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ParentArn
    ///
    /// * GranteePrincipalArn
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the received license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReceivedGrantsForOrganizationOutput {
    /// Lists the grants the organization has received.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

public struct ListReceivedLicensesInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * Status
    ///
    /// * Fingerprint
    ///
    /// * IssuerName
    ///
    /// * Beneficiary
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {

    public enum ReceivedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceivedStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// Metadata associated with received licenses and grants.
    public struct ReceivedMetadata {
        /// Allowed operations.
        public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// Received status.
        public var receivedStatus: LicenseManagerClientTypes.ReceivedStatus?
        /// Received status reason.
        public var receivedStatusReason: Swift.String?

        public init(
            allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            receivedStatus: LicenseManagerClientTypes.ReceivedStatus? = nil,
            receivedStatusReason: Swift.String? = nil
        )
        {
            self.allowedOperations = allowedOperations
            self.receivedStatus = receivedStatus
            self.receivedStatusReason = receivedStatusReason
        }
    }

}

extension LicenseManagerClientTypes {
    /// Describes a license that is granted to a grantee.
    public struct GrantedLicense {
        /// Granted license beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// Creation time of the granted license.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the granted license.
        public var homeRegion: Swift.String?
        /// Granted license issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Granted license metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// Granted license received metadata.
        public var receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata?
        /// Granted license status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the granted license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// Version of the granted license.
        public var version: Swift.String?

        public init(
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.receivedMetadata = receivedMetadata
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

public struct ListReceivedLicensesOutput {
    /// Received license details.
    public var licenses: [LicenseManagerClientTypes.GrantedLicense]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.GrantedLicense]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

public struct ListReceivedLicensesForOrganizationInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * Beneficiary
    ///
    /// * ProductSKU
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListReceivedLicensesForOrganizationOutput {
    /// Lists the licenses the organization has received.
    public var licenses: [LicenseManagerClientTypes.GrantedLicense]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenses: [LicenseManagerClientTypes.GrantedLicense]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

/// A dependency required to run the API is missing.
public struct FailedDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailedDependency" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension LicenseManagerClientTypes {

    public enum InventoryFilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case contains
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryFilterCondition] {
            return [
                .beginsWith,
                .contains,
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerClientTypes {
    /// An inventory filter.
    public struct InventoryFilter {
        /// Condition of the filter.
        /// This member is required.
        public var condition: LicenseManagerClientTypes.InventoryFilterCondition?
        /// Name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init(
            condition: LicenseManagerClientTypes.InventoryFilterCondition? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.value = value
        }
    }

}

public struct ListResourceInventoryInput {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * account_id - The ID of the Amazon Web Services account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * application_name - The name of the application. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * license_included - The type of license included. Logical operators are EQUALS | NOT_EQUALS. Possible values are sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
    ///
    /// * platform - The platform of the resource. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * resource_id - The ID of the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * tag: - The key/value combination of a tag assigned to the resource. Logical operators are EQUALS (single account) or EQUALS | NOT_EQUALS (cross account).
    public var filters: [LicenseManagerClientTypes.InventoryFilter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// Details about a resource.
    public struct ResourceInventory {
        /// Platform of the resource.
        public var platform: Swift.String?
        /// Platform version of the resource in the inventory.
        public var platformVersion: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the resource.
        public var resourceId: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwningAccountId: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            platform: Swift.String? = nil,
            platformVersion: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceOwningAccountId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.platform = platform
            self.platformVersion = platformVersion
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceOwningAccountId = resourceOwningAccountId
            self.resourceType = resourceType
        }
    }

}

public struct ListResourceInventoryOutput {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the resources.
    public var resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]?

    public init(
        nextToken: Swift.String? = nil,
        resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInventoryList = resourceInventoryList
    }
}

public struct ListTagsForResourceInput {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Information about the tags.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTokensInput {
    /// Filters to scope the results. The following filter is supported:
    ///
    /// * LicenseArns
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Token IDs.
    public var tokenIds: [Swift.String]?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tokenIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tokenIds = tokenIds
    }
}

extension LicenseManagerClientTypes {
    /// Describes a token.
    public struct TokenData {
        /// Token expiration time, in ISO8601-UTC format.
        public var expirationTime: Swift.String?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Amazon Resource Names (ARN) of the roles included in the token.
        public var roleArns: [Swift.String]?
        /// Token status. The possible values are AVAILABLE and DELETED.
        public var status: Swift.String?
        /// Token ID.
        public var tokenId: Swift.String?
        /// Data specified by the caller.
        public var tokenProperties: [Swift.String]?
        /// Type of token generated. The supported value is REFRESH_TOKEN.
        public var tokenType: Swift.String?

        public init(
            expirationTime: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            roleArns: [Swift.String]? = nil,
            status: Swift.String? = nil,
            tokenId: Swift.String? = nil,
            tokenProperties: [Swift.String]? = nil,
            tokenType: Swift.String? = nil
        )
        {
            self.expirationTime = expirationTime
            self.licenseArn = licenseArn
            self.roleArns = roleArns
            self.status = status
            self.tokenId = tokenId
            self.tokenProperties = tokenProperties
            self.tokenType = tokenType
        }
    }

}

public struct ListTokensOutput {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Received token details.
    public var tokens: [LicenseManagerClientTypes.TokenData]?

    public init(
        nextToken: Swift.String? = nil,
        tokens: [LicenseManagerClientTypes.TokenData]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokens = tokens
    }
}

public struct ListUsageForLicenseConfigurationInput {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * resourceArn - The ARN of the license configuration resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceType - The resource type (EC2_INSTANCE | EC2_HOST | EC2_AMI | SYSTEMS_MANAGER_MANAGED_INSTANCE). Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceAccount - The ID of the account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LicenseManagerClientTypes {
    /// Details about the usage of a resource associated with a license configuration.
    public struct LicenseConfigurationUsage {
        /// Time when the license configuration was initially associated with the resource.
        public var associationTime: Foundation.Date?
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Status of the resource.
        public var resourceStatus: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init(
            associationTime: Foundation.Date? = nil,
            consumedLicenses: Swift.Int? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceStatus: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationTime = associationTime
            self.consumedLicenses = consumedLicenses
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceStatus = resourceStatus
            self.resourceType = resourceType
        }
    }

}

public struct ListUsageForLicenseConfigurationOutput {
    /// Information about the license configurations.
    public var licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationUsageList = licenseConfigurationUsageList
        self.nextToken = nextToken
    }
}

public struct RejectGrantInput {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init(
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

public struct RejectGrantOutput {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init(
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

public struct TagResourceInput {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys identifying the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension LicenseManagerClientTypes {

    public enum LicenseConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConfigurationStatus] {
            return [
                .available,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateLicenseConfigurationInput {
    /// New description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// New status of the license configuration.
    public var licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus?
    /// New number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// New hard limit of the number of available licenses.
    public var licenseCountHardLimit: Swift.Bool?
    /// New license rule. The only rule that you can add after you create a license configuration is licenseAffinityToHost.
    public var licenseRules: [Swift.String]?
    /// New name of the license configuration.
    public var name: Swift.String?
    /// New product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?

    public init(
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationStatus = licenseConfigurationStatus
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
    }
}

public struct UpdateLicenseConfigurationOutput {

    public init() { }
}

public struct UpdateLicenseManagerReportGeneratorInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Amazon Resource Name (ARN) of the report generator to update.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?
    /// The report context.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Type of reports to generate. The following report types are supported:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        licenseManagerReportGeneratorArn: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.type = type
    }
}

public struct UpdateLicenseManagerReportGeneratorOutput {

    public init() { }
}

/// License Manager cannot allocate a license to a resource because of its state. For example, you cannot allocate a license to an instance in the process of shutting down.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You do not have enough licenses available to support a new resource launch.
public struct LicenseUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LicenseUsageFailure" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateLicenseSpecificationsForResourceInput {
    /// ARNs of the license configurations to add.
    public var addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// ARNs of the license configurations to remove.
    public var removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Amazon Resource Name (ARN) of the Amazon Web Services resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.addLicenseSpecifications = addLicenseSpecifications
        self.removeLicenseSpecifications = removeLicenseSpecifications
        self.resourceArn = resourceArn
    }
}

public struct UpdateLicenseSpecificationsForResourceOutput {

    public init() { }
}

public struct UpdateServiceSettingsInput {
    /// Activates cross-account discovery.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Enables integration with Organizations for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.
    public var s3BucketArn: Swift.String?
    /// Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.
    public var snsTopicArn: Swift.String?

    public init(
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

public struct UpdateServiceSettingsOutput {

    public init() { }
}

extension AcceptGrantInput {

    static func urlPathProvider(_ value: AcceptGrantInput) -> Swift.String? {
        return "/"
    }
}

extension CheckInLicenseInput {

    static func urlPathProvider(_ value: CheckInLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension CheckoutBorrowLicenseInput {

    static func urlPathProvider(_ value: CheckoutBorrowLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension CheckoutLicenseInput {

    static func urlPathProvider(_ value: CheckoutLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGrantInput {

    static func urlPathProvider(_ value: CreateGrantInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGrantVersionInput {

    static func urlPathProvider(_ value: CreateGrantVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLicenseInput {

    static func urlPathProvider(_ value: CreateLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLicenseConfigurationInput {

    static func urlPathProvider(_ value: CreateLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLicenseConversionTaskForResourceInput {

    static func urlPathProvider(_ value: CreateLicenseConversionTaskForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLicenseManagerReportGeneratorInput {

    static func urlPathProvider(_ value: CreateLicenseManagerReportGeneratorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLicenseVersionInput {

    static func urlPathProvider(_ value: CreateLicenseVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTokenInput {

    static func urlPathProvider(_ value: CreateTokenInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGrantInput {

    static func urlPathProvider(_ value: DeleteGrantInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLicenseInput {

    static func urlPathProvider(_ value: DeleteLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLicenseConfigurationInput {

    static func urlPathProvider(_ value: DeleteLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLicenseManagerReportGeneratorInput {

    static func urlPathProvider(_ value: DeleteLicenseManagerReportGeneratorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTokenInput {

    static func urlPathProvider(_ value: DeleteTokenInput) -> Swift.String? {
        return "/"
    }
}

extension ExtendLicenseConsumptionInput {

    static func urlPathProvider(_ value: ExtendLicenseConsumptionInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccessTokenInput {

    static func urlPathProvider(_ value: GetAccessTokenInput) -> Swift.String? {
        return "/"
    }
}

extension GetGrantInput {

    static func urlPathProvider(_ value: GetGrantInput) -> Swift.String? {
        return "/"
    }
}

extension GetLicenseInput {

    static func urlPathProvider(_ value: GetLicenseInput) -> Swift.String? {
        return "/"
    }
}

extension GetLicenseConfigurationInput {

    static func urlPathProvider(_ value: GetLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetLicenseConversionTaskInput {

    static func urlPathProvider(_ value: GetLicenseConversionTaskInput) -> Swift.String? {
        return "/"
    }
}

extension GetLicenseManagerReportGeneratorInput {

    static func urlPathProvider(_ value: GetLicenseManagerReportGeneratorInput) -> Swift.String? {
        return "/"
    }
}

extension GetLicenseUsageInput {

    static func urlPathProvider(_ value: GetLicenseUsageInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceSettingsInput {

    static func urlPathProvider(_ value: GetServiceSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociationsForLicenseConfigurationInput {

    static func urlPathProvider(_ value: ListAssociationsForLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ListDistributedGrantsInput {

    static func urlPathProvider(_ value: ListDistributedGrantsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFailuresForLicenseConfigurationOperationsInput {

    static func urlPathProvider(_ value: ListFailuresForLicenseConfigurationOperationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicenseConfigurationsInput {

    static func urlPathProvider(_ value: ListLicenseConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicenseConversionTasksInput {

    static func urlPathProvider(_ value: ListLicenseConversionTasksInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicenseManagerReportGeneratorsInput {

    static func urlPathProvider(_ value: ListLicenseManagerReportGeneratorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicensesInput {

    static func urlPathProvider(_ value: ListLicensesInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicenseSpecificationsForResourceInput {

    static func urlPathProvider(_ value: ListLicenseSpecificationsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListLicenseVersionsInput {

    static func urlPathProvider(_ value: ListLicenseVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListReceivedGrantsInput {

    static func urlPathProvider(_ value: ListReceivedGrantsInput) -> Swift.String? {
        return "/"
    }
}

extension ListReceivedGrantsForOrganizationInput {

    static func urlPathProvider(_ value: ListReceivedGrantsForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension ListReceivedLicensesInput {

    static func urlPathProvider(_ value: ListReceivedLicensesInput) -> Swift.String? {
        return "/"
    }
}

extension ListReceivedLicensesForOrganizationInput {

    static func urlPathProvider(_ value: ListReceivedLicensesForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceInventoryInput {

    static func urlPathProvider(_ value: ListResourceInventoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTokensInput {

    static func urlPathProvider(_ value: ListTokensInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsageForLicenseConfigurationInput {

    static func urlPathProvider(_ value: ListUsageForLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension RejectGrantInput {

    static func urlPathProvider(_ value: RejectGrantInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLicenseConfigurationInput {

    static func urlPathProvider(_ value: UpdateLicenseConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLicenseManagerReportGeneratorInput {

    static func urlPathProvider(_ value: UpdateLicenseManagerReportGeneratorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLicenseSpecificationsForResourceInput {

    static func urlPathProvider(_ value: UpdateLicenseSpecificationsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceSettingsInput {

    static func urlPathProvider(_ value: UpdateServiceSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptGrantInput {

    static func write(value: AcceptGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantArn"].write(value.grantArn)
    }
}

extension CheckInLicenseInput {

    static func write(value: CheckInLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Beneficiary"].write(value.beneficiary)
        try writer["LicenseConsumptionToken"].write(value.licenseConsumptionToken)
    }
}

extension CheckoutBorrowLicenseInput {

    static func write(value: CheckoutBorrowLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CheckoutMetadata"].writeList(value.checkoutMetadata, memberWritingClosure: LicenseManagerClientTypes.Metadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DigitalSignatureMethod"].write(value.digitalSignatureMethod)
        try writer["Entitlements"].writeList(value.entitlements, memberWritingClosure: LicenseManagerClientTypes.EntitlementData.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["NodeId"].write(value.nodeId)
    }
}

extension CheckoutLicenseInput {

    static func write(value: CheckoutLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Beneficiary"].write(value.beneficiary)
        try writer["CheckoutType"].write(value.checkoutType)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Entitlements"].writeList(value.entitlements, memberWritingClosure: LicenseManagerClientTypes.EntitlementData.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KeyFingerprint"].write(value.keyFingerprint)
        try writer["NodeId"].write(value.nodeId)
        try writer["ProductSKU"].write(value.productSKU)
    }
}

extension CreateGrantInput {

    static func write(value: CreateGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedOperations"].writeList(value.allowedOperations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LicenseManagerClientTypes.AllowedOperation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["GrantName"].write(value.grantName)
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["Principals"].writeList(value.principals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGrantVersionInput {

    static func write(value: CreateGrantVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedOperations"].writeList(value.allowedOperations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LicenseManagerClientTypes.AllowedOperation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["GrantArn"].write(value.grantArn)
        try writer["GrantName"].write(value.grantName)
        try writer["Options"].write(value.options, with: LicenseManagerClientTypes.Options.write(value:to:))
        try writer["SourceVersion"].write(value.sourceVersion)
        try writer["Status"].write(value.status)
        try writer["StatusReason"].write(value.statusReason)
    }
}

extension CreateLicenseInput {

    static func write(value: CreateLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Beneficiary"].write(value.beneficiary)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConsumptionConfiguration"].write(value.consumptionConfiguration, with: LicenseManagerClientTypes.ConsumptionConfiguration.write(value:to:))
        try writer["Entitlements"].writeList(value.entitlements, memberWritingClosure: LicenseManagerClientTypes.Entitlement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["Issuer"].write(value.issuer, with: LicenseManagerClientTypes.Issuer.write(value:to:))
        try writer["LicenseMetadata"].writeList(value.licenseMetadata, memberWritingClosure: LicenseManagerClientTypes.Metadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseName"].write(value.licenseName)
        try writer["ProductName"].write(value.productName)
        try writer["ProductSKU"].write(value.productSKU)
        try writer["Validity"].write(value.validity, with: LicenseManagerClientTypes.DatetimeRange.write(value:to:))
    }
}

extension CreateLicenseConfigurationInput {

    static func write(value: CreateLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisassociateWhenNotFound"].write(value.disassociateWhenNotFound)
        try writer["LicenseCount"].write(value.licenseCount)
        try writer["LicenseCountHardLimit"].write(value.licenseCountHardLimit)
        try writer["LicenseCountingType"].write(value.licenseCountingType)
        try writer["LicenseRules"].writeList(value.licenseRules, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ProductInformationList"].writeList(value.productInformationList, memberWritingClosure: LicenseManagerClientTypes.ProductInformation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LicenseManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLicenseConversionTaskForResourceInput {

    static func write(value: CreateLicenseConversionTaskForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationLicenseContext"].write(value.destinationLicenseContext, with: LicenseManagerClientTypes.LicenseConversionContext.write(value:to:))
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["SourceLicenseContext"].write(value.sourceLicenseContext, with: LicenseManagerClientTypes.LicenseConversionContext.write(value:to:))
    }
}

extension CreateLicenseManagerReportGeneratorInput {

    static func write(value: CreateLicenseManagerReportGeneratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["ReportContext"].write(value.reportContext, with: LicenseManagerClientTypes.ReportContext.write(value:to:))
        try writer["ReportFrequency"].write(value.reportFrequency, with: LicenseManagerClientTypes.ReportFrequency.write(value:to:))
        try writer["ReportGeneratorName"].write(value.reportGeneratorName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LicenseManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].writeList(value.type, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LicenseManagerClientTypes.ReportType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLicenseVersionInput {

    static func write(value: CreateLicenseVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConsumptionConfiguration"].write(value.consumptionConfiguration, with: LicenseManagerClientTypes.ConsumptionConfiguration.write(value:to:))
        try writer["Entitlements"].writeList(value.entitlements, memberWritingClosure: LicenseManagerClientTypes.Entitlement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["Issuer"].write(value.issuer, with: LicenseManagerClientTypes.Issuer.write(value:to:))
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["LicenseMetadata"].writeList(value.licenseMetadata, memberWritingClosure: LicenseManagerClientTypes.Metadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseName"].write(value.licenseName)
        try writer["ProductName"].write(value.productName)
        try writer["SourceVersion"].write(value.sourceVersion)
        try writer["Status"].write(value.status)
        try writer["Validity"].write(value.validity, with: LicenseManagerClientTypes.DatetimeRange.write(value:to:))
    }
}

extension CreateTokenInput {

    static func write(value: CreateTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ExpirationInDays"].write(value.expirationInDays)
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["RoleArns"].writeList(value.roleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TokenProperties"].writeList(value.tokenProperties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteGrantInput {

    static func write(value: DeleteGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantArn"].write(value.grantArn)
        try writer["StatusReason"].write(value.statusReason)
        try writer["Version"].write(value.version)
    }
}

extension DeleteLicenseInput {

    static func write(value: DeleteLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["SourceVersion"].write(value.sourceVersion)
    }
}

extension DeleteLicenseConfigurationInput {

    static func write(value: DeleteLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }
}

extension DeleteLicenseManagerReportGeneratorInput {

    static func write(value: DeleteLicenseManagerReportGeneratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseManagerReportGeneratorArn"].write(value.licenseManagerReportGeneratorArn)
    }
}

extension DeleteTokenInput {

    static func write(value: DeleteTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TokenId"].write(value.tokenId)
    }
}

extension ExtendLicenseConsumptionInput {

    static func write(value: ExtendLicenseConsumptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DryRun"].write(value.dryRun)
        try writer["LicenseConsumptionToken"].write(value.licenseConsumptionToken)
    }
}

extension GetAccessTokenInput {

    static func write(value: GetAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Token"].write(value.token)
        try writer["TokenProperties"].writeList(value.tokenProperties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetGrantInput {

    static func write(value: GetGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantArn"].write(value.grantArn)
        try writer["Version"].write(value.version)
    }
}

extension GetLicenseInput {

    static func write(value: GetLicenseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["Version"].write(value.version)
    }
}

extension GetLicenseConfigurationInput {

    static func write(value: GetLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }
}

extension GetLicenseConversionTaskInput {

    static func write(value: GetLicenseConversionTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConversionTaskId"].write(value.licenseConversionTaskId)
    }
}

extension GetLicenseManagerReportGeneratorInput {

    static func write(value: GetLicenseManagerReportGeneratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseManagerReportGeneratorArn"].write(value.licenseManagerReportGeneratorArn)
    }
}

extension GetLicenseUsageInput {

    static func write(value: GetLicenseUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseArn"].write(value.licenseArn)
    }
}

extension GetServiceSettingsInput {

    static func write(value: GetServiceSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListAssociationsForLicenseConfigurationInput {

    static func write(value: ListAssociationsForLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDistributedGrantsInput {

    static func write(value: ListDistributedGrantsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GrantArns"].writeList(value.grantArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFailuresForLicenseConfigurationOperationsInput {

    static func write(value: ListFailuresForLicenseConfigurationOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicenseConfigurationsInput {

    static func write(value: ListLicenseConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseConfigurationArns"].writeList(value.licenseConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicenseConversionTasksInput {

    static func write(value: ListLicenseConversionTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicenseManagerReportGeneratorsInput {

    static func write(value: ListLicenseManagerReportGeneratorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicensesInput {

    static func write(value: ListLicensesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseArns"].writeList(value.licenseArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicenseSpecificationsForResourceInput {

    static func write(value: ListLicenseSpecificationsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListLicenseVersionsInput {

    static func write(value: ListLicenseVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListReceivedGrantsInput {

    static func write(value: ListReceivedGrantsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GrantArns"].writeList(value.grantArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListReceivedGrantsForOrganizationInput {

    static func write(value: ListReceivedGrantsForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseArn"].write(value.licenseArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListReceivedLicensesInput {

    static func write(value: ListReceivedLicensesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseArns"].writeList(value.licenseArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListReceivedLicensesForOrganizationInput {

    static func write(value: ListReceivedLicensesForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceInventoryInput {

    static func write(value: ListResourceInventoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.InventoryFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListTokensInput {

    static func write(value: ListTokensInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TokenIds"].writeList(value.tokenIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListUsageForLicenseConfigurationInput {

    static func write(value: ListUsageForLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension RejectGrantInput {

    static func write(value: RejectGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantArn"].write(value.grantArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: LicenseManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLicenseConfigurationInput {

    static func write(value: UpdateLicenseConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisassociateWhenNotFound"].write(value.disassociateWhenNotFound)
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
        try writer["LicenseConfigurationStatus"].write(value.licenseConfigurationStatus)
        try writer["LicenseCount"].write(value.licenseCount)
        try writer["LicenseCountHardLimit"].write(value.licenseCountHardLimit)
        try writer["LicenseRules"].writeList(value.licenseRules, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ProductInformationList"].writeList(value.productInformationList, memberWritingClosure: LicenseManagerClientTypes.ProductInformation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLicenseManagerReportGeneratorInput {

    static func write(value: UpdateLicenseManagerReportGeneratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["LicenseManagerReportGeneratorArn"].write(value.licenseManagerReportGeneratorArn)
        try writer["ReportContext"].write(value.reportContext, with: LicenseManagerClientTypes.ReportContext.write(value:to:))
        try writer["ReportFrequency"].write(value.reportFrequency, with: LicenseManagerClientTypes.ReportFrequency.write(value:to:))
        try writer["ReportGeneratorName"].write(value.reportGeneratorName)
        try writer["Type"].writeList(value.type, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LicenseManagerClientTypes.ReportType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLicenseSpecificationsForResourceInput {

    static func write(value: UpdateLicenseSpecificationsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddLicenseSpecifications"].writeList(value.addLicenseSpecifications, memberWritingClosure: LicenseManagerClientTypes.LicenseSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RemoveLicenseSpecifications"].writeList(value.removeLicenseSpecifications, memberWritingClosure: LicenseManagerClientTypes.LicenseSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension UpdateServiceSettingsInput {

    static func write(value: UpdateServiceSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableCrossAccountsDiscovery"].write(value.enableCrossAccountsDiscovery)
        try writer["OrganizationConfiguration"].write(value.organizationConfiguration, with: LicenseManagerClientTypes.OrganizationConfiguration.write(value:to:))
        try writer["S3BucketArn"].write(value.s3BucketArn)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
    }
}

extension AcceptGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptGrantOutput()
        value.grantArn = try reader["GrantArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CheckInLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckInLicenseOutput {
        return CheckInLicenseOutput()
    }
}

extension CheckoutBorrowLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckoutBorrowLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckoutBorrowLicenseOutput()
        value.checkoutMetadata = try reader["CheckoutMetadata"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Metadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.entitlementsAllowed = try reader["EntitlementsAllowed"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.EntitlementData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expiration = try reader["Expiration"].readIfPresent()
        value.issuedAt = try reader["IssuedAt"].readIfPresent()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.licenseConsumptionToken = try reader["LicenseConsumptionToken"].readIfPresent()
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.signedToken = try reader["SignedToken"].readIfPresent()
        return value
    }
}

extension CheckoutLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckoutLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckoutLicenseOutput()
        value.checkoutType = try reader["CheckoutType"].readIfPresent()
        value.entitlementsAllowed = try reader["EntitlementsAllowed"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.EntitlementData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expiration = try reader["Expiration"].readIfPresent()
        value.issuedAt = try reader["IssuedAt"].readIfPresent()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.licenseConsumptionToken = try reader["LicenseConsumptionToken"].readIfPresent()
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.signedToken = try reader["SignedToken"].readIfPresent()
        return value
    }
}

extension CreateGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGrantOutput()
        value.grantArn = try reader["GrantArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateGrantVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGrantVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGrantVersionOutput()
        value.grantArn = try reader["GrantArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseOutput()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseConfigurationOutput()
        value.licenseConfigurationArn = try reader["LicenseConfigurationArn"].readIfPresent()
        return value
    }
}

extension CreateLicenseConversionTaskForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseConversionTaskForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseConversionTaskForResourceOutput()
        value.licenseConversionTaskId = try reader["LicenseConversionTaskId"].readIfPresent()
        return value
    }
}

extension CreateLicenseManagerReportGeneratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseManagerReportGeneratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseManagerReportGeneratorOutput()
        value.licenseManagerReportGeneratorArn = try reader["LicenseManagerReportGeneratorArn"].readIfPresent()
        return value
    }
}

extension CreateLicenseVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseVersionOutput()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTokenOutput()
        value.token = try reader["Token"].readIfPresent()
        value.tokenId = try reader["TokenId"].readIfPresent()
        value.tokenType = try reader["TokenType"].readIfPresent()
        return value
    }
}

extension DeleteGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGrantOutput()
        value.grantArn = try reader["GrantArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension DeleteLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLicenseOutput()
        value.deletionDate = try reader["DeletionDate"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DeleteLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLicenseConfigurationOutput {
        return DeleteLicenseConfigurationOutput()
    }
}

extension DeleteLicenseManagerReportGeneratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLicenseManagerReportGeneratorOutput {
        return DeleteLicenseManagerReportGeneratorOutput()
    }
}

extension DeleteTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTokenOutput {
        return DeleteTokenOutput()
    }
}

extension ExtendLicenseConsumptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExtendLicenseConsumptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExtendLicenseConsumptionOutput()
        value.expiration = try reader["Expiration"].readIfPresent()
        value.licenseConsumptionToken = try reader["LicenseConsumptionToken"].readIfPresent()
        return value
    }
}

extension GetAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessTokenOutput()
        value.accessToken = try reader["AccessToken"].readIfPresent()
        return value
    }
}

extension GetGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGrantOutput()
        value.grant = try reader["Grant"].readIfPresent(with: LicenseManagerClientTypes.Grant.read(from:))
        return value
    }
}

extension GetLicenseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseOutput()
        value.license = try reader["License"].readIfPresent(with: LicenseManagerClientTypes.License.read(from:))
        return value
    }
}

extension GetLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseConfigurationOutput()
        value.automatedDiscoveryInformation = try reader["AutomatedDiscoveryInformation"].readIfPresent(with: LicenseManagerClientTypes.AutomatedDiscoveryInformation.read(from:))
        value.consumedLicenseSummaryList = try reader["ConsumedLicenseSummaryList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ConsumedLicenseSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.consumedLicenses = try reader["ConsumedLicenses"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.disassociateWhenNotFound = try reader["DisassociateWhenNotFound"].readIfPresent()
        value.licenseConfigurationArn = try reader["LicenseConfigurationArn"].readIfPresent()
        value.licenseConfigurationId = try reader["LicenseConfigurationId"].readIfPresent()
        value.licenseCount = try reader["LicenseCount"].readIfPresent()
        value.licenseCountHardLimit = try reader["LicenseCountHardLimit"].readIfPresent()
        value.licenseCountingType = try reader["LicenseCountingType"].readIfPresent()
        value.licenseRules = try reader["LicenseRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedResourceSummaryList = try reader["ManagedResourceSummaryList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ManagedResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.productInformationList = try reader["ProductInformationList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ProductInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetLicenseConversionTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseConversionTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseConversionTaskOutput()
        value.destinationLicenseContext = try reader["DestinationLicenseContext"].readIfPresent(with: LicenseManagerClientTypes.LicenseConversionContext.read(from:))
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.licenseConversionTaskId = try reader["LicenseConversionTaskId"].readIfPresent()
        value.licenseConversionTime = try reader["LicenseConversionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.sourceLicenseContext = try reader["SourceLicenseContext"].readIfPresent(with: LicenseManagerClientTypes.LicenseConversionContext.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension GetLicenseManagerReportGeneratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseManagerReportGeneratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseManagerReportGeneratorOutput()
        value.reportGenerator = try reader["ReportGenerator"].readIfPresent(with: LicenseManagerClientTypes.ReportGenerator.read(from:))
        return value
    }
}

extension GetLicenseUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseUsageOutput()
        value.licenseUsage = try reader["LicenseUsage"].readIfPresent(with: LicenseManagerClientTypes.LicenseUsage.read(from:))
        return value
    }
}

extension GetServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceSettingsOutput()
        value.enableCrossAccountsDiscovery = try reader["EnableCrossAccountsDiscovery"].readIfPresent()
        value.licenseManagerResourceShareArn = try reader["LicenseManagerResourceShareArn"].readIfPresent()
        value.organizationConfiguration = try reader["OrganizationConfiguration"].readIfPresent(with: LicenseManagerClientTypes.OrganizationConfiguration.read(from:))
        value.s3BucketArn = try reader["S3BucketArn"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        return value
    }
}

extension ListAssociationsForLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociationsForLicenseConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociationsForLicenseConfigurationOutput()
        value.licenseConfigurationAssociations = try reader["LicenseConfigurationAssociations"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseConfigurationAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDistributedGrantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributedGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributedGrantsOutput()
        value.grants = try reader["Grants"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Grant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFailuresForLicenseConfigurationOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFailuresForLicenseConfigurationOperationsOutput()
        value.licenseOperationFailureList = try reader["LicenseOperationFailureList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseOperationFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseConfigurationsOutput()
        value.licenseConfigurations = try reader["LicenseConfigurations"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseConversionTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseConversionTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseConversionTasksOutput()
        value.licenseConversionTasks = try reader["LicenseConversionTasks"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseConversionTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseManagerReportGeneratorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseManagerReportGeneratorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseManagerReportGeneratorsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reportGenerators = try reader["ReportGenerators"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ReportGenerator.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListLicensesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicensesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicensesOutput()
        value.licenses = try reader["Licenses"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.License.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseSpecificationsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseSpecificationsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseSpecificationsForResourceOutput()
        value.licenseSpecifications = try reader["LicenseSpecifications"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseSpecification.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseVersionsOutput()
        value.licenses = try reader["Licenses"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.License.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListReceivedGrantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReceivedGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReceivedGrantsOutput()
        value.grants = try reader["Grants"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Grant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListReceivedGrantsForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReceivedGrantsForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReceivedGrantsForOrganizationOutput()
        value.grants = try reader["Grants"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Grant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListReceivedLicensesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReceivedLicensesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReceivedLicensesOutput()
        value.licenses = try reader["Licenses"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.GrantedLicense.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListReceivedLicensesForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReceivedLicensesForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReceivedLicensesForOrganizationOutput()
        value.licenses = try reader["Licenses"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.GrantedLicense.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResourceInventoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceInventoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceInventoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceInventoryList = try reader["ResourceInventoryList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ResourceInventory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTokensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTokensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTokensOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tokens = try reader["Tokens"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.TokenData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsageForLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsageForLicenseConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsageForLicenseConfigurationOutput()
        value.licenseConfigurationUsageList = try reader["LicenseConfigurationUsageList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.LicenseConfigurationUsage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension RejectGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectGrantOutput()
        value.grantArn = try reader["GrantArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLicenseConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLicenseConfigurationOutput {
        return UpdateLicenseConfigurationOutput()
    }
}

extension UpdateLicenseManagerReportGeneratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLicenseManagerReportGeneratorOutput {
        return UpdateLicenseManagerReportGeneratorOutput()
    }
}

extension UpdateLicenseSpecificationsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLicenseSpecificationsForResourceOutput {
        return UpdateLicenseSpecificationsForResourceOutput()
    }
}

extension UpdateServiceSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceSettingsOutput {
        return UpdateServiceSettingsOutput()
    }
}

enum AcceptGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckInLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckoutBorrowLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "EntitlementNotAllowedException": return try EntitlementNotAllowedException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoEntitlementsAllowedException": return try NoEntitlementsAllowedException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "UnsupportedDigitalSignatureMethodException": return try UnsupportedDigitalSignatureMethodException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckoutLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoEntitlementsAllowedException": return try NoEntitlementsAllowedException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "UnsupportedDigitalSignatureMethodException": return try UnsupportedDigitalSignatureMethodException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGrantVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseConversionTaskForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseManagerReportGeneratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLicenseManagerReportGeneratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "RedirectException": return try RedirectException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExtendLicenseConsumptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseConversionTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseManagerReportGeneratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociationsForLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "FilterLimitExceeded": return try FilterLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributedGrantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFailuresForLicenseConfigurationOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "FilterLimitExceeded": return try FilterLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseConversionTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseManagerReportGeneratorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicensesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseSpecificationsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReceivedGrantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReceivedGrantsForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReceivedLicensesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReceivedLicensesForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceInventoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "FailedDependency": return try FailedDependencyException.makeError(baseError: baseError)
            case "FilterLimitExceeded": return try FilterLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTokensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsageForLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "FilterLimitExceeded": return try FilterLimitExceededException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLicenseConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLicenseManagerReportGeneratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "InvalidResource.NotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLicenseSpecificationsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidResourceState": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "LicenseUsageFailure": return try LicenseUsageException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ServiceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "AuthorizationFailure": return try AuthorizationException.makeError(baseError: baseError)
            case "InvalidParameterValueProvided": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "RateLimitExceeded": return try RateLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try ServerInternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RateLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RateLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = RateLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServerInternalException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServerInternalException {
        let reader = baseError.errorBodyReader
        var value = ServerInternalException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuthorizationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AuthorizationException {
        let reader = baseError.errorBodyReader
        var value = AuthorizationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntitlementNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntitlementNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = EntitlementNotAllowedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoEntitlementsAllowedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoEntitlementsAllowedException {
        let reader = baseError.errorBodyReader
        var value = NoEntitlementsAllowedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RedirectException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RedirectException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = RedirectException()
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.properties.location = locationHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedDigitalSignatureMethodException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedDigitalSignatureMethodException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedDigitalSignatureMethodException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FilterLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FilterLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = FilterLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FailedDependencyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FailedDependencyException {
        let reader = baseError.errorBodyReader
        var value = FailedDependencyException()
        value.properties.errorCode = try reader["ErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseUsageException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LicenseUsageException {
        let reader = baseError.errorBodyReader
        var value = LicenseUsageException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseManagerClientTypes.EntitlementData {

    static func write(value: LicenseManagerClientTypes.EntitlementData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.EntitlementData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.EntitlementData()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension LicenseManagerClientTypes.Metadata {

    static func write(value: LicenseManagerClientTypes.Metadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.Metadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.Metadata()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.Grant {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.Grant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.Grant()
        value.grantArn = try reader["GrantArn"].readIfPresent() ?? ""
        value.grantName = try reader["GrantName"].readIfPresent() ?? ""
        value.parentArn = try reader["ParentArn"].readIfPresent() ?? ""
        value.licenseArn = try reader["LicenseArn"].readIfPresent() ?? ""
        value.granteePrincipalArn = try reader["GranteePrincipalArn"].readIfPresent() ?? ""
        value.homeRegion = try reader["HomeRegion"].readIfPresent() ?? ""
        value.grantStatus = try reader["GrantStatus"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? ""
        value.grantedOperations = try reader["GrantedOperations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LicenseManagerClientTypes.AllowedOperation>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.options = try reader["Options"].readIfPresent(with: LicenseManagerClientTypes.Options.read(from:))
        return value
    }
}

extension LicenseManagerClientTypes.Options {

    static func write(value: LicenseManagerClientTypes.Options?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationOverrideBehavior"].write(value.activationOverrideBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.Options {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.Options()
        value.activationOverrideBehavior = try reader["ActivationOverrideBehavior"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.License {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.License {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.License()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.licenseName = try reader["LicenseName"].readIfPresent()
        value.productName = try reader["ProductName"].readIfPresent()
        value.productSKU = try reader["ProductSKU"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent(with: LicenseManagerClientTypes.IssuerDetails.read(from:))
        value.homeRegion = try reader["HomeRegion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.validity = try reader["Validity"].readIfPresent(with: LicenseManagerClientTypes.DatetimeRange.read(from:))
        value.beneficiary = try reader["Beneficiary"].readIfPresent()
        value.entitlements = try reader["Entitlements"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.consumptionConfiguration = try reader["ConsumptionConfiguration"].readIfPresent(with: LicenseManagerClientTypes.ConsumptionConfiguration.read(from:))
        value.licenseMetadata = try reader["LicenseMetadata"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Metadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createTime = try reader["CreateTime"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ConsumptionConfiguration {

    static func write(value: LicenseManagerClientTypes.ConsumptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BorrowConfiguration"].write(value.borrowConfiguration, with: LicenseManagerClientTypes.BorrowConfiguration.write(value:to:))
        try writer["ProvisionalConfiguration"].write(value.provisionalConfiguration, with: LicenseManagerClientTypes.ProvisionalConfiguration.write(value:to:))
        try writer["RenewType"].write(value.renewType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ConsumptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ConsumptionConfiguration()
        value.renewType = try reader["RenewType"].readIfPresent()
        value.provisionalConfiguration = try reader["ProvisionalConfiguration"].readIfPresent(with: LicenseManagerClientTypes.ProvisionalConfiguration.read(from:))
        value.borrowConfiguration = try reader["BorrowConfiguration"].readIfPresent(with: LicenseManagerClientTypes.BorrowConfiguration.read(from:))
        return value
    }
}

extension LicenseManagerClientTypes.BorrowConfiguration {

    static func write(value: LicenseManagerClientTypes.BorrowConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowEarlyCheckIn"].write(value.allowEarlyCheckIn)
        try writer["MaxTimeToLiveInMinutes"].write(value.maxTimeToLiveInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.BorrowConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.BorrowConfiguration()
        value.allowEarlyCheckIn = try reader["AllowEarlyCheckIn"].readIfPresent() ?? false
        value.maxTimeToLiveInMinutes = try reader["MaxTimeToLiveInMinutes"].readIfPresent() ?? 0
        return value
    }
}

extension LicenseManagerClientTypes.ProvisionalConfiguration {

    static func write(value: LicenseManagerClientTypes.ProvisionalConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxTimeToLiveInMinutes"].write(value.maxTimeToLiveInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ProvisionalConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ProvisionalConfiguration()
        value.maxTimeToLiveInMinutes = try reader["MaxTimeToLiveInMinutes"].readIfPresent() ?? 0
        return value
    }
}

extension LicenseManagerClientTypes.Entitlement {

    static func write(value: LicenseManagerClientTypes.Entitlement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCheckIn"].write(value.allowCheckIn)
        try writer["MaxCount"].write(value.maxCount)
        try writer["Name"].write(value.name)
        try writer["Overage"].write(value.overage)
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.Entitlement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.Entitlement()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        value.maxCount = try reader["MaxCount"].readIfPresent()
        value.overage = try reader["Overage"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        value.allowCheckIn = try reader["AllowCheckIn"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.DatetimeRange {

    static func write(value: LicenseManagerClientTypes.DatetimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Begin"].write(value.begin)
        try writer["End"].write(value.end)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.DatetimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.DatetimeRange()
        value.begin = try reader["Begin"].readIfPresent() ?? ""
        value.end = try reader["End"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.IssuerDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.IssuerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.IssuerDetails()
        value.name = try reader["Name"].readIfPresent()
        value.signKey = try reader["SignKey"].readIfPresent()
        value.keyFingerprint = try reader["KeyFingerprint"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ConsumedLicenseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ConsumedLicenseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ConsumedLicenseSummary()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.consumedLicenses = try reader["ConsumedLicenses"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ManagedResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ManagedResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ManagedResourceSummary()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.associationCount = try reader["AssociationCount"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.Tag {

    static func write(value: LicenseManagerClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ProductInformation {

    static func write(value: LicenseManagerClientTypes.ProductInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProductInformationFilterList"].writeList(value.productInformationFilterList, memberWritingClosure: LicenseManagerClientTypes.ProductInformationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ProductInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ProductInformation()
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.productInformationFilterList = try reader["ProductInformationFilterList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ProductInformationFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LicenseManagerClientTypes.ProductInformationFilter {

    static func write(value: LicenseManagerClientTypes.ProductInformationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProductInformationFilterComparator"].write(value.productInformationFilterComparator)
        try writer["ProductInformationFilterName"].write(value.productInformationFilterName)
        try writer["ProductInformationFilterValue"].writeList(value.productInformationFilterValue, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ProductInformationFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ProductInformationFilter()
        value.productInformationFilterName = try reader["ProductInformationFilterName"].readIfPresent() ?? ""
        value.productInformationFilterValue = try reader["ProductInformationFilterValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.productInformationFilterComparator = try reader["ProductInformationFilterComparator"].readIfPresent() ?? ""
        return value
    }
}

extension LicenseManagerClientTypes.AutomatedDiscoveryInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.AutomatedDiscoveryInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.AutomatedDiscoveryInformation()
        value.lastRunTime = try reader["LastRunTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LicenseManagerClientTypes.LicenseConversionContext {

    static func write(value: LicenseManagerClientTypes.LicenseConversionContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UsageOperation"].write(value.usageOperation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseConversionContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseConversionContext()
        value.usageOperation = try reader["UsageOperation"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ReportGenerator {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ReportGenerator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ReportGenerator()
        value.reportGeneratorName = try reader["ReportGeneratorName"].readIfPresent()
        value.reportType = try reader["ReportType"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LicenseManagerClientTypes.ReportType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reportContext = try reader["ReportContext"].readIfPresent(with: LicenseManagerClientTypes.ReportContext.read(from:))
        value.reportFrequency = try reader["ReportFrequency"].readIfPresent(with: LicenseManagerClientTypes.ReportFrequency.read(from:))
        value.licenseManagerReportGeneratorArn = try reader["LicenseManagerReportGeneratorArn"].readIfPresent()
        value.lastRunStatus = try reader["LastRunStatus"].readIfPresent()
        value.lastRunFailureReason = try reader["LastRunFailureReason"].readIfPresent()
        value.lastReportGenerationTime = try reader["LastReportGenerationTime"].readIfPresent()
        value.reportCreatorAccount = try reader["ReportCreatorAccount"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.s3Location = try reader["S3Location"].readIfPresent(with: LicenseManagerClientTypes.S3Location.read(from:))
        value.createTime = try reader["CreateTime"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LicenseManagerClientTypes.S3Location {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.S3Location()
        value.bucket = try reader["bucket"].readIfPresent()
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ReportFrequency {

    static func write(value: LicenseManagerClientTypes.ReportFrequency?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["period"].write(value.period)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ReportFrequency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ReportFrequency()
        value.value = try reader["value"].readIfPresent()
        value.period = try reader["period"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.ReportContext {

    static func write(value: LicenseManagerClientTypes.ReportContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["licenseConfigurationArns"].writeList(value.licenseConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ReportContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ReportContext()
        value.licenseConfigurationArns = try reader["licenseConfigurationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LicenseManagerClientTypes.LicenseUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseUsage()
        value.entitlementUsages = try reader["EntitlementUsages"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.EntitlementUsage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LicenseManagerClientTypes.EntitlementUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.EntitlementUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.EntitlementUsage()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.consumedValue = try reader["ConsumedValue"].readIfPresent() ?? ""
        value.maxCount = try reader["MaxCount"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension LicenseManagerClientTypes.OrganizationConfiguration {

    static func write(value: LicenseManagerClientTypes.OrganizationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableIntegration"].write(value.enableIntegration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.OrganizationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.OrganizationConfiguration()
        value.enableIntegration = try reader["EnableIntegration"].readIfPresent() ?? false
        return value
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseConfigurationAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseConfigurationAssociation()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceOwnerId = try reader["ResourceOwnerId"].readIfPresent()
        value.associationTime = try reader["AssociationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.amiAssociationScope = try reader["AmiAssociationScope"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.LicenseOperationFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseOperationFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseOperationFailure()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.failureTime = try reader["FailureTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.operationName = try reader["OperationName"].readIfPresent()
        value.resourceOwnerId = try reader["ResourceOwnerId"].readIfPresent()
        value.operationRequestedBy = try reader["OperationRequestedBy"].readIfPresent()
        value.metadataList = try reader["MetadataList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Metadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LicenseManagerClientTypes.LicenseConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseConfiguration()
        value.licenseConfigurationId = try reader["LicenseConfigurationId"].readIfPresent()
        value.licenseConfigurationArn = try reader["LicenseConfigurationArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.licenseCountingType = try reader["LicenseCountingType"].readIfPresent()
        value.licenseRules = try reader["LicenseRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseCount = try reader["LicenseCount"].readIfPresent()
        value.licenseCountHardLimit = try reader["LicenseCountHardLimit"].readIfPresent()
        value.disassociateWhenNotFound = try reader["DisassociateWhenNotFound"].readIfPresent()
        value.consumedLicenses = try reader["ConsumedLicenses"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.consumedLicenseSummaryList = try reader["ConsumedLicenseSummaryList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ConsumedLicenseSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedResourceSummaryList = try reader["ManagedResourceSummaryList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ManagedResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productInformationList = try reader["ProductInformationList"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.ProductInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.automatedDiscoveryInformation = try reader["AutomatedDiscoveryInformation"].readIfPresent(with: LicenseManagerClientTypes.AutomatedDiscoveryInformation.read(from:))
        return value
    }
}

extension LicenseManagerClientTypes.LicenseConversionTask {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseConversionTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseConversionTask()
        value.licenseConversionTaskId = try reader["LicenseConversionTaskId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.sourceLicenseContext = try reader["SourceLicenseContext"].readIfPresent(with: LicenseManagerClientTypes.LicenseConversionContext.read(from:))
        value.destinationLicenseContext = try reader["DestinationLicenseContext"].readIfPresent(with: LicenseManagerClientTypes.LicenseConversionContext.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.licenseConversionTime = try reader["LicenseConversionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LicenseManagerClientTypes.LicenseSpecification {

    static func write(value: LicenseManagerClientTypes.LicenseSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmiAssociationScope"].write(value.amiAssociationScope)
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseSpecification()
        value.licenseConfigurationArn = try reader["LicenseConfigurationArn"].readIfPresent() ?? ""
        value.amiAssociationScope = try reader["AmiAssociationScope"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.GrantedLicense {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.GrantedLicense {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.GrantedLicense()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.licenseName = try reader["LicenseName"].readIfPresent()
        value.productName = try reader["ProductName"].readIfPresent()
        value.productSKU = try reader["ProductSKU"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent(with: LicenseManagerClientTypes.IssuerDetails.read(from:))
        value.homeRegion = try reader["HomeRegion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.validity = try reader["Validity"].readIfPresent(with: LicenseManagerClientTypes.DatetimeRange.read(from:))
        value.beneficiary = try reader["Beneficiary"].readIfPresent()
        value.entitlements = try reader["Entitlements"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Entitlement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.consumptionConfiguration = try reader["ConsumptionConfiguration"].readIfPresent(with: LicenseManagerClientTypes.ConsumptionConfiguration.read(from:))
        value.licenseMetadata = try reader["LicenseMetadata"].readListIfPresent(memberReadingClosure: LicenseManagerClientTypes.Metadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createTime = try reader["CreateTime"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.receivedMetadata = try reader["ReceivedMetadata"].readIfPresent(with: LicenseManagerClientTypes.ReceivedMetadata.read(from:))
        return value
    }
}

extension LicenseManagerClientTypes.ReceivedMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ReceivedMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ReceivedMetadata()
        value.receivedStatus = try reader["ReceivedStatus"].readIfPresent()
        value.receivedStatusReason = try reader["ReceivedStatusReason"].readIfPresent()
        value.allowedOperations = try reader["AllowedOperations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LicenseManagerClientTypes.AllowedOperation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LicenseManagerClientTypes.ResourceInventory {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.ResourceInventory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.ResourceInventory()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.resourceOwningAccountId = try reader["ResourceOwningAccountId"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.TokenData {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.TokenData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.TokenData()
        value.tokenId = try reader["TokenId"].readIfPresent()
        value.tokenType = try reader["TokenType"].readIfPresent()
        value.licenseArn = try reader["LicenseArn"].readIfPresent()
        value.expirationTime = try reader["ExpirationTime"].readIfPresent()
        value.tokenProperties = try reader["TokenProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArns = try reader["RoleArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerClientTypes.LicenseConfigurationUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerClientTypes.LicenseConfigurationUsage()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceStatus = try reader["ResourceStatus"].readIfPresent()
        value.resourceOwnerId = try reader["ResourceOwnerId"].readIfPresent()
        value.associationTime = try reader["AssociationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.consumedLicenses = try reader["ConsumedLicenses"].readIfPresent()
        return value
    }
}

extension LicenseManagerClientTypes.Issuer {

    static func write(value: LicenseManagerClientTypes.Issuer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SignKey"].write(value.signKey)
    }
}

extension LicenseManagerClientTypes.Filter {

    static func write(value: LicenseManagerClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LicenseManagerClientTypes.InventoryFilter {

    static func write(value: LicenseManagerClientTypes.InventoryFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

public enum LicenseManagerClientTypes {}
