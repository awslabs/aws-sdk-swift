//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct CreateTagsOutput {

    public init() { }
}

public struct DeleteTagsOutput {

    public init() { }
}

extension MqClientTypes {
    /// Action required for a broker.
    public struct ActionRequired {
        /// The code you can use to find instructions on the action required to resolve your broker issue.
        public var actionRequiredCode: Swift.String?
        /// Information about the action required to resolve your broker issue.
        public var actionRequiredInfo: Swift.String?

        public init(
            actionRequiredCode: Swift.String? = nil,
            actionRequiredInfo: Swift.String? = nil
        )
        {
            self.actionRequiredCode = actionRequiredCode
            self.actionRequiredInfo = actionRequiredInfo
        }
    }

}

extension MqClientTypes {
    /// Name of the availability zone.
    public struct AvailabilityZone {
        /// Id for the availability zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension MqClientTypes {

    /// The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activemq
        case rabbitmq
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .activemq,
                .rabbitmq
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activemq: return "ACTIVEMQ"
            case .rabbitmq: return "RABBITMQ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Id of the engine version.
    public struct EngineVersion {
        /// Id for the version.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension MqClientTypes {
    /// Types of broker engines.
    public struct BrokerEngineType {
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The list of engine versions.
        public var engineVersions: [MqClientTypes.EngineVersion]?

        public init(
            engineType: MqClientTypes.EngineType? = nil,
            engineVersions: [MqClientTypes.EngineVersion]? = nil
        )
        {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }
    }

}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerInstance {
        /// The brokers web console URL.
        public var consoleURL: Swift.String?
        /// The broker's wire-level protocol endpoints.
        public var endpoints: [Swift.String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public var ipAddress: Swift.String?

        public init(
            consoleURL: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }
    }

}

extension MqClientTypes {

    /// The broker's storage type. EFS is not supported for RabbitMQ engine type.
    public enum BrokerStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebs
        case efs
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerStorageType] {
            return [
                .ebs,
                .efs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .efs: return "EFS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {

    /// The broker's deployment mode.
    public enum DeploymentMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeStandbyMultiAz
        case clusterMultiAz
        case singleInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentMode] {
            return [
                .activeStandbyMultiAz,
                .clusterMultiAz,
                .singleInstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeStandbyMultiAz: return "ACTIVE_STANDBY_MULTI_AZ"
            case .clusterMultiAz: return "CLUSTER_MULTI_AZ"
            case .singleInstance: return "SINGLE_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Option for host instance type.
    public struct BrokerInstanceOption {
        /// The list of available az.
        public var availabilityZones: [MqClientTypes.AvailabilityZone]?
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?
        /// The broker's storage type.
        public var storageType: MqClientTypes.BrokerStorageType?
        /// The list of supported deployment modes.
        public var supportedDeploymentModes: [MqClientTypes.DeploymentMode]?
        /// The list of supported engine versions.
        public var supportedEngineVersions: [Swift.String]?

        public init(
            availabilityZones: [MqClientTypes.AvailabilityZone]? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil,
            storageType: MqClientTypes.BrokerStorageType? = nil,
            supportedDeploymentModes: [MqClientTypes.DeploymentMode]? = nil,
            supportedEngineVersions: [Swift.String]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }
    }

}

extension MqClientTypes {

    /// The broker's status.
    public enum BrokerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case criticalActionRequired
        case deletionInProgress
        case rebootInProgress
        case replica
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerState] {
            return [
                .creationFailed,
                .creationInProgress,
                .criticalActionRequired,
                .deletionInProgress,
                .rebootInProgress,
                .replica,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .criticalActionRequired: return "CRITICAL_ACTION_REQUIRED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .rebootInProgress: return "REBOOT_IN_PROGRESS"
            case .replica: return "REPLICA"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerSummary {
        /// The broker's Amazon Resource Name (ARN).
        public var brokerArn: Swift.String?
        /// The unique ID that Amazon MQ generates for the broker.
        public var brokerId: Swift.String?
        /// The broker's name. This value is unique in your Amazon Web Services account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public var brokerName: Swift.String?
        /// The broker's status.
        public var brokerState: MqClientTypes.BrokerState?
        /// The time when the broker was created.
        public var created: Foundation.Date?
        /// The broker's deployment mode.
        /// This member is required.
        public var deploymentMode: MqClientTypes.DeploymentMode?
        /// The type of broker engine.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?

        public init(
            brokerArn: Swift.String? = nil,
            brokerId: Swift.String? = nil,
            brokerName: Swift.String? = nil,
            brokerState: MqClientTypes.BrokerState? = nil,
            created: Foundation.Date? = nil,
            deploymentMode: MqClientTypes.DeploymentMode? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil
        )
        {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }
    }

}

extension MqClientTypes {

    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public enum AuthenticationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ldap
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationStrategy] {
            return [
                .ldap,
                .simple
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ldap: return "LDAP"
            case .simple: return "SIMPLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Returns information about the specified configuration revision.
    public struct ConfigurationRevision {
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: Foundation.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// Required. The revision number of the configuration.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.created = created
            self.description = description
            self.revision = revision
        }
    }

}

extension MqClientTypes {
    /// Returns information about all configurations.
    public struct Configuration {
        /// Required. The ARN of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        /// This member is required.
        public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: Foundation.Date?
        /// Required. The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For a list of supported engine versions, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
        /// This member is required.
        public var engineVersion: Swift.String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Required. The latest revision of the configuration.
        /// This member is required.
        public var latestRevision: MqClientTypes.ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        /// This member is required.
        public var name: Swift.String?
        /// The list of all tags associated with this configuration.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            latestRevision: MqClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }
    }

}

extension MqClientTypes {
    /// A list of information about the configuration.
    public struct ConfigurationId {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// The revision number of the configuration.
        public var revision: Swift.Int?

        public init(
            id: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension MqClientTypes {

    /// The reason for which the configuration elements or attributes were sanitized.
    public enum SanitizationWarningReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disallowedAttributeRemoved
        case disallowedElementRemoved
        case invalidAttributeValueRemoved
        case sdkUnknown(Swift.String)

        public static var allCases: [SanitizationWarningReason] {
            return [
                .disallowedAttributeRemoved,
                .disallowedElementRemoved,
                .invalidAttributeValueRemoved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disallowedAttributeRemoved: return "DISALLOWED_ATTRIBUTE_REMOVED"
            case .disallowedElementRemoved: return "DISALLOWED_ELEMENT_REMOVED"
            case .invalidAttributeValueRemoved: return "INVALID_ATTRIBUTE_VALUE_REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Returns information about the configuration element or attribute that was sanitized in the configuration.
    public struct SanitizationWarning {
        /// The name of the configuration attribute that has been sanitized.
        public var attributeName: Swift.String?
        /// The name of the configuration element that has been sanitized.
        public var elementName: Swift.String?
        /// The reason for which the configuration elements or attributes were sanitized.
        /// This member is required.
        public var reason: MqClientTypes.SanitizationWarningReason?

        public init(
            attributeName: Swift.String? = nil,
            elementName: Swift.String? = nil,
            reason: MqClientTypes.SanitizationWarningReason? = nil
        )
        {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }
    }

}

extension MqClientTypes {
    /// A user associated with the broker. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    public struct User {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public var groups: [Swift.String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        /// This member is required.
        public var password: Swift.String?
        /// Defines if this user is intended for CRDR replication purposes.
        public var replicationUser: Swift.Bool?
        /// The username of the broker user. The following restrictions apply to broker usernames:
        ///
        /// * For Amazon MQ for ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        ///
        /// * para>For Amazon MQ for RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
        ///
        ///
        /// Do not add personally identifiable information (PII) or other confidential or sensitive information in broker usernames. Broker usernames are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker usernames are not intended to be used for private or sensitive data.
        /// This member is required.
        public var username: Swift.String?

        public init(
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            password: Swift.String? = nil,
            replicationUser: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.replicationUser = replicationUser
            self.username = username
        }
    }

}

extension MqClientTypes {

    /// The type of change pending for the ActiveMQ user.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .create,
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Returns a list of all broker users. Does not apply to RabbitMQ brokers.
    public struct UserSummary {
        /// The type of change pending for the broker user.
        public var pendingChange: MqClientTypes.ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        /// This member is required.
        public var username: Swift.String?

        public init(
            pendingChange: MqClientTypes.ChangeType? = nil,
            username: Swift.String? = nil
        )
        {
            self.pendingChange = pendingChange
            self.username = username
        }
    }

}

/// Returns information about an error.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

extension MqClientTypes {
    /// Broker configuration information
    public struct Configurations {
        /// The broker's current configuration.
        public var current: MqClientTypes.ConfigurationId?
        /// The history of configurations applied to the broker.
        public var history: [MqClientTypes.ConfigurationId]?
        /// The broker's pending configuration.
        public var pending: MqClientTypes.ConfigurationId?

        public init(
            current: MqClientTypes.ConfigurationId? = nil,
            history: [MqClientTypes.ConfigurationId]? = nil,
            pending: MqClientTypes.ConfigurationId? = nil
        )
        {
            self.current = current
            self.history = history
            self.pending = pending
        }
    }

}

/// Returns information about an error.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

extension MqClientTypes {

    /// Specifies whether a broker is a part of a data replication pair.
    public enum DataReplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crdr
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationMode] {
            return [
                .crdr,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crdr: return "CRDR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// Encryption options for the broker.
    public struct EncryptionOptions {
        /// The customer master key (CMK) to use for the A KMS (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// Enables the use of an Amazon Web Services owned CMK using KMS (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        /// This member is required.
        public var useAwsOwnedKey: Swift.Bool?

        public init(
            kmsKeyId: Swift.String? = nil,
            useAwsOwnedKey: Swift.Bool? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }
    }

}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public struct LdapServerMetadataInput {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountPassword: Swift.String?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init(
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountPassword: Swift.String? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct Logs {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init(
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension MqClientTypes {

    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MqClientTypes {
    /// The scheduled time period relative to UTC during which Amazon MQ begins to apply pending updates or patches to the broker.
    public struct WeeklyStartTime {
        /// Required. The day of the week.
        /// This member is required.
        public var dayOfWeek: MqClientTypes.DayOfWeek?
        /// Required. The time, in 24-hour format.
        /// This member is required.
        public var timeOfDay: Swift.String?
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public var timeZone: Swift.String?

        public init(
            dayOfWeek: MqClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }
    }

}

/// Creates a broker using the specified properties.
public struct CreateBrokerInput {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot. Set to true by default, if no value is specified. Must be set to true for ActiveMQ brokers version 5.18 and above and for RabbitMQ brokers version 3.13 and above.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The broker's name. This value must be unique in your Amazon Web Services account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters. Do not add personally identifiable information (PII) or other confidential or sensitive information in broker names. Broker names are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker names are not intended to be used for private or sensitive data.
    /// This member is required.
    public var brokerName: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
    public var creatorRequestId: Swift.String?
    /// Defines whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when dataReplicationMode is set to CRDR.
    public var dataReplicationPrimaryBrokerArn: Swift.String?
    /// Required. The broker's deployment mode.
    /// This member is required.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var engineVersion: Swift.String?
    /// Required. The broker's instance type.
    /// This member is required.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
    /// This member is required.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a [shared VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-sharing.html) for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your Amazon Web Services account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your Amazon Web Services account.
    public var subnetIds: [Swift.String]?
    /// Create tags when creating the broker.
    public var tags: [Swift.String: Swift.String]?
    /// The list of broker users (persons or applications) who can access queues and topics. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    /// This member is required.
    public var users: [MqClientTypes.User]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerName: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        creatorRequestId: Swift.String? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        dataReplicationPrimaryBrokerArn: Swift.String? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        users: [MqClientTypes.User]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerName = brokerName
        self.configuration = configuration
        self.creatorRequestId = creatorRequestId
        self.dataReplicationMode = dataReplicationMode
        self.dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArn
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

public struct CreateBrokerOutput {
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
    }
}

/// Creates a new configuration for the specified configuration name. Amazon MQ uses the default configuration (the engine type and version).
public struct CreateConfigurationInput {
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var engineVersion: Swift.String?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags when creating the configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateConfigurationOutput {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration.
    public var created: Foundation.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: Foundation.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
    }
}

/// Returns information about an error.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

/// A map of the key-value pairs for the resource tag.
public struct CreateTagsInput {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// Creates a new ActiveMQ user.
public struct CreateUserInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    /// This member is required.
    public var password: Swift.String?
    /// Defines if this user is intended for CRDR replication purposes.
    public var replicationUser: Swift.Bool?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.replicationUser = replicationUser
        self.username = username
    }
}

public struct CreateUserOutput {

    public init() { }
}

extension MqClientTypes {
    /// Specifies a broker in a data replication pair.
    public struct DataReplicationCounterpart {
        /// Required. The unique broker id generated by Amazon MQ.
        /// This member is required.
        public var brokerId: Swift.String?
        /// Required. The region of the broker.
        /// This member is required.
        public var region: Swift.String?

        public init(
            brokerId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.brokerId = brokerId
            self.region = region
        }
    }

}

extension MqClientTypes {
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode or pendingDataReplicationMode is set to CRDR.
    public struct DataReplicationMetadataOutput {
        /// Describes the replica/primary broker. Only returned if this broker is currently set as a primary or replica in the broker's dataReplicationRole property.
        public var dataReplicationCounterpart: MqClientTypes.DataReplicationCounterpart?
        /// Defines the role of this broker in a data replication pair. When a replica broker is promoted to primary, this role is interchanged.
        /// This member is required.
        public var dataReplicationRole: Swift.String?

        public init(
            dataReplicationCounterpart: MqClientTypes.DataReplicationCounterpart? = nil,
            dataReplicationRole: Swift.String? = nil
        )
        {
            self.dataReplicationCounterpart = dataReplicationCounterpart
            self.dataReplicationRole = dataReplicationRole
        }
    }

}

public struct DeleteBrokerInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

public struct DeleteBrokerOutput {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

public struct DeleteTagsInput {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct DeleteUserInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DescribeBrokerInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public struct LdapServerMetadataOutput {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init(
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct PendingLogs {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init(
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension MqClientTypes {
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public struct LogsSummary {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public var auditLogGroup: Swift.String?
        /// Enables general logging.
        /// This member is required.
        public var general: Swift.Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        /// This member is required.
        public var generalLogGroup: Swift.String?
        /// The list of information about logs pending to be deployed for the specified broker.
        public var pending: MqClientTypes.PendingLogs?

        public init(
            audit: Swift.Bool? = nil,
            auditLogGroup: Swift.String? = nil,
            general: Swift.Bool? = nil,
            generalLogGroup: Swift.String? = nil,
            pending: MqClientTypes.PendingLogs? = nil
        )
        {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }
    }

}

public struct DescribeBrokerOutput {
    /// Actions required for a broker.
    public var actionsRequired: [MqClientTypes.ActionRequired]?
    /// The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// A list of information about allocated brokers.
    public var brokerInstances: [MqClientTypes.BrokerInstance]?
    /// The broker's name. This value must be unique in your Amazon Web Services account account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    public var brokerName: Swift.String?
    /// The broker's status.
    public var brokerState: MqClientTypes.BrokerState?
    /// The list of all revisions for the specified configuration.
    public var configurations: MqClientTypes.Configurations?
    /// The time when the broker was created.
    public var created: Foundation.Date?
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
    public var dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker's deployment mode.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine version. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var engineVersion: Swift.String?
    /// The broker's instance type.
    public var hostInstanceType: Swift.String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public var logs: MqClientTypes.LogsSummary?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
    public var pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
    public var pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker will be a part of a data replication pair after reboot.
    public var pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version to upgrade to. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var pendingEngineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var pendingHostInstanceType: Swift.String?
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
    public var pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of pending security groups to authorize connections to brokers.
    public var pendingSecurityGroups: [Swift.String]?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
    public var subnetIds: [Swift.String]?
    /// The list of all tags associated with this broker.
    public var tags: [Swift.String: Swift.String]?
    /// The list of all broker usernames for the specified broker.
    public var users: [MqClientTypes.UserSummary]?

    public init(
        actionsRequired: [MqClientTypes.ActionRequired]? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil,
        brokerInstances: [MqClientTypes.BrokerInstance]? = nil,
        brokerName: Swift.String? = nil,
        brokerState: MqClientTypes.BrokerState? = nil,
        configurations: MqClientTypes.Configurations? = nil,
        created: Foundation.Date? = nil,
        dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.LogsSummary? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        pendingDataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        pendingEngineVersion: Swift.String? = nil,
        pendingHostInstanceType: Swift.String? = nil,
        pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        pendingSecurityGroups: [Swift.String]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.actionsRequired = actionsRequired
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerInstances = brokerInstances
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.configurations = configurations
        self.created = created
        self.dataReplicationMetadata = dataReplicationMetadata
        self.dataReplicationMode = dataReplicationMode
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
        self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
        self.pendingDataReplicationMode = pendingDataReplicationMode
        self.pendingEngineVersion = pendingEngineVersion
        self.pendingHostInstanceType = pendingHostInstanceType
        self.pendingLdapServerMetadata = pendingLdapServerMetadata
        self.pendingSecurityGroups = pendingSecurityGroups
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

public struct DescribeBrokerEngineTypesInput {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        engineType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeBrokerEngineTypesOutput {
    /// List of available engine types and versions.
    public var brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerEngineTypes: [MqClientTypes.BrokerEngineType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerEngineTypes = brokerEngineTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeBrokerInstanceOptionsInput {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// Filter response by host instance type.
    public var hostInstanceType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Filter response by storage type.
    public var storageType: Swift.String?

    public init(
        engineType: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageType: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageType = storageType
    }
}

public struct DescribeBrokerInstanceOptionsOutput {
    /// List of available broker instance options.
    public var brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerInstanceOptions = brokerInstanceOptions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationInput {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

public struct DescribeConfigurationOutput {
    /// Required. The ARN of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public var created: Foundation.Date?
    /// Required. The description of the configuration.
    public var description: Swift.String?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine version. Defaults to the latest available version for the specified broker engine type. For a list of supported engine versions, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var engineVersion: Swift.String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// Required. The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of all tags associated with this configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: Foundation.Date? = nil,
        description: Swift.String? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

public struct DescribeConfigurationRevisionInput {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The revision of the configuration.
    /// This member is required.
    public var configurationRevision: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        configurationRevision: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationRevision = configurationRevision
    }
}

public struct DescribeConfigurationRevisionOutput {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: Foundation.Date?
    /// Amazon MQ for ActiveMQ: the base64-encoded XML configuration. Amazon MQ for RabbitMQ: base64-encoded Cuttlefish.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        created: Foundation.Date? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.created = created
        self.data = data
        self.description = description
    }
}

public struct DescribeUserInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

extension MqClientTypes {
    /// Returns information about the status of the changes pending for the ActiveMQ user.
    public struct UserPendingChanges {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public var groups: [Swift.String]?
        /// Required. The type of change pending for the ActiveMQ user.
        /// This member is required.
        public var pendingChange: MqClientTypes.ChangeType?

        public init(
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            pendingChange: MqClientTypes.ChangeType? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }
    }

}

public struct DescribeUserOutput {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The status of the changes pending for the ActiveMQ user.
    public var pending: MqClientTypes.UserPendingChanges?
    /// Describes whether the user is intended for data replication
    public var replicationUser: Swift.Bool?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        pending: MqClientTypes.UserPendingChanges? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pending = pending
        self.replicationUser = replicationUser
        self.username = username
    }
}

public struct ListBrokersInput {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBrokersOutput {
    /// A list of information about all brokers.
    public var brokerSummaries: [MqClientTypes.BrokerSummary]?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerSummaries: [MqClientTypes.BrokerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerSummaries = brokerSummaries
        self.nextToken = nextToken
    }
}

public struct ListConfigurationRevisionsInput {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConfigurationRevisionsOutput {
    /// The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// The list of all revisions for the specified configuration.
    public var revisions: [MqClientTypes.ConfigurationRevision]?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisions: [MqClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

public struct ListConfigurationsInput {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConfigurationsOutput {
    /// The list of all revisions for the specified configuration.
    public var configurations: [MqClientTypes.Configuration]?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        configurations: [MqClientTypes.Configuration]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTagsInput {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsOutput {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListUsersInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListUsersOutput {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
    public var users: [MqClientTypes.UserSummary]?

    public init(
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.users = users
    }
}

extension MqClientTypes {

    /// The Promote mode requested.
    public enum PromoteMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case switchover
        case sdkUnknown(Swift.String)

        public static var allCases: [PromoteMode] {
            return [
                .failover,
                .switchover
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .switchover: return "SWITCHOVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Promotes a data replication replica broker to the primary broker role.
public struct PromoteInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The Promote mode requested. Note: Valid values for the parameter are SWITCHOVER, FAILOVER.
    /// This member is required.
    public var mode: MqClientTypes.PromoteMode?

    public init(
        brokerId: Swift.String? = nil,
        mode: MqClientTypes.PromoteMode? = nil
    )
    {
        self.brokerId = brokerId
        self.mode = mode
    }
}

public struct PromoteOutput {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

public struct RebootBrokerInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

public struct RebootBrokerOutput {

    public init() { }
}

/// Updates the broker using the specified properties.
public struct UpdateBrokerInput {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot. Must be set to true for ActiveMQ brokers version 5.18 and above and for RabbitMQ brokers version 3.13 and above.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// Defines whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide. When upgrading to ActiveMQ version 5.18 and above or RabbitMQ version 3.13 and above, you must have autoMinorVersionUpgrade set to true for the broker.
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.dataReplicationMode = dataReplicationMode
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

public struct UpdateBrokerOutput {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new patch versions for brokers as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// The ID of the updated configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
    public var dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version to upgrade to. For more information, see the [ActiveMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/activemq-version-management.html) and the [RabbitMQ version management](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/rabbitmq-version-management.html) sections in the Amazon MQ Developer Guide.
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs to be enabled for the specified broker.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
    public var pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker will be a part of a data replication pair after reboot.
    public var pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        pendingDataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.dataReplicationMetadata = dataReplicationMetadata
        self.dataReplicationMode = dataReplicationMode
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
        self.pendingDataReplicationMode = pendingDataReplicationMode
        self.securityGroups = securityGroups
    }
}

/// Updates the specified configuration.
public struct UpdateConfigurationInput {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Amazon MQ for Active MQ: The base64-encoded XML configuration. Amazon MQ for RabbitMQ: the base64-encoded Cuttlefish configuration.
    /// This member is required.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.data = data
        self.description = description
    }
}

public struct UpdateConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: Foundation.Date?
    /// The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of the first 20 warnings about the configuration elements or attributes that were sanitized.
    public var warnings: [MqClientTypes.SanitizationWarning]?

    public init(
        arn: Swift.String? = nil,
        created: Foundation.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        warnings: [MqClientTypes.SanitizationWarning]? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.warnings = warnings
    }
}

/// Updates the information for an ActiveMQ user.
public struct UpdateUserInput {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    public var password: Swift.String?
    /// Defines whether the user is intended for data replication.
    public var replicationUser: Swift.Bool?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.replicationUser = replicationUser
        self.username = username
    }
}

public struct UpdateUserOutput {

    public init() { }
}

extension CreateBrokerInput {

    static func urlPathProvider(_ value: CreateBrokerInput) -> Swift.String? {
        return "/v1/brokers"
    }
}

extension CreateConfigurationInput {

    static func urlPathProvider(_ value: CreateConfigurationInput) -> Swift.String? {
        return "/v1/configurations"
    }
}

extension CreateTagsInput {

    static func urlPathProvider(_ value: CreateTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        guard let username = value.username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

extension DeleteBrokerInput {

    static func urlPathProvider(_ value: DeleteBrokerInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

extension DeleteTagsInput {

    static func urlPathProvider(_ value: DeleteTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension DeleteTagsInput {

    static func queryItemProvider(_ value: DeleteTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        guard let username = value.username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

extension DescribeBrokerInput {

    static func urlPathProvider(_ value: DescribeBrokerInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

extension DescribeBrokerEngineTypesInput {

    static func urlPathProvider(_ value: DescribeBrokerEngineTypesInput) -> Swift.String? {
        return "/v1/broker-engine-types"
    }
}

extension DescribeBrokerEngineTypesInput {

    static func queryItemProvider(_ value: DescribeBrokerEngineTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = value.engineType {
            let engineTypeQueryItem = Smithy.URIQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension DescribeBrokerInstanceOptionsInput {

    static func urlPathProvider(_ value: DescribeBrokerInstanceOptionsInput) -> Swift.String? {
        return "/v1/broker-instance-options"
    }
}

extension DescribeBrokerInstanceOptionsInput {

    static func queryItemProvider(_ value: DescribeBrokerInstanceOptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let storageType = value.storageType {
            let storageTypeQueryItem = Smithy.URIQueryItem(name: "storageType".urlPercentEncoding(), value: Swift.String(storageType).urlPercentEncoding())
            items.append(storageTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = value.engineType {
            let engineTypeQueryItem = Smithy.URIQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        if let hostInstanceType = value.hostInstanceType {
            let hostInstanceTypeQueryItem = Smithy.URIQueryItem(name: "hostInstanceType".urlPercentEncoding(), value: Swift.String(hostInstanceType).urlPercentEncoding())
            items.append(hostInstanceTypeQueryItem)
        }
        return items
    }
}

extension DescribeConfigurationInput {

    static func urlPathProvider(_ value: DescribeConfigurationInput) -> Swift.String? {
        guard let configurationId = value.configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

extension DescribeConfigurationRevisionInput {

    static func urlPathProvider(_ value: DescribeConfigurationRevisionInput) -> Swift.String? {
        guard let configurationId = value.configurationId else {
            return nil
        }
        guard let configurationRevision = value.configurationRevision else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions/\(configurationRevision.urlPercentEncoding())"
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        guard let username = value.username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

extension ListBrokersInput {

    static func urlPathProvider(_ value: ListBrokersInput) -> Swift.String? {
        return "/v1/brokers"
    }
}

extension ListBrokersInput {

    static func queryItemProvider(_ value: ListBrokersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationRevisionsInput {

    static func urlPathProvider(_ value: ListConfigurationRevisionsInput) -> Swift.String? {
        guard let configurationId = value.configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions"
    }
}

extension ListConfigurationRevisionsInput {

    static func queryItemProvider(_ value: ListConfigurationRevisionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationsInput {

    static func urlPathProvider(_ value: ListConfigurationsInput) -> Swift.String? {
        return "/v1/configurations"
    }
}

extension ListConfigurationsInput {

    static func queryItemProvider(_ value: ListConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users"
    }
}

extension ListUsersInput {

    static func queryItemProvider(_ value: ListUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PromoteInput {

    static func urlPathProvider(_ value: PromoteInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/promote"
    }
}

extension RebootBrokerInput {

    static func urlPathProvider(_ value: RebootBrokerInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/reboot"
    }
}

extension UpdateBrokerInput {

    static func urlPathProvider(_ value: UpdateBrokerInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

extension UpdateConfigurationInput {

    static func urlPathProvider(_ value: UpdateConfigurationInput) -> Swift.String? {
        guard let configurationId = value.configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let brokerId = value.brokerId else {
            return nil
        }
        guard let username = value.username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

extension CreateBrokerInput {

    static func write(value: CreateBrokerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationStrategy"].write(value.authenticationStrategy)
        try writer["autoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["brokerName"].write(value.brokerName)
        try writer["configuration"].write(value.configuration, with: MqClientTypes.ConfigurationId.write(value:to:))
        try writer["creatorRequestId"].write(value.creatorRequestId)
        try writer["dataReplicationMode"].write(value.dataReplicationMode)
        try writer["dataReplicationPrimaryBrokerArn"].write(value.dataReplicationPrimaryBrokerArn)
        try writer["deploymentMode"].write(value.deploymentMode)
        try writer["encryptionOptions"].write(value.encryptionOptions, with: MqClientTypes.EncryptionOptions.write(value:to:))
        try writer["engineType"].write(value.engineType)
        try writer["engineVersion"].write(value.engineVersion)
        try writer["hostInstanceType"].write(value.hostInstanceType)
        try writer["ldapServerMetadata"].write(value.ldapServerMetadata, with: MqClientTypes.LdapServerMetadataInput.write(value:to:))
        try writer["logs"].write(value.logs, with: MqClientTypes.Logs.write(value:to:))
        try writer["maintenanceWindowStartTime"].write(value.maintenanceWindowStartTime, with: MqClientTypes.WeeklyStartTime.write(value:to:))
        try writer["publiclyAccessible"].write(value.publiclyAccessible)
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["storageType"].write(value.storageType)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["users"].writeList(value.users, memberWritingClosure: MqClientTypes.User.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateConfigurationInput {

    static func write(value: CreateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationStrategy"].write(value.authenticationStrategy)
        try writer["engineType"].write(value.engineType)
        try writer["engineVersion"].write(value.engineVersion)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTagsInput {

    static func write(value: CreateTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consoleAccess"].write(value.consoleAccess)
        try writer["groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["password"].write(value.password)
        try writer["replicationUser"].write(value.replicationUser)
    }
}

extension PromoteInput {

    static func write(value: PromoteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
    }
}

extension UpdateBrokerInput {

    static func write(value: UpdateBrokerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationStrategy"].write(value.authenticationStrategy)
        try writer["autoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["configuration"].write(value.configuration, with: MqClientTypes.ConfigurationId.write(value:to:))
        try writer["dataReplicationMode"].write(value.dataReplicationMode)
        try writer["engineVersion"].write(value.engineVersion)
        try writer["hostInstanceType"].write(value.hostInstanceType)
        try writer["ldapServerMetadata"].write(value.ldapServerMetadata, with: MqClientTypes.LdapServerMetadataInput.write(value:to:))
        try writer["logs"].write(value.logs, with: MqClientTypes.Logs.write(value:to:))
        try writer["maintenanceWindowStartTime"].write(value.maintenanceWindowStartTime, with: MqClientTypes.WeeklyStartTime.write(value:to:))
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateConfigurationInput {

    static func write(value: UpdateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["description"].write(value.description)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consoleAccess"].write(value.consoleAccess)
        try writer["groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["password"].write(value.password)
        try writer["replicationUser"].write(value.replicationUser)
    }
}

extension CreateBrokerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBrokerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBrokerOutput()
        value.brokerArn = try reader["brokerArn"].readIfPresent()
        value.brokerId = try reader["brokerId"].readIfPresent()
        return value
    }
}

extension CreateConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authenticationStrategy = try reader["authenticationStrategy"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: MqClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTagsOutput {
        return CreateTagsOutput()
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        return CreateUserOutput()
    }
}

extension DeleteBrokerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBrokerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBrokerOutput()
        value.brokerId = try reader["brokerId"].readIfPresent()
        return value
    }
}

extension DeleteTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTagsOutput {
        return DeleteTagsOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DescribeBrokerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBrokerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBrokerOutput()
        value.actionsRequired = try reader["actionsRequired"].readListIfPresent(memberReadingClosure: MqClientTypes.ActionRequired.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.authenticationStrategy = try reader["authenticationStrategy"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["autoMinorVersionUpgrade"].readIfPresent()
        value.brokerArn = try reader["brokerArn"].readIfPresent()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.brokerInstances = try reader["brokerInstances"].readListIfPresent(memberReadingClosure: MqClientTypes.BrokerInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.brokerName = try reader["brokerName"].readIfPresent()
        value.brokerState = try reader["brokerState"].readIfPresent()
        value.configurations = try reader["configurations"].readIfPresent(with: MqClientTypes.Configurations.read(from:))
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.dataReplicationMetadata = try reader["dataReplicationMetadata"].readIfPresent(with: MqClientTypes.DataReplicationMetadataOutput.read(from:))
        value.dataReplicationMode = try reader["dataReplicationMode"].readIfPresent()
        value.deploymentMode = try reader["deploymentMode"].readIfPresent()
        value.encryptionOptions = try reader["encryptionOptions"].readIfPresent(with: MqClientTypes.EncryptionOptions.read(from:))
        value.engineType = try reader["engineType"].readIfPresent()
        value.engineVersion = try reader["engineVersion"].readIfPresent()
        value.hostInstanceType = try reader["hostInstanceType"].readIfPresent()
        value.ldapServerMetadata = try reader["ldapServerMetadata"].readIfPresent(with: MqClientTypes.LdapServerMetadataOutput.read(from:))
        value.logs = try reader["logs"].readIfPresent(with: MqClientTypes.LogsSummary.read(from:))
        value.maintenanceWindowStartTime = try reader["maintenanceWindowStartTime"].readIfPresent(with: MqClientTypes.WeeklyStartTime.read(from:))
        value.pendingAuthenticationStrategy = try reader["pendingAuthenticationStrategy"].readIfPresent()
        value.pendingDataReplicationMetadata = try reader["pendingDataReplicationMetadata"].readIfPresent(with: MqClientTypes.DataReplicationMetadataOutput.read(from:))
        value.pendingDataReplicationMode = try reader["pendingDataReplicationMode"].readIfPresent()
        value.pendingEngineVersion = try reader["pendingEngineVersion"].readIfPresent()
        value.pendingHostInstanceType = try reader["pendingHostInstanceType"].readIfPresent()
        value.pendingLdapServerMetadata = try reader["pendingLdapServerMetadata"].readIfPresent(with: MqClientTypes.LdapServerMetadataOutput.read(from:))
        value.pendingSecurityGroups = try reader["pendingSecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.publiclyAccessible = try reader["publiclyAccessible"].readIfPresent()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageType = try reader["storageType"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: MqClientTypes.UserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeBrokerEngineTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBrokerEngineTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBrokerEngineTypesOutput()
        value.brokerEngineTypes = try reader["brokerEngineTypes"].readListIfPresent(memberReadingClosure: MqClientTypes.BrokerEngineType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeBrokerInstanceOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBrokerInstanceOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBrokerInstanceOptionsOutput()
        value.brokerInstanceOptions = try reader["brokerInstanceOptions"].readListIfPresent(memberReadingClosure: MqClientTypes.BrokerInstanceOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authenticationStrategy = try reader["authenticationStrategy"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.engineType = try reader["engineType"].readIfPresent()
        value.engineVersion = try reader["engineVersion"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: MqClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeConfigurationRevisionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationRevisionOutput()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.data = try reader["data"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension DescribeUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserOutput()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.consoleAccess = try reader["consoleAccess"].readIfPresent()
        value.groups = try reader["groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pending = try reader["pending"].readIfPresent(with: MqClientTypes.UserPendingChanges.read(from:))
        value.replicationUser = try reader["replicationUser"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        return value
    }
}

extension ListBrokersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBrokersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBrokersOutput()
        value.brokerSummaries = try reader["brokerSummaries"].readListIfPresent(memberReadingClosure: MqClientTypes.BrokerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConfigurationRevisionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationRevisionsOutput()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.revisions = try reader["revisions"].readListIfPresent(memberReadingClosure: MqClientTypes.ConfigurationRevision.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationsOutput()
        value.configurations = try reader["configurations"].readListIfPresent(memberReadingClosure: MqClientTypes.Configuration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.users = try reader["users"].readListIfPresent(memberReadingClosure: MqClientTypes.UserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PromoteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PromoteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PromoteOutput()
        value.brokerId = try reader["brokerId"].readIfPresent()
        return value
    }
}

extension RebootBrokerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebootBrokerOutput {
        return RebootBrokerOutput()
    }
}

extension UpdateBrokerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBrokerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBrokerOutput()
        value.authenticationStrategy = try reader["authenticationStrategy"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["autoMinorVersionUpgrade"].readIfPresent()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent(with: MqClientTypes.ConfigurationId.read(from:))
        value.dataReplicationMetadata = try reader["dataReplicationMetadata"].readIfPresent(with: MqClientTypes.DataReplicationMetadataOutput.read(from:))
        value.dataReplicationMode = try reader["dataReplicationMode"].readIfPresent()
        value.engineVersion = try reader["engineVersion"].readIfPresent()
        value.hostInstanceType = try reader["hostInstanceType"].readIfPresent()
        value.ldapServerMetadata = try reader["ldapServerMetadata"].readIfPresent(with: MqClientTypes.LdapServerMetadataOutput.read(from:))
        value.logs = try reader["logs"].readIfPresent(with: MqClientTypes.Logs.read(from:))
        value.maintenanceWindowStartTime = try reader["maintenanceWindowStartTime"].readIfPresent(with: MqClientTypes.WeeklyStartTime.read(from:))
        value.pendingDataReplicationMetadata = try reader["pendingDataReplicationMetadata"].readIfPresent(with: MqClientTypes.DataReplicationMetadataOutput.read(from:))
        value.pendingDataReplicationMode = try reader["pendingDataReplicationMode"].readIfPresent()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: MqClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: MqClientTypes.SanitizationWarning.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        return UpdateUserOutput()
    }
}

enum CreateBrokerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBrokerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBrokerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBrokerEngineTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBrokerInstanceOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationRevisionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBrokersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationRevisionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PromoteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebootBrokerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBrokerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.errorAttribute = try reader["errorAttribute"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MqClientTypes.ConfigurationRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.ConfigurationRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.ConfigurationRevision()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension MqClientTypes.ActionRequired {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.ActionRequired {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.ActionRequired()
        value.actionRequiredCode = try reader["actionRequiredCode"].readIfPresent()
        value.actionRequiredInfo = try reader["actionRequiredInfo"].readIfPresent()
        return value
    }
}

extension MqClientTypes.BrokerInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.BrokerInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.BrokerInstance()
        value.consoleURL = try reader["consoleURL"].readIfPresent()
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        return value
    }
}

extension MqClientTypes.Configurations {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.Configurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.Configurations()
        value.current = try reader["current"].readIfPresent(with: MqClientTypes.ConfigurationId.read(from:))
        value.history = try reader["history"].readListIfPresent(memberReadingClosure: MqClientTypes.ConfigurationId.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pending = try reader["pending"].readIfPresent(with: MqClientTypes.ConfigurationId.read(from:))
        return value
    }
}

extension MqClientTypes.ConfigurationId {

    static func write(value: MqClientTypes.ConfigurationId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["revision"].write(value.revision)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.ConfigurationId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.ConfigurationId()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.revision = try reader["revision"].readIfPresent()
        return value
    }
}

extension MqClientTypes.EncryptionOptions {

    static func write(value: MqClientTypes.EncryptionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["useAwsOwnedKey"].write(value.useAwsOwnedKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.EncryptionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.EncryptionOptions()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.useAwsOwnedKey = try reader["useAwsOwnedKey"].readIfPresent() ?? false
        return value
    }
}

extension MqClientTypes.LdapServerMetadataOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.LdapServerMetadataOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.LdapServerMetadataOutput()
        value.hosts = try reader["hosts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.roleBase = try reader["roleBase"].readIfPresent() ?? ""
        value.roleName = try reader["roleName"].readIfPresent()
        value.roleSearchMatching = try reader["roleSearchMatching"].readIfPresent() ?? ""
        value.roleSearchSubtree = try reader["roleSearchSubtree"].readIfPresent()
        value.serviceAccountUsername = try reader["serviceAccountUsername"].readIfPresent() ?? ""
        value.userBase = try reader["userBase"].readIfPresent() ?? ""
        value.userRoleName = try reader["userRoleName"].readIfPresent()
        value.userSearchMatching = try reader["userSearchMatching"].readIfPresent() ?? ""
        value.userSearchSubtree = try reader["userSearchSubtree"].readIfPresent()
        return value
    }
}

extension MqClientTypes.LogsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.LogsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.LogsSummary()
        value.audit = try reader["audit"].readIfPresent()
        value.auditLogGroup = try reader["auditLogGroup"].readIfPresent()
        value.general = try reader["general"].readIfPresent() ?? false
        value.generalLogGroup = try reader["generalLogGroup"].readIfPresent() ?? ""
        value.pending = try reader["pending"].readIfPresent(with: MqClientTypes.PendingLogs.read(from:))
        return value
    }
}

extension MqClientTypes.PendingLogs {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.PendingLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.PendingLogs()
        value.audit = try reader["audit"].readIfPresent()
        value.general = try reader["general"].readIfPresent()
        return value
    }
}

extension MqClientTypes.WeeklyStartTime {

    static func write(value: MqClientTypes.WeeklyStartTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dayOfWeek"].write(value.dayOfWeek)
        try writer["timeOfDay"].write(value.timeOfDay)
        try writer["timeZone"].write(value.timeZone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.WeeklyStartTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.WeeklyStartTime()
        value.dayOfWeek = try reader["dayOfWeek"].readIfPresent() ?? .sdkUnknown("")
        value.timeOfDay = try reader["timeOfDay"].readIfPresent() ?? ""
        value.timeZone = try reader["timeZone"].readIfPresent()
        return value
    }
}

extension MqClientTypes.UserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.UserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.UserSummary()
        value.pendingChange = try reader["pendingChange"].readIfPresent()
        value.username = try reader["username"].readIfPresent() ?? ""
        return value
    }
}

extension MqClientTypes.DataReplicationMetadataOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.DataReplicationMetadataOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.DataReplicationMetadataOutput()
        value.dataReplicationCounterpart = try reader["dataReplicationCounterpart"].readIfPresent(with: MqClientTypes.DataReplicationCounterpart.read(from:))
        value.dataReplicationRole = try reader["dataReplicationRole"].readIfPresent() ?? ""
        return value
    }
}

extension MqClientTypes.DataReplicationCounterpart {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.DataReplicationCounterpart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.DataReplicationCounterpart()
        value.brokerId = try reader["brokerId"].readIfPresent() ?? ""
        value.region = try reader["region"].readIfPresent() ?? ""
        return value
    }
}

extension MqClientTypes.BrokerEngineType {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.BrokerEngineType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.BrokerEngineType()
        value.engineType = try reader["engineType"].readIfPresent()
        value.engineVersions = try reader["engineVersions"].readListIfPresent(memberReadingClosure: MqClientTypes.EngineVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MqClientTypes.EngineVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.EngineVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.EngineVersion()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension MqClientTypes.BrokerInstanceOption {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.BrokerInstanceOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.BrokerInstanceOption()
        value.availabilityZones = try reader["availabilityZones"].readListIfPresent(memberReadingClosure: MqClientTypes.AvailabilityZone.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.engineType = try reader["engineType"].readIfPresent()
        value.hostInstanceType = try reader["hostInstanceType"].readIfPresent()
        value.storageType = try reader["storageType"].readIfPresent()
        value.supportedDeploymentModes = try reader["supportedDeploymentModes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MqClientTypes.DeploymentMode>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedEngineVersions = try reader["supportedEngineVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MqClientTypes.AvailabilityZone {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.AvailabilityZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.AvailabilityZone()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension MqClientTypes.UserPendingChanges {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.UserPendingChanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.UserPendingChanges()
        value.consoleAccess = try reader["consoleAccess"].readIfPresent()
        value.groups = try reader["groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pendingChange = try reader["pendingChange"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MqClientTypes.BrokerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.BrokerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.BrokerSummary()
        value.brokerArn = try reader["brokerArn"].readIfPresent()
        value.brokerId = try reader["brokerId"].readIfPresent()
        value.brokerName = try reader["brokerName"].readIfPresent()
        value.brokerState = try reader["brokerState"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentMode = try reader["deploymentMode"].readIfPresent() ?? .sdkUnknown("")
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.hostInstanceType = try reader["hostInstanceType"].readIfPresent()
        return value
    }
}

extension MqClientTypes.Configuration {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.Configuration()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.authenticationStrategy = try reader["authenticationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent() ?? ""
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.engineVersion = try reader["engineVersion"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: MqClientTypes.ConfigurationRevision.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MqClientTypes.Logs {

    static func write(value: MqClientTypes.Logs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audit"].write(value.audit)
        try writer["general"].write(value.general)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.Logs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.Logs()
        value.audit = try reader["audit"].readIfPresent()
        value.general = try reader["general"].readIfPresent()
        return value
    }
}

extension MqClientTypes.SanitizationWarning {

    static func read(from reader: SmithyJSON.Reader) throws -> MqClientTypes.SanitizationWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MqClientTypes.SanitizationWarning()
        value.attributeName = try reader["attributeName"].readIfPresent()
        value.elementName = try reader["elementName"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MqClientTypes.LdapServerMetadataInput {

    static func write(value: MqClientTypes.LdapServerMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hosts"].writeList(value.hosts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleBase"].write(value.roleBase)
        try writer["roleName"].write(value.roleName)
        try writer["roleSearchMatching"].write(value.roleSearchMatching)
        try writer["roleSearchSubtree"].write(value.roleSearchSubtree)
        try writer["serviceAccountPassword"].write(value.serviceAccountPassword)
        try writer["serviceAccountUsername"].write(value.serviceAccountUsername)
        try writer["userBase"].write(value.userBase)
        try writer["userRoleName"].write(value.userRoleName)
        try writer["userSearchMatching"].write(value.userSearchMatching)
        try writer["userSearchSubtree"].write(value.userSearchSubtree)
    }
}

extension MqClientTypes.User {

    static func write(value: MqClientTypes.User?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["consoleAccess"].write(value.consoleAccess)
        try writer["groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["password"].write(value.password)
        try writer["replicationUser"].write(value.replicationUser)
        try writer["username"].write(value.username)
    }
}

public enum MqClientTypes {}
