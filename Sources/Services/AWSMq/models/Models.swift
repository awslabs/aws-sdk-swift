// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MqClientTypes.ActionRequired: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionRequiredCode = "actionRequiredCode"
        case actionRequiredInfo = "actionRequiredInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionRequiredCode = self.actionRequiredCode {
            try encodeContainer.encode(actionRequiredCode, forKey: .actionRequiredCode)
        }
        if let actionRequiredInfo = self.actionRequiredInfo {
            try encodeContainer.encode(actionRequiredInfo, forKey: .actionRequiredInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionRequiredCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionRequiredCode)
        actionRequiredCode = actionRequiredCodeDecoded
        let actionRequiredInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionRequiredInfo)
        actionRequiredInfo = actionRequiredInfoDecoded
    }
}

extension MqClientTypes {
    /// Action required for a broker.
    public struct ActionRequired: Swift.Equatable {
        /// The code you can use to find instructions on the action required to resolve your broker issue.
        public var actionRequiredCode: Swift.String?
        /// Information about the action required to resolve your broker issue.
        public var actionRequiredInfo: Swift.String?

        public init(
            actionRequiredCode: Swift.String? = nil,
            actionRequiredInfo: Swift.String? = nil
        )
        {
            self.actionRequiredCode = actionRequiredCode
            self.actionRequiredInfo = actionRequiredInfo
        }
    }

}

extension MqClientTypes {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public enum AuthenticationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ldap
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationStrategy] {
            return [
                .ldap,
                .simple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ldap: return "LDAP"
            case .simple: return "SIMPLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationStrategy(rawValue: rawValue) ?? AuthenticationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes {
    /// Name of the availability zone.
    public struct AvailabilityZone: Swift.Equatable {
        /// Id for the availability zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.BrokerEngineType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineType = "engineType"
        case engineVersions = "engineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersions = engineVersions {
            var engineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineVersions)
            for engineversion0 in engineVersions {
                try engineVersionsContainer.encode(engineversion0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionsContainer = try containerValues.decodeIfPresent([MqClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[MqClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [MqClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
    }
}

extension MqClientTypes {
    /// Types of broker engines.
    public struct BrokerEngineType: Swift.Equatable {
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The list of engine versions.
        public var engineVersions: [MqClientTypes.EngineVersion]?

        public init(
            engineType: MqClientTypes.EngineType? = nil,
            engineVersions: [MqClientTypes.EngineVersion]? = nil
        )
        {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }
    }

}

extension MqClientTypes.BrokerInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleURL = "consoleURL"
        case endpoints = "endpoints"
        case ipAddress = "ipAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleURL = self.consoleURL {
            try encodeContainer.encode(consoleURL, forKey: .consoleURL)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __string0 in endpoints {
                try endpointsContainer.encode(__string0)
            }
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleURL)
        consoleURL = consoleURLDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerInstance: Swift.Equatable {
        /// The brokers web console URL.
        public var consoleURL: Swift.String?
        /// The broker's wire-level protocol endpoints.
        public var endpoints: [Swift.String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public var ipAddress: Swift.String?

        public init(
            consoleURL: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }
    }

}

extension MqClientTypes.BrokerInstanceOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "availabilityZones"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
        case storageType = "storageType"
        case supportedDeploymentModes = "supportedDeploymentModes"
        case supportedEngineVersions = "supportedEngineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = self.hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let supportedDeploymentModes = supportedDeploymentModes {
            var supportedDeploymentModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDeploymentModes)
            for deploymentmode0 in supportedDeploymentModes {
                try supportedDeploymentModesContainer.encode(deploymentmode0.rawValue)
            }
        }
        if let supportedEngineVersions = supportedEngineVersions {
            var supportedEngineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngineVersions)
            for __string0 in supportedEngineVersions {
                try supportedEngineVersionsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([MqClientTypes.AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[MqClientTypes.AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [MqClientTypes.AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportedDeploymentModesContainer = try containerValues.decodeIfPresent([MqClientTypes.DeploymentMode?].self, forKey: .supportedDeploymentModes)
        var supportedDeploymentModesDecoded0:[MqClientTypes.DeploymentMode]? = nil
        if let supportedDeploymentModesContainer = supportedDeploymentModesContainer {
            supportedDeploymentModesDecoded0 = [MqClientTypes.DeploymentMode]()
            for enum0 in supportedDeploymentModesContainer {
                if let enum0 = enum0 {
                    supportedDeploymentModesDecoded0?.append(enum0)
                }
            }
        }
        supportedDeploymentModes = supportedDeploymentModesDecoded0
        let supportedEngineVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedEngineVersions)
        var supportedEngineVersionsDecoded0:[Swift.String]? = nil
        if let supportedEngineVersionsContainer = supportedEngineVersionsContainer {
            supportedEngineVersionsDecoded0 = [Swift.String]()
            for string0 in supportedEngineVersionsContainer {
                if let string0 = string0 {
                    supportedEngineVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedEngineVersions = supportedEngineVersionsDecoded0
    }
}

extension MqClientTypes {
    /// Option for host instance type.
    public struct BrokerInstanceOption: Swift.Equatable {
        /// The list of available az.
        public var availabilityZones: [MqClientTypes.AvailabilityZone]?
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?
        /// The broker's storage type.
        public var storageType: MqClientTypes.BrokerStorageType?
        /// The list of supported deployment modes.
        public var supportedDeploymentModes: [MqClientTypes.DeploymentMode]?
        /// The list of supported engine versions.
        public var supportedEngineVersions: [Swift.String]?

        public init(
            availabilityZones: [MqClientTypes.AvailabilityZone]? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil,
            storageType: MqClientTypes.BrokerStorageType? = nil,
            supportedDeploymentModes: [MqClientTypes.DeploymentMode]? = nil,
            supportedEngineVersions: [Swift.String]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }
    }

}

extension MqClientTypes {
    /// The broker's status.
    public enum BrokerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case criticalActionRequired
        case deletionInProgress
        case rebootInProgress
        case replica
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerState] {
            return [
                .creationFailed,
                .creationInProgress,
                .criticalActionRequired,
                .deletionInProgress,
                .rebootInProgress,
                .replica,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .criticalActionRequired: return "CRITICAL_ACTION_REQUIRED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .rebootInProgress: return "REBOOT_IN_PROGRESS"
            case .replica: return "REPLICA"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerState(rawValue: rawValue) ?? BrokerState.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes {
    /// The broker's storage type. EFS is not supported for RabbitMQ engine type.
    public enum BrokerStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case efs
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerStorageType] {
            return [
                .ebs,
                .efs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .efs: return "EFS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerStorageType(rawValue: rawValue) ?? BrokerStorageType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.BrokerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerArn = self.brokerArn {
            try encodeContainer.encode(brokerArn, forKey: .brokerArn)
        }
        if let brokerId = self.brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let brokerName = self.brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let brokerState = self.brokerState {
            try encodeContainer.encode(brokerState.rawValue, forKey: .brokerState)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let deploymentMode = self.deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = self.hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
    }
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerSummary: Swift.Equatable {
        /// The broker's Amazon Resource Name (ARN).
        public var brokerArn: Swift.String?
        /// The unique ID that Amazon MQ generates for the broker.
        public var brokerId: Swift.String?
        /// The broker's name. This value is unique in your Amazon Web Services account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public var brokerName: Swift.String?
        /// The broker's status.
        public var brokerState: MqClientTypes.BrokerState?
        /// The time when the broker was created.
        public var created: ClientRuntime.Date?
        /// The broker's deployment mode.
        /// This member is required.
        public var deploymentMode: MqClientTypes.DeploymentMode?
        /// The type of broker engine.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?

        public init(
            brokerArn: Swift.String? = nil,
            brokerId: Swift.String? = nil,
            brokerName: Swift.String? = nil,
            brokerState: MqClientTypes.BrokerState? = nil,
            created: ClientRuntime.Date? = nil,
            deploymentMode: MqClientTypes.DeploymentMode? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil
        )
        {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }
    }

}

extension MqClientTypes {
    /// The type of change pending for the ActiveMQ user.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationStrategy = self.authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let latestRevision = self.latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MqClientTypes {
    /// Returns information about all configurations.
    public struct Configuration: Swift.Equatable {
        /// Required. The ARN of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        /// This member is required.
        public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// Required. The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// Required. The broker engine's version. For a list of supported engine versions, see, [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
        /// This member is required.
        public var engineVersion: Swift.String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Required. The latest revision of the configuration.
        /// This member is required.
        public var latestRevision: MqClientTypes.ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        /// This member is required.
        public var name: Swift.String?
        /// The list of all tags associated with this configuration.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            latestRevision: MqClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }
    }

}

extension MqClientTypes.ConfigurationId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes {
    /// A list of information about the configuration.
    public struct ConfigurationId: Swift.Equatable {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// The revision number of the configuration.
        public var revision: Swift.Int?

        public init(
            id: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension MqClientTypes.ConfigurationRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "created"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .dateTime, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the specified configuration revision.
    public struct ConfigurationRevision: Swift.Equatable {
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// Required. The revision number of the configuration.
        /// This member is required.
        public var revision: Swift.Int?

        public init(
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.created = created
            self.description = description
            self.revision = revision
        }
    }

}

extension MqClientTypes.Configurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case current = "current"
        case history = "history"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let current = self.current {
            try encodeContainer.encode(current, forKey: .current)
        }
        if let history = history {
            var historyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .history)
            for configurationid0 in history {
                try historyContainer.encode(configurationid0)
            }
        }
        if let pending = self.pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .current)
        current = currentDecoded
        let historyContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationId?].self, forKey: .history)
        var historyDecoded0:[MqClientTypes.ConfigurationId]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [MqClientTypes.ConfigurationId]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes {
    /// Broker configuration information
    public struct Configurations: Swift.Equatable {
        /// The broker's current configuration.
        public var current: MqClientTypes.ConfigurationId?
        /// The history of configurations applied to the broker.
        public var history: [MqClientTypes.ConfigurationId]?
        /// The broker's pending configuration.
        public var pending: MqClientTypes.ConfigurationId?

        public init(
            current: MqClientTypes.ConfigurationId? = nil,
            history: [MqClientTypes.ConfigurationId]? = nil,
            pending: MqClientTypes.ConfigurationId? = nil
        )
        {
            self.current = current
            self.history = history
            self.pending = pending
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBrokerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case dataReplicationMode = "dataReplicationMode"
        case dataReplicationPrimaryBrokerArn = "dataReplicationPrimaryBrokerArn"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = self.authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let brokerName = self.brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let dataReplicationMode = self.dataReplicationMode {
            try encodeContainer.encode(dataReplicationMode.rawValue, forKey: .dataReplicationMode)
        }
        if let dataReplicationPrimaryBrokerArn = self.dataReplicationPrimaryBrokerArn {
            try encodeContainer.encode(dataReplicationPrimaryBrokerArn, forKey: .dataReplicationPrimaryBrokerArn)
        }
        if let deploymentMode = self.deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let encryptionOptions = self.encryptionOptions {
            try encodeContainer.encode(encryptionOptions, forKey: .encryptionOptions)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = self.hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = self.ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = self.logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = self.maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __string0 in securityGroups {
                try securityGroupsContainer.encode(__string0)
            }
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __string0 in subnetIds {
                try subnetIdsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for user0 in users {
                try usersContainer.encode(user0)
            }
        }
    }
}

extension CreateBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/brokers"
    }
}

/// Creates a broker using the specified properties.
public struct CreateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot. Set to true by default, if no value is specified.
    /// This member is required.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The broker's name. This value must be unique in your Amazon Web Services account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters. Do not add personally identifiable information (PII) or other confidential or sensitive information in broker names. Broker names are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker names are not intended to be used for private or sensitive data.
    /// This member is required.
    public var brokerName: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
    public var creatorRequestId: Swift.String?
    /// Defines whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The Amazon Resource Name (ARN) of the primary broker that is used to replicate data from in a data replication pair, and is applied to the replica broker. Must be set when dataReplicationMode is set to CRDR.
    public var dataReplicationPrimaryBrokerArn: Swift.String?
    /// Required. The broker's deployment mode.
    /// This member is required.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The broker's instance type.
    /// This member is required.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
    /// This member is required.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a [shared VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-sharing.html) for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your Amazon Web Services account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your Amazon Web Services account.
    public var subnetIds: [Swift.String]?
    /// Create tags when creating the broker.
    public var tags: [Swift.String:Swift.String]?
    /// The list of broker users (persons or applications) who can access queues and topics. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    /// This member is required.
    public var users: [MqClientTypes.User]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerName: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        creatorRequestId: Swift.String? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        dataReplicationPrimaryBrokerArn: Swift.String? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.User]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerName = brokerName
        self.configuration = configuration
        self.creatorRequestId = creatorRequestId
        self.dataReplicationMode = dataReplicationMode
        self.dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArn
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct CreateBrokerInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerName: Swift.String?
    let configuration: MqClientTypes.ConfigurationId?
    let creatorRequestId: Swift.String?
    let deploymentMode: MqClientTypes.DeploymentMode?
    let encryptionOptions: MqClientTypes.EncryptionOptions?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let publiclyAccessible: Swift.Bool?
    let securityGroups: [Swift.String]?
    let storageType: MqClientTypes.BrokerStorageType?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let users: [MqClientTypes.User]?
    let dataReplicationMode: MqClientTypes.DataReplicationMode?
    let dataReplicationPrimaryBrokerArn: Swift.String?
}

extension CreateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case dataReplicationMode = "dataReplicationMode"
        case dataReplicationPrimaryBrokerArn = "dataReplicationPrimaryBrokerArn"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let dataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .dataReplicationMode)
        dataReplicationMode = dataReplicationModeDecoded
        let dataReplicationPrimaryBrokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataReplicationPrimaryBrokerArn)
        dataReplicationPrimaryBrokerArn = dataReplicationPrimaryBrokerArnDecoded
    }
}

extension CreateBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBrokerOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
        } else {
            self.brokerArn = nil
            self.brokerId = nil
        }
    }
}

public struct CreateBrokerOutput: Swift.Equatable {
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
    }
}

struct CreateBrokerOutputBody: Swift.Equatable {
    let brokerArn: Swift.String?
    let brokerId: Swift.String?
}

extension CreateBrokerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

enum CreateBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = self.authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

/// Creates a new configuration for the specified configuration name. Amazon MQ uses the default configuration (the engine type and version).
public struct CreateConfigurationInput: Swift.Equatable {
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags when creating the configuration.
    public var tags: [Swift.String:Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigurationInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
        }
    }
}

public struct CreateConfigurationOutput: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
    }
}

struct CreateConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let created: ClientRuntime.Date?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
}

extension CreateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// A map of the key-value pairs for the resource tag.
public struct CreateTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTagsOutput: Swift.Equatable {

    public init() { }
}

enum CreateTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case replicationUser = "replicationUser"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = self.consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __string0 in groups {
                try groupsContainer.encode(__string0)
            }
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let replicationUser = self.replicationUser {
            try encodeContainer.encode(replicationUser, forKey: .replicationUser)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

/// Creates a new ActiveMQ user.
public struct CreateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    /// This member is required.
    public var password: Swift.String?
    /// Defines if this user is intended for CRDR replication purposes.
    public var replicationUser: Swift.Bool?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.replicationUser = replicationUser
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let password: Swift.String?
    let replicationUser: Swift.Bool?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case replicationUser = "replicationUser"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let replicationUserDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicationUser)
        replicationUser = replicationUserDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateUserOutput: Swift.Equatable {

    public init() { }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes.DataReplicationCounterpart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case region = "region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerId = self.brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension MqClientTypes {
    /// Specifies a broker in a data replication pair.
    public struct DataReplicationCounterpart: Swift.Equatable {
        /// Required. The unique broker id generated by Amazon MQ.
        /// This member is required.
        public var brokerId: Swift.String?
        /// Required. The region of the broker.
        /// This member is required.
        public var region: Swift.String?

        public init(
            brokerId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.brokerId = brokerId
            self.region = region
        }
    }

}

extension MqClientTypes.DataReplicationMetadataOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationCounterpart = "dataReplicationCounterpart"
        case dataReplicationRole = "dataReplicationRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationCounterpart = self.dataReplicationCounterpart {
            try encodeContainer.encode(dataReplicationCounterpart, forKey: .dataReplicationCounterpart)
        }
        if let dataReplicationRole = self.dataReplicationRole {
            try encodeContainer.encode(dataReplicationRole, forKey: .dataReplicationRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataReplicationCounterpartDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationCounterpart.self, forKey: .dataReplicationCounterpart)
        dataReplicationCounterpart = dataReplicationCounterpartDecoded
        let dataReplicationRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataReplicationRole)
        dataReplicationRole = dataReplicationRoleDecoded
    }
}

extension MqClientTypes {
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode or pendingDataReplicationMode is set to CRDR.
    public struct DataReplicationMetadataOutput: Swift.Equatable {
        /// Describes the replica/primary broker. Only returned if this broker is currently set as a primary or replica in the broker's dataReplicationRole property.
        public var dataReplicationCounterpart: MqClientTypes.DataReplicationCounterpart?
        /// Defines the role of this broker in a data replication pair. When a replica broker is promoted to primary, this role is interchanged.
        /// This member is required.
        public var dataReplicationRole: Swift.String?

        public init(
            dataReplicationCounterpart: MqClientTypes.DataReplicationCounterpart? = nil,
            dataReplicationRole: Swift.String? = nil
        )
        {
            self.dataReplicationCounterpart = dataReplicationCounterpart
            self.dataReplicationRole = dataReplicationRole
        }
    }

}

extension MqClientTypes {
    /// Specifies whether a broker is a part of a data replication pair.
    public enum DataReplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crdr
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationMode] {
            return [
                .crdr,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crdr: return "CRDR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationMode(rawValue: rawValue) ?? DataReplicationMode.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

public struct DeleteBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerInputBody: Swift.Equatable {
}

extension DeleteBrokerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBrokerOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
        } else {
            self.brokerId = nil
        }
    }
}

public struct DeleteBrokerOutput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerOutputBody: Swift.Equatable {
    let brokerId: Swift.String?
}

extension DeleteBrokerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

enum DeleteBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
}

extension DeleteTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTagsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes {
    /// The broker's deployment mode.
    public enum DeploymentMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeStandbyMultiAz
        case clusterMultiAz
        case singleInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentMode] {
            return [
                .activeStandbyMultiAz,
                .clusterMultiAz,
                .singleInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeStandbyMultiAz: return "ACTIVE_STANDBY_MULTI_AZ"
            case .clusterMultiAz: return "CLUSTER_MULTI_AZ"
            case .singleInstance: return "SINGLE_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentMode(rawValue: rawValue) ?? DeploymentMode.sdkUnknown(rawValue)
        }
    }
}

extension DescribeBrokerEngineTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let engineType = engineType {
                let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
                items.append(engineTypeQueryItem)
            }
            return items
        }
    }
}

extension DescribeBrokerEngineTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/broker-engine-types"
    }
}

public struct DescribeBrokerEngineTypesInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        engineType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesInputBody: Swift.Equatable {
}

extension DescribeBrokerEngineTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerEngineTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBrokerEngineTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerEngineTypes = output.brokerEngineTypes
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerEngineTypes = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerEngineTypesOutput: Swift.Equatable {
    /// List of available engine types and versions.
    public var brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerEngineTypes: [MqClientTypes.BrokerEngineType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerEngineTypes = brokerEngineTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesOutputBody: Swift.Equatable {
    let brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBrokerEngineTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerEngineTypes = "brokerEngineTypes"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEngineTypesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerEngineType?].self, forKey: .brokerEngineTypes)
        var brokerEngineTypesDecoded0:[MqClientTypes.BrokerEngineType]? = nil
        if let brokerEngineTypesContainer = brokerEngineTypesContainer {
            brokerEngineTypesDecoded0 = [MqClientTypes.BrokerEngineType]()
            for structure0 in brokerEngineTypesContainer {
                if let structure0 = structure0 {
                    brokerEngineTypesDecoded0?.append(structure0)
                }
            }
        }
        brokerEngineTypes = brokerEngineTypesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBrokerEngineTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

public struct DescribeBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DescribeBrokerInputBody: Swift.Equatable {
}

extension DescribeBrokerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let storageType = storageType {
                let storageTypeQueryItem = ClientRuntime.URLQueryItem(name: "storageType".urlPercentEncoding(), value: Swift.String(storageType).urlPercentEncoding())
                items.append(storageTypeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let engineType = engineType {
                let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
                items.append(engineTypeQueryItem)
            }
            if let hostInstanceType = hostInstanceType {
                let hostInstanceTypeQueryItem = ClientRuntime.URLQueryItem(name: "hostInstanceType".urlPercentEncoding(), value: Swift.String(hostInstanceType).urlPercentEncoding())
                items.append(hostInstanceTypeQueryItem)
            }
            return items
        }
    }
}

extension DescribeBrokerInstanceOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/broker-instance-options"
    }
}

public struct DescribeBrokerInstanceOptionsInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// Filter response by host instance type.
    public var hostInstanceType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Filter response by storage type.
    public var storageType: Swift.String?

    public init(
        engineType: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageType: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageType = storageType
    }
}

struct DescribeBrokerInstanceOptionsInputBody: Swift.Equatable {
}

extension DescribeBrokerInstanceOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBrokerInstanceOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerInstanceOptions = output.brokerInstanceOptions
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerInstanceOptions = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerInstanceOptionsOutput: Swift.Equatable {
    /// List of available broker instance options.
    public var brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerInstanceOptions = brokerInstanceOptions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerInstanceOptionsOutputBody: Swift.Equatable {
    let brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBrokerInstanceOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerInstanceOptions = "brokerInstanceOptions"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerInstanceOptionsContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstanceOption?].self, forKey: .brokerInstanceOptions)
        var brokerInstanceOptionsDecoded0:[MqClientTypes.BrokerInstanceOption]? = nil
        if let brokerInstanceOptionsContainer = brokerInstanceOptionsContainer {
            brokerInstanceOptionsDecoded0 = [MqClientTypes.BrokerInstanceOption]()
            for structure0 in brokerInstanceOptionsContainer {
                if let structure0 = structure0 {
                    brokerInstanceOptionsDecoded0?.append(structure0)
                }
            }
        }
        brokerInstanceOptions = brokerInstanceOptionsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBrokerInstanceOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBrokerOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionsRequired = output.actionsRequired
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
            self.brokerInstances = output.brokerInstances
            self.brokerName = output.brokerName
            self.brokerState = output.brokerState
            self.configurations = output.configurations
            self.created = output.created
            self.dataReplicationMetadata = output.dataReplicationMetadata
            self.dataReplicationMode = output.dataReplicationMode
            self.deploymentMode = output.deploymentMode
            self.encryptionOptions = output.encryptionOptions
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = output.pendingAuthenticationStrategy
            self.pendingDataReplicationMetadata = output.pendingDataReplicationMetadata
            self.pendingDataReplicationMode = output.pendingDataReplicationMode
            self.pendingEngineVersion = output.pendingEngineVersion
            self.pendingHostInstanceType = output.pendingHostInstanceType
            self.pendingLdapServerMetadata = output.pendingLdapServerMetadata
            self.pendingSecurityGroups = output.pendingSecurityGroups
            self.publiclyAccessible = output.publiclyAccessible
            self.securityGroups = output.securityGroups
            self.storageType = output.storageType
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.users = output.users
        } else {
            self.actionsRequired = nil
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerArn = nil
            self.brokerId = nil
            self.brokerInstances = nil
            self.brokerName = nil
            self.brokerState = nil
            self.configurations = nil
            self.created = nil
            self.dataReplicationMetadata = nil
            self.dataReplicationMode = nil
            self.deploymentMode = nil
            self.encryptionOptions = nil
            self.engineType = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.pendingAuthenticationStrategy = nil
            self.pendingDataReplicationMetadata = nil
            self.pendingDataReplicationMode = nil
            self.pendingEngineVersion = nil
            self.pendingHostInstanceType = nil
            self.pendingLdapServerMetadata = nil
            self.pendingSecurityGroups = nil
            self.publiclyAccessible = nil
            self.securityGroups = nil
            self.storageType = nil
            self.subnetIds = nil
            self.tags = nil
            self.users = nil
        }
    }
}

public struct DescribeBrokerOutput: Swift.Equatable {
    /// Actions required for a broker.
    public var actionsRequired: [MqClientTypes.ActionRequired]?
    /// The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// A list of information about allocated brokers.
    public var brokerInstances: [MqClientTypes.BrokerInstance]?
    /// The broker's name. This value must be unique in your Amazon Web Services account account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    public var brokerName: Swift.String?
    /// The broker's status.
    public var brokerState: MqClientTypes.BrokerState?
    /// The list of all revisions for the specified configuration.
    public var configurations: MqClientTypes.Configurations?
    /// The time when the broker was created.
    public var created: ClientRuntime.Date?
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
    public var dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker's deployment mode.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine's version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's instance type.
    public var hostInstanceType: Swift.String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public var logs: MqClientTypes.LogsSummary?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
    public var pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
    public var pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker will be a part of a data replication pair after reboot.
    public var pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var pendingEngineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var pendingHostInstanceType: Swift.String?
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
    public var pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of pending security groups to authorize connections to brokers.
    public var pendingSecurityGroups: [Swift.String]?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
    public var subnetIds: [Swift.String]?
    /// The list of all tags associated with this broker.
    public var tags: [Swift.String:Swift.String]?
    /// The list of all broker usernames for the specified broker.
    public var users: [MqClientTypes.UserSummary]?

    public init(
        actionsRequired: [MqClientTypes.ActionRequired]? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil,
        brokerInstances: [MqClientTypes.BrokerInstance]? = nil,
        brokerName: Swift.String? = nil,
        brokerState: MqClientTypes.BrokerState? = nil,
        configurations: MqClientTypes.Configurations? = nil,
        created: ClientRuntime.Date? = nil,
        dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.LogsSummary? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        pendingDataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        pendingEngineVersion: Swift.String? = nil,
        pendingHostInstanceType: Swift.String? = nil,
        pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        pendingSecurityGroups: [Swift.String]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.actionsRequired = actionsRequired
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerInstances = brokerInstances
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.configurations = configurations
        self.created = created
        self.dataReplicationMetadata = dataReplicationMetadata
        self.dataReplicationMode = dataReplicationMode
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
        self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
        self.pendingDataReplicationMode = pendingDataReplicationMode
        self.pendingEngineVersion = pendingEngineVersion
        self.pendingHostInstanceType = pendingHostInstanceType
        self.pendingLdapServerMetadata = pendingLdapServerMetadata
        self.pendingSecurityGroups = pendingSecurityGroups
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct DescribeBrokerOutputBody: Swift.Equatable {
    let actionsRequired: [MqClientTypes.ActionRequired]?
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerArn: Swift.String?
    let brokerId: Swift.String?
    let brokerInstances: [MqClientTypes.BrokerInstance]?
    let brokerName: Swift.String?
    let brokerState: MqClientTypes.BrokerState?
    let configurations: MqClientTypes.Configurations?
    let created: ClientRuntime.Date?
    let deploymentMode: MqClientTypes.DeploymentMode?
    let encryptionOptions: MqClientTypes.EncryptionOptions?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let logs: MqClientTypes.LogsSummary?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let pendingEngineVersion: Swift.String?
    let pendingHostInstanceType: Swift.String?
    let pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let pendingSecurityGroups: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let securityGroups: [Swift.String]?
    let storageType: MqClientTypes.BrokerStorageType?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let users: [MqClientTypes.UserSummary]?
    let dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    let dataReplicationMode: MqClientTypes.DataReplicationMode?
    let pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    let pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
}

extension DescribeBrokerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsRequired = "actionsRequired"
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerInstances = "brokerInstances"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case configurations = "configurations"
        case created = "created"
        case dataReplicationMetadata = "dataReplicationMetadata"
        case dataReplicationMode = "dataReplicationMode"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case pendingAuthenticationStrategy = "pendingAuthenticationStrategy"
        case pendingDataReplicationMetadata = "pendingDataReplicationMetadata"
        case pendingDataReplicationMode = "pendingDataReplicationMode"
        case pendingEngineVersion = "pendingEngineVersion"
        case pendingHostInstanceType = "pendingHostInstanceType"
        case pendingLdapServerMetadata = "pendingLdapServerMetadata"
        case pendingSecurityGroups = "pendingSecurityGroups"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsRequiredContainer = try containerValues.decodeIfPresent([MqClientTypes.ActionRequired?].self, forKey: .actionsRequired)
        var actionsRequiredDecoded0:[MqClientTypes.ActionRequired]? = nil
        if let actionsRequiredContainer = actionsRequiredContainer {
            actionsRequiredDecoded0 = [MqClientTypes.ActionRequired]()
            for structure0 in actionsRequiredContainer {
                if let structure0 = structure0 {
                    actionsRequiredDecoded0?.append(structure0)
                }
            }
        }
        actionsRequired = actionsRequiredDecoded0
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerInstancesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstance?].self, forKey: .brokerInstances)
        var brokerInstancesDecoded0:[MqClientTypes.BrokerInstance]? = nil
        if let brokerInstancesContainer = brokerInstancesContainer {
            brokerInstancesDecoded0 = [MqClientTypes.BrokerInstance]()
            for structure0 in brokerInstancesContainer {
                if let structure0 = structure0 {
                    brokerInstancesDecoded0?.append(structure0)
                }
            }
        }
        brokerInstances = brokerInstancesDecoded0
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let configurationsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Configurations.self, forKey: .configurations)
        configurations = configurationsDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.LogsSummary.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let pendingAuthenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .pendingAuthenticationStrategy)
        pendingAuthenticationStrategy = pendingAuthenticationStrategyDecoded
        let pendingEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingEngineVersion)
        pendingEngineVersion = pendingEngineVersionDecoded
        let pendingHostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingHostInstanceType)
        pendingHostInstanceType = pendingHostInstanceTypeDecoded
        let pendingLdapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .pendingLdapServerMetadata)
        pendingLdapServerMetadata = pendingLdapServerMetadataDecoded
        let pendingSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pendingSecurityGroups)
        var pendingSecurityGroupsDecoded0:[Swift.String]? = nil
        if let pendingSecurityGroupsContainer = pendingSecurityGroupsContainer {
            pendingSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in pendingSecurityGroupsContainer {
                if let string0 = string0 {
                    pendingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        pendingSecurityGroups = pendingSecurityGroupsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let dataReplicationMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMetadataOutput.self, forKey: .dataReplicationMetadata)
        dataReplicationMetadata = dataReplicationMetadataDecoded
        let dataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .dataReplicationMode)
        dataReplicationMode = dataReplicationModeDecoded
        let pendingDataReplicationMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMetadataOutput.self, forKey: .pendingDataReplicationMetadata)
        pendingDataReplicationMetadata = pendingDataReplicationMetadataDecoded
        let pendingDataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .pendingDataReplicationMode)
        pendingDataReplicationMode = pendingDataReplicationModeDecoded
    }
}

enum DescribeBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct DescribeConfigurationInputBody: Swift.Equatable {
}

extension DescribeConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.description = output.description
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.description = nil
            self.engineType = nil
            self.engineVersion = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct DescribeConfigurationOutput: Swift.Equatable {
    /// Required. The ARN of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public var created: ClientRuntime.Date?
    /// Required. The description of the configuration.
    public var description: Swift.String?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see, [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// Required. The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of all tags associated with this configuration.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

struct DescribeConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let created: ClientRuntime.Date?
    let description: Swift.String?
    let engineType: MqClientTypes.EngineType?
    let engineVersion: Swift.String?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationRevisionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        guard let configurationRevision = configurationRevision else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions/\(configurationRevision.urlPercentEncoding())"
    }
}

public struct DescribeConfigurationRevisionInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The revision of the configuration.
    /// This member is required.
    public var configurationRevision: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        configurationRevision: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationRevision = configurationRevision
    }
}

struct DescribeConfigurationRevisionInputBody: Swift.Equatable {
}

extension DescribeConfigurationRevisionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.created = output.created
            self.data = output.data
            self.description = output.description
        } else {
            self.configurationId = nil
            self.created = nil
            self.data = nil
            self.description = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutput: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Amazon MQ for ActiveMQ: the base64-encoded XML configuration. Amazon MQ for RabbitMQ: base64-encoded Cuttlefish.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.created = created
        self.data = data
        self.description = description
    }
}

struct DescribeConfigurationRevisionOutputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let created: ClientRuntime.Date?
    let data: Swift.String?
    let description: Swift.String?
}

extension DescribeConfigurationRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case created = "created"
        case data = "data"
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum DescribeConfigurationRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.consoleAccess = output.consoleAccess
            self.groups = output.groups
            self.pending = output.pending
            self.replicationUser = output.replicationUser
            self.username = output.username
        } else {
            self.brokerId = nil
            self.consoleAccess = nil
            self.groups = nil
            self.pending = nil
            self.replicationUser = nil
            self.username = nil
        }
    }
}

public struct DescribeUserOutput: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The status of the changes pending for the ActiveMQ user.
    public var pending: MqClientTypes.UserPendingChanges?
    /// Describes whether the user is intended for data replication
    public var replicationUser: Swift.Bool?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        pending: MqClientTypes.UserPendingChanges? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pending = pending
        self.replicationUser = replicationUser
        self.username = username
    }
}

struct DescribeUserOutputBody: Swift.Equatable {
    let brokerId: Swift.String?
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let pending: MqClientTypes.UserPendingChanges?
    let username: Swift.String?
    let replicationUser: Swift.Bool?
}

extension DescribeUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pending = "pending"
        case replicationUser = "replicationUser"
        case username = "username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.UserPendingChanges.self, forKey: .pending)
        pending = pendingDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let replicationUserDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicationUser)
        replicationUser = replicationUserDecoded
    }
}

enum DescribeUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes.EncryptionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "kmsKeyId"
        case useAwsOwnedKey = "useAwsOwnedKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let useAwsOwnedKey = self.useAwsOwnedKey {
            try encodeContainer.encode(useAwsOwnedKey, forKey: .useAwsOwnedKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let useAwsOwnedKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAwsOwnedKey)
        useAwsOwnedKey = useAwsOwnedKeyDecoded
    }
}

extension MqClientTypes {
    /// Encryption options for the broker.
    public struct EncryptionOptions: Swift.Equatable {
        /// The customer master key (CMK) to use for the A KMS (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// Enables the use of an Amazon Web Services owned CMK using KMS (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        /// This member is required.
        public var useAwsOwnedKey: Swift.Bool?

        public init(
            kmsKeyId: Swift.String? = nil,
            useAwsOwnedKey: Swift.Bool? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }
    }

}

extension MqClientTypes {
    /// The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activemq
        case rabbitmq
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .activemq,
                .rabbitmq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activemq: return "ACTIVEMQ"
            case .rabbitmq: return "RABBITMQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes {
    /// Id of the engine version.
    public struct EngineVersion: Swift.Equatable {
        /// Id for the version.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.LdapServerMetadataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountPassword = "serviceAccountPassword"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __string0 in hosts {
                try hostsContainer.encode(__string0)
            }
        }
        if let roleBase = self.roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = self.roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = self.roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountPassword = self.serviceAccountPassword {
            try encodeContainer.encode(serviceAccountPassword, forKey: .serviceAccountPassword)
        }
        if let serviceAccountUsername = self.serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = self.userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = self.userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = self.userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = self.userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountPassword)
        serviceAccountPassword = serviceAccountPasswordDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public struct LdapServerMetadataInput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountPassword: Swift.String?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init(
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountPassword: Swift.String? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension MqClientTypes.LdapServerMetadataOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __string0 in hosts {
                try hostsContainer.encode(__string0)
            }
        }
        if let roleBase = self.roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = self.roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = self.roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountUsername = self.serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = self.userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = self.userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = self.userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = self.userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public struct LdapServerMetadataOutput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as Directory Service for Microsoft Active Directory. Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example, dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp, dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init(
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension ListBrokersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBrokersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/brokers"
    }
}

public struct ListBrokersInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrokersInputBody: Swift.Equatable {
}

extension ListBrokersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBrokersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBrokersOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerSummaries = output.brokerSummaries
            self.nextToken = output.nextToken
        } else {
            self.brokerSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrokersOutput: Swift.Equatable {
    /// A list of information about all brokers.
    public var brokerSummaries: [MqClientTypes.BrokerSummary]?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerSummaries: [MqClientTypes.BrokerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerSummaries = brokerSummaries
        self.nextToken = nextToken
    }
}

struct ListBrokersOutputBody: Swift.Equatable {
    let brokerSummaries: [MqClientTypes.BrokerSummary]?
    let nextToken: Swift.String?
}

extension ListBrokersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerSummaries = "brokerSummaries"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerSummariesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerSummary?].self, forKey: .brokerSummaries)
        var brokerSummariesDecoded0:[MqClientTypes.BrokerSummary]? = nil
        if let brokerSummariesContainer = brokerSummariesContainer {
            brokerSummariesDecoded0 = [MqClientTypes.BrokerSummary]()
            for structure0 in brokerSummariesContainer {
                if let structure0 = structure0 {
                    brokerSummariesDecoded0?.append(structure0)
                }
            }
        }
        brokerSummaries = brokerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBrokersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfigurationRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions"
    }
}

public struct ListConfigurationRevisionsInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Swift.Equatable {
}

extension ListConfigurationRevisionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.configurationId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// The list of all revisions for the specified configuration.
    public var revisions: [MqClientTypes.ConfigurationRevision]?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisions: [MqClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let revisions: [MqClientTypes.ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[MqClientTypes.ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [MqClientTypes.ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

enum ListConfigurationRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/configurations"
    }
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
}

extension ListConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutput: Swift.Equatable {
    /// The list of all revisions for the specified configuration.
    public var configurations: [MqClientTypes.Configuration]?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        configurations: [MqClientTypes.Configuration]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputBody: Swift.Equatable {
    let configurations: [MqClientTypes.Configuration]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "configurations"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([MqClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[MqClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [MqClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.brokerId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
    public var users: [MqClientTypes.UserSummary]?

    public init(
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let brokerId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let users: [MqClientTypes.UserSummary]?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case users = "users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes.Logs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = self.audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = self.general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct Logs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init(
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension MqClientTypes.LogsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case auditLogGroup = "auditLogGroup"
        case general = "general"
        case generalLogGroup = "generalLogGroup"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = self.audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let auditLogGroup = self.auditLogGroup {
            try encodeContainer.encode(auditLogGroup, forKey: .auditLogGroup)
        }
        if let general = self.general {
            try encodeContainer.encode(general, forKey: .general)
        }
        if let generalLogGroup = self.generalLogGroup {
            try encodeContainer.encode(generalLogGroup, forKey: .generalLogGroup)
        }
        if let pending = self.pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let auditLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditLogGroup)
        auditLogGroup = auditLogGroupDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
        let generalLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generalLogGroup)
        generalLogGroup = generalLogGroupDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.PendingLogs.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public struct LogsSummary: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public var auditLogGroup: Swift.String?
        /// Enables general logging.
        /// This member is required.
        public var general: Swift.Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        /// This member is required.
        public var generalLogGroup: Swift.String?
        /// The list of information about logs pending to be deployed for the specified broker.
        public var pending: MqClientTypes.PendingLogs?

        public init(
            audit: Swift.Bool? = nil,
            auditLogGroup: Swift.String? = nil,
            general: Swift.Bool? = nil,
            generalLogGroup: Swift.String? = nil,
            pending: MqClientTypes.PendingLogs? = nil
        )
        {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.PendingLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = self.audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = self.general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct PendingLogs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init(
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension PromoteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }
}

extension PromoteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/promote"
    }
}

/// Promotes a data replication replica broker to the primary broker role.
public struct PromoteInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The Promote mode requested. Note: Valid values for the parameter are SWITCHOVER, FAILOVER.
    /// This member is required.
    public var mode: MqClientTypes.PromoteMode?

    public init(
        brokerId: Swift.String? = nil,
        mode: MqClientTypes.PromoteMode? = nil
    )
    {
        self.brokerId = brokerId
        self.mode = mode
    }
}

struct PromoteInputBody: Swift.Equatable {
    let mode: MqClientTypes.PromoteMode?
}

extension PromoteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "mode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(MqClientTypes.PromoteMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension MqClientTypes {
    /// The Promote mode requested.
    public enum PromoteMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failover
        case switchover
        case sdkUnknown(Swift.String)

        public static var allCases: [PromoteMode] {
            return [
                .failover,
                .switchover,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .switchover: return "SWITCHOVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromoteMode(rawValue: rawValue) ?? PromoteMode.sdkUnknown(rawValue)
        }
    }
}

extension PromoteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PromoteOutputBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
        } else {
            self.brokerId = nil
        }
    }
}

public struct PromoteOutput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct PromoteOutputBody: Swift.Equatable {
    let brokerId: Swift.String?
}

extension PromoteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

enum PromoteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RebootBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/reboot"
    }
}

public struct RebootBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init(
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct RebootBrokerInputBody: Swift.Equatable {
}

extension RebootBrokerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RebootBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RebootBrokerOutput: Swift.Equatable {

    public init() { }
}

enum RebootBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes.SanitizationWarning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case elementName = "elementName"
        case reason = "reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let elementName = self.elementName {
            try encodeContainer.encode(elementName, forKey: .elementName)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let elementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elementName)
        elementName = elementNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MqClientTypes.SanitizationWarningReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the configuration element or attribute that was sanitized in the configuration.
    public struct SanitizationWarning: Swift.Equatable {
        /// The name of the configuration attribute that has been sanitized.
        public var attributeName: Swift.String?
        /// The name of the configuration element that has been sanitized.
        public var elementName: Swift.String?
        /// The reason for which the configuration elements or attributes were sanitized.
        /// This member is required.
        public var reason: MqClientTypes.SanitizationWarningReason?

        public init(
            attributeName: Swift.String? = nil,
            elementName: Swift.String? = nil,
            reason: MqClientTypes.SanitizationWarningReason? = nil
        )
        {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }
    }

}

extension MqClientTypes {
    /// The reason for which the configuration elements or attributes were sanitized.
    public enum SanitizationWarningReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disallowedAttributeRemoved
        case disallowedElementRemoved
        case invalidAttributeValueRemoved
        case sdkUnknown(Swift.String)

        public static var allCases: [SanitizationWarningReason] {
            return [
                .disallowedAttributeRemoved,
                .disallowedElementRemoved,
                .invalidAttributeValueRemoved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disallowedAttributeRemoved: return "DISALLOWED_ATTRIBUTE_REMOVED"
            case .disallowedElementRemoved: return "DISALLOWED_ELEMENT_REMOVED"
            case .invalidAttributeValueRemoved: return "INVALID_ATTRIBUTE_VALUE_REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SanitizationWarningReason(rawValue: rawValue) ?? SanitizationWarningReason.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorAttribute = output.errorAttribute
            self.properties.message = output.message
        } else {
            self.properties.errorAttribute = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The attribute which caused the error.
        public internal(set) var errorAttribute: Swift.String? = nil
        /// The explanation of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorAttribute = errorAttribute
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let errorAttribute: Swift.String?
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateBrokerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case dataReplicationMode = "dataReplicationMode"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = self.authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let dataReplicationMode = self.dataReplicationMode {
            try encodeContainer.encode(dataReplicationMode.rawValue, forKey: .dataReplicationMode)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = self.hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = self.ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = self.logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = self.maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __string0 in securityGroups {
                try securityGroupsContainer.encode(__string0)
            }
        }
    }
}

extension UpdateBrokerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())"
    }
}

/// Updates the broker using the specified properties.
public struct UpdateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// Defines whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.dataReplicationMode = dataReplicationMode
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerInputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let configuration: MqClientTypes.ConfigurationId?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let securityGroups: [Swift.String]?
    let dataReplicationMode: MqClientTypes.DataReplicationMode?
}

extension UpdateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case dataReplicationMode = "dataReplicationMode"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let dataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .dataReplicationMode)
        dataReplicationMode = dataReplicationModeDecoded
    }
}

extension UpdateBrokerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBrokerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerId = output.brokerId
            self.configuration = output.configuration
            self.dataReplicationMetadata = output.dataReplicationMetadata
            self.dataReplicationMode = output.dataReplicationMode
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.pendingDataReplicationMetadata = output.pendingDataReplicationMetadata
            self.pendingDataReplicationMode = output.pendingDataReplicationMode
            self.securityGroups = output.securityGroups
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerId = nil
            self.configuration = nil
            self.dataReplicationMetadata = nil
            self.dataReplicationMode = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.pendingDataReplicationMetadata = nil
            self.pendingDataReplicationMode = nil
            self.securityGroups = nil
        }
    }
}

public struct UpdateBrokerOutput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The new boolean value that specifies whether broker engines automatically upgrade to new minor versions as new versions are released and supported by Amazon MQ.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// The ID of the updated configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The replication details of the data replication-enabled broker. Only returned if dataReplicationMode is set to CRDR.
    public var dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker is a part of a data replication pair.
    public var dataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see [Supported engines](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html).
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see [Broker instance types](https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types).
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs to be enabled for the specified broker.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The pending replication details of the data replication-enabled broker. Only returned if pendingDataReplicationMode is set to CRDR.
    public var pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    /// Describes whether this broker will be a part of a data replication pair after reboot.
    public var pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init(
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        dataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput? = nil,
        pendingDataReplicationMode: MqClientTypes.DataReplicationMode? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.dataReplicationMetadata = dataReplicationMetadata
        self.dataReplicationMode = dataReplicationMode
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingDataReplicationMetadata = pendingDataReplicationMetadata
        self.pendingDataReplicationMode = pendingDataReplicationMode
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerOutputBody: Swift.Equatable {
    let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    let autoMinorVersionUpgrade: Swift.Bool?
    let brokerId: Swift.String?
    let configuration: MqClientTypes.ConfigurationId?
    let engineVersion: Swift.String?
    let hostInstanceType: Swift.String?
    let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    let logs: MqClientTypes.Logs?
    let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    let securityGroups: [Swift.String]?
    let dataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    let dataReplicationMode: MqClientTypes.DataReplicationMode?
    let pendingDataReplicationMetadata: MqClientTypes.DataReplicationMetadataOutput?
    let pendingDataReplicationMode: MqClientTypes.DataReplicationMode?
}

extension UpdateBrokerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerId = "brokerId"
        case configuration = "configuration"
        case dataReplicationMetadata = "dataReplicationMetadata"
        case dataReplicationMode = "dataReplicationMode"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case pendingDataReplicationMetadata = "pendingDataReplicationMetadata"
        case pendingDataReplicationMode = "pendingDataReplicationMode"
        case securityGroups = "securityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let dataReplicationMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMetadataOutput.self, forKey: .dataReplicationMetadata)
        dataReplicationMetadata = dataReplicationMetadataDecoded
        let dataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .dataReplicationMode)
        dataReplicationMode = dataReplicationModeDecoded
        let pendingDataReplicationMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMetadataOutput.self, forKey: .pendingDataReplicationMetadata)
        pendingDataReplicationMetadata = pendingDataReplicationMetadataDecoded
        let pendingDataReplicationModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DataReplicationMode.self, forKey: .pendingDataReplicationMode)
        pendingDataReplicationMode = pendingDataReplicationModeDecoded
    }
}

enum UpdateBrokerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationId = configurationId else {
            return nil
        }
        return "/v1/configurations/\(configurationId.urlPercentEncoding())"
    }
}

/// Updates the specified configuration.
public struct UpdateConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Amazon MQ for Active MQ: The base64-encoded XML configuration. Amazon MQ for RabbitMQ: the base64-encoded Cuttlefish configuration.
    /// This member is required.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.data = data
        self.description = description
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    let data: Swift.String?
    let description: Swift.String?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.warnings = output.warnings
        } else {
            self.arn = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.warnings = nil
        }
    }
}

public struct UpdateConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of the first 20 warnings about the configuration elements or attributes that were sanitized.
    public var warnings: [MqClientTypes.SanitizationWarning]?

    public init(
        arn: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        warnings: [MqClientTypes.SanitizationWarning]? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.warnings = warnings
    }
}

struct UpdateConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let created: ClientRuntime.Date?
    let id: Swift.String?
    let latestRevision: MqClientTypes.ConfigurationRevision?
    let name: Swift.String?
    let warnings: [MqClientTypes.SanitizationWarning]?
}

extension UpdateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let warningsContainer = try containerValues.decodeIfPresent([MqClientTypes.SanitizationWarning?].self, forKey: .warnings)
        var warningsDecoded0:[MqClientTypes.SanitizationWarning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [MqClientTypes.SanitizationWarning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum UpdateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case replicationUser = "replicationUser"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = self.consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __string0 in groups {
                try groupsContainer.encode(__string0)
            }
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let replicationUser = self.replicationUser {
            try encodeContainer.encode(replicationUser, forKey: .replicationUser)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let brokerId = brokerId else {
            return nil
        }
        guard let username = username else {
            return nil
        }
        return "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
    }
}

/// Updates the information for an ActiveMQ user.
public struct UpdateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    public var password: Swift.String?
    /// Defines whether the user is intended for data replication.
    public var replicationUser: Swift.Bool?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init(
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        replicationUser: Swift.Bool? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.replicationUser = replicationUser
        self.username = username
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let consoleAccess: Swift.Bool?
    let groups: [Swift.String]?
    let password: Swift.String?
    let replicationUser: Swift.Bool?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case replicationUser = "replicationUser"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let replicationUserDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicationUser)
        replicationUser = replicationUserDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MqClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case replicationUser = "replicationUser"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = self.consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __string0 in groups {
                try groupsContainer.encode(__string0)
            }
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let replicationUser = self.replicationUser {
            try encodeContainer.encode(replicationUser, forKey: .replicationUser)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let replicationUserDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicationUser)
        replicationUser = replicationUserDecoded
    }
}

extension MqClientTypes {
    /// A user associated with the broker. For Amazon MQ for RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    public struct User: Swift.Equatable {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public var groups: [Swift.String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        /// This member is required.
        public var password: Swift.String?
        /// Defines if this user is intended for CRDR replication purposes.
        public var replicationUser: Swift.Bool?
        /// The username of the broker user. The following restrictions apply to broker usernames:
        ///
        /// * For Amazon MQ for ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        ///
        /// * para>For Amazon MQ for RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
        ///
        ///
        /// Do not add personally identifiable information (PII) or other confidential or sensitive information in broker usernames. Broker usernames are accessible to other Amazon Web Services services, including CloudWatch Logs. Broker usernames are not intended to be used for private or sensitive data.
        /// This member is required.
        public var username: Swift.String?

        public init(
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            password: Swift.String? = nil,
            replicationUser: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.replicationUser = replicationUser
            self.username = username
        }
    }

}

extension MqClientTypes.UserPendingChanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pendingChange = "pendingChange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = self.consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __string0 in groups {
                try groupsContainer.encode(__string0)
            }
        }
        if let pendingChange = self.pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
    }
}

extension MqClientTypes {
    /// Returns information about the status of the changes pending for the ActiveMQ user.
    public struct UserPendingChanges: Swift.Equatable {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public var groups: [Swift.String]?
        /// Required. The type of change pending for the ActiveMQ user.
        /// This member is required.
        public var pendingChange: MqClientTypes.ChangeType?

        public init(
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            pendingChange: MqClientTypes.ChangeType? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }
    }

}

extension MqClientTypes.UserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingChange = "pendingChange"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingChange = self.pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes {
    /// Returns a list of all broker users. Does not apply to RabbitMQ brokers.
    public struct UserSummary: Swift.Equatable {
        /// The type of change pending for the broker user.
        public var pendingChange: MqClientTypes.ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        /// This member is required.
        public var username: Swift.String?

        public init(
            pendingChange: MqClientTypes.ChangeType? = nil,
            username: Swift.String? = nil
        )
        {
            self.pendingChange = pendingChange
            self.username = username
        }
    }

}

extension MqClientTypes.WeeklyStartTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfWeek = "dayOfWeek"
        case timeOfDay = "timeOfDay"
        case timeZone = "timeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let timeOfDay = self.timeOfDay {
            try encodeContainer.encode(timeOfDay, forKey: .timeOfDay)
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(MqClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let timeOfDayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeOfDay)
        timeOfDay = timeOfDayDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
    }
}

extension MqClientTypes {
    /// The scheduled time period relative to UTC during which Amazon MQ begins to apply pending updates or patches to the broker.
    public struct WeeklyStartTime: Swift.Equatable {
        /// Required. The day of the week.
        /// This member is required.
        public var dayOfWeek: MqClientTypes.DayOfWeek?
        /// Required. The time, in 24-hour format.
        /// This member is required.
        public var timeOfDay: Swift.String?
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public var timeZone: Swift.String?

        public init(
            dayOfWeek: MqClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }
    }

}
