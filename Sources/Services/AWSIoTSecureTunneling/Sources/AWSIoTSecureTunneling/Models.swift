//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension IoTSecureTunnelingClientTypes {

    public enum ClientMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case destination
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientMode] {
            return [
                .all,
                .destination,
                .source
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .destination: return "DESTINATION"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Thrown when an operation is attempted on a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CloseTunnelInput: Swift.Sendable {
    /// When set to true, IoT Secure Tunneling deletes the tunnel data immediately.
    public var delete: Swift.Bool?
    /// The ID of the tunnel to close.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        delete: Swift.Bool? = false,
        tunnelId: Swift.String? = nil
    )
    {
        self.delete = delete
        self.tunnelId = tunnelId
    }
}

public struct CloseTunnelOutput: Swift.Sendable {

    public init() { }
}

extension IoTSecureTunnelingClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSecureTunnelingClientTypes {

    /// The state of a connection.
    public struct ConnectionState: Swift.Sendable {
        /// The last time the connection status was updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The connection status of the tunnel. Valid values are CONNECTED and DISCONNECTED.
        public var status: IoTSecureTunnelingClientTypes.ConnectionStatus?

        public init(
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTSecureTunnelingClientTypes.ConnectionStatus? = nil
        )
        {
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }
}

public struct DescribeTunnelInput: Swift.Sendable {
    /// The tunnel to describe.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        tunnelId: Swift.String? = nil
    )
    {
        self.tunnelId = tunnelId
    }
}

extension IoTSecureTunnelingClientTypes {

    /// The destination configuration.
    public struct DestinationConfig: Swift.Sendable {
        /// A list of service names that identify the target application. The IoT client running on the destination device reads this value and uses it to look up a port or an IP address and a port. The IoT client instantiates the local proxy, which uses this information to connect to the destination application.
        /// This member is required.
        public var services: [Swift.String]?
        /// The name of the IoT thing to which you want to connect.
        public var thingName: Swift.String?

        public init(
            services: [Swift.String]? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.services = services
            self.thingName = thingName
        }
    }
}

extension IoTSecureTunnelingClientTypes {

    public enum TunnelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelStatus] {
            return [
                .closed,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSecureTunnelingClientTypes {

    /// An arbitary key/value pair used to add searchable metadata to secure tunnel resources.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension IoTSecureTunnelingClientTypes {

    /// Tunnel timeout configuration.
    public struct TimeoutConfig: Swift.Sendable {
        /// The maximum amount of time (in minutes) a tunnel can remain open. If not specified, maxLifetimeTimeoutMinutes defaults to 720 minutes. Valid values are from 1 minute to 12 hours (720 minutes)
        public var maxLifetimeTimeoutMinutes: Swift.Int?

        public init(
            maxLifetimeTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutes
        }
    }
}

extension IoTSecureTunnelingClientTypes {

    /// A connection between a source computer and a destination device.
    public struct Tunnel: Swift.Sendable {
        /// The time when the tunnel was created.
        public var createdAt: Foundation.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The destination configuration that specifies the thing name of the destination device and a service name that the local proxy uses to connect to the destination application.
        public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
        /// The connection state of the destination application.
        public var destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The last time the tunnel was updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The connection state of the source application.
        public var sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// A list of tag metadata associated with the secure tunnel.
        public var tags: [IoTSecureTunnelingClientTypes.Tag]?
        /// Timeout configuration for the tunnel.
        public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?
        /// The Amazon Resource Name (ARN) of a tunnel.
        public var tunnelArn: Swift.String?
        /// A unique alpha-numeric ID that identifies a tunnel.
        public var tunnelId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
            destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
            timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.destinationConfig = destinationConfig
            self.destinationConnectionState = destinationConnectionState
            self.lastUpdatedAt = lastUpdatedAt
            self.sourceConnectionState = sourceConnectionState
            self.status = status
            self.tags = tags
            self.timeoutConfig = timeoutConfig
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }
}

public struct DescribeTunnelOutput: Swift.Sendable {
    /// The tunnel being described.
    public var tunnel: IoTSecureTunnelingClientTypes.Tunnel?

    public init(
        tunnel: IoTSecureTunnelingClientTypes.Tunnel? = nil
    )
    {
        self.tunnel = tunnel
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the specified resource.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init(
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTunnelsInput: Swift.Sendable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the IoT thing associated with the destination device.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

extension IoTSecureTunnelingClientTypes {

    /// Information about the tunnel.
    public struct TunnelSummary: Swift.Sendable {
        /// The time the tunnel was created.
        public var createdAt: Foundation.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The time the tunnel was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// The Amazon Resource Name of the tunnel.
        public var tunnelArn: Swift.String?
        /// The unique alpha-numeric identifier for the tunnel.
        public var tunnelId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }
}

public struct ListTunnelsOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A short description of the tunnels in an Amazon Web Services account.
    public var tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tunnelSummaries = tunnelSummaries
    }
}

/// Thrown when a tunnel limit is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct OpenTunnelInput: Swift.Sendable {
    /// A short text description of the tunnel.
    public var description: Swift.String?
    /// The destination configuration for the OpenTunnel request.
    public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    /// A collection of tag metadata.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?
    /// Timeout configuration for a tunnel.
    public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?

    public init(
        description: Swift.String? = nil,
        destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
        timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil
    )
    {
        self.description = description
        self.destinationConfig = destinationConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

public struct OpenTunnelOutput: Swift.Sendable {
    /// The access token the destination local proxy uses to connect to IoT Secure Tunneling.
    public var destinationAccessToken: Swift.String?
    /// The access token the source local proxy uses to connect to IoT Secure Tunneling.
    public var sourceAccessToken: Swift.String?
    /// The Amazon Resource Name for the tunnel.
    public var tunnelArn: Swift.String?
    /// A unique alpha-numeric tunnel ID.
    public var tunnelId: Swift.String?

    public init(
        destinationAccessToken: Swift.String? = nil,
        sourceAccessToken: Swift.String? = nil,
        tunnelArn: Swift.String? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

extension OpenTunnelOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenTunnelOutput(tunnelArn: \(Swift.String(describing: tunnelArn)), tunnelId: \(Swift.String(describing: tunnelId)), destinationAccessToken: \"CONTENT_REDACTED\", sourceAccessToken: \"CONTENT_REDACTED\")"}
}

public struct RotateTunnelAccessTokenInput: Swift.Sendable {
    /// The mode of the client that will use the client token, which can be either the source or destination, or both source and destination.
    /// This member is required.
    public var clientMode: IoTSecureTunnelingClientTypes.ClientMode?
    /// The destination configuration.
    public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    /// The tunnel for which you want to rotate the access tokens.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        clientMode: IoTSecureTunnelingClientTypes.ClientMode? = nil,
        destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.clientMode = clientMode
        self.destinationConfig = destinationConfig
        self.tunnelId = tunnelId
    }
}

public struct RotateTunnelAccessTokenOutput: Swift.Sendable {
    /// The client access token that the destination local proxy uses to connect to IoT Secure Tunneling.
    public var destinationAccessToken: Swift.String?
    /// The client access token that the source local proxy uses to connect to IoT Secure Tunneling.
    public var sourceAccessToken: Swift.String?
    /// The Amazon Resource Name for the tunnel.
    public var tunnelArn: Swift.String?

    public init(
        destinationAccessToken: Swift.String? = nil,
        sourceAccessToken: Swift.String? = nil,
        tunnelArn: Swift.String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
    }
}

extension RotateTunnelAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateTunnelAccessTokenOutput(tunnelArn: \(Swift.String(describing: tunnelArn)), destinationAccessToken: \"CONTENT_REDACTED\", sourceAccessToken: \"CONTENT_REDACTED\")"}
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CloseTunnelInput {

    static func urlPathProvider(_ value: CloseTunnelInput) -> Swift.String? {
        return "/"
    }
}

extension CloseTunnelInput {

    static func queryItemProvider(_ value: CloseTunnelInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension DescribeTunnelInput {

    static func urlPathProvider(_ value: DescribeTunnelInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTunnelsInput {

    static func urlPathProvider(_ value: ListTunnelsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTunnelsInput {

    static func queryItemProvider(_ value: ListTunnelsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension OpenTunnelInput {

    static func urlPathProvider(_ value: OpenTunnelInput) -> Swift.String? {
        return "/"
    }
}

extension RotateTunnelAccessTokenInput {

    static func urlPathProvider(_ value: RotateTunnelAccessTokenInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CloseTunnelInput {

    static func write(value: CloseTunnelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeTunnelInput {

    static func write(value: DescribeTunnelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTunnelsInput {

    static func write(value: ListTunnelsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension OpenTunnelInput {

    static func write(value: OpenTunnelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["destinationConfig"].write(value.destinationConfig, with: IoTSecureTunnelingClientTypes.DestinationConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTSecureTunnelingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutConfig"].write(value.timeoutConfig, with: IoTSecureTunnelingClientTypes.TimeoutConfig.write(value:to:))
    }
}

extension RotateTunnelAccessTokenInput {

    static func write(value: RotateTunnelAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientMode"].write(value.clientMode)
        try writer["destinationConfig"].write(value.destinationConfig, with: IoTSecureTunnelingClientTypes.DestinationConfig.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTSecureTunnelingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CloseTunnelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CloseTunnelOutput {
        return CloseTunnelOutput()
    }
}

extension DescribeTunnelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTunnelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTunnelOutput()
        value.tunnel = try reader["tunnel"].readIfPresent(with: IoTSecureTunnelingClientTypes.Tunnel.read(from:))
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: IoTSecureTunnelingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTunnelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTunnelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTunnelsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tunnelSummaries = try reader["tunnelSummaries"].readListIfPresent(memberReadingClosure: IoTSecureTunnelingClientTypes.TunnelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenTunnelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OpenTunnelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = OpenTunnelOutput()
        value.destinationAccessToken = try reader["destinationAccessToken"].readIfPresent()
        value.sourceAccessToken = try reader["sourceAccessToken"].readIfPresent()
        value.tunnelArn = try reader["tunnelArn"].readIfPresent()
        value.tunnelId = try reader["tunnelId"].readIfPresent()
        return value
    }
}

extension RotateTunnelAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RotateTunnelAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RotateTunnelAccessTokenOutput()
        value.destinationAccessToken = try reader["destinationAccessToken"].readIfPresent()
        value.sourceAccessToken = try reader["sourceAccessToken"].readIfPresent()
        value.tunnelArn = try reader["tunnelArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CloseTunnelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTunnelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTunnelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OpenTunnelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RotateTunnelAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTSecureTunnelingClientTypes.Tunnel {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.Tunnel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.Tunnel()
        value.tunnelId = try reader["tunnelId"].readIfPresent()
        value.tunnelArn = try reader["tunnelArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.sourceConnectionState = try reader["sourceConnectionState"].readIfPresent(with: IoTSecureTunnelingClientTypes.ConnectionState.read(from:))
        value.destinationConnectionState = try reader["destinationConnectionState"].readIfPresent(with: IoTSecureTunnelingClientTypes.ConnectionState.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.destinationConfig = try reader["destinationConfig"].readIfPresent(with: IoTSecureTunnelingClientTypes.DestinationConfig.read(from:))
        value.timeoutConfig = try reader["timeoutConfig"].readIfPresent(with: IoTSecureTunnelingClientTypes.TimeoutConfig.read(from:))
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: IoTSecureTunnelingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTSecureTunnelingClientTypes.Tag {

    static func write(value: IoTSecureTunnelingClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSecureTunnelingClientTypes.TimeoutConfig {

    static func write(value: IoTSecureTunnelingClientTypes.TimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxLifetimeTimeoutMinutes"].write(value.maxLifetimeTimeoutMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.TimeoutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.TimeoutConfig()
        value.maxLifetimeTimeoutMinutes = try reader["maxLifetimeTimeoutMinutes"].readIfPresent()
        return value
    }
}

extension IoTSecureTunnelingClientTypes.DestinationConfig {

    static func write(value: IoTSecureTunnelingClientTypes.DestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingName"].write(value.thingName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.DestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.DestinationConfig()
        value.thingName = try reader["thingName"].readIfPresent()
        value.services = try reader["services"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSecureTunnelingClientTypes.ConnectionState {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.ConnectionState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.ConnectionState()
        value.status = try reader["status"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTSecureTunnelingClientTypes.TunnelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSecureTunnelingClientTypes.TunnelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSecureTunnelingClientTypes.TunnelSummary()
        value.tunnelId = try reader["tunnelId"].readIfPresent()
        value.tunnelArn = try reader["tunnelArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

public enum IoTSecureTunnelingClientTypes {}
