// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTSecureTunnelingClientTypes {
    public enum ClientMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case destination
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientMode] {
            return [
                .all,
                .destination,
                .source,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .destination: return "DESTINATION"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientMode(rawValue: rawValue) ?? ClientMode.sdkUnknown(rawValue)
        }
    }
}

extension CloseTunnelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension CloseTunnelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension CloseTunnelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CloseTunnelInput: Swift.Equatable {
    /// When set to true, IoT Secure Tunneling deletes the tunnel data immediately.
    public var delete: Swift.Bool?
    /// The ID of the tunnel to close.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        delete: Swift.Bool? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.delete = delete
        self.tunnelId = tunnelId
    }
}

struct CloseTunnelInputBody: Swift.Equatable {
}

extension CloseTunnelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloseTunnelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CloseTunnelOutput: Swift.Equatable {

    public init() { }
}

enum CloseTunnelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSecureTunnelingClientTypes.ConnectionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdatedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes {
    /// The state of a connection.
    public struct ConnectionState: Swift.Equatable {
        /// The last time the connection status was updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The connection status of the tunnel. Valid values are CONNECTED and DISCONNECTED.
        public var status: IoTSecureTunnelingClientTypes.ConnectionStatus?

        public init(
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTSecureTunnelingClientTypes.ConnectionStatus? = nil
        )
        {
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }
    }

}

extension IoTSecureTunnelingClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeTunnelInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeTunnelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTunnelInput: Swift.Equatable {
    /// The tunnel to describe.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        tunnelId: Swift.String? = nil
    )
    {
        self.tunnelId = tunnelId
    }
}

struct DescribeTunnelInputBody: Swift.Equatable {
}

extension DescribeTunnelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTunnelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTunnelOutputBody = try responseDecoder.decode(responseBody: data)
            self.tunnel = output.tunnel
        } else {
            self.tunnel = nil
        }
    }
}

public struct DescribeTunnelOutput: Swift.Equatable {
    /// The tunnel being described.
    public var tunnel: IoTSecureTunnelingClientTypes.Tunnel?

    public init(
        tunnel: IoTSecureTunnelingClientTypes.Tunnel? = nil
    )
    {
        self.tunnel = tunnel
    }
}

struct DescribeTunnelOutputBody: Swift.Equatable {
    let tunnel: IoTSecureTunnelingClientTypes.Tunnel?
}

extension DescribeTunnelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tunnel
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.Tunnel.self, forKey: .tunnel)
        tunnel = tunnelDecoded
    }
}

enum DescribeTunnelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSecureTunnelingClientTypes.DestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case services
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
    }
}

extension IoTSecureTunnelingClientTypes {
    /// The destination configuration.
    public struct DestinationConfig: Swift.Equatable {
        /// A list of service names that identify the target application. The IoT client running on the destination device reads this value and uses it to look up a port or an IP address and a port. The IoT client instantiates the local proxy, which uses this information to connect to the destination application.
        /// This member is required.
        public var services: [Swift.String]?
        /// The name of the IoT thing to which you want to connect.
        public var thingName: Swift.String?

        public init(
            services: [Swift.String]? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.services = services
            self.thingName = thingName
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a tunnel limit is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the specified resource.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init(
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [IoTSecureTunnelingClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTunnelsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTunnelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTunnelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTunnelsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the IoT thing associated with the destination device.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListTunnelsInputBody: Swift.Equatable {
}

extension ListTunnelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTunnelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTunnelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tunnelSummaries = output.tunnelSummaries
        } else {
            self.nextToken = nil
            self.tunnelSummaries = nil
        }
    }
}

public struct ListTunnelsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A short description of the tunnels in an Amazon Web Services account.
    public var tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tunnelSummaries = tunnelSummaries
    }
}

struct ListTunnelsOutputBody: Swift.Equatable {
    let tunnelSummaries: [IoTSecureTunnelingClientTypes.TunnelSummary]?
    let nextToken: Swift.String?
}

extension ListTunnelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tunnelSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelSummariesContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.TunnelSummary?].self, forKey: .tunnelSummaries)
        var tunnelSummariesDecoded0:[IoTSecureTunnelingClientTypes.TunnelSummary]? = nil
        if let tunnelSummariesContainer = tunnelSummariesContainer {
            tunnelSummariesDecoded0 = [IoTSecureTunnelingClientTypes.TunnelSummary]()
            for structure0 in tunnelSummariesContainer {
                if let structure0 = structure0 {
                    tunnelSummariesDecoded0?.append(structure0)
                }
            }
        }
        tunnelSummaries = tunnelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTunnelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpenTunnelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

extension OpenTunnelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OpenTunnelInput: Swift.Equatable {
    /// A short text description of the tunnel.
    public var description: Swift.String?
    /// The destination configuration for the OpenTunnel request.
    public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    /// A collection of tag metadata.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?
    /// Timeout configuration for a tunnel.
    public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?

    public init(
        description: Swift.String? = nil,
        destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
        timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil
    )
    {
        self.description = description
        self.destinationConfig = destinationConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

struct OpenTunnelInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [IoTSecureTunnelingClientTypes.Tag]?
    let destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    let timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?
}

extension OpenTunnelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let destinationConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension OpenTunnelOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenTunnelOutput(tunnelArn: \(Swift.String(describing: tunnelArn)), tunnelId: \(Swift.String(describing: tunnelId)), destinationAccessToken: \"CONTENT_REDACTED\", sourceAccessToken: \"CONTENT_REDACTED\")"}
}

extension OpenTunnelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OpenTunnelOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationAccessToken = output.destinationAccessToken
            self.sourceAccessToken = output.sourceAccessToken
            self.tunnelArn = output.tunnelArn
            self.tunnelId = output.tunnelId
        } else {
            self.destinationAccessToken = nil
            self.sourceAccessToken = nil
            self.tunnelArn = nil
            self.tunnelId = nil
        }
    }
}

public struct OpenTunnelOutput: Swift.Equatable {
    /// The access token the destination local proxy uses to connect to IoT Secure Tunneling.
    public var destinationAccessToken: Swift.String?
    /// The access token the source local proxy uses to connect to IoT Secure Tunneling.
    public var sourceAccessToken: Swift.String?
    /// The Amazon Resource Name for the tunnel.
    public var tunnelArn: Swift.String?
    /// A unique alpha-numeric tunnel ID.
    public var tunnelId: Swift.String?

    public init(
        destinationAccessToken: Swift.String? = nil,
        sourceAccessToken: Swift.String? = nil,
        tunnelArn: Swift.String? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

struct OpenTunnelOutputBody: Swift.Equatable {
    let tunnelId: Swift.String?
    let tunnelArn: Swift.String?
    let sourceAccessToken: Swift.String?
    let destinationAccessToken: Swift.String?
}

extension OpenTunnelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAccessToken
        case sourceAccessToken
        case tunnelArn
        case tunnelId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let sourceAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccessToken)
        sourceAccessToken = sourceAccessTokenDecoded
        let destinationAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccessToken)
        destinationAccessToken = destinationAccessTokenDecoded
    }
}

enum OpenTunnelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when an operation is attempted on a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RotateTunnelAccessTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientMode
        case destinationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientMode = self.clientMode {
            try encodeContainer.encode(clientMode.rawValue, forKey: .clientMode)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
    }
}

extension RotateTunnelAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RotateTunnelAccessTokenInput: Swift.Equatable {
    /// The mode of the client that will use the client token, which can be either the source or destination, or both source and destination.
    /// This member is required.
    public var clientMode: IoTSecureTunnelingClientTypes.ClientMode?
    /// The destination configuration.
    public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
    /// The tunnel for which you want to rotate the access tokens.
    /// This member is required.
    public var tunnelId: Swift.String?

    public init(
        clientMode: IoTSecureTunnelingClientTypes.ClientMode? = nil,
        destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
        tunnelId: Swift.String? = nil
    )
    {
        self.clientMode = clientMode
        self.destinationConfig = destinationConfig
        self.tunnelId = tunnelId
    }
}

struct RotateTunnelAccessTokenInputBody: Swift.Equatable {
    let clientMode: IoTSecureTunnelingClientTypes.ClientMode?
    let destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
}

extension RotateTunnelAccessTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientMode
        case destinationConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientModeDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ClientMode.self, forKey: .clientMode)
        clientMode = clientModeDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension RotateTunnelAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateTunnelAccessTokenOutput(tunnelArn: \(Swift.String(describing: tunnelArn)), destinationAccessToken: \"CONTENT_REDACTED\", sourceAccessToken: \"CONTENT_REDACTED\")"}
}

extension RotateTunnelAccessTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RotateTunnelAccessTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationAccessToken = output.destinationAccessToken
            self.sourceAccessToken = output.sourceAccessToken
            self.tunnelArn = output.tunnelArn
        } else {
            self.destinationAccessToken = nil
            self.sourceAccessToken = nil
            self.tunnelArn = nil
        }
    }
}

public struct RotateTunnelAccessTokenOutput: Swift.Equatable {
    /// The client access token that the destination local proxy uses to connect to IoT Secure Tunneling.
    public var destinationAccessToken: Swift.String?
    /// The client access token that the source local proxy uses to connect to IoT Secure Tunneling.
    public var sourceAccessToken: Swift.String?
    /// The Amazon Resource Name for the tunnel.
    public var tunnelArn: Swift.String?

    public init(
        destinationAccessToken: Swift.String? = nil,
        sourceAccessToken: Swift.String? = nil,
        tunnelArn: Swift.String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
    }
}

struct RotateTunnelAccessTokenOutputBody: Swift.Equatable {
    let tunnelArn: Swift.String?
    let sourceAccessToken: Swift.String?
    let destinationAccessToken: Swift.String?
}

extension RotateTunnelAccessTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAccessToken
        case sourceAccessToken
        case tunnelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let sourceAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccessToken)
        sourceAccessToken = sourceAccessTokenDecoded
        let destinationAccessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccessToken)
        destinationAccessToken = destinationAccessTokenDecoded
    }
}

enum RotateTunnelAccessTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSecureTunnelingClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSecureTunnelingClientTypes {
    /// An arbitary key/value pair used to add searchable metadata to secure tunnel resources.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [IoTSecureTunnelingClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTSecureTunnelingClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [IoTSecureTunnelingClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSecureTunnelingClientTypes.TimeoutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLifetimeTimeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLifetimeTimeoutMinutes = self.maxLifetimeTimeoutMinutes {
            try encodeContainer.encode(maxLifetimeTimeoutMinutes, forKey: .maxLifetimeTimeoutMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLifetimeTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLifetimeTimeoutMinutes)
        maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutesDecoded
    }
}

extension IoTSecureTunnelingClientTypes {
    /// Tunnel timeout configuration.
    public struct TimeoutConfig: Swift.Equatable {
        /// The maximum amount of time (in minutes) a tunnel can remain open. If not specified, maxLifetimeTimeoutMinutes defaults to 720 minutes. Valid values are from 1 minute to 12 hours (720 minutes)
        public var maxLifetimeTimeoutMinutes: Swift.Int?

        public init(
            maxLifetimeTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutes
        }
    }

}

extension IoTSecureTunnelingClientTypes.Tunnel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case destinationConfig
        case destinationConnectionState
        case lastUpdatedAt
        case sourceConnectionState
        case status
        case tags
        case timeoutConfig
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let destinationConnectionState = self.destinationConnectionState {
            try encodeContainer.encode(destinationConnectionState, forKey: .destinationConnectionState)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let sourceConnectionState = self.sourceConnectionState {
            try encodeContainer.encode(sourceConnectionState, forKey: .sourceConnectionState)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
        if let tunnelArn = self.tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = self.tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConnectionStateDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionState.self, forKey: .sourceConnectionState)
        sourceConnectionState = sourceConnectionStateDecoded
        let destinationConnectionStateDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.ConnectionState.self, forKey: .destinationConnectionState)
        destinationConnectionState = destinationConnectionStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTSecureTunnelingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTSecureTunnelingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTSecureTunnelingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes {
    /// A connection between a source computer and a destination device.
    public struct Tunnel: Swift.Equatable {
        /// The time when the tunnel was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The destination configuration that specifies the thing name of the destination device and a service name that the local proxy uses to connect to the destination application.
        public var destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig?
        /// The connection state of the destination application.
        public var destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The last time the tunnel was updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The connection state of the source application.
        public var sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// A list of tag metadata associated with the secure tunnel.
        public var tags: [IoTSecureTunnelingClientTypes.Tag]?
        /// Timeout configuration for the tunnel.
        public var timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig?
        /// The Amazon Resource Name (ARN) of a tunnel.
        public var tunnelArn: Swift.String?
        /// A unique alpha-numeric ID that identifies a tunnel.
        public var tunnelId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            destinationConfig: IoTSecureTunnelingClientTypes.DestinationConfig? = nil,
            destinationConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            sourceConnectionState: IoTSecureTunnelingClientTypes.ConnectionState? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tags: [IoTSecureTunnelingClientTypes.Tag]? = nil,
            timeoutConfig: IoTSecureTunnelingClientTypes.TimeoutConfig? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.destinationConfig = destinationConfig
            self.destinationConnectionState = destinationConnectionState
            self.lastUpdatedAt = lastUpdatedAt
            self.sourceConnectionState = sourceConnectionState
            self.status = status
            self.tags = tags
            self.timeoutConfig = timeoutConfig
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }

}

extension IoTSecureTunnelingClientTypes {
    public enum TunnelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelStatus] {
            return [
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TunnelStatus(rawValue: rawValue) ?? TunnelStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSecureTunnelingClientTypes.TunnelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case lastUpdatedAt
        case status
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tunnelArn = self.tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = self.tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSecureTunnelingClientTypes.TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension IoTSecureTunnelingClientTypes {
    /// Information about the tunnel.
    public struct TunnelSummary: Swift.Equatable {
        /// The time the tunnel was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the tunnel.
        public var description: Swift.String?
        /// The time the tunnel was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status of a tunnel. Valid values are: Open and Closed.
        public var status: IoTSecureTunnelingClientTypes.TunnelStatus?
        /// The Amazon Resource Name of the tunnel.
        public var tunnelArn: Swift.String?
        /// The unique alpha-numeric identifier for the tunnel.
        public var tunnelId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTSecureTunnelingClientTypes.TunnelStatus? = nil,
            tunnelArn: Swift.String? = nil,
            tunnelId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.tunnelArn = tunnelArn
            self.tunnelId = tunnelId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
