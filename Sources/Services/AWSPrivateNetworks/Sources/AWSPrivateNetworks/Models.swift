//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

public struct PingInput {

    public init() { }
}

/// You do not have permission to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Information about an internal error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the affected resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a field that failed validation.
    public struct ValidationExceptionField {
        /// The message about the validation failure.
        /// This member is required.
        public var message: Swift.String?
        /// The field name that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PrivateNetworksClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotAssumeRole
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotAssumeRole,
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotAssumeRole: return "CANNOT_ASSUME_ROLE"
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed validation.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that caused the error, if applicable.
        public internal(set) var fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: PrivateNetworksClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PrivateNetworksClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcknowledgeOrderReceiptInput {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init(
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

extension PrivateNetworksClientTypes {

    public enum AcknowledgmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledged
        case acknowledging
        case unacknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [AcknowledgmentStatus] {
            return [
                .acknowledged,
                .acknowledging,
                .unacknowledged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .acknowledging: return "ACKNOWLEDGING"
            case .unacknowledged: return "UNACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {

    public enum CommitmentLength: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneYear
        case sixtyDays
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentLength] {
            return [
                .oneYear,
                .sixtyDays,
                .threeYears
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .sixtyDays: return "SIXTY_DAYS"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Determines the duration and renewal status of the commitment period for a radio unit. For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing).
    public struct CommitmentConfiguration {
        /// Determines whether the commitment period for a radio unit is set to automatically renew for an additional 1 year after your current commitment period expires. Set to True, if you want your commitment period to automatically renew. Set to False if you do not want your commitment to automatically renew. You can do the following:
        ///
        /// * Set a 1-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 1-year rate.
        ///
        /// * Set a 3-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 3-year rate.
        ///
        /// * Turn off a previously-enabled automatic renewal on a 1-year or 3-year commitment.
        ///
        ///
        /// You cannot use the automatic-renewal option for a 60-day commitment.
        /// This member is required.
        public var automaticRenewal: Swift.Bool?
        /// The duration of the commitment period for the radio unit. You can choose a 60-day, 1-year, or 3-year period.
        /// This member is required.
        public var commitmentLength: PrivateNetworksClientTypes.CommitmentLength?

        public init(
            automaticRenewal: Swift.Bool? = nil,
            commitmentLength: PrivateNetworksClientTypes.CommitmentLength? = nil
        )
        {
            self.automaticRenewal = automaticRenewal
            self.commitmentLength = commitmentLength
        }
    }

}

extension PrivateNetworksClientTypes {

    public enum NetworkResourceDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceIdentifier
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceDefinitionType] {
            return [
                .deviceIdentifier,
                .radioUnit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceIdentifier: return "DEVICE_IDENTIFIER"
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Details of the network resources in the order.
    public struct OrderedResourceDefinition {
        /// The duration and renewal status of the commitment period for each radio unit in the order. Does not show details if the resource type is DEVICE_IDENTIFIER.
        public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
        /// The number of network resources in the order.
        /// This member is required.
        public var count: Swift.Int?
        /// The type of network resource in the order.
        /// This member is required.
        public var type: PrivateNetworksClientTypes.NetworkResourceDefinitionType?

        public init(
            commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
            count: Swift.Int? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceDefinitionType? = nil
        )
        {
            self.commitmentConfiguration = commitmentConfiguration
            self.count = count
            self.type = type
        }
    }

}

extension PrivateNetworksClientTypes {
    /// Information about an address.
    public struct Address {
        /// The city for this address.
        /// This member is required.
        public var city: Swift.String?
        /// The company name for this address.
        public var company: Swift.String?
        /// The country for this address.
        /// This member is required.
        public var country: Swift.String?
        /// The recipient's email address.
        public var emailAddress: Swift.String?
        /// The recipient's name for this address.
        /// This member is required.
        public var name: Swift.String?
        /// The recipient's phone number.
        public var phoneNumber: Swift.String?
        /// The postal code for this address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state or province for this address.
        /// This member is required.
        public var stateOrProvince: Swift.String?
        /// The first line of the street address.
        /// This member is required.
        public var street1: Swift.String?
        /// The second line of the street address.
        public var street2: Swift.String?
        /// The third line of the street address.
        public var street3: Swift.String?

        public init(
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil
        )
        {
            self.city = city
            self.company = company
            self.country = country
            self.emailAddress = emailAddress
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
        }
    }

}

extension PrivateNetworksClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrProvince: \"CONTENT_REDACTED\", street1: \"CONTENT_REDACTED\", street2: \"CONTENT_REDACTED\", street3: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {
    /// Information about tracking a shipment.
    public struct TrackingInformation {
        /// The tracking number of the shipment.
        public var trackingNumber: Swift.String?

        public init(
            trackingNumber: Swift.String? = nil
        )
        {
            self.trackingNumber = trackingNumber
        }
    }

}

extension PrivateNetworksClientTypes {
    /// Information about an order.
    public struct Order {
        /// The acknowledgement status of the order.
        public var acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus?
        /// The creation time of the order.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the network associated with this order.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site associated with this order.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order.
        public var orderArn: Swift.String?
        /// A list of the network resources placed in the order.
        public var orderedResources: [PrivateNetworksClientTypes.OrderedResourceDefinition]?
        /// The shipping address of the order.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The tracking information of the order.
        public var trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]?

        public init(
            acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus? = nil,
            createdAt: Foundation.Date? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            orderedResources: [PrivateNetworksClientTypes.OrderedResourceDefinition]? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]? = nil
        )
        {
            self.acknowledgmentStatus = acknowledgmentStatus
            self.createdAt = createdAt
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.orderedResources = orderedResources
            self.shippingAddress = shippingAddress
            self.trackingInformation = trackingInformation
        }
    }

}

public struct AcknowledgeOrderReceiptOutput {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?

    public init(
        order: PrivateNetworksClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

public struct ActivateDeviceIdentifierInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

extension PrivateNetworksClientTypes {

    public enum DeviceIdentifierStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a subscriber of a device that can use a network.
    public struct DeviceIdentifier {
        /// The creation time of this device identifier.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the device identifier.
        public var deviceIdentifierArn: Swift.String?
        /// The Integrated Circuit Card Identifier of the device identifier.
        public var iccid: Swift.String?
        /// The International Mobile Subscriber Identity of the device identifier.
        public var imsi: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which the device identifier appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase the device identifier.
        public var orderArn: Swift.String?
        /// The status of the device identifier.
        public var status: PrivateNetworksClientTypes.DeviceIdentifierStatus?
        /// The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.
        public var trafficGroupArn: Swift.String?
        /// The vendor of the device identifier.
        public var vendor: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            deviceIdentifierArn: Swift.String? = nil,
            iccid: Swift.String? = nil,
            imsi: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            status: PrivateNetworksClientTypes.DeviceIdentifierStatus? = nil,
            trafficGroupArn: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceIdentifierArn = deviceIdentifierArn
            self.iccid = iccid
            self.imsi = imsi
            self.networkArn = networkArn
            self.orderArn = orderArn
            self.status = status
            self.trafficGroupArn = trafficGroupArn
            self.vendor = vendor
        }
    }

}

extension PrivateNetworksClientTypes.DeviceIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceIdentifier(createdAt: \(Swift.String(describing: createdAt)), deviceIdentifierArn: \(Swift.String(describing: deviceIdentifierArn)), iccid: \(Swift.String(describing: iccid)), networkArn: \(Swift.String(describing: networkArn)), orderArn: \(Swift.String(describing: orderArn)), status: \(Swift.String(describing: status)), trafficGroupArn: \(Swift.String(describing: trafficGroupArn)), vendor: \(Swift.String(describing: vendor)), imsi: \"CONTENT_REDACTED\")"}
}

public struct ActivateDeviceIdentifierOutput {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The tags on the device identifier.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

extension ActivateDeviceIdentifierOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateDeviceIdentifierOutput(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

public struct ActivateNetworkSiteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// Determines the duration and renewal status of the commitment period for all pending radio units. If you include commitmentConfiguration in the ActivateNetworkSiteRequest action, you must specify the following:
    ///
    /// * The commitment period for the radio unit. You can choose a 60-day, 1-year, or 3-year period.
    ///
    /// * Whether you want your commitment period to automatically renew for one more year after your current commitment period expires.
    ///
    ///
    /// For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing). If you do not include commitmentConfiguration in the ActivateNetworkSiteRequest action, the commitment period is set to 60-days.
    public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The shipping address of the network site.
    /// This member is required.
    public var shippingAddress: PrivateNetworksClientTypes.Address?

    public init(
        clientToken: Swift.String? = nil,
        commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
        networkSiteArn: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil
    )
    {
        self.clientToken = clientToken
        self.commitmentConfiguration = commitmentConfiguration
        self.networkSiteArn = networkSiteArn
        self.shippingAddress = shippingAddress
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a name/value pair.
    public struct NameValuePair {
        /// The name of the pair.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the pair.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PrivateNetworksClientTypes {
    /// Information about a network resource definition.
    public struct NetworkResourceDefinition {
        /// The count in the network resource definition.
        /// This member is required.
        public var count: Swift.Int?
        /// The options in the network resource definition.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The type in the network resource definition.
        /// This member is required.
        public var type: PrivateNetworksClientTypes.NetworkResourceDefinitionType?

        public init(
            count: Swift.Int? = nil,
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceDefinitionType? = nil
        )
        {
            self.count = count
            self.options = options
            self.type = type
        }
    }

}

extension PrivateNetworksClientTypes {
    /// Information about a site plan.
    public struct SitePlan {
        /// The options of the plan.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The resource definitions of the plan.
        public var resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]?

        public init(
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]? = nil
        )
        {
            self.options = options
            self.resourceDefinitions = resourceDefinitions
        }
    }

}

extension PrivateNetworksClientTypes {

    public enum NetworkSiteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network site.
    public struct NetworkSite {
        /// The parent Availability Zone for the network site.
        public var availabilityZone: Swift.String?
        /// The parent Availability Zone ID for the network site.
        public var availabilityZoneId: Swift.String?
        /// The creation time of the network site.
        public var createdAt: Foundation.Date?
        /// The current plan of the network site.
        public var currentPlan: PrivateNetworksClientTypes.SitePlan?
        /// The description of the network site.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network to which the network site belongs.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site.
        /// This member is required.
        public var networkSiteArn: Swift.String?
        /// The name of the network site.
        /// This member is required.
        public var networkSiteName: Swift.String?
        /// The pending plan of the network site.
        public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
        /// The status of the network site.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkSiteStatus?
        /// The status reason of the network site.
        public var statusReason: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            currentPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            networkSiteName: Swift.String? = nil,
            pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            status: PrivateNetworksClientTypes.NetworkSiteStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.createdAt = createdAt
            self.currentPlan = currentPlan
            self.description = description
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.networkSiteName = networkSiteName
            self.pendingPlan = pendingPlan
            self.status = status
            self.statusReason = statusReason
        }
    }

}

public struct ActivateNetworkSiteOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

extension PrivateNetworksClientTypes {
    /// Shows the duration, the date and time that the contract started and ends, and the renewal status of the commitment period for the radio unit.
    public struct CommitmentInformation {
        /// The duration and renewal status of the commitment period for the radio unit.
        /// This member is required.
        public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
        /// The date and time that the commitment period ends. If you do not cancel or renew the commitment before the expiration date, you will be billed at the 60-day-commitment rate.
        public var expiresOn: Foundation.Date?
        /// The date and time that the commitment period started.
        public var startAt: Foundation.Date?

        public init(
            commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
            expiresOn: Foundation.Date? = nil,
            startAt: Foundation.Date? = nil
        )
        {
            self.commitmentConfiguration = commitmentConfiguration
            self.expiresOn = expiresOn
            self.startAt = startAt
        }
    }

}

extension PrivateNetworksClientTypes {

    public enum ElevationReference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agl
        case amsl
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationReference] {
            return [
                .agl,
                .amsl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agl: return "AGL"
            case .amsl: return "AMSL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {

    public enum ElevationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Feet.
        case feet
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationUnit] {
            return [
                .feet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .feet: return "FEET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a position.
    public struct Position {
        /// The elevation of the equipment at this position.
        public var elevation: Swift.Double?
        /// The reference point from which elevation is reported.
        public var elevationReference: PrivateNetworksClientTypes.ElevationReference?
        /// The units used to measure the elevation of the position.
        public var elevationUnit: PrivateNetworksClientTypes.ElevationUnit?
        /// The latitude of the position.
        public var latitude: Swift.Double?
        /// The longitude of the position.
        public var longitude: Swift.Double?

        public init(
            elevation: Swift.Double? = nil,
            elevationReference: PrivateNetworksClientTypes.ElevationReference? = nil,
            elevationUnit: PrivateNetworksClientTypes.ElevationUnit? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.elevation = elevation
            self.elevationReference = elevationReference
            self.elevationUnit = elevationUnit
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

public struct ConfigureAccessPointInput {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var accessPointArn: Swift.String?
    /// A Base64 encoded string of the CPI certificate associated with the CPI user who is certifying the coordinates of the network resource.
    public var cpiSecretKey: Swift.String?
    /// The CPI user ID of the CPI user who is certifying the coordinates of the network resource.
    public var cpiUserId: Swift.String?
    /// The CPI password associated with the CPI certificate in cpiSecretKey.
    public var cpiUserPassword: Swift.String?
    /// The CPI user name of the CPI user who is certifying the coordinates of the radio unit.
    public var cpiUsername: Swift.String?
    /// The position of the network resource.
    public var position: PrivateNetworksClientTypes.Position?

    public init(
        accessPointArn: Swift.String? = nil,
        cpiSecretKey: Swift.String? = nil,
        cpiUserId: Swift.String? = nil,
        cpiUserPassword: Swift.String? = nil,
        cpiUsername: Swift.String? = nil,
        position: PrivateNetworksClientTypes.Position? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.cpiSecretKey = cpiSecretKey
        self.cpiUserId = cpiUserId
        self.cpiUserPassword = cpiUserPassword
        self.cpiUsername = cpiUsername
        self.position = position
    }
}

extension ConfigureAccessPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureAccessPointInput(accessPointArn: \(Swift.String(describing: accessPointArn)), position: \(Swift.String(describing: position)), cpiSecretKey: \"CONTENT_REDACTED\", cpiUserId: \"CONTENT_REDACTED\", cpiUserPassword: \"CONTENT_REDACTED\", cpiUsername: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {

    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .initial,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a request to return a network resource.
    public struct ReturnInformation {
        /// The Amazon Resource Name (ARN) of the replacement order.
        public var replacementOrderArn: Swift.String?
        /// The reason for the return. If the return request did not include a reason for the return, this value is null.
        public var returnReason: Swift.String?
        /// The shipping address.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The URL of the shipping label. The shipping label is available for download only if the status of the network resource is PENDING_RETURN. For more information, see [Return a radio unit](https://docs.aws.amazon.com/private-networks/latest/userguide/radio-units.html#return-radio-unit).
        public var shippingLabel: Swift.String?

        public init(
            replacementOrderArn: Swift.String? = nil,
            returnReason: Swift.String? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            shippingLabel: Swift.String? = nil
        )
        {
            self.replacementOrderArn = replacementOrderArn
            self.returnReason = returnReason
            self.shippingAddress = shippingAddress
            self.shippingLabel = shippingLabel
        }
    }

}

extension PrivateNetworksClientTypes {

    public enum NetworkResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creatingShippingLabel
        case deleted
        case deleting
        case pending
        case pendingReturn
        case provisioned
        case provisioning
        case shipped
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceStatus] {
            return [
                .available,
                .creatingShippingLabel,
                .deleted,
                .deleting,
                .pending,
                .pendingReturn,
                .provisioned,
                .provisioning,
                .shipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creatingShippingLabel: return "CREATING_SHIPPING_LABEL"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .pendingReturn: return "PENDING_RETURN"
            case .provisioned: return "PROVISIONED"
            case .provisioning: return "PROVISIONING"
            case .shipped: return "SHIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {

    public enum NetworkResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceType] {
            return [
                .radioUnit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network resource.
    public struct NetworkResource {
        /// The attributes of the network resource.
        public var attributes: [PrivateNetworksClientTypes.NameValuePair]?
        /// Information about the commitment period for the radio unit. Shows the duration, the date and time that the contract started and ends, and the renewal status of the commitment period.
        public var commitmentInformation: PrivateNetworksClientTypes.CommitmentInformation?
        /// The creation time of the network resource.
        public var createdAt: Foundation.Date?
        /// The description of the network resource.
        public var description: Swift.String?
        /// The health of the network resource.
        public var health: PrivateNetworksClientTypes.HealthStatus?
        /// The model of the network resource.
        public var model: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which this network resource appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network resource.
        public var networkResourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site on which this network resource appears.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase this network resource.
        public var orderArn: Swift.String?
        /// The position of the network resource.
        public var position: PrivateNetworksClientTypes.Position?
        /// Information about a request to return the network resource.
        public var returnInformation: PrivateNetworksClientTypes.ReturnInformation?
        /// The serial number of the network resource.
        public var serialNumber: Swift.String?
        /// The status of the network resource.
        public var status: PrivateNetworksClientTypes.NetworkResourceStatus?
        /// The status reason of the network resource.
        public var statusReason: Swift.String?
        /// The type of the network resource.
        public var type: PrivateNetworksClientTypes.NetworkResourceType?
        /// The vendor of the network resource.
        public var vendor: Swift.String?

        public init(
            attributes: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            commitmentInformation: PrivateNetworksClientTypes.CommitmentInformation? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            health: PrivateNetworksClientTypes.HealthStatus? = nil,
            model: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkResourceArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            position: PrivateNetworksClientTypes.Position? = nil,
            returnInformation: PrivateNetworksClientTypes.ReturnInformation? = nil,
            serialNumber: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceType? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.commitmentInformation = commitmentInformation
            self.createdAt = createdAt
            self.description = description
            self.health = health
            self.model = model
            self.networkArn = networkArn
            self.networkResourceArn = networkResourceArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.position = position
            self.returnInformation = returnInformation
            self.serialNumber = serialNumber
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.vendor = vendor
        }
    }

}

public struct ConfigureAccessPointOutput {
    /// Information about the network resource.
    /// This member is required.
    public var accessPoint: PrivateNetworksClientTypes.NetworkResource?

    public init(
        accessPoint: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

/// The limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateNetworkInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the network.
    public var description: Swift.String?
    /// The name of the network. You can't change the name after you create the network.
    /// This member is required.
    public var networkName: Swift.String?
    /// The tags to apply to the network.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkName = networkName
        self.tags = tags
    }
}

extension CreateNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkName: \(Swift.String(describing: networkName)), tags: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {

    public enum NetworkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network.
    public struct Network {
        /// The creation time of the network.
        public var createdAt: Foundation.Date?
        /// The description of the network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The name of the network.
        /// This member is required.
        public var networkName: Swift.String?
        /// The status of the network.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkStatus?
        /// The status reason of the network.
        public var statusReason: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkName: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.networkArn = networkArn
            self.networkName = networkName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

public struct CreateNetworkOutput {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

extension CreateNetworkOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkOutput(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNetworkSiteInput {
    /// The Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZoneId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the site.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The name of the site. You can't change the name after you create the site.
    /// This member is required.
    public var networkSiteName: Swift.String?
    /// Information about the pending plan for this site.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
    /// The tags to apply to the network site.
    public var tags: [Swift.String: Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkArn: Swift.String? = nil,
        networkSiteName: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.description = description
        self.networkArn = networkArn
        self.networkSiteName = networkSiteName
        self.pendingPlan = pendingPlan
        self.tags = tags
    }
}

extension CreateNetworkSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteInput(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkArn: \(Swift.String(describing: networkArn)), networkSiteName: \(Swift.String(describing: networkSiteName)), pendingPlan: \(Swift.String(describing: pendingPlan)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNetworkSiteOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

extension CreateNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

public struct DeactivateDeviceIdentifierInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

public struct DeactivateDeviceIdentifierOutput {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
    }
}

public struct DeleteNetworkInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkArn = networkArn
    }
}

public struct DeleteNetworkOutput {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil
    )
    {
        self.network = network
    }
}

public struct DeleteNetworkSiteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
    }
}

public struct DeleteNetworkSiteOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

extension PrivateNetworksClientTypes {

    public enum DeviceIdentifierFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case order
        case status
        case trafficGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierFilterKeys] {
            return [
                .order,
                .status,
                .trafficGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case .trafficGroup: return "TRAFFIC_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDeviceIdentifierInput {
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

public struct GetDeviceIdentifierOutput {
    /// Information about the device identifier.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The device identifier tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

extension GetDeviceIdentifierOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceIdentifierOutput(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetNetworkInput {
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init(
        networkArn: Swift.String? = nil
    )
    {
        self.networkArn = networkArn
    }
}

public struct GetNetworkOutput {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

extension GetNetworkOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkOutput(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetNetworkResourceInput {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?

    public init(
        networkResourceArn: Swift.String? = nil
    )
    {
        self.networkResourceArn = networkResourceArn
    }
}

public struct GetNetworkResourceOutput {
    /// Information about the network resource.
    /// This member is required.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?
    /// The network resource tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.networkResource = networkResource
        self.tags = tags
    }
}

extension GetNetworkResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceOutput(networkResource: \(Swift.String(describing: networkResource)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetNetworkSiteInput {
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        networkSiteArn: Swift.String? = nil
    )
    {
        self.networkSiteArn = networkSiteArn
    }
}

public struct GetNetworkSiteOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

extension GetNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetOrderInput {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init(
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

public struct GetOrderOutput {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?
    /// The order tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        order: PrivateNetworksClientTypes.Order? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.order = order
        self.tags = tags
    }
}

extension GetOrderOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOrderOutput(order: \(Swift.String(describing: order)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListDeviceIdentifiersInput {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (ACTIVE | INACTIVE).
    ///
    /// * TRAFFIC_GROUP - The Amazon Resource Name (ARN) of the traffic group.
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

public struct ListDeviceIdentifiersOutput {
    /// Information about the device identifiers.
    public var deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceIdentifiers = deviceIdentifiers
        self.nextToken = nextToken
    }
}

extension PrivateNetworksClientTypes {

    public enum NetworkResourceFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case order
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceFilterKeys] {
            return [
                .order,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListNetworkResourcesInput {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (AVAILABLE | DELETED | DELETING | PENDING | PENDING_RETURN | PROVISIONING | SHIPPED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

public struct ListNetworkResourcesOutput {
    /// Information about network resources.
    public var networkResources: [PrivateNetworksClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkResources: [PrivateNetworksClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

extension PrivateNetworksClientTypes {

    public enum NetworkFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFilterKeys] {
            return [
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListNetworksInput {
    /// The filters.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.startToken = startToken
    }
}

public struct ListNetworksOutput {
    /// The networks.
    public var networks: [PrivateNetworksClientTypes.Network]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networks: [PrivateNetworksClientTypes.Network]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networks = networks
        self.nextToken = nextToken
    }
}

extension PrivateNetworksClientTypes {

    public enum NetworkSiteFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteFilterKeys] {
            return [
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListNetworkSitesInput {
    /// The filters. Add filters to your request to return a more specific list of results. Use filters to match the status of the network sites.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

public struct ListNetworkSitesOutput {
    /// Information about the network sites.
    public var networkSites: [PrivateNetworksClientTypes.NetworkSite]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkSites: [PrivateNetworksClientTypes.NetworkSite]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSites = networkSites
        self.nextToken = nextToken
    }
}

extension PrivateNetworksClientTypes {

    public enum OrderFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case networkSite
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderFilterKeys] {
            return [
                .networkSite,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .networkSite: return "NETWORK_SITE"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListOrdersInput {
    /// The filters.
    ///
    /// * NETWORK_SITE - The Amazon Resource Name (ARN) of the network site.
    ///
    /// * STATUS - The status (ACKNOWLEDGING | ACKNOWLEDGED | UNACKNOWLEDGED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

public struct ListOrdersOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the orders.
    public var orders: [PrivateNetworksClientTypes.Order]?

    public init(
        nextToken: Swift.String? = nil,
        orders: [PrivateNetworksClientTypes.Order]? = nil
    )
    {
        self.nextToken = nextToken
        self.orders = orders
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The resource tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct PingOutput {
    /// Information about the health of the service.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

extension PrivateNetworksClientTypes {

    public enum UpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case commitment
        case replace
        case `return`
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateType] {
            return [
                .commitment,
                .replace,
                .return
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .commitment: return "COMMITMENT"
            case .replace: return "REPLACE"
            case .return: return "RETURN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartNetworkResourceUpdateInput {
    /// Use this action to extend and automatically renew the commitment period for the radio unit. You can do the following:
    ///
    /// * Change a 60-day commitment to a 1-year or 3-year commitment. The change is immediate and the hourly rate decreases to the rate for the new commitment period.
    ///
    /// * Change a 1-year commitment to a 3-year commitment. The change is immediate and the hourly rate decreases to the rate for the 3-year commitment period.
    ///
    /// * Set a 1-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 1-year rate.
    ///
    /// * Set a 3-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 3-year rate.
    ///
    /// * Turn off a previously-enabled automatic renewal on a 1-year or 3-year commitment. You cannot use the automatic-renewal option for a 60-day commitment.
    ///
    ///
    /// For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing).
    public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?
    /// The reason for the return. Providing a reason for a return is optional.
    public var returnReason: Swift.String?
    /// The shipping address. If you don't provide a shipping address when replacing or returning a network resource, we use the address from the original order for the network resource.
    public var shippingAddress: PrivateNetworksClientTypes.Address?
    /// The update type.
    ///
    /// * REPLACE - Submits a request to replace a defective radio unit. We provide a shipping label that you can use for the return process and we ship a replacement radio unit to you.
    ///
    /// * RETURN - Submits a request to return a radio unit that you no longer need. We provide a shipping label that you can use for the return process.
    ///
    /// * COMMITMENT - Submits a request to change or renew the commitment period. If you choose this value, then you must set [commitmentConfiguration](https://docs.aws.amazon.com/private-networks/latest/APIReference/API_StartNetworkResourceUpdate.html#privatenetworks-StartNetworkResourceUpdate-request-commitmentConfiguration).
    /// This member is required.
    public var updateType: PrivateNetworksClientTypes.UpdateType?

    public init(
        commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
        networkResourceArn: Swift.String? = nil,
        returnReason: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil,
        updateType: PrivateNetworksClientTypes.UpdateType? = nil
    )
    {
        self.commitmentConfiguration = commitmentConfiguration
        self.networkResourceArn = networkResourceArn
        self.returnReason = returnReason
        self.shippingAddress = shippingAddress
        self.updateType = updateType
    }
}

public struct StartNetworkResourceUpdateOutput {
    /// The network resource.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?

    public init(
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.networkResource = networkResource
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateNetworkSiteInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkSiteArn = networkSiteArn
    }
}

public struct UpdateNetworkSiteOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

extension UpdateNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

public struct UpdateNetworkSitePlanInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The pending plan.
    /// This member is required.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?

    public init(
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
        self.pendingPlan = pendingPlan
    }
}

public struct UpdateNetworkSitePlanOutput {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

extension UpdateNetworkSitePlanOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSitePlanOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension AcknowledgeOrderReceiptInput {

    static func urlPathProvider(_ value: AcknowledgeOrderReceiptInput) -> Swift.String? {
        return "/v1/orders/acknowledge"
    }
}

extension ActivateDeviceIdentifierInput {

    static func urlPathProvider(_ value: ActivateDeviceIdentifierInput) -> Swift.String? {
        return "/v1/device-identifiers/activate"
    }
}

extension ActivateNetworkSiteInput {

    static func urlPathProvider(_ value: ActivateNetworkSiteInput) -> Swift.String? {
        return "/v1/network-sites/activate"
    }
}

extension ConfigureAccessPointInput {

    static func urlPathProvider(_ value: ConfigureAccessPointInput) -> Swift.String? {
        return "/v1/network-resources/configure"
    }
}

extension CreateNetworkInput {

    static func urlPathProvider(_ value: CreateNetworkInput) -> Swift.String? {
        return "/v1/networks"
    }
}

extension CreateNetworkSiteInput {

    static func urlPathProvider(_ value: CreateNetworkSiteInput) -> Swift.String? {
        return "/v1/network-sites"
    }
}

extension DeactivateDeviceIdentifierInput {

    static func urlPathProvider(_ value: DeactivateDeviceIdentifierInput) -> Swift.String? {
        return "/v1/device-identifiers/deactivate"
    }
}

extension DeleteNetworkInput {

    static func urlPathProvider(_ value: DeleteNetworkInput) -> Swift.String? {
        guard let networkArn = value.networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

extension DeleteNetworkInput {

    static func queryItemProvider(_ value: DeleteNetworkInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteNetworkSiteInput {

    static func urlPathProvider(_ value: DeleteNetworkSiteInput) -> Swift.String? {
        guard let networkSiteArn = value.networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

extension DeleteNetworkSiteInput {

    static func queryItemProvider(_ value: DeleteNetworkSiteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension GetDeviceIdentifierInput {

    static func urlPathProvider(_ value: GetDeviceIdentifierInput) -> Swift.String? {
        guard let deviceIdentifierArn = value.deviceIdentifierArn else {
            return nil
        }
        return "/v1/device-identifiers/\(deviceIdentifierArn.urlPercentEncoding())"
    }
}

extension GetNetworkInput {

    static func urlPathProvider(_ value: GetNetworkInput) -> Swift.String? {
        guard let networkArn = value.networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

extension GetNetworkResourceInput {

    static func urlPathProvider(_ value: GetNetworkResourceInput) -> Swift.String? {
        guard let networkResourceArn = value.networkResourceArn else {
            return nil
        }
        return "/v1/network-resources/\(networkResourceArn.urlPercentEncoding())"
    }
}

extension GetNetworkSiteInput {

    static func urlPathProvider(_ value: GetNetworkSiteInput) -> Swift.String? {
        guard let networkSiteArn = value.networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

extension GetOrderInput {

    static func urlPathProvider(_ value: GetOrderInput) -> Swift.String? {
        guard let orderArn = value.orderArn else {
            return nil
        }
        return "/v1/orders/\(orderArn.urlPercentEncoding())"
    }
}

extension ListDeviceIdentifiersInput {

    static func urlPathProvider(_ value: ListDeviceIdentifiersInput) -> Swift.String? {
        return "/v1/device-identifiers/list"
    }
}

extension ListNetworkResourcesInput {

    static func urlPathProvider(_ value: ListNetworkResourcesInput) -> Swift.String? {
        return "/v1/network-resources"
    }
}

extension ListNetworksInput {

    static func urlPathProvider(_ value: ListNetworksInput) -> Swift.String? {
        return "/v1/networks/list"
    }
}

extension ListNetworkSitesInput {

    static func urlPathProvider(_ value: ListNetworkSitesInput) -> Swift.String? {
        return "/v1/network-sites/list"
    }
}

extension ListOrdersInput {

    static func urlPathProvider(_ value: ListOrdersInput) -> Swift.String? {
        return "/v1/orders/list"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PingInput {

    static func urlPathProvider(_ value: PingInput) -> Swift.String? {
        return "/ping"
    }
}

extension StartNetworkResourceUpdateInput {

    static func urlPathProvider(_ value: StartNetworkResourceUpdateInput) -> Swift.String? {
        return "/v1/network-resources/update"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateNetworkSiteInput {

    static func urlPathProvider(_ value: UpdateNetworkSiteInput) -> Swift.String? {
        return "/v1/network-sites/site"
    }
}

extension UpdateNetworkSitePlanInput {

    static func urlPathProvider(_ value: UpdateNetworkSitePlanInput) -> Swift.String? {
        return "/v1/network-sites/plan"
    }
}

extension AcknowledgeOrderReceiptInput {

    static func write(value: AcknowledgeOrderReceiptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["orderArn"].write(value.orderArn)
    }
}

extension ActivateDeviceIdentifierInput {

    static func write(value: ActivateDeviceIdentifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceIdentifierArn"].write(value.deviceIdentifierArn)
    }
}

extension ActivateNetworkSiteInput {

    static func write(value: ActivateNetworkSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["commitmentConfiguration"].write(value.commitmentConfiguration, with: PrivateNetworksClientTypes.CommitmentConfiguration.write(value:to:))
        try writer["networkSiteArn"].write(value.networkSiteArn)
        try writer["shippingAddress"].write(value.shippingAddress, with: PrivateNetworksClientTypes.Address.write(value:to:))
    }
}

extension ConfigureAccessPointInput {

    static func write(value: ConfigureAccessPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessPointArn"].write(value.accessPointArn)
        try writer["cpiSecretKey"].write(value.cpiSecretKey)
        try writer["cpiUserId"].write(value.cpiUserId)
        try writer["cpiUserPassword"].write(value.cpiUserPassword)
        try writer["cpiUsername"].write(value.cpiUsername)
        try writer["position"].write(value.position, with: PrivateNetworksClientTypes.Position.write(value:to:))
    }
}

extension CreateNetworkInput {

    static func write(value: CreateNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["networkName"].write(value.networkName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateNetworkSiteInput {

    static func write(value: CreateNetworkSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["networkArn"].write(value.networkArn)
        try writer["networkSiteName"].write(value.networkSiteName)
        try writer["pendingPlan"].write(value.pendingPlan, with: PrivateNetworksClientTypes.SitePlan.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeactivateDeviceIdentifierInput {

    static func write(value: DeactivateDeviceIdentifierInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["deviceIdentifierArn"].write(value.deviceIdentifierArn)
    }
}

extension ListDeviceIdentifiersInput {

    static func write(value: ListDeviceIdentifiersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["networkArn"].write(value.networkArn)
        try writer["startToken"].write(value.startToken)
    }
}

extension ListNetworkResourcesInput {

    static func write(value: ListNetworkResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["networkArn"].write(value.networkArn)
        try writer["startToken"].write(value.startToken)
    }
}

extension ListNetworksInput {

    static func write(value: ListNetworksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["startToken"].write(value.startToken)
    }
}

extension ListNetworkSitesInput {

    static func write(value: ListNetworkSitesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["networkArn"].write(value.networkArn)
        try writer["startToken"].write(value.startToken)
    }
}

extension ListOrdersInput {

    static func write(value: ListOrdersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["networkArn"].write(value.networkArn)
        try writer["startToken"].write(value.startToken)
    }
}

extension StartNetworkResourceUpdateInput {

    static func write(value: StartNetworkResourceUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitmentConfiguration"].write(value.commitmentConfiguration, with: PrivateNetworksClientTypes.CommitmentConfiguration.write(value:to:))
        try writer["networkResourceArn"].write(value.networkResourceArn)
        try writer["returnReason"].write(value.returnReason)
        try writer["shippingAddress"].write(value.shippingAddress, with: PrivateNetworksClientTypes.Address.write(value:to:))
        try writer["updateType"].write(value.updateType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateNetworkSiteInput {

    static func write(value: UpdateNetworkSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["networkSiteArn"].write(value.networkSiteArn)
    }
}

extension UpdateNetworkSitePlanInput {

    static func write(value: UpdateNetworkSitePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["networkSiteArn"].write(value.networkSiteArn)
        try writer["pendingPlan"].write(value.pendingPlan, with: PrivateNetworksClientTypes.SitePlan.write(value:to:))
    }
}

extension AcknowledgeOrderReceiptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcknowledgeOrderReceiptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcknowledgeOrderReceiptOutput()
        value.order = try reader["order"].readIfPresent(with: PrivateNetworksClientTypes.Order.read(from:))
        return value
    }
}

extension ActivateDeviceIdentifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateDeviceIdentifierOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateDeviceIdentifierOutput()
        value.deviceIdentifier = try reader["deviceIdentifier"].readIfPresent(with: PrivateNetworksClientTypes.DeviceIdentifier.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ActivateNetworkSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateNetworkSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateNetworkSiteOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        return value
    }
}

extension ConfigureAccessPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfigureAccessPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfigureAccessPointOutput()
        value.accessPoint = try reader["accessPoint"].readIfPresent(with: PrivateNetworksClientTypes.NetworkResource.read(from:))
        return value
    }
}

extension CreateNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkOutput()
        value.network = try reader["network"].readIfPresent(with: PrivateNetworksClientTypes.Network.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateNetworkSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkSiteOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DeactivateDeviceIdentifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateDeviceIdentifierOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeactivateDeviceIdentifierOutput()
        value.deviceIdentifier = try reader["deviceIdentifier"].readIfPresent(with: PrivateNetworksClientTypes.DeviceIdentifier.read(from:))
        return value
    }
}

extension DeleteNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNetworkOutput()
        value.network = try reader["network"].readIfPresent(with: PrivateNetworksClientTypes.Network.read(from:))
        return value
    }
}

extension DeleteNetworkSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNetworkSiteOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        return value
    }
}

extension GetDeviceIdentifierOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceIdentifierOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceIdentifierOutput()
        value.deviceIdentifier = try reader["deviceIdentifier"].readIfPresent(with: PrivateNetworksClientTypes.DeviceIdentifier.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkOutput()
        value.network = try reader["network"].readIfPresent(with: PrivateNetworksClientTypes.Network.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetNetworkResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkResourceOutput()
        value.networkResource = try reader["networkResource"].readIfPresent(with: PrivateNetworksClientTypes.NetworkResource.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetNetworkSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkSiteOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrderOutput()
        value.order = try reader["order"].readIfPresent(with: PrivateNetworksClientTypes.Order.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListDeviceIdentifiersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceIdentifiersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceIdentifiersOutput()
        value.deviceIdentifiers = try reader["deviceIdentifiers"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.DeviceIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworkResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworkResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworkResourcesOutput()
        value.networkResources = try reader["networkResources"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NetworkResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworksOutput()
        value.networks = try reader["networks"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.Network.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworkSitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworkSitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworkSitesOutput()
        value.networkSites = try reader["networkSites"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NetworkSite.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOrdersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrdersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrdersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.orders = try reader["orders"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.Order.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PingOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension StartNetworkResourceUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartNetworkResourceUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartNetworkResourceUpdateOutput()
        value.networkResource = try reader["networkResource"].readIfPresent(with: PrivateNetworksClientTypes.NetworkResource.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateNetworkSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkSiteOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateNetworkSitePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkSitePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkSitePlanOutput()
        value.networkSite = try reader["networkSite"].readIfPresent(with: PrivateNetworksClientTypes.NetworkSite.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

enum AcknowledgeOrderReceiptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ActivateDeviceIdentifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ActivateNetworkSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfigureAccessPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateDeviceIdentifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceIdentifierOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceIdentifiersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworkResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworkSitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrdersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartNetworkResourceUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkSitePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PrivateNetworksClientTypes.Order {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.Order {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.Order()
        value.orderArn = try reader["orderArn"].readIfPresent()
        value.shippingAddress = try reader["shippingAddress"].readIfPresent(with: PrivateNetworksClientTypes.Address.read(from:))
        value.networkArn = try reader["networkArn"].readIfPresent()
        value.networkSiteArn = try reader["networkSiteArn"].readIfPresent()
        value.trackingInformation = try reader["trackingInformation"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.TrackingInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.acknowledgmentStatus = try reader["acknowledgmentStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.orderedResources = try reader["orderedResources"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.OrderedResourceDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PrivateNetworksClientTypes.OrderedResourceDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.OrderedResourceDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.OrderedResourceDefinition()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.count = try reader["count"].readIfPresent() ?? 0
        value.commitmentConfiguration = try reader["commitmentConfiguration"].readIfPresent(with: PrivateNetworksClientTypes.CommitmentConfiguration.read(from:))
        return value
    }
}

extension PrivateNetworksClientTypes.CommitmentConfiguration {

    static func write(value: PrivateNetworksClientTypes.CommitmentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["automaticRenewal"].write(value.automaticRenewal)
        try writer["commitmentLength"].write(value.commitmentLength)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.CommitmentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.CommitmentConfiguration()
        value.commitmentLength = try reader["commitmentLength"].readIfPresent() ?? .sdkUnknown("")
        value.automaticRenewal = try reader["automaticRenewal"].readIfPresent() ?? false
        return value
    }
}

extension PrivateNetworksClientTypes.TrackingInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.TrackingInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.TrackingInformation()
        value.trackingNumber = try reader["trackingNumber"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.Address {

    static func write(value: PrivateNetworksClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["city"].write(value.city)
        try writer["company"].write(value.company)
        try writer["country"].write(value.country)
        try writer["emailAddress"].write(value.emailAddress)
        try writer["name"].write(value.name)
        try writer["phoneNumber"].write(value.phoneNumber)
        try writer["postalCode"].write(value.postalCode)
        try writer["stateOrProvince"].write(value.stateOrProvince)
        try writer["street1"].write(value.street1)
        try writer["street2"].write(value.street2)
        try writer["street3"].write(value.street3)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.Address()
        value.city = try reader["city"].readIfPresent() ?? ""
        value.company = try reader["company"].readIfPresent()
        value.country = try reader["country"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phoneNumber = try reader["phoneNumber"].readIfPresent()
        value.postalCode = try reader["postalCode"].readIfPresent() ?? ""
        value.stateOrProvince = try reader["stateOrProvince"].readIfPresent() ?? ""
        value.street1 = try reader["street1"].readIfPresent() ?? ""
        value.street2 = try reader["street2"].readIfPresent()
        value.street3 = try reader["street3"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.DeviceIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.DeviceIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.DeviceIdentifier()
        value.deviceIdentifierArn = try reader["deviceIdentifierArn"].readIfPresent()
        value.trafficGroupArn = try reader["trafficGroupArn"].readIfPresent()
        value.networkArn = try reader["networkArn"].readIfPresent()
        value.imsi = try reader["imsi"].readIfPresent()
        value.iccid = try reader["iccid"].readIfPresent()
        value.vendor = try reader["vendor"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.orderArn = try reader["orderArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PrivateNetworksClientTypes.NetworkSite {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.NetworkSite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.NetworkSite()
        value.networkSiteArn = try reader["networkSiteArn"].readIfPresent() ?? ""
        value.networkSiteName = try reader["networkSiteName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.networkArn = try reader["networkArn"].readIfPresent() ?? ""
        value.pendingPlan = try reader["pendingPlan"].readIfPresent(with: PrivateNetworksClientTypes.SitePlan.read(from:))
        value.currentPlan = try reader["currentPlan"].readIfPresent(with: PrivateNetworksClientTypes.SitePlan.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.SitePlan {

    static func write(value: PrivateNetworksClientTypes.SitePlan?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["options"].writeList(value.options, memberWritingClosure: PrivateNetworksClientTypes.NameValuePair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceDefinitions"].writeList(value.resourceDefinitions, memberWritingClosure: PrivateNetworksClientTypes.NetworkResourceDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.SitePlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.SitePlan()
        value.resourceDefinitions = try reader["resourceDefinitions"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NetworkResourceDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.options = try reader["options"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NameValuePair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PrivateNetworksClientTypes.NameValuePair {

    static func write(value: PrivateNetworksClientTypes.NameValuePair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.NameValuePair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.NameValuePair()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.NetworkResourceDefinition {

    static func write(value: PrivateNetworksClientTypes.NetworkResourceDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["count"].write(value.count)
        try writer["options"].writeList(value.options, memberWritingClosure: PrivateNetworksClientTypes.NameValuePair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.NetworkResourceDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.NetworkResourceDefinition()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.options = try reader["options"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NameValuePair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.count = try reader["count"].readIfPresent() ?? 0
        return value
    }
}

extension PrivateNetworksClientTypes.NetworkResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.NetworkResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.NetworkResource()
        value.networkResourceArn = try reader["networkResourceArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vendor = try reader["vendor"].readIfPresent()
        value.model = try reader["model"].readIfPresent()
        value.serialNumber = try reader["serialNumber"].readIfPresent()
        value.health = try reader["health"].readIfPresent()
        value.networkArn = try reader["networkArn"].readIfPresent()
        value.networkSiteArn = try reader["networkSiteArn"].readIfPresent()
        value.orderArn = try reader["orderArn"].readIfPresent()
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: PrivateNetworksClientTypes.NameValuePair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent(with: PrivateNetworksClientTypes.Position.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.returnInformation = try reader["returnInformation"].readIfPresent(with: PrivateNetworksClientTypes.ReturnInformation.read(from:))
        value.commitmentInformation = try reader["commitmentInformation"].readIfPresent(with: PrivateNetworksClientTypes.CommitmentInformation.read(from:))
        return value
    }
}

extension PrivateNetworksClientTypes.CommitmentInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.CommitmentInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.CommitmentInformation()
        value.commitmentConfiguration = try reader["commitmentConfiguration"].readIfPresent(with: PrivateNetworksClientTypes.CommitmentConfiguration.read(from:))
        value.startAt = try reader["startAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.expiresOn = try reader["expiresOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PrivateNetworksClientTypes.ReturnInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.ReturnInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.ReturnInformation()
        value.shippingAddress = try reader["shippingAddress"].readIfPresent(with: PrivateNetworksClientTypes.Address.read(from:))
        value.returnReason = try reader["returnReason"].readIfPresent()
        value.replacementOrderArn = try reader["replacementOrderArn"].readIfPresent()
        value.shippingLabel = try reader["shippingLabel"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.Position {

    static func write(value: PrivateNetworksClientTypes.Position?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["elevation"].write(value.elevation)
        try writer["elevationReference"].write(value.elevationReference)
        try writer["elevationUnit"].write(value.elevationUnit)
        try writer["latitude"].write(value.latitude)
        try writer["longitude"].write(value.longitude)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.Position {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.Position()
        value.latitude = try reader["latitude"].readIfPresent()
        value.longitude = try reader["longitude"].readIfPresent()
        value.elevation = try reader["elevation"].readIfPresent()
        value.elevationUnit = try reader["elevationUnit"].readIfPresent()
        value.elevationReference = try reader["elevationReference"].readIfPresent()
        return value
    }
}

extension PrivateNetworksClientTypes.Network {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.Network {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.Network()
        value.networkArn = try reader["networkArn"].readIfPresent() ?? ""
        value.networkName = try reader["networkName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PrivateNetworksClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PrivateNetworksClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PrivateNetworksClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum PrivateNetworksClientTypes {}
