// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have permission to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcknowledgeOrderReceiptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
    }
}

extension AcknowledgeOrderReceiptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/orders/acknowledge"
    }
}

public struct AcknowledgeOrderReceiptInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init(
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

struct AcknowledgeOrderReceiptInputBody: Swift.Equatable {
    let orderArn: Swift.String?
}

extension AcknowledgeOrderReceiptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
    }
}

extension AcknowledgeOrderReceiptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcknowledgeOrderReceiptOutputBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
        } else {
            self.order = nil
        }
    }
}

public struct AcknowledgeOrderReceiptOutput: Swift.Equatable {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?

    public init(
        order: PrivateNetworksClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

struct AcknowledgeOrderReceiptOutputBody: Swift.Equatable {
    let order: PrivateNetworksClientTypes.Order?
}

extension AcknowledgeOrderReceiptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

enum AcknowledgeOrderReceiptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum AcknowledgmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case acknowledging
        case unacknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [AcknowledgmentStatus] {
            return [
                .acknowledged,
                .acknowledging,
                .unacknowledged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .acknowledging: return "ACKNOWLEDGING"
            case .unacknowledged: return "UNACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcknowledgmentStatus(rawValue: rawValue) ?? AcknowledgmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ActivateDeviceIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
    }
}

extension ActivateDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/activate"
    }
}

public struct ActivateDeviceIdentifierInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct ActivateDeviceIdentifierInputBody: Swift.Equatable {
    let deviceIdentifierArn: Swift.String?
    let clientToken: Swift.String?
}

extension ActivateDeviceIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ActivateDeviceIdentifierOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateDeviceIdentifierOutput(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

extension ActivateDeviceIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActivateDeviceIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
            self.tags = output.tags
        } else {
            self.deviceIdentifier = nil
            self.tags = nil
        }
    }
}

public struct ActivateDeviceIdentifierOutput: Swift.Equatable {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The tags on the device identifier.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

struct ActivateDeviceIdentifierOutputBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    let tags: [Swift.String:Swift.String]?
}

extension ActivateDeviceIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ActivateDeviceIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ActivateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case commitmentConfiguration
        case networkSiteArn
        case shippingAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let commitmentConfiguration = self.commitmentConfiguration {
            try encodeContainer.encode(commitmentConfiguration, forKey: .commitmentConfiguration)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

extension ActivateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/activate"
    }
}

public struct ActivateNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// Determines the duration and renewal status of the commitment period for all pending radio units. If you include commitmentConfiguration in the ActivateNetworkSiteRequest action, you must specify the following:
    ///
    /// * The commitment period for the radio unit. You can choose a 60-day, 1-year, or 3-year period.
    ///
    /// * Whether you want your commitment period to automatically renew for one more year after your current commitment period expires.
    ///
    ///
    /// For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing). If you do not include commitmentConfiguration in the ActivateNetworkSiteRequest action, the commitment period is set to 60-days.
    public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The shipping address of the network site.
    /// This member is required.
    public var shippingAddress: PrivateNetworksClientTypes.Address?

    public init(
        clientToken: Swift.String? = nil,
        commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
        networkSiteArn: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil
    )
    {
        self.clientToken = clientToken
        self.commitmentConfiguration = commitmentConfiguration
        self.networkSiteArn = networkSiteArn
        self.shippingAddress = shippingAddress
    }
}

struct ActivateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let shippingAddress: PrivateNetworksClientTypes.Address?
    let clientToken: Swift.String?
    let commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
}

extension ActivateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case commitmentConfiguration
        case networkSiteArn
        case shippingAddress
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let commitmentConfigurationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentConfiguration.self, forKey: .commitmentConfiguration)
        commitmentConfiguration = commitmentConfigurationDecoded
    }
}

extension ActivateNetworkSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActivateNetworkSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
        } else {
            self.networkSite = nil
        }
    }
}

public struct ActivateNetworkSiteOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

struct ActivateNetworkSiteOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
}

extension ActivateNetworkSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
    }
}

enum ActivateNetworkSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case company
        case country
        case emailAddress
        case name
        case phoneNumber
        case postalCode
        case stateOrProvince
        case street1
        case street2
        case street3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let stateOrProvince = self.stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = self.street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = self.street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = self.street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let street1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street3)
        street3 = street3Decoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension PrivateNetworksClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrProvince: \"CONTENT_REDACTED\", street1: \"CONTENT_REDACTED\", street2: \"CONTENT_REDACTED\", street3: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {
    /// Information about an address.
    public struct Address: Swift.Equatable {
        /// The city for this address.
        /// This member is required.
        public var city: Swift.String?
        /// The company name for this address.
        public var company: Swift.String?
        /// The country for this address.
        /// This member is required.
        public var country: Swift.String?
        /// The recipient's email address.
        public var emailAddress: Swift.String?
        /// The recipient's name for this address.
        /// This member is required.
        public var name: Swift.String?
        /// The recipient's phone number.
        public var phoneNumber: Swift.String?
        /// The postal code for this address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state or province for this address.
        /// This member is required.
        public var stateOrProvince: Swift.String?
        /// The first line of the street address.
        /// This member is required.
        public var street1: Swift.String?
        /// The second line of the street address.
        public var street2: Swift.String?
        /// The third line of the street address.
        public var street3: Swift.String?

        public init(
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil
        )
        {
            self.city = city
            self.company = company
            self.country = country
            self.emailAddress = emailAddress
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
        }
    }

}

extension PrivateNetworksClientTypes.CommitmentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticRenewal
        case commitmentLength
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticRenewal = self.automaticRenewal {
            try encodeContainer.encode(automaticRenewal, forKey: .automaticRenewal)
        }
        if let commitmentLength = self.commitmentLength {
            try encodeContainer.encode(commitmentLength.rawValue, forKey: .commitmentLength)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitmentLengthDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentLength.self, forKey: .commitmentLength)
        commitmentLength = commitmentLengthDecoded
        let automaticRenewalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automaticRenewal)
        automaticRenewal = automaticRenewalDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Determines the duration and renewal status of the commitment period for a radio unit. For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing).
    public struct CommitmentConfiguration: Swift.Equatable {
        /// Determines whether the commitment period for a radio unit is set to automatically renew for an additional 1 year after your current commitment period expires. Set to True, if you want your commitment period to automatically renew. Set to False if you do not want your commitment to automatically renew. You can do the following:
        ///
        /// * Set a 1-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 1-year rate.
        ///
        /// * Set a 3-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 3-year rate.
        ///
        /// * Turn off a previously-enabled automatic renewal on a 1-year or 3-year commitment.
        ///
        ///
        /// You cannot use the automatic-renewal option for a 60-day commitment.
        /// This member is required.
        public var automaticRenewal: Swift.Bool?
        /// The duration of the commitment period for the radio unit. You can choose a 60-day, 1-year, or 3-year period.
        /// This member is required.
        public var commitmentLength: PrivateNetworksClientTypes.CommitmentLength?

        public init(
            automaticRenewal: Swift.Bool? = nil,
            commitmentLength: PrivateNetworksClientTypes.CommitmentLength? = nil
        )
        {
            self.automaticRenewal = automaticRenewal
            self.commitmentLength = commitmentLength
        }
    }

}

extension PrivateNetworksClientTypes.CommitmentInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentConfiguration
        case expiresOn
        case startAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitmentConfiguration = self.commitmentConfiguration {
            try encodeContainer.encode(commitmentConfiguration, forKey: .commitmentConfiguration)
        }
        if let expiresOn = self.expiresOn {
            try encodeContainer.encodeTimestamp(expiresOn, format: .dateTime, forKey: .expiresOn)
        }
        if let startAt = self.startAt {
            try encodeContainer.encodeTimestamp(startAt, format: .dateTime, forKey: .startAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitmentConfigurationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentConfiguration.self, forKey: .commitmentConfiguration)
        commitmentConfiguration = commitmentConfigurationDecoded
        let startAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startAt)
        startAt = startAtDecoded
        let expiresOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresOn)
        expiresOn = expiresOnDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Shows the duration, the date and time that the contract started and ends, and the renewal status of the commitment period for the radio unit.
    public struct CommitmentInformation: Swift.Equatable {
        /// The duration and renewal status of the commitment period for the radio unit.
        /// This member is required.
        public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
        /// The date and time that the commitment period ends. If you do not cancel or renew the commitment before the expiration date, you will be billed at the 60-day-commitment rate.
        public var expiresOn: ClientRuntime.Date?
        /// The date and time that the commitment period started.
        public var startAt: ClientRuntime.Date?

        public init(
            commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
            expiresOn: ClientRuntime.Date? = nil,
            startAt: ClientRuntime.Date? = nil
        )
        {
            self.commitmentConfiguration = commitmentConfiguration
            self.expiresOn = expiresOn
            self.startAt = startAt
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum CommitmentLength: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case sixtyDays
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentLength] {
            return [
                .oneYear,
                .sixtyDays,
                .threeYears,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .sixtyDays: return "SIXTY_DAYS"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommitmentLength(rawValue: rawValue) ?? CommitmentLength.sdkUnknown(rawValue)
        }
    }
}

extension ConfigureAccessPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureAccessPointInput(accessPointArn: \(Swift.String(describing: accessPointArn)), position: \(Swift.String(describing: position)), cpiSecretKey: \"CONTENT_REDACTED\", cpiUserId: \"CONTENT_REDACTED\", cpiUserPassword: \"CONTENT_REDACTED\", cpiUsername: \"CONTENT_REDACTED\")"}
}

extension ConfigureAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn
        case cpiSecretKey
        case cpiUserId
        case cpiUserPassword
        case cpiUsername
        case position
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = self.accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
        if let cpiSecretKey = self.cpiSecretKey {
            try encodeContainer.encode(cpiSecretKey, forKey: .cpiSecretKey)
        }
        if let cpiUserId = self.cpiUserId {
            try encodeContainer.encode(cpiUserId, forKey: .cpiUserId)
        }
        if let cpiUserPassword = self.cpiUserPassword {
            try encodeContainer.encode(cpiUserPassword, forKey: .cpiUserPassword)
        }
        if let cpiUsername = self.cpiUsername {
            try encodeContainer.encode(cpiUsername, forKey: .cpiUsername)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
    }
}

extension ConfigureAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources/configure"
    }
}

public struct ConfigureAccessPointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var accessPointArn: Swift.String?
    /// A Base64 encoded string of the CPI certificate associated with the CPI user who is certifying the coordinates of the network resource.
    public var cpiSecretKey: Swift.String?
    /// The CPI user ID of the CPI user who is certifying the coordinates of the network resource.
    public var cpiUserId: Swift.String?
    /// The CPI password associated with the CPI certificate in cpiSecretKey.
    public var cpiUserPassword: Swift.String?
    /// The CPI user name of the CPI user who is certifying the coordinates of the radio unit.
    public var cpiUsername: Swift.String?
    /// The position of the network resource.
    public var position: PrivateNetworksClientTypes.Position?

    public init(
        accessPointArn: Swift.String? = nil,
        cpiSecretKey: Swift.String? = nil,
        cpiUserId: Swift.String? = nil,
        cpiUserPassword: Swift.String? = nil,
        cpiUsername: Swift.String? = nil,
        position: PrivateNetworksClientTypes.Position? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.cpiSecretKey = cpiSecretKey
        self.cpiUserId = cpiUserId
        self.cpiUserPassword = cpiUserPassword
        self.cpiUsername = cpiUsername
        self.position = position
    }
}

struct ConfigureAccessPointInputBody: Swift.Equatable {
    let accessPointArn: Swift.String?
    let position: PrivateNetworksClientTypes.Position?
    let cpiUsername: Swift.String?
    let cpiUserId: Swift.String?
    let cpiUserPassword: Swift.String?
    let cpiSecretKey: Swift.String?
}

extension ConfigureAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn
        case cpiSecretKey
        case cpiUserId
        case cpiUserPassword
        case cpiUsername
        case position
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let positionDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Position.self, forKey: .position)
        position = positionDecoded
        let cpiUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUsername)
        cpiUsername = cpiUsernameDecoded
        let cpiUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUserId)
        cpiUserId = cpiUserIdDecoded
        let cpiUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUserPassword)
        cpiUserPassword = cpiUserPasswordDecoded
        let cpiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiSecretKey)
        cpiSecretKey = cpiSecretKeyDecoded
    }
}

extension ConfigureAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConfigureAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoint = output.accessPoint
        } else {
            self.accessPoint = nil
        }
    }
}

public struct ConfigureAccessPointOutput: Swift.Equatable {
    /// Information about the network resource.
    /// This member is required.
    public var accessPoint: PrivateNetworksClientTypes.NetworkResource?

    public init(
        accessPoint: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

struct ConfigureAccessPointOutputBody: Swift.Equatable {
    let accessPoint: PrivateNetworksClientTypes.NetworkResource?
}

extension ConfigureAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .accessPoint)
        accessPoint = accessPointDecoded
    }
}

enum ConfigureAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkName: \(Swift.String(describing: networkName)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/networks"
    }
}

public struct CreateNetworkInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the network.
    public var description: Swift.String?
    /// The name of the network. You can't change the name after you create the network.
    /// This member is required.
    public var networkName: Swift.String?
    /// The tags to apply to the network.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkName = networkName
        self.tags = tags
    }
}

struct CreateNetworkInputBody: Swift.Equatable {
    let networkName: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkOutput(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
            self.tags = output.tags
        } else {
            self.network = nil
            self.tags = nil
        }
    }
}

public struct CreateNetworkOutput: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

struct CreateNetworkOutputBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNetworkSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteInput(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkArn: \(Swift.String(describing: networkArn)), networkSiteName: \(Swift.String(describing: networkSiteName)), pendingPlan: \(Swift.String(describing: pendingPlan)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case clientToken
        case description
        case networkArn
        case networkSiteName
        case pendingPlan
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteName = self.networkSiteName {
            try encodeContainer.encode(networkSiteName, forKey: .networkSiteName)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites"
    }
}

public struct CreateNetworkSiteInput: Swift.Equatable {
    /// The Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZoneId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the site.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The name of the site. You can't change the name after you create the site.
    /// This member is required.
    public var networkSiteName: Swift.String?
    /// Information about the pending plan for this site.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
    /// The tags to apply to the network site.
    public var tags: [Swift.String:Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkArn: Swift.String? = nil,
        networkSiteName: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.description = description
        self.networkArn = networkArn
        self.networkSiteName = networkSiteName
        self.pendingPlan = pendingPlan
        self.tags = tags
    }
}

struct CreateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteName: Swift.String?
    let description: Swift.String?
    let networkArn: Swift.String?
    let pendingPlan: PrivateNetworksClientTypes.SitePlan?
    let clientToken: Swift.String?
    let availabilityZone: Swift.String?
    let availabilityZoneId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case clientToken
        case description
        case networkArn
        case networkSiteName
        case pendingPlan
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteName)
        networkSiteName = networkSiteNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct CreateNetworkSiteOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct CreateNetworkSiteOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateNetworkSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeactivateDeviceIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
    }
}

extension DeactivateDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/deactivate"
    }
}

public struct DeactivateDeviceIdentifierInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct DeactivateDeviceIdentifierInputBody: Swift.Equatable {
    let deviceIdentifierArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeactivateDeviceIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeactivateDeviceIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeactivateDeviceIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
        } else {
            self.deviceIdentifier = nil
        }
    }
}

public struct DeactivateDeviceIdentifierOutput: Swift.Equatable {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
    }
}

struct DeactivateDeviceIdentifierOutputBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
}

extension DeactivateDeviceIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
    }
}

enum DeactivateDeviceIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkArn = networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

public struct DeleteNetworkInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkArn = networkArn
    }
}

struct DeleteNetworkInputBody: Swift.Equatable {
}

extension DeleteNetworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
        } else {
            self.network = nil
        }
    }
}

public struct DeleteNetworkOutput: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil
    )
    {
        self.network = network
    }
}

struct DeleteNetworkOutputBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
}

extension DeleteNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
    }
}

enum DeleteNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkSiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSiteArn = networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

public struct DeleteNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
    }
}

struct DeleteNetworkSiteInputBody: Swift.Equatable {
}

extension DeleteNetworkSiteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteNetworkSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
        } else {
            self.networkSite = nil
        }
    }
}

public struct DeleteNetworkSiteOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

struct DeleteNetworkSiteOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
}

extension DeleteNetworkSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
    }
}

enum DeleteNetworkSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes.DeviceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceIdentifierArn
        case iccid
        case imsi
        case networkArn
        case orderArn
        case status
        case trafficGroupArn
        case vendor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
        if let iccid = self.iccid {
            try encodeContainer.encode(iccid, forKey: .iccid)
        }
        if let imsi = self.imsi {
            try encodeContainer.encode(imsi, forKey: .imsi)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let trafficGroupArn = self.trafficGroupArn {
            try encodeContainer.encode(trafficGroupArn, forKey: .trafficGroupArn)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let trafficGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trafficGroupArn)
        trafficGroupArn = trafficGroupArnDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let imsiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imsi)
        imsi = imsiDecoded
        let iccidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iccid)
        iccid = iccidDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifierStatus.self, forKey: .status)
        status = statusDecoded
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension PrivateNetworksClientTypes.DeviceIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceIdentifier(createdAt: \(Swift.String(describing: createdAt)), deviceIdentifierArn: \(Swift.String(describing: deviceIdentifierArn)), iccid: \(Swift.String(describing: iccid)), networkArn: \(Swift.String(describing: networkArn)), orderArn: \(Swift.String(describing: orderArn)), status: \(Swift.String(describing: status)), trafficGroupArn: \(Swift.String(describing: trafficGroupArn)), vendor: \(Swift.String(describing: vendor)), imsi: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {
    /// Information about a subscriber of a device that can use a network.
    public struct DeviceIdentifier: Swift.Equatable {
        /// The creation time of this device identifier.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the device identifier.
        public var deviceIdentifierArn: Swift.String?
        /// The Integrated Circuit Card Identifier of the device identifier.
        public var iccid: Swift.String?
        /// The International Mobile Subscriber Identity of the device identifier.
        public var imsi: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which the device identifier appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase the device identifier.
        public var orderArn: Swift.String?
        /// The status of the device identifier.
        public var status: PrivateNetworksClientTypes.DeviceIdentifierStatus?
        /// The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.
        public var trafficGroupArn: Swift.String?
        /// The vendor of the device identifier.
        public var vendor: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            deviceIdentifierArn: Swift.String? = nil,
            iccid: Swift.String? = nil,
            imsi: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            status: PrivateNetworksClientTypes.DeviceIdentifierStatus? = nil,
            trafficGroupArn: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceIdentifierArn = deviceIdentifierArn
            self.iccid = iccid
            self.imsi = imsi
            self.networkArn = networkArn
            self.orderArn = orderArn
            self.status = status
            self.trafficGroupArn = trafficGroupArn
            self.vendor = vendor
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum DeviceIdentifierFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case order
        case status
        case trafficGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierFilterKeys] {
            return [
                .order,
                .status,
                .trafficGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case .trafficGroup: return "TRAFFIC_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceIdentifierFilterKeys(rawValue: rawValue) ?? DeviceIdentifierFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum DeviceIdentifierStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceIdentifierStatus(rawValue: rawValue) ?? DeviceIdentifierStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum ElevationReference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agl
        case amsl
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationReference] {
            return [
                .agl,
                .amsl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agl: return "AGL"
            case .amsl: return "AMSL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ElevationReference(rawValue: rawValue) ?? ElevationReference.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum ElevationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Feet.
        case feet
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationUnit] {
            return [
                .feet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .feet: return "FEET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ElevationUnit(rawValue: rawValue) ?? ElevationUnit.sdkUnknown(rawValue)
        }
    }
}

extension GetDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceIdentifierArn = deviceIdentifierArn else {
            return nil
        }
        return "/v1/device-identifiers/\(deviceIdentifierArn.urlPercentEncoding())"
    }
}

public struct GetDeviceIdentifierInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init(
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct GetDeviceIdentifierInputBody: Swift.Equatable {
}

extension GetDeviceIdentifierInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceIdentifierOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceIdentifierOutput(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

extension GetDeviceIdentifierOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceIdentifierOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
            self.tags = output.tags
        } else {
            self.deviceIdentifier = nil
            self.tags = nil
        }
    }
}

public struct GetDeviceIdentifierOutput: Swift.Equatable {
    /// Information about the device identifier.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The device identifier tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

struct GetDeviceIdentifierOutputBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    let tags: [Swift.String:Swift.String]?
}

extension GetDeviceIdentifierOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDeviceIdentifierOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkArn = networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

public struct GetNetworkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init(
        networkArn: Swift.String? = nil
    )
    {
        self.networkArn = networkArn
    }
}

struct GetNetworkInputBody: Swift.Equatable {
}

extension GetNetworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkOutput(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
            self.tags = output.tags
        } else {
            self.network = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkOutput: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

struct GetNetworkOutputBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkResourceArn = networkResourceArn else {
            return nil
        }
        return "/v1/network-resources/\(networkResourceArn.urlPercentEncoding())"
    }
}

public struct GetNetworkResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?

    public init(
        networkResourceArn: Swift.String? = nil
    )
    {
        self.networkResourceArn = networkResourceArn
    }
}

struct GetNetworkResourceInputBody: Swift.Equatable {
}

extension GetNetworkResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceOutput(networkResource: \(Swift.String(describing: networkResource)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkResource = output.networkResource
            self.tags = output.tags
        } else {
            self.networkResource = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkResourceOutput: Swift.Equatable {
    /// Information about the network resource.
    /// This member is required.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?
    /// The network resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkResource = networkResource
        self.tags = tags
    }
}

struct GetNetworkResourceOutputBody: Swift.Equatable {
    let networkResource: PrivateNetworksClientTypes.NetworkResource?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResource
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .networkResource)
        networkResource = networkResourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetNetworkResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSiteArn = networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

public struct GetNetworkSiteInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        networkSiteArn: Swift.String? = nil
    )
    {
        self.networkSiteArn = networkSiteArn
    }
}

struct GetNetworkSiteInputBody: Swift.Equatable {
}

extension GetNetworkSiteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkSiteOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct GetNetworkSiteOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetNetworkSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let orderArn = orderArn else {
            return nil
        }
        return "/v1/orders/\(orderArn.urlPercentEncoding())"
    }
}

public struct GetOrderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init(
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

struct GetOrderInputBody: Swift.Equatable {
}

extension GetOrderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOrderOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOrderOutput(order: \(Swift.String(describing: order)), tags: \"CONTENT_REDACTED\")"}
}

extension GetOrderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOrderOutputBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
            self.tags = output.tags
        } else {
            self.order = nil
            self.tags = nil
        }
    }
}

public struct GetOrderOutput: Swift.Equatable {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?
    /// The order tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        order: PrivateNetworksClientTypes.Order? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.order = order
        self.tags = tags
    }
}

struct GetOrderOutputBody: Swift.Equatable {
    let order: PrivateNetworksClientTypes.Order?
    let tags: [Swift.String:Swift.String]?
}

extension GetOrderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Order.self, forKey: .order)
        order = orderDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .initial,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Information about an internal error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDeviceIdentifiersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, deviceIdentifierFilters0) in filters {
                var deviceIdentifierFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in deviceIdentifierFilters0 {
                    try deviceIdentifierFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListDeviceIdentifiersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/list"
    }
}

public struct ListDeviceIdentifiersInput: Swift.Equatable {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (ACTIVE | INACTIVE).
    ///
    /// * TRAFFIC_GROUP - The Amazon Resource Name (ARN) of the traffic group.
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListDeviceIdentifiersInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeviceIdentifiersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, deviceidentifierfiltervalues0) in filtersContainer {
                var deviceidentifierfiltervalues0Decoded0: [Swift.String]? = nil
                if let deviceidentifierfiltervalues0 = deviceidentifierfiltervalues0 {
                    deviceidentifierfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in deviceidentifierfiltervalues0 {
                        if let string1 = string1 {
                            deviceidentifierfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = deviceidentifierfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeviceIdentifiersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeviceIdentifiersOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifiers = output.deviceIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.deviceIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceIdentifiersOutput: Swift.Equatable {
    /// Information about the device identifiers.
    public var deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceIdentifiers = deviceIdentifiers
        self.nextToken = nextToken
    }
}

struct ListDeviceIdentifiersOutputBody: Swift.Equatable {
    let deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]?
    let nextToken: Swift.String?
}

extension ListDeviceIdentifiersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifiers
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifiersContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.DeviceIdentifier?].self, forKey: .deviceIdentifiers)
        var deviceIdentifiersDecoded0:[PrivateNetworksClientTypes.DeviceIdentifier]? = nil
        if let deviceIdentifiersContainer = deviceIdentifiersContainer {
            deviceIdentifiersDecoded0 = [PrivateNetworksClientTypes.DeviceIdentifier]()
            for structure0 in deviceIdentifiersContainer {
                if let structure0 = structure0 {
                    deviceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        deviceIdentifiers = deviceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeviceIdentifiersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworkResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkResourceFilters0) in filters {
                var networkResourceFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkResourceFilters0 {
                    try networkResourceFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworkResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources"
    }
}

public struct ListNetworkResourcesInput: Swift.Equatable {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (AVAILABLE | DELETED | DELETING | PENDING | PENDING_RETURN | PROVISIONING | SHIPPED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListNetworkResourcesInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworkResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networkresourcefiltervalues0) in filtersContainer {
                var networkresourcefiltervalues0Decoded0: [Swift.String]? = nil
                if let networkresourcefiltervalues0 = networkresourcefiltervalues0 {
                    networkresourcefiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networkresourcefiltervalues0 {
                        if let string1 = string1 {
                            networkresourcefiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networkresourcefiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworkResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworkResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkResources = output.networkResources
            self.nextToken = output.nextToken
        } else {
            self.networkResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkResourcesOutput: Swift.Equatable {
    /// Information about network resources.
    public var networkResources: [PrivateNetworksClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkResources: [PrivateNetworksClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

struct ListNetworkResourcesOutputBody: Swift.Equatable {
    let networkResources: [PrivateNetworksClientTypes.NetworkResource]?
    let nextToken: Swift.String?
}

extension ListNetworkResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourcesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkResource?].self, forKey: .networkResources)
        var networkResourcesDecoded0:[PrivateNetworksClientTypes.NetworkResource]? = nil
        if let networkResourcesContainer = networkResourcesContainer {
            networkResourcesDecoded0 = [PrivateNetworksClientTypes.NetworkResource]()
            for structure0 in networkResourcesContainer {
                if let structure0 = structure0 {
                    networkResourcesDecoded0?.append(structure0)
                }
            }
        }
        networkResources = networkResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNetworkResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworkSitesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkSiteFilters0) in filters {
                var networkSiteFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkSiteFilters0 {
                    try networkSiteFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworkSitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/list"
    }
}

public struct ListNetworkSitesInput: Swift.Equatable {
    /// The filters. Add filters to your request to return a more specific list of results. Use filters to match the status of the network sites.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListNetworkSitesInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworkSitesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networksitefiltervalues0) in filtersContainer {
                var networksitefiltervalues0Decoded0: [Swift.String]? = nil
                if let networksitefiltervalues0 = networksitefiltervalues0 {
                    networksitefiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networksitefiltervalues0 {
                        if let string1 = string1 {
                            networksitefiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networksitefiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworkSitesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworkSitesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSites = output.networkSites
            self.nextToken = output.nextToken
        } else {
            self.networkSites = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSitesOutput: Swift.Equatable {
    /// Information about the network sites.
    public var networkSites: [PrivateNetworksClientTypes.NetworkSite]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkSites: [PrivateNetworksClientTypes.NetworkSite]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSites = networkSites
        self.nextToken = nextToken
    }
}

struct ListNetworkSitesOutputBody: Swift.Equatable {
    let networkSites: [PrivateNetworksClientTypes.NetworkSite]?
    let nextToken: Swift.String?
}

extension ListNetworkSitesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSites
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSitesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkSite?].self, forKey: .networkSites)
        var networkSitesDecoded0:[PrivateNetworksClientTypes.NetworkSite]? = nil
        if let networkSitesContainer = networkSitesContainer {
            networkSitesDecoded0 = [PrivateNetworksClientTypes.NetworkSite]()
            for structure0 in networkSitesContainer {
                if let structure0 = structure0 {
                    networkSitesDecoded0?.append(structure0)
                }
            }
        }
        networkSites = networkSitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNetworkSitesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNetworksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkFilters0) in filters {
                var networkFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkFilters0 {
                    try networkFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/networks/list"
    }
}

public struct ListNetworksInput: Swift.Equatable {
    /// The filters.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.startToken = startToken
    }
}

struct ListNetworksInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case startToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networkfiltervalues0) in filtersContainer {
                var networkfiltervalues0Decoded0: [Swift.String]? = nil
                if let networkfiltervalues0 = networkfiltervalues0 {
                    networkfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networkfiltervalues0 {
                        if let string1 = string1 {
                            networkfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networkfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNetworksOutputBody = try responseDecoder.decode(responseBody: data)
            self.networks = output.networks
            self.nextToken = output.nextToken
        } else {
            self.networks = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworksOutput: Swift.Equatable {
    /// The networks.
    public var networks: [PrivateNetworksClientTypes.Network]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networks: [PrivateNetworksClientTypes.Network]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networks = networks
        self.nextToken = nextToken
    }
}

struct ListNetworksOutputBody: Swift.Equatable {
    let networks: [PrivateNetworksClientTypes.Network]?
    let nextToken: Swift.String?
}

extension ListNetworksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networks
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networksContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.Network?].self, forKey: .networks)
        var networksDecoded0:[PrivateNetworksClientTypes.Network]? = nil
        if let networksContainer = networksContainer {
            networksDecoded0 = [PrivateNetworksClientTypes.Network]()
            for structure0 in networksContainer {
                if let structure0 = structure0 {
                    networksDecoded0?.append(structure0)
                }
            }
        }
        networks = networksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNetworksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrdersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, orderFilters0) in filters {
                var orderFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in orderFilters0 {
                    try orderFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListOrdersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/orders/list"
    }
}

public struct ListOrdersInput: Swift.Equatable {
    /// The filters.
    ///
    /// * NETWORK_SITE - The Amazon Resource Name (ARN) of the network site.
    ///
    /// * STATUS - The status (ACKNOWLEDGING | ACKNOWLEDGED | UNACKNOWLEDGED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init(
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListOrdersInputBody: Swift.Equatable {
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [Swift.String:[Swift.String]]?
}

extension ListOrdersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, orderfiltervalues0) in filtersContainer {
                var orderfiltervalues0Decoded0: [Swift.String]? = nil
                if let orderfiltervalues0 = orderfiltervalues0 {
                    orderfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in orderfiltervalues0 {
                        if let string1 = string1 {
                            orderfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = orderfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOrdersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrdersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.orders = output.orders
        } else {
            self.nextToken = nil
            self.orders = nil
        }
    }
}

public struct ListOrdersOutput: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the orders.
    public var orders: [PrivateNetworksClientTypes.Order]?

    public init(
        nextToken: Swift.String? = nil,
        orders: [PrivateNetworksClientTypes.Order]? = nil
    )
    {
        self.nextToken = nextToken
        self.orders = orders
    }
}

struct ListOrdersOutputBody: Swift.Equatable {
    let orders: [PrivateNetworksClientTypes.Order]?
    let nextToken: Swift.String?
}

extension ListOrdersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case orders
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ordersContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.Order?].self, forKey: .orders)
        var ordersDecoded0:[PrivateNetworksClientTypes.Order]? = nil
        if let ordersContainer = ordersContainer {
            ordersDecoded0 = [PrivateNetworksClientTypes.Order]()
            for structure0 in ordersContainer {
                if let structure0 = structure0 {
                    ordersDecoded0?.append(structure0)
                }
            }
        }
        orders = ordersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOrdersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes.NameValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a name/value pair.
    public struct NameValuePair: Swift.Equatable {
        /// The name of the pair.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the pair.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PrivateNetworksClientTypes.Network: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case networkArn
        case networkName
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network.
    public struct Network: Swift.Equatable {
        /// The creation time of the network.
        public var createdAt: ClientRuntime.Date?
        /// The description of the network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The name of the network.
        /// This member is required.
        public var networkName: Swift.String?
        /// The status of the network.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkStatus?
        /// The status reason of the network.
        public var statusReason: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkName: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.networkArn = networkArn
            self.networkName = networkName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFilterKeys] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkFilterKeys(rawValue: rawValue) ?? NetworkFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.NetworkResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case commitmentInformation
        case createdAt
        case description
        case health
        case model
        case networkArn
        case networkResourceArn
        case networkSiteArn
        case orderArn
        case position
        case returnInformation
        case serialNumber
        case status
        case statusReason
        case type
        case vendor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for namevaluepair0 in attributes {
                try attributesContainer.encode(namevaluepair0)
            }
        }
        if let commitmentInformation = self.commitmentInformation {
            try encodeContainer.encode(commitmentInformation, forKey: .commitmentInformation)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkResourceArn = self.networkResourceArn {
            try encodeContainer.encode(networkResourceArn, forKey: .networkResourceArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let returnInformation = self.returnInformation {
            try encodeContainer.encode(returnInformation, forKey: .returnInformation)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkResourceArn)
        networkResourceArn = networkResourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let healthDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.HealthStatus.self, forKey: .health)
        health = healthDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .attributes)
        var attributesDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let positionDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Position.self, forKey: .position)
        position = positionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let returnInformationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ReturnInformation.self, forKey: .returnInformation)
        returnInformation = returnInformationDecoded
        let commitmentInformationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentInformation.self, forKey: .commitmentInformation)
        commitmentInformation = commitmentInformationDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network resource.
    public struct NetworkResource: Swift.Equatable {
        /// The attributes of the network resource.
        public var attributes: [PrivateNetworksClientTypes.NameValuePair]?
        /// Information about the commitment period for the radio unit. Shows the duration, the date and time that the contract started and ends, and the renewal status of the commitment period.
        public var commitmentInformation: PrivateNetworksClientTypes.CommitmentInformation?
        /// The creation time of the network resource.
        public var createdAt: ClientRuntime.Date?
        /// The description of the network resource.
        public var description: Swift.String?
        /// The health of the network resource.
        public var health: PrivateNetworksClientTypes.HealthStatus?
        /// The model of the network resource.
        public var model: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which this network resource appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network resource.
        public var networkResourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site on which this network resource appears.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase this network resource.
        public var orderArn: Swift.String?
        /// The position of the network resource.
        public var position: PrivateNetworksClientTypes.Position?
        /// Information about a request to return the network resource.
        public var returnInformation: PrivateNetworksClientTypes.ReturnInformation?
        /// The serial number of the network resource.
        public var serialNumber: Swift.String?
        /// The status of the network resource.
        public var status: PrivateNetworksClientTypes.NetworkResourceStatus?
        /// The status reason of the network resource.
        public var statusReason: Swift.String?
        /// The type of the network resource.
        public var type: PrivateNetworksClientTypes.NetworkResourceType?
        /// The vendor of the network resource.
        public var vendor: Swift.String?

        public init(
            attributes: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            commitmentInformation: PrivateNetworksClientTypes.CommitmentInformation? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            health: PrivateNetworksClientTypes.HealthStatus? = nil,
            model: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkResourceArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            position: PrivateNetworksClientTypes.Position? = nil,
            returnInformation: PrivateNetworksClientTypes.ReturnInformation? = nil,
            serialNumber: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceType? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.commitmentInformation = commitmentInformation
            self.createdAt = createdAt
            self.description = description
            self.health = health
            self.model = model
            self.networkArn = networkArn
            self.networkResourceArn = networkResourceArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.position = position
            self.returnInformation = returnInformation
            self.serialNumber = serialNumber
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.vendor = vendor
        }
    }

}

extension PrivateNetworksClientTypes.NetworkResourceDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case options
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for namevaluepair0 in options {
                try optionsContainer.encode(namevaluepair0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceDefinitionType.self, forKey: .type)
        type = typeDecoded
        let optionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .options)
        var optionsDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network resource definition.
    public struct NetworkResourceDefinition: Swift.Equatable {
        /// The count in the network resource definition.
        /// This member is required.
        public var count: Swift.Int?
        /// The options in the network resource definition.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The type in the network resource definition.
        /// This member is required.
        public var type: PrivateNetworksClientTypes.NetworkResourceDefinitionType?

        public init(
            count: Swift.Int? = nil,
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceDefinitionType? = nil
        )
        {
            self.count = count
            self.options = options
            self.type = type
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceIdentifier
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceDefinitionType] {
            return [
                .deviceIdentifier,
                .radioUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceIdentifier: return "DEVICE_IDENTIFIER"
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceDefinitionType(rawValue: rawValue) ?? NetworkResourceDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case order
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceFilterKeys] {
            return [
                .order,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceFilterKeys(rawValue: rawValue) ?? NetworkResourceFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creatingShippingLabel
        case deleted
        case deleting
        case pending
        case pendingReturn
        case provisioned
        case provisioning
        case shipped
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceStatus] {
            return [
                .available,
                .creatingShippingLabel,
                .deleted,
                .deleting,
                .pending,
                .pendingReturn,
                .provisioned,
                .provisioning,
                .shipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creatingShippingLabel: return "CREATING_SHIPPING_LABEL"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .pendingReturn: return "PENDING_RETURN"
            case .provisioned: return "PROVISIONED"
            case .provisioning: return "PROVISIONING"
            case .shipped: return "SHIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceStatus(rawValue: rawValue) ?? NetworkResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceType] {
            return [
                .radioUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceType(rawValue: rawValue) ?? NetworkResourceType.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.NetworkSite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case createdAt
        case currentPlan
        case description
        case networkArn
        case networkSiteArn
        case networkSiteName
        case pendingPlan
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let currentPlan = self.currentPlan {
            try encodeContainer.encode(currentPlan, forKey: .currentPlan)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let networkSiteName = self.networkSiteName {
            try encodeContainer.encode(networkSiteName, forKey: .networkSiteName)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let networkSiteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteName)
        networkSiteName = networkSiteNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSiteStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let currentPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .currentPlan)
        currentPlan = currentPlanDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network site.
    public struct NetworkSite: Swift.Equatable {
        /// The parent Availability Zone for the network site.
        public var availabilityZone: Swift.String?
        /// The parent Availability Zone ID for the network site.
        public var availabilityZoneId: Swift.String?
        /// The creation time of the network site.
        public var createdAt: ClientRuntime.Date?
        /// The current plan of the network site.
        public var currentPlan: PrivateNetworksClientTypes.SitePlan?
        /// The description of the network site.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network to which the network site belongs.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site.
        /// This member is required.
        public var networkSiteArn: Swift.String?
        /// The name of the network site.
        /// This member is required.
        public var networkSiteName: Swift.String?
        /// The pending plan of the network site.
        public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
        /// The status of the network site.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkSiteStatus?
        /// The status reason of the network site.
        public var statusReason: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            currentPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            networkSiteName: Swift.String? = nil,
            pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            status: PrivateNetworksClientTypes.NetworkSiteStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.createdAt = createdAt
            self.currentPlan = currentPlan
            self.description = description
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.networkSiteName = networkSiteName
            self.pendingPlan = pendingPlan
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkSiteFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteFilterKeys] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSiteFilterKeys(rawValue: rawValue) ?? NetworkSiteFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkSiteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSiteStatus(rawValue: rawValue) ?? NetworkSiteStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkStatus(rawValue: rawValue) ?? NetworkStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.Order: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgmentStatus
        case createdAt
        case networkArn
        case networkSiteArn
        case orderArn
        case orderedResources
        case shippingAddress
        case trackingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgmentStatus = self.acknowledgmentStatus {
            try encodeContainer.encode(acknowledgmentStatus.rawValue, forKey: .acknowledgmentStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let orderedResources = orderedResources {
            var orderedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedResources)
            for orderedresourcedefinition0 in orderedResources {
                try orderedResourcesContainer.encode(orderedresourcedefinition0)
            }
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let trackingInformation = trackingInformation {
            var trackingInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trackingInformation)
            for trackinginformation0 in trackingInformation {
                try trackingInformationContainer.encode(trackinginformation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let trackingInformationContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.TrackingInformation?].self, forKey: .trackingInformation)
        var trackingInformationDecoded0:[PrivateNetworksClientTypes.TrackingInformation]? = nil
        if let trackingInformationContainer = trackingInformationContainer {
            trackingInformationDecoded0 = [PrivateNetworksClientTypes.TrackingInformation]()
            for structure0 in trackingInformationContainer {
                if let structure0 = structure0 {
                    trackingInformationDecoded0?.append(structure0)
                }
            }
        }
        trackingInformation = trackingInformationDecoded0
        let acknowledgmentStatusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.AcknowledgmentStatus.self, forKey: .acknowledgmentStatus)
        acknowledgmentStatus = acknowledgmentStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let orderedResourcesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.OrderedResourceDefinition?].self, forKey: .orderedResources)
        var orderedResourcesDecoded0:[PrivateNetworksClientTypes.OrderedResourceDefinition]? = nil
        if let orderedResourcesContainer = orderedResourcesContainer {
            orderedResourcesDecoded0 = [PrivateNetworksClientTypes.OrderedResourceDefinition]()
            for structure0 in orderedResourcesContainer {
                if let structure0 = structure0 {
                    orderedResourcesDecoded0?.append(structure0)
                }
            }
        }
        orderedResources = orderedResourcesDecoded0
    }
}

extension PrivateNetworksClientTypes {
    /// Information about an order.
    public struct Order: Swift.Equatable {
        /// The acknowledgement status of the order.
        public var acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus?
        /// The creation time of the order.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the network associated with this order.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site associated with this order.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order.
        public var orderArn: Swift.String?
        /// A list of the network resources placed in the order.
        public var orderedResources: [PrivateNetworksClientTypes.OrderedResourceDefinition]?
        /// The shipping address of the order.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The tracking information of the order.
        public var trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]?

        public init(
            acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            orderedResources: [PrivateNetworksClientTypes.OrderedResourceDefinition]? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]? = nil
        )
        {
            self.acknowledgmentStatus = acknowledgmentStatus
            self.createdAt = createdAt
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.orderedResources = orderedResources
            self.shippingAddress = shippingAddress
            self.trackingInformation = trackingInformation
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum OrderFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case networkSite
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderFilterKeys] {
            return [
                .networkSite,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .networkSite: return "NETWORK_SITE"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderFilterKeys(rawValue: rawValue) ?? OrderFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.OrderedResourceDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentConfiguration
        case count
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitmentConfiguration = self.commitmentConfiguration {
            try encodeContainer.encode(commitmentConfiguration, forKey: .commitmentConfiguration)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceDefinitionType.self, forKey: .type)
        type = typeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let commitmentConfigurationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentConfiguration.self, forKey: .commitmentConfiguration)
        commitmentConfiguration = commitmentConfigurationDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Details of the network resources in the order.
    public struct OrderedResourceDefinition: Swift.Equatable {
        /// The duration and renewal status of the commitment period for each radio unit in the order. Does not show details if the resource type is DEVICE_IDENTIFIER.
        public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
        /// The number of network resources in the order.
        /// This member is required.
        public var count: Swift.Int?
        /// The type of network resource in the order.
        /// This member is required.
        public var type: PrivateNetworksClientTypes.NetworkResourceDefinitionType?

        public init(
            commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
            count: Swift.Int? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceDefinitionType? = nil
        )
        {
            self.commitmentConfiguration = commitmentConfiguration
            self.count = count
            self.type = type
        }
    }

}

extension PingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ping"
    }
}

public struct PingInput: Swift.Equatable {

    public init() { }
}

struct PingInputBody: Swift.Equatable {
}

extension PingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PingOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct PingOutput: Swift.Equatable {
    /// Information about the health of the service.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct PingOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension PingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum PingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes.Position: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elevation
        case elevationReference
        case elevationUnit
        case latitude
        case longitude
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elevation = self.elevation {
            try encodeContainer.encode(elevation, forKey: .elevation)
        }
        if let elevationReference = self.elevationReference {
            try encodeContainer.encode(elevationReference.rawValue, forKey: .elevationReference)
        }
        if let elevationUnit = self.elevationUnit {
            try encodeContainer.encode(elevationUnit.rawValue, forKey: .elevationUnit)
        }
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .longitude)
        longitude = longitudeDecoded
        let elevationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .elevation)
        elevation = elevationDecoded
        let elevationUnitDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ElevationUnit.self, forKey: .elevationUnit)
        elevationUnit = elevationUnitDecoded
        let elevationReferenceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ElevationReference.self, forKey: .elevationReference)
        elevationReference = elevationReferenceDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a position.
    public struct Position: Swift.Equatable {
        /// The elevation of the equipment at this position.
        public var elevation: Swift.Double?
        /// The reference point from which elevation is reported.
        public var elevationReference: PrivateNetworksClientTypes.ElevationReference?
        /// The units used to measure the elevation of the position.
        public var elevationUnit: PrivateNetworksClientTypes.ElevationUnit?
        /// The latitude of the position.
        public var latitude: Swift.Double?
        /// The longitude of the position.
        public var longitude: Swift.Double?

        public init(
            elevation: Swift.Double? = nil,
            elevationReference: PrivateNetworksClientTypes.ElevationReference? = nil,
            elevationUnit: PrivateNetworksClientTypes.ElevationUnit? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.elevation = elevation
            self.elevationReference = elevationReference
            self.elevationUnit = elevationUnit
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the affected resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension PrivateNetworksClientTypes.ReturnInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replacementOrderArn
        case returnReason
        case shippingAddress
        case shippingLabel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replacementOrderArn = self.replacementOrderArn {
            try encodeContainer.encode(replacementOrderArn, forKey: .replacementOrderArn)
        }
        if let returnReason = self.returnReason {
            try encodeContainer.encode(returnReason, forKey: .returnReason)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let shippingLabel = self.shippingLabel {
            try encodeContainer.encode(shippingLabel, forKey: .shippingLabel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let returnReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnReason)
        returnReason = returnReasonDecoded
        let replacementOrderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementOrderArn)
        replacementOrderArn = replacementOrderArnDecoded
        let shippingLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shippingLabel)
        shippingLabel = shippingLabelDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a request to return a network resource.
    public struct ReturnInformation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the replacement order.
        public var replacementOrderArn: Swift.String?
        /// The reason for the return. If the return request did not include a reason for the return, this value is null.
        public var returnReason: Swift.String?
        /// The shipping address.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The URL of the shipping label. The shipping label is available for download only if the status of the network resource is PENDING_RETURN. For more information, see [Return a radio unit](https://docs.aws.amazon.com/private-networks/latest/userguide/radio-units.html#return-radio-unit).
        public var shippingLabel: Swift.String?

        public init(
            replacementOrderArn: Swift.String? = nil,
            returnReason: Swift.String? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            shippingLabel: Swift.String? = nil
        )
        {
            self.replacementOrderArn = replacementOrderArn
            self.returnReason = returnReason
            self.shippingAddress = shippingAddress
            self.shippingLabel = shippingLabel
        }
    }

}

extension PrivateNetworksClientTypes.SitePlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
        case resourceDefinitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for namevaluepair0 in options {
                try optionsContainer.encode(namevaluepair0)
            }
        }
        if let resourceDefinitions = resourceDefinitions {
            var resourceDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceDefinitions)
            for networkresourcedefinition0 in resourceDefinitions {
                try resourceDefinitionsContainer.encode(networkresourcedefinition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDefinitionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkResourceDefinition?].self, forKey: .resourceDefinitions)
        var resourceDefinitionsDecoded0:[PrivateNetworksClientTypes.NetworkResourceDefinition]? = nil
        if let resourceDefinitionsContainer = resourceDefinitionsContainer {
            resourceDefinitionsDecoded0 = [PrivateNetworksClientTypes.NetworkResourceDefinition]()
            for structure0 in resourceDefinitionsContainer {
                if let structure0 = structure0 {
                    resourceDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        resourceDefinitions = resourceDefinitionsDecoded0
        let optionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .options)
        var optionsDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a site plan.
    public struct SitePlan: Swift.Equatable {
        /// The options of the plan.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The resource definitions of the plan.
        public var resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]?

        public init(
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]? = nil
        )
        {
            self.options = options
            self.resourceDefinitions = resourceDefinitions
        }
    }

}

extension StartNetworkResourceUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentConfiguration
        case networkResourceArn
        case returnReason
        case shippingAddress
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitmentConfiguration = self.commitmentConfiguration {
            try encodeContainer.encode(commitmentConfiguration, forKey: .commitmentConfiguration)
        }
        if let networkResourceArn = self.networkResourceArn {
            try encodeContainer.encode(networkResourceArn, forKey: .networkResourceArn)
        }
        if let returnReason = self.returnReason {
            try encodeContainer.encode(returnReason, forKey: .returnReason)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension StartNetworkResourceUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources/update"
    }
}

public struct StartNetworkResourceUpdateInput: Swift.Equatable {
    /// Use this action to extend and automatically renew the commitment period for the radio unit. You can do the following:
    ///
    /// * Change a 60-day commitment to a 1-year or 3-year commitment. The change is immediate and the hourly rate decreases to the rate for the new commitment period.
    ///
    /// * Change a 1-year commitment to a 3-year commitment. The change is immediate and the hourly rate decreases to the rate for the 3-year commitment period.
    ///
    /// * Set a 1-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 1-year rate.
    ///
    /// * Set a 3-year commitment to automatically renew for an additional 1 year. The hourly rate for the additional year will continue to be the same as your existing 3-year rate.
    ///
    /// * Turn off a previously-enabled automatic renewal on a 1-year or 3-year commitment. You cannot use the automatic-renewal option for a 60-day commitment.
    ///
    ///
    /// For pricing, see [Amazon Web Services Private 5G Pricing](http://aws.amazon.com/private5g/pricing).
    public var commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?
    /// The reason for the return. Providing a reason for a return is optional.
    public var returnReason: Swift.String?
    /// The shipping address. If you don't provide a shipping address when replacing or returning a network resource, we use the address from the original order for the network resource.
    public var shippingAddress: PrivateNetworksClientTypes.Address?
    /// The update type.
    ///
    /// * REPLACE - Submits a request to replace a defective radio unit. We provide a shipping label that you can use for the return process and we ship a replacement radio unit to you.
    ///
    /// * RETURN - Submits a request to return a radio unit that you no longer need. We provide a shipping label that you can use for the return process.
    ///
    /// * COMMITMENT - Submits a request to change or renew the commitment period. If you choose this value, then you must set [commitmentConfiguration](https://docs.aws.amazon.com/private-networks/latest/APIReference/API_StartNetworkResourceUpdate.html#privatenetworks-StartNetworkResourceUpdate-request-commitmentConfiguration).
    /// This member is required.
    public var updateType: PrivateNetworksClientTypes.UpdateType?

    public init(
        commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration? = nil,
        networkResourceArn: Swift.String? = nil,
        returnReason: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil,
        updateType: PrivateNetworksClientTypes.UpdateType? = nil
    )
    {
        self.commitmentConfiguration = commitmentConfiguration
        self.networkResourceArn = networkResourceArn
        self.returnReason = returnReason
        self.shippingAddress = shippingAddress
        self.updateType = updateType
    }
}

struct StartNetworkResourceUpdateInputBody: Swift.Equatable {
    let networkResourceArn: Swift.String?
    let updateType: PrivateNetworksClientTypes.UpdateType?
    let shippingAddress: PrivateNetworksClientTypes.Address?
    let returnReason: Swift.String?
    let commitmentConfiguration: PrivateNetworksClientTypes.CommitmentConfiguration?
}

extension StartNetworkResourceUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentConfiguration
        case networkResourceArn
        case returnReason
        case shippingAddress
        case updateType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkResourceArn)
        networkResourceArn = networkResourceArnDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.UpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let returnReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnReason)
        returnReason = returnReasonDecoded
        let commitmentConfigurationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.CommitmentConfiguration.self, forKey: .commitmentConfiguration)
        commitmentConfiguration = commitmentConfigurationDecoded
    }
}

extension StartNetworkResourceUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartNetworkResourceUpdateOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkResource = output.networkResource
        } else {
            self.networkResource = nil
        }
    }
}

public struct StartNetworkResourceUpdateOutput: Swift.Equatable {
    /// The network resource.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?

    public init(
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.networkResource = networkResource
    }
}

struct StartNetworkResourceUpdateOutputBody: Swift.Equatable {
    let networkResource: PrivateNetworksClientTypes.NetworkResource?
}

extension StartNetworkResourceUpdateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .networkResource)
        networkResource = networkResourceDecoded
    }
}

enum StartNetworkResourceUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PrivateNetworksClientTypes.TrackingInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trackingNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trackingNumber = self.trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackingNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about tracking a shipment.
    public struct TrackingInformation: Swift.Equatable {
        /// The tracking number of the shipment.
        public var trackingNumber: Swift.String?

        public init(
            trackingNumber: Swift.String? = nil
        )
        {
            self.trackingNumber = trackingNumber
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkSiteArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
    }
}

extension UpdateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/site"
    }
}

public struct UpdateNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkSiteArn = networkSiteArn
    }
}

struct UpdateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
}

extension UpdateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkSiteArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateNetworkSiteOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSiteOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNetworkSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct UpdateNetworkSiteOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct UpdateNetworkSiteOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateNetworkSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateNetworkSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNetworkSitePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case pendingPlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
    }
}

extension UpdateNetworkSitePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/plan"
    }
}

public struct UpdateNetworkSitePlanInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The pending plan.
    /// This member is required.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?

    public init(
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
        self.pendingPlan = pendingPlan
    }
}

struct UpdateNetworkSitePlanInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let pendingPlan: PrivateNetworksClientTypes.SitePlan?
    let clientToken: Swift.String?
}

extension UpdateNetworkSitePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case pendingPlan
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateNetworkSitePlanOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSitePlanOutput(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkSitePlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateNetworkSitePlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct UpdateNetworkSitePlanOutput: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct UpdateNetworkSitePlanOutputBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateNetworkSitePlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateNetworkSitePlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum UpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case commitment
        case replace
        case `return`
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateType] {
            return [
                .commitment,
                .replace,
                .return,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .commitment: return "COMMITMENT"
            case .replace: return "REPLACE"
            case .return: return "RETURN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateType(rawValue: rawValue) ?? UpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed validation.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that caused the error, if applicable.
        public internal(set) var fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: PrivateNetworksClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PrivateNetworksClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PrivateNetworksClientTypes.ValidationExceptionReason?
    let fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[PrivateNetworksClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [PrivateNetworksClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension PrivateNetworksClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a field that failed validation.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message about the validation failure.
        /// This member is required.
        public var message: Swift.String?
        /// The field name that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotAssumeRole
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotAssumeRole,
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotAssumeRole: return "CANNOT_ASSUME_ROLE"
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
