// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcknowledgeOrderReceiptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
    }
}

extension AcknowledgeOrderReceiptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/orders/acknowledge"
    }
}

public struct AcknowledgeOrderReceiptInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init (
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

struct AcknowledgeOrderReceiptInputBody: Swift.Equatable {
    let orderArn: Swift.String?
}

extension AcknowledgeOrderReceiptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
    }
}

extension AcknowledgeOrderReceiptOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcknowledgeOrderReceiptOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcknowledgeOrderReceiptOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcknowledgeOrderReceiptOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcknowledgeOrderReceiptOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
        } else {
            self.order = nil
        }
    }
}

public struct AcknowledgeOrderReceiptOutputResponse: Swift.Equatable {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?

    public init (
        order: PrivateNetworksClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

struct AcknowledgeOrderReceiptOutputResponseBody: Swift.Equatable {
    let order: PrivateNetworksClientTypes.Order?
}

extension AcknowledgeOrderReceiptOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension PrivateNetworksClientTypes {
    public enum AcknowledgmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case acknowledging
        case unacknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [AcknowledgmentStatus] {
            return [
                .acknowledged,
                .acknowledging,
                .unacknowledged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .acknowledging: return "ACKNOWLEDGING"
            case .unacknowledged: return "UNACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcknowledgmentStatus(rawValue: rawValue) ?? AcknowledgmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ActivateDeviceIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
    }
}

extension ActivateDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/activate"
    }
}

public struct ActivateDeviceIdentifierInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct ActivateDeviceIdentifierInputBody: Swift.Equatable {
    let deviceIdentifierArn: Swift.String?
    let clientToken: Swift.String?
}

extension ActivateDeviceIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ActivateDeviceIdentifierOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateDeviceIdentifierOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ActivateDeviceIdentifierOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateDeviceIdentifierOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateDeviceIdentifierOutputResponse(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

extension ActivateDeviceIdentifierOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ActivateDeviceIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
            self.tags = output.tags
        } else {
            self.deviceIdentifier = nil
            self.tags = nil
        }
    }
}

public struct ActivateDeviceIdentifierOutputResponse: Swift.Equatable {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The tags on the device identifier.
    public var tags: [Swift.String:Swift.String]?

    public init (
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

struct ActivateDeviceIdentifierOutputResponseBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    let tags: [Swift.String:Swift.String]?
}

extension ActivateDeviceIdentifierOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ActivateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case shippingAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
    }
}

extension ActivateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/activate"
    }
}

public struct ActivateNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The shipping address of the network site.
    /// This member is required.
    public var shippingAddress: PrivateNetworksClientTypes.Address?

    public init (
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
        self.shippingAddress = shippingAddress
    }
}

struct ActivateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let shippingAddress: PrivateNetworksClientTypes.Address?
    let clientToken: Swift.String?
}

extension ActivateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case shippingAddress
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ActivateNetworkSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateNetworkSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ActivateNetworkSiteOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateNetworkSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ActivateNetworkSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
        } else {
            self.networkSite = nil
        }
    }
}

public struct ActivateNetworkSiteOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

struct ActivateNetworkSiteOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
}

extension ActivateNetworkSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
    }
}

extension PrivateNetworksClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case company
        case country
        case name
        case phoneNumber
        case postalCode
        case stateOrProvince
        case street1
        case street2
        case street3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let stateOrProvince = self.stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = self.street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = self.street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = self.street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let street1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street3)
        street3 = street3Decoded
    }
}

extension PrivateNetworksClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrProvince: \"CONTENT_REDACTED\", street1: \"CONTENT_REDACTED\", street2: \"CONTENT_REDACTED\", street3: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {
    /// Information about an address.
    public struct Address: Swift.Equatable {
        /// The city for this address.
        /// This member is required.
        public var city: Swift.String?
        /// The company name for this address.
        public var company: Swift.String?
        /// The country for this address.
        /// This member is required.
        public var country: Swift.String?
        /// The recipient's name for this address.
        /// This member is required.
        public var name: Swift.String?
        /// The phone number for this address.
        public var phoneNumber: Swift.String?
        /// The postal code for this address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state or province for this address.
        /// This member is required.
        public var stateOrProvince: Swift.String?
        /// The first line of the street address.
        /// This member is required.
        public var street1: Swift.String?
        /// The second line of the street address.
        public var street2: Swift.String?
        /// The third line of the street address.
        public var street3: Swift.String?

        public init (
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil
        )
        {
            self.city = city
            self.company = company
            self.country = country
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
        }
    }

}

extension ConfigureAccessPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureAccessPointInput(accessPointArn: \(Swift.String(describing: accessPointArn)), position: \(Swift.String(describing: position)), cpiSecretKey: \"CONTENT_REDACTED\", cpiUserId: \"CONTENT_REDACTED\", cpiUserPassword: \"CONTENT_REDACTED\", cpiUsername: \"CONTENT_REDACTED\")"}
}

extension ConfigureAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn
        case cpiSecretKey
        case cpiUserId
        case cpiUserPassword
        case cpiUsername
        case position
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = self.accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
        if let cpiSecretKey = self.cpiSecretKey {
            try encodeContainer.encode(cpiSecretKey, forKey: .cpiSecretKey)
        }
        if let cpiUserId = self.cpiUserId {
            try encodeContainer.encode(cpiUserId, forKey: .cpiUserId)
        }
        if let cpiUserPassword = self.cpiUserPassword {
            try encodeContainer.encode(cpiUserPassword, forKey: .cpiUserPassword)
        }
        if let cpiUsername = self.cpiUsername {
            try encodeContainer.encode(cpiUsername, forKey: .cpiUsername)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
    }
}

extension ConfigureAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources/configure"
    }
}

public struct ConfigureAccessPointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var accessPointArn: Swift.String?
    /// A Base64 encoded string of the CPI certificate associated with the CPI user who is certifying the coordinates of the network resource.
    public var cpiSecretKey: Swift.String?
    /// The CPI user ID of the CPI user who is certifying the coordinates of the network resource.
    public var cpiUserId: Swift.String?
    /// The CPI password associated with the CPI certificate in cpiSecretKey.
    public var cpiUserPassword: Swift.String?
    /// The CPI user name of the CPI user who is certifying the coordinates of the radio unit.
    public var cpiUsername: Swift.String?
    /// The position of the network resource.
    public var position: PrivateNetworksClientTypes.Position?

    public init (
        accessPointArn: Swift.String? = nil,
        cpiSecretKey: Swift.String? = nil,
        cpiUserId: Swift.String? = nil,
        cpiUserPassword: Swift.String? = nil,
        cpiUsername: Swift.String? = nil,
        position: PrivateNetworksClientTypes.Position? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.cpiSecretKey = cpiSecretKey
        self.cpiUserId = cpiUserId
        self.cpiUserPassword = cpiUserPassword
        self.cpiUsername = cpiUsername
        self.position = position
    }
}

struct ConfigureAccessPointInputBody: Swift.Equatable {
    let accessPointArn: Swift.String?
    let position: PrivateNetworksClientTypes.Position?
    let cpiUsername: Swift.String?
    let cpiUserId: Swift.String?
    let cpiUserPassword: Swift.String?
    let cpiSecretKey: Swift.String?
}

extension ConfigureAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn
        case cpiSecretKey
        case cpiUserId
        case cpiUserPassword
        case cpiUsername
        case position
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let positionDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Position.self, forKey: .position)
        position = positionDecoded
        let cpiUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUsername)
        cpiUsername = cpiUsernameDecoded
        let cpiUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUserId)
        cpiUserId = cpiUserIdDecoded
        let cpiUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiUserPassword)
        cpiUserPassword = cpiUserPasswordDecoded
        let cpiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpiSecretKey)
        cpiSecretKey = cpiSecretKeyDecoded
    }
}

extension ConfigureAccessPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureAccessPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfigureAccessPointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureAccessPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfigureAccessPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPoint = output.accessPoint
        } else {
            self.accessPoint = nil
        }
    }
}

public struct ConfigureAccessPointOutputResponse: Swift.Equatable {
    /// Information about the network resource.
    /// This member is required.
    public var accessPoint: PrivateNetworksClientTypes.NetworkResource?

    public init (
        accessPoint: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.accessPoint = accessPoint
    }
}

struct ConfigureAccessPointOutputResponseBody: Swift.Equatable {
    let accessPoint: PrivateNetworksClientTypes.NetworkResource?
}

extension ConfigureAccessPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .accessPoint)
        accessPoint = accessPointDecoded
    }
}

extension CreateNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkName: \(Swift.String(describing: networkName)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/networks"
    }
}

public struct CreateNetworkInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the network.
    public var description: Swift.String?
    /// The name of the network. You can't change the name after you create the network.
    /// This member is required.
    public var networkName: Swift.String?
    /// The tags to apply to the network.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkName = networkName
        self.tags = tags
    }
}

struct CreateNetworkInputBody: Swift.Equatable {
    let networkName: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNetworkOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkOutputResponse(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
            self.tags = output.tags
        } else {
            self.network = nil
            self.tags = nil
        }
    }
}

public struct CreateNetworkOutputResponse: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

struct CreateNetworkOutputResponseBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteInput(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), networkArn: \(Swift.String(describing: networkArn)), networkSiteName: \(Swift.String(describing: networkSiteName)), pendingPlan: \(Swift.String(describing: pendingPlan)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case clientToken
        case description
        case networkArn
        case networkSiteName
        case pendingPlan
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteName = self.networkSiteName {
            try encodeContainer.encode(networkSiteName, forKey: .networkSiteName)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites"
    }
}

public struct CreateNetworkSiteInput: Swift.Equatable {
    /// The Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone that is the parent of this site. You can't change the Availability Zone after you create the site.
    public var availabilityZoneId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description of the site.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The name of the site. You can't change the name after you create the site.
    /// This member is required.
    public var networkSiteName: Swift.String?
    /// Information about the pending plan for this site.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
    /// The tags to apply to the network site.
    public var tags: [Swift.String:Swift.String]?

    public init (
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkArn: Swift.String? = nil,
        networkSiteName: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.description = description
        self.networkArn = networkArn
        self.networkSiteName = networkSiteName
        self.pendingPlan = pendingPlan
        self.tags = tags
    }
}

struct CreateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteName: Swift.String?
    let description: Swift.String?
    let networkArn: Swift.String?
    let pendingPlan: PrivateNetworksClientTypes.SitePlan?
    let clientToken: Swift.String?
    let availabilityZone: Swift.String?
    let availabilityZoneId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case clientToken
        case description
        case networkArn
        case networkSiteName
        case pendingPlan
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteName)
        networkSiteName = networkSiteNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNetworkSiteOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSiteOutputResponse(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNetworkSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct CreateNetworkSiteOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct CreateNetworkSiteOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension CreateNetworkSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeactivateDeviceIdentifierInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
    }
}

extension DeactivateDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/deactivate"
    }
}

public struct DeactivateDeviceIdentifierInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct DeactivateDeviceIdentifierInputBody: Swift.Equatable {
    let deviceIdentifierArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeactivateDeviceIdentifierInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case deviceIdentifierArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeactivateDeviceIdentifierOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateDeviceIdentifierOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeactivateDeviceIdentifierOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateDeviceIdentifierOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeactivateDeviceIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
        } else {
            self.deviceIdentifier = nil
        }
    }
}

public struct DeactivateDeviceIdentifierOutputResponse: Swift.Equatable {
    /// Information about the device identifier.
    /// This member is required.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?

    public init (
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
    }
}

struct DeactivateDeviceIdentifierOutputResponseBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
}

extension DeactivateDeviceIdentifierOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
    }
}

extension DeleteNetworkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkArn = networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

public struct DeleteNetworkInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        networkArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkArn = networkArn
    }
}

struct DeleteNetworkInputBody: Swift.Equatable {
}

extension DeleteNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
        } else {
            self.network = nil
        }
    }
}

public struct DeleteNetworkOutputResponse: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?

    public init (
        network: PrivateNetworksClientTypes.Network? = nil
    )
    {
        self.network = network
    }
}

struct DeleteNetworkOutputResponseBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
}

extension DeleteNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
    }
}

extension DeleteNetworkSiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSiteArn = networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

public struct DeleteNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
    }
}

struct DeleteNetworkSiteInputBody: Swift.Equatable {
}

extension DeleteNetworkSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNetworkSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteNetworkSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
        } else {
            self.networkSite = nil
        }
    }
}

public struct DeleteNetworkSiteOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil
    )
    {
        self.networkSite = networkSite
    }
}

struct DeleteNetworkSiteOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
}

extension DeleteNetworkSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
    }
}

extension PrivateNetworksClientTypes.DeviceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deviceIdentifierArn
        case iccid
        case imsi
        case networkArn
        case orderArn
        case status
        case trafficGroupArn
        case vendor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let deviceIdentifierArn = self.deviceIdentifierArn {
            try encodeContainer.encode(deviceIdentifierArn, forKey: .deviceIdentifierArn)
        }
        if let iccid = self.iccid {
            try encodeContainer.encode(iccid, forKey: .iccid)
        }
        if let imsi = self.imsi {
            try encodeContainer.encode(imsi, forKey: .imsi)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let trafficGroupArn = self.trafficGroupArn {
            try encodeContainer.encode(trafficGroupArn, forKey: .trafficGroupArn)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceIdentifierArn)
        deviceIdentifierArn = deviceIdentifierArnDecoded
        let trafficGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trafficGroupArn)
        trafficGroupArn = trafficGroupArnDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let imsiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imsi)
        imsi = imsiDecoded
        let iccidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iccid)
        iccid = iccidDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifierStatus.self, forKey: .status)
        status = statusDecoded
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension PrivateNetworksClientTypes.DeviceIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceIdentifier(createdAt: \(Swift.String(describing: createdAt)), deviceIdentifierArn: \(Swift.String(describing: deviceIdentifierArn)), iccid: \(Swift.String(describing: iccid)), networkArn: \(Swift.String(describing: networkArn)), orderArn: \(Swift.String(describing: orderArn)), status: \(Swift.String(describing: status)), trafficGroupArn: \(Swift.String(describing: trafficGroupArn)), vendor: \(Swift.String(describing: vendor)), imsi: \"CONTENT_REDACTED\")"}
}

extension PrivateNetworksClientTypes {
    /// Information about a subscriber of a device that can use a network.
    public struct DeviceIdentifier: Swift.Equatable {
        /// The creation time of this device identifier.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the device identifier.
        public var deviceIdentifierArn: Swift.String?
        /// The Integrated Circuit Card Identifier of the device identifier.
        public var iccid: Swift.String?
        /// The International Mobile Subscriber Identity of the device identifier.
        public var imsi: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which the device identifier appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase the device identifier.
        public var orderArn: Swift.String?
        /// The status of the device identifier.
        public var status: PrivateNetworksClientTypes.DeviceIdentifierStatus?
        /// The Amazon Resource Name (ARN) of the traffic group to which the device identifier belongs.
        public var trafficGroupArn: Swift.String?
        /// The vendor of the device identifier.
        public var vendor: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            deviceIdentifierArn: Swift.String? = nil,
            iccid: Swift.String? = nil,
            imsi: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            status: PrivateNetworksClientTypes.DeviceIdentifierStatus? = nil,
            trafficGroupArn: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deviceIdentifierArn = deviceIdentifierArn
            self.iccid = iccid
            self.imsi = imsi
            self.networkArn = networkArn
            self.orderArn = orderArn
            self.status = status
            self.trafficGroupArn = trafficGroupArn
            self.vendor = vendor
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum DeviceIdentifierFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case order
        case status
        case trafficGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierFilterKeys] {
            return [
                .order,
                .status,
                .trafficGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case .trafficGroup: return "TRAFFIC_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceIdentifierFilterKeys(rawValue: rawValue) ?? DeviceIdentifierFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum DeviceIdentifierStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceIdentifierStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceIdentifierStatus(rawValue: rawValue) ?? DeviceIdentifierStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum ElevationReference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agl
        case amsl
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationReference] {
            return [
                .agl,
                .amsl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agl: return "AGL"
            case .amsl: return "AMSL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ElevationReference(rawValue: rawValue) ?? ElevationReference.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum ElevationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Feet.
        case feet
        case sdkUnknown(Swift.String)

        public static var allCases: [ElevationUnit] {
            return [
                .feet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .feet: return "FEET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ElevationUnit(rawValue: rawValue) ?? ElevationUnit.sdkUnknown(rawValue)
        }
    }
}

extension GetDeviceIdentifierInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceIdentifierArn = deviceIdentifierArn else {
            return nil
        }
        return "/v1/device-identifiers/\(deviceIdentifierArn.urlPercentEncoding())"
    }
}

public struct GetDeviceIdentifierInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device identifier.
    /// This member is required.
    public var deviceIdentifierArn: Swift.String?

    public init (
        deviceIdentifierArn: Swift.String? = nil
    )
    {
        self.deviceIdentifierArn = deviceIdentifierArn
    }
}

struct GetDeviceIdentifierInputBody: Swift.Equatable {
}

extension GetDeviceIdentifierInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceIdentifierOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceIdentifierOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceIdentifierOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceIdentifierOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceIdentifierOutputResponse(deviceIdentifier: \(Swift.String(describing: deviceIdentifier)), tags: \"CONTENT_REDACTED\")"}
}

extension GetDeviceIdentifierOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifier = output.deviceIdentifier
            self.tags = output.tags
        } else {
            self.deviceIdentifier = nil
            self.tags = nil
        }
    }
}

public struct GetDeviceIdentifierOutputResponse: Swift.Equatable {
    /// Information about the device identifier.
    public var deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    /// The device identifier tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deviceIdentifier = deviceIdentifier
        self.tags = tags
    }
}

struct GetDeviceIdentifierOutputResponseBody: Swift.Equatable {
    let deviceIdentifier: PrivateNetworksClientTypes.DeviceIdentifier?
    let tags: [Swift.String:Swift.String]?
}

extension GetDeviceIdentifierOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifier
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifierDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.DeviceIdentifier.self, forKey: .deviceIdentifier)
        deviceIdentifier = deviceIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkArn = networkArn else {
            return nil
        }
        return "/v1/networks/\(networkArn.urlPercentEncoding())"
    }
}

public struct GetNetworkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?

    public init (
        networkArn: Swift.String? = nil
    )
    {
        self.networkArn = networkArn
    }
}

struct GetNetworkInputBody: Swift.Equatable {
}

extension GetNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkOutputResponse(network: \(Swift.String(describing: network)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.network = output.network
            self.tags = output.tags
        } else {
            self.network = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkOutputResponse: Swift.Equatable {
    /// Information about the network.
    /// This member is required.
    public var network: PrivateNetworksClientTypes.Network?
    /// The network tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        network: PrivateNetworksClientTypes.Network? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.network = network
        self.tags = tags
    }
}

struct GetNetworkOutputResponseBody: Swift.Equatable {
    let network: PrivateNetworksClientTypes.Network?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Network.self, forKey: .network)
        network = networkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetNetworkResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkResourceArn = networkResourceArn else {
            return nil
        }
        return "/v1/network-resources/\(networkResourceArn.urlPercentEncoding())"
    }
}

public struct GetNetworkResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?

    public init (
        networkResourceArn: Swift.String? = nil
    )
    {
        self.networkResourceArn = networkResourceArn
    }
}

struct GetNetworkResourceInputBody: Swift.Equatable {
}

extension GetNetworkResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkResourceOutputResponse(networkResource: \(Swift.String(describing: networkResource)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResource = output.networkResource
            self.tags = output.tags
        } else {
            self.networkResource = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkResourceOutputResponse: Swift.Equatable {
    /// Information about the network resource.
    /// This member is required.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?
    /// The network resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkResource = networkResource
        self.tags = tags
    }
}

struct GetNetworkResourceOutputResponseBody: Swift.Equatable {
    let networkResource: PrivateNetworksClientTypes.NetworkResource?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResource
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .networkResource)
        networkResource = networkResourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let networkSiteArn = networkSiteArn else {
            return nil
        }
        return "/v1/network-sites/\(networkSiteArn.urlPercentEncoding())"
    }
}

public struct GetNetworkSiteInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init (
        networkSiteArn: Swift.String? = nil
    )
    {
        self.networkSiteArn = networkSiteArn
    }
}

struct GetNetworkSiteInputBody: Swift.Equatable {
}

extension GetNetworkSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetNetworkSiteOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkSiteOutputResponse(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension GetNetworkSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetNetworkSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct GetNetworkSiteOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct GetNetworkSiteOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension GetNetworkSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let orderArn = orderArn else {
            return nil
        }
        return "/v1/orders/\(orderArn.urlPercentEncoding())"
    }
}

public struct GetOrderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the order.
    /// This member is required.
    public var orderArn: Swift.String?

    public init (
        orderArn: Swift.String? = nil
    )
    {
        self.orderArn = orderArn
    }
}

struct GetOrderInputBody: Swift.Equatable {
}

extension GetOrderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrderOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOrderOutputResponse(order: \(Swift.String(describing: order)), tags: \"CONTENT_REDACTED\")"}
}

extension GetOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
            self.tags = output.tags
        } else {
            self.order = nil
            self.tags = nil
        }
    }
}

public struct GetOrderOutputResponse: Swift.Equatable {
    /// Information about the order.
    /// This member is required.
    public var order: PrivateNetworksClientTypes.Order?
    /// The order tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        order: PrivateNetworksClientTypes.Order? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.order = order
        self.tags = tags
    }
}

struct GetOrderOutputResponseBody: Swift.Equatable {
    let order: PrivateNetworksClientTypes.Order?
    let tags: [Swift.String:Swift.String]?
}

extension GetOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Order.self, forKey: .order)
        order = orderDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PrivateNetworksClientTypes {
    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case initial
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .initial,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Information about an internal error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDeviceIdentifiersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, deviceIdentifierFilters0) in filters {
                var deviceIdentifierFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in deviceIdentifierFilters0 {
                    try deviceIdentifierFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListDeviceIdentifiersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/device-identifiers/list"
    }
}

public struct ListDeviceIdentifiersInput: Swift.Equatable {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (ACTIVE | INACTIVE).
    ///
    /// * TRAFFIC_GROUP - The Amazon Resource Name (ARN) of the traffic group.
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init (
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListDeviceIdentifiersInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeviceIdentifiersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, deviceidentifierfiltervalues0) in filtersContainer {
                var deviceidentifierfiltervalues0Decoded0: [Swift.String]? = nil
                if let deviceidentifierfiltervalues0 = deviceidentifierfiltervalues0 {
                    deviceidentifierfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in deviceidentifierfiltervalues0 {
                        if let string1 = string1 {
                            deviceidentifierfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = deviceidentifierfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeviceIdentifiersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceIdentifiersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceIdentifiersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceIdentifiersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceIdentifiersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceIdentifiers = output.deviceIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.deviceIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceIdentifiersOutputResponse: Swift.Equatable {
    /// Information about the device identifiers.
    public var deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceIdentifiers = deviceIdentifiers
        self.nextToken = nextToken
    }
}

struct ListDeviceIdentifiersOutputResponseBody: Swift.Equatable {
    let deviceIdentifiers: [PrivateNetworksClientTypes.DeviceIdentifier]?
    let nextToken: Swift.String?
}

extension ListDeviceIdentifiersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIdentifiers
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdentifiersContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.DeviceIdentifier?].self, forKey: .deviceIdentifiers)
        var deviceIdentifiersDecoded0:[PrivateNetworksClientTypes.DeviceIdentifier]? = nil
        if let deviceIdentifiersContainer = deviceIdentifiersContainer {
            deviceIdentifiersDecoded0 = [PrivateNetworksClientTypes.DeviceIdentifier]()
            for structure0 in deviceIdentifiersContainer {
                if let structure0 = structure0 {
                    deviceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        deviceIdentifiers = deviceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkResourceFilters0) in filters {
                var networkResourceFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkResourceFilters0 {
                    try networkResourceFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworkResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources"
    }
}

public struct ListNetworkResourcesInput: Swift.Equatable {
    /// The filters.
    ///
    /// * ORDER - The Amazon Resource Name (ARN) of the order.
    ///
    /// * STATUS - The status (AVAILABLE | DELETED | DELETING | PENDING | PENDING_RETURN | PROVISIONING | SHIPPED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init (
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListNetworkResourcesInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworkResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networkresourcefiltervalues0) in filtersContainer {
                var networkresourcefiltervalues0Decoded0: [Swift.String]? = nil
                if let networkresourcefiltervalues0 = networkresourcefiltervalues0 {
                    networkresourcefiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networkresourcefiltervalues0 {
                        if let string1 = string1 {
                            networkresourcefiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networkresourcefiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworkResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworkResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworkResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResources = output.networkResources
            self.nextToken = output.nextToken
        } else {
            self.networkResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkResourcesOutputResponse: Swift.Equatable {
    /// Information about network resources.
    public var networkResources: [PrivateNetworksClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkResources: [PrivateNetworksClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

struct ListNetworkResourcesOutputResponseBody: Swift.Equatable {
    let networkResources: [PrivateNetworksClientTypes.NetworkResource]?
    let nextToken: Swift.String?
}

extension ListNetworkResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourcesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkResource?].self, forKey: .networkResources)
        var networkResourcesDecoded0:[PrivateNetworksClientTypes.NetworkResource]? = nil
        if let networkResourcesContainer = networkResourcesContainer {
            networkResourcesDecoded0 = [PrivateNetworksClientTypes.NetworkResource]()
            for structure0 in networkResourcesContainer {
                if let structure0 = structure0 {
                    networkResourcesDecoded0?.append(structure0)
                }
            }
        }
        networkResources = networkResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkSitesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkSiteFilters0) in filters {
                var networkSiteFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkSiteFilters0 {
                    try networkSiteFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworkSitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/list"
    }
}

public struct ListNetworkSitesInput: Swift.Equatable {
    /// The filters. Add filters to your request to return a more specific list of results. Use filters to match the status of the network sites.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init (
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListNetworkSitesInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworkSitesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networksitefiltervalues0) in filtersContainer {
                var networksitefiltervalues0Decoded0: [Swift.String]? = nil
                if let networksitefiltervalues0 = networksitefiltervalues0 {
                    networksitefiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networksitefiltervalues0 {
                        if let string1 = string1 {
                            networksitefiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networksitefiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworkSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworkSitesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworkSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSites = output.networkSites
            self.nextToken = output.nextToken
        } else {
            self.networkSites = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSitesOutputResponse: Swift.Equatable {
    /// Information about the network sites.
    public var networkSites: [PrivateNetworksClientTypes.NetworkSite]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networkSites: [PrivateNetworksClientTypes.NetworkSite]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSites = networkSites
        self.nextToken = nextToken
    }
}

struct ListNetworkSitesOutputResponseBody: Swift.Equatable {
    let networkSites: [PrivateNetworksClientTypes.NetworkSite]?
    let nextToken: Swift.String?
}

extension ListNetworkSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSites
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSitesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkSite?].self, forKey: .networkSites)
        var networkSitesDecoded0:[PrivateNetworksClientTypes.NetworkSite]? = nil
        if let networkSitesContainer = networkSitesContainer {
            networkSitesDecoded0 = [PrivateNetworksClientTypes.NetworkSite]()
            for structure0 in networkSitesContainer {
                if let structure0 = structure0 {
                    networkSitesDecoded0?.append(structure0)
                }
            }
        }
        networkSites = networkSitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, networkFilters0) in filters {
                var networkFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in networkFilters0 {
                    try networkFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/networks/list"
    }
}

public struct ListNetworksInput: Swift.Equatable {
    /// The filters.
    ///
    /// * STATUS - The status (AVAILABLE | CREATED | DELETED | DEPROVISIONING | PROVISIONING).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init (
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.startToken = startToken
    }
}

struct ListNetworksInputBody: Swift.Equatable {
    let filters: [Swift.String:[Swift.String]]?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListNetworksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case startToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, networkfiltervalues0) in filtersContainer {
                var networkfiltervalues0Decoded0: [Swift.String]? = nil
                if let networkfiltervalues0 = networkfiltervalues0 {
                    networkfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in networkfiltervalues0 {
                        if let string1 = string1 {
                            networkfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = networkfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNetworksOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networks = output.networks
            self.nextToken = output.nextToken
        } else {
            self.networks = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworksOutputResponse: Swift.Equatable {
    /// The networks.
    public var networks: [PrivateNetworksClientTypes.Network]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        networks: [PrivateNetworksClientTypes.Network]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networks = networks
        self.nextToken = nextToken
    }
}

struct ListNetworksOutputResponseBody: Swift.Equatable {
    let networks: [PrivateNetworksClientTypes.Network]?
    let nextToken: Swift.String?
}

extension ListNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networks
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networksContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.Network?].self, forKey: .networks)
        var networksDecoded0:[PrivateNetworksClientTypes.Network]? = nil
        if let networksContainer = networksContainer {
            networksDecoded0 = [PrivateNetworksClientTypes.Network]()
            for structure0 in networksContainer {
                if let structure0 = structure0 {
                    networksDecoded0?.append(structure0)
                }
            }
        }
        networks = networksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrdersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, orderFilters0) in filters {
                var orderFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in orderFilters0 {
                    try orderFilters0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let startToken = self.startToken {
            try encodeContainer.encode(startToken, forKey: .startToken)
        }
    }
}

extension ListOrdersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/orders/list"
    }
}

public struct ListOrdersInput: Swift.Equatable {
    /// The filters.
    ///
    /// * NETWORK_SITE - The Amazon Resource Name (ARN) of the network site.
    ///
    /// * STATUS - The status (ACKNOWLEDGING | ACKNOWLEDGED | UNACKNOWLEDGED).
    ///
    ///
    /// Filter values are case sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the network.
    /// This member is required.
    public var networkArn: Swift.String?
    /// The token for the next page of results.
    public var startToken: Swift.String?

    public init (
        filters: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        networkArn: Swift.String? = nil,
        startToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.networkArn = networkArn
        self.startToken = startToken
    }
}

struct ListOrdersInputBody: Swift.Equatable {
    let networkArn: Swift.String?
    let startToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [Swift.String:[Swift.String]]?
}

extension ListOrdersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case networkArn
        case startToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let startTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startToken)
        startToken = startTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, orderfiltervalues0) in filtersContainer {
                var orderfiltervalues0Decoded0: [Swift.String]? = nil
                if let orderfiltervalues0 = orderfiltervalues0 {
                    orderfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in orderfiltervalues0 {
                        if let string1 = string1 {
                            orderfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = orderfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOrdersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrdersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrdersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrdersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrdersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.orders = output.orders
        } else {
            self.nextToken = nil
            self.orders = nil
        }
    }
}

public struct ListOrdersOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the orders.
    public var orders: [PrivateNetworksClientTypes.Order]?

    public init (
        nextToken: Swift.String? = nil,
        orders: [PrivateNetworksClientTypes.Order]? = nil
    )
    {
        self.nextToken = nextToken
        self.orders = orders
    }
}

struct ListOrdersOutputResponseBody: Swift.Equatable {
    let orders: [PrivateNetworksClientTypes.Order]?
    let nextToken: Swift.String?
}

extension ListOrdersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case orders
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ordersContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.Order?].self, forKey: .orders)
        var ordersDecoded0:[PrivateNetworksClientTypes.Order]? = nil
        if let ordersContainer = ordersContainer {
            ordersDecoded0 = [PrivateNetworksClientTypes.Order]()
            for structure0 in ordersContainer {
                if let structure0 = structure0 {
                    ordersDecoded0?.append(structure0)
                }
            }
        }
        orders = ordersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PrivateNetworksClientTypes.NameValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a name/value pair.
    public struct NameValuePair: Swift.Equatable {
        /// The name of the pair.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the pair.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PrivateNetworksClientTypes.Network: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case networkArn
        case networkName
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkName = self.networkName {
            try encodeContainer.encode(networkName, forKey: .networkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkName)
        networkName = networkNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network.
    public struct Network: Swift.Equatable {
        /// The creation time of the network.
        public var createdAt: ClientRuntime.Date?
        /// The description of the network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The name of the network.
        /// This member is required.
        public var networkName: Swift.String?
        /// The status of the network.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkStatus?
        /// The status reason of the network.
        public var statusReason: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkName: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.networkArn = networkArn
            self.networkName = networkName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFilterKeys] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkFilterKeys(rawValue: rawValue) ?? NetworkFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.NetworkResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case createdAt
        case description
        case health
        case model
        case networkArn
        case networkResourceArn
        case networkSiteArn
        case orderArn
        case position
        case returnInformation
        case serialNumber
        case status
        case statusReason
        case type
        case vendor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for namevaluepair0 in attributes {
                try attributesContainer.encode(namevaluepair0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkResourceArn = self.networkResourceArn {
            try encodeContainer.encode(networkResourceArn, forKey: .networkResourceArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let returnInformation = self.returnInformation {
            try encodeContainer.encode(returnInformation, forKey: .returnInformation)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkResourceArn)
        networkResourceArn = networkResourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let healthDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.HealthStatus.self, forKey: .health)
        health = healthDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .attributes)
        var attributesDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let positionDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Position.self, forKey: .position)
        position = positionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let returnInformationDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ReturnInformation.self, forKey: .returnInformation)
        returnInformation = returnInformationDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network resource.
    public struct NetworkResource: Swift.Equatable {
        /// The attributes of the network resource.
        public var attributes: [PrivateNetworksClientTypes.NameValuePair]?
        /// The creation time of the network resource.
        public var createdAt: ClientRuntime.Date?
        /// The description of the network resource.
        public var description: Swift.String?
        /// The health of the network resource.
        public var health: PrivateNetworksClientTypes.HealthStatus?
        /// The model of the network resource.
        public var model: Swift.String?
        /// The Amazon Resource Name (ARN) of the network on which this network resource appears.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network resource.
        public var networkResourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site on which this network resource appears.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order used to purchase this network resource.
        public var orderArn: Swift.String?
        /// The position of the network resource.
        public var position: PrivateNetworksClientTypes.Position?
        /// Information about a request to return the network resource.
        public var returnInformation: PrivateNetworksClientTypes.ReturnInformation?
        /// The serial number of the network resource.
        public var serialNumber: Swift.String?
        /// The status of the network resource.
        public var status: PrivateNetworksClientTypes.NetworkResourceStatus?
        /// The status reason of the network resource.
        public var statusReason: Swift.String?
        /// The type of the network resource.
        public var type: PrivateNetworksClientTypes.NetworkResourceType?
        /// The vendor of the network resource.
        public var vendor: Swift.String?

        public init (
            attributes: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            health: PrivateNetworksClientTypes.HealthStatus? = nil,
            model: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkResourceArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            position: PrivateNetworksClientTypes.Position? = nil,
            returnInformation: PrivateNetworksClientTypes.ReturnInformation? = nil,
            serialNumber: Swift.String? = nil,
            status: PrivateNetworksClientTypes.NetworkResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceType? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.createdAt = createdAt
            self.description = description
            self.health = health
            self.model = model
            self.networkArn = networkArn
            self.networkResourceArn = networkResourceArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.position = position
            self.returnInformation = returnInformation
            self.serialNumber = serialNumber
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.vendor = vendor
        }
    }

}

extension PrivateNetworksClientTypes.NetworkResourceDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case options
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for namevaluepair0 in options {
                try optionsContainer.encode(namevaluepair0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResourceDefinitionType.self, forKey: .type)
        type = typeDecoded
        let optionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .options)
        var optionsDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network resource definition.
    public struct NetworkResourceDefinition: Swift.Equatable {
        /// The count in the network resource definition.
        /// This member is required.
        public var count: Swift.Int?
        /// The options in the network resource definition.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The type in the network resource definition.
        /// This member is required.
        public var type: PrivateNetworksClientTypes.NetworkResourceDefinitionType?

        public init (
            count: Swift.Int? = nil,
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            type: PrivateNetworksClientTypes.NetworkResourceDefinitionType? = nil
        )
        {
            self.count = count
            self.options = options
            self.type = type
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceIdentifier
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceDefinitionType] {
            return [
                .deviceIdentifier,
                .radioUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceIdentifier: return "DEVICE_IDENTIFIER"
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceDefinitionType(rawValue: rawValue) ?? NetworkResourceDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case order
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceFilterKeys] {
            return [
                .order,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .order: return "ORDER"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceFilterKeys(rawValue: rawValue) ?? NetworkResourceFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creatingShippingLabel
        case deleted
        case deleting
        case pending
        case pendingReturn
        case provisioned
        case provisioning
        case shipped
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceStatus] {
            return [
                .available,
                .creatingShippingLabel,
                .deleted,
                .deleting,
                .pending,
                .pendingReturn,
                .provisioned,
                .provisioning,
                .shipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creatingShippingLabel: return "CREATING_SHIPPING_LABEL"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .pendingReturn: return "PENDING_RETURN"
            case .provisioned: return "PROVISIONED"
            case .provisioning: return "PROVISIONING"
            case .shipped: return "SHIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceStatus(rawValue: rawValue) ?? NetworkResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case radioUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkResourceType] {
            return [
                .radioUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .radioUnit: return "RADIO_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkResourceType(rawValue: rawValue) ?? NetworkResourceType.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.NetworkSite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone
        case availabilityZoneId
        case createdAt
        case currentPlan
        case description
        case networkArn
        case networkSiteArn
        case networkSiteName
        case pendingPlan
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let currentPlan = self.currentPlan {
            try encodeContainer.encode(currentPlan, forKey: .currentPlan)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let networkSiteName = self.networkSiteName {
            try encodeContainer.encode(networkSiteName, forKey: .networkSiteName)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let networkSiteNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteName)
        networkSiteName = networkSiteNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSiteStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let currentPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .currentPlan)
        currentPlan = currentPlanDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a network site.
    public struct NetworkSite: Swift.Equatable {
        /// The parent Availability Zone for the network site.
        public var availabilityZone: Swift.String?
        /// The parent Availability Zone ID for the network site.
        public var availabilityZoneId: Swift.String?
        /// The creation time of the network site.
        public var createdAt: ClientRuntime.Date?
        /// The current plan of the network site.
        public var currentPlan: PrivateNetworksClientTypes.SitePlan?
        /// The description of the network site.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the network to which the network site belongs.
        /// This member is required.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site.
        /// This member is required.
        public var networkSiteArn: Swift.String?
        /// The name of the network site.
        /// This member is required.
        public var networkSiteName: Swift.String?
        /// The pending plan of the network site.
        public var pendingPlan: PrivateNetworksClientTypes.SitePlan?
        /// The status of the network site.
        /// This member is required.
        public var status: PrivateNetworksClientTypes.NetworkSiteStatus?
        /// The status reason of the network site.
        public var statusReason: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            currentPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            description: Swift.String? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            networkSiteName: Swift.String? = nil,
            pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil,
            status: PrivateNetworksClientTypes.NetworkSiteStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.createdAt = createdAt
            self.currentPlan = currentPlan
            self.description = description
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.networkSiteName = networkSiteName
            self.pendingPlan = pendingPlan
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum NetworkSiteFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteFilterKeys] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSiteFilterKeys(rawValue: rawValue) ?? NetworkSiteFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkSiteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSiteStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSiteStatus(rawValue: rawValue) ?? NetworkSiteStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes {
    public enum NetworkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case created
        case deleted
        case deprovisioning
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkStatus] {
            return [
                .available,
                .created,
                .deleted,
                .deprovisioning,
                .provisioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .deprovisioning: return "DEPROVISIONING"
            case .provisioning: return "PROVISIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkStatus(rawValue: rawValue) ?? NetworkStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateNetworksClientTypes.Order: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgmentStatus
        case createdAt
        case networkArn
        case networkSiteArn
        case orderArn
        case shippingAddress
        case trackingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgmentStatus = self.acknowledgmentStatus {
            try encodeContainer.encode(acknowledgmentStatus.rawValue, forKey: .acknowledgmentStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let networkArn = self.networkArn {
            try encodeContainer.encode(networkArn, forKey: .networkArn)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let orderArn = self.orderArn {
            try encodeContainer.encode(orderArn, forKey: .orderArn)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let trackingInformation = trackingInformation {
            var trackingInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trackingInformation)
            for trackinginformation0 in trackingInformation {
                try trackingInformationContainer.encode(trackinginformation0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderArn)
        orderArn = orderArnDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let networkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkArn)
        networkArn = networkArnDecoded
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let trackingInformationContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.TrackingInformation?].self, forKey: .trackingInformation)
        var trackingInformationDecoded0:[PrivateNetworksClientTypes.TrackingInformation]? = nil
        if let trackingInformationContainer = trackingInformationContainer {
            trackingInformationDecoded0 = [PrivateNetworksClientTypes.TrackingInformation]()
            for structure0 in trackingInformationContainer {
                if let structure0 = structure0 {
                    trackingInformationDecoded0?.append(structure0)
                }
            }
        }
        trackingInformation = trackingInformationDecoded0
        let acknowledgmentStatusDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.AcknowledgmentStatus.self, forKey: .acknowledgmentStatus)
        acknowledgmentStatus = acknowledgmentStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about an order.
    public struct Order: Swift.Equatable {
        /// The acknowledgement status of the order.
        public var acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus?
        /// The creation time of the order.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the network associated with this order.
        public var networkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the network site associated with this order.
        public var networkSiteArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the order.
        public var orderArn: Swift.String?
        /// The shipping address of the order.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The tracking information of the order.
        public var trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]?

        public init (
            acknowledgmentStatus: PrivateNetworksClientTypes.AcknowledgmentStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            networkArn: Swift.String? = nil,
            networkSiteArn: Swift.String? = nil,
            orderArn: Swift.String? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            trackingInformation: [PrivateNetworksClientTypes.TrackingInformation]? = nil
        )
        {
            self.acknowledgmentStatus = acknowledgmentStatus
            self.createdAt = createdAt
            self.networkArn = networkArn
            self.networkSiteArn = networkSiteArn
            self.orderArn = orderArn
            self.shippingAddress = shippingAddress
            self.trackingInformation = trackingInformation
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum OrderFilterKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case networkSite
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderFilterKeys] {
            return [
                .networkSite,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .networkSite: return "NETWORK_SITE"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderFilterKeys(rawValue: rawValue) ?? OrderFilterKeys.sdkUnknown(rawValue)
        }
    }
}

extension PingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ping"
    }
}

public struct PingInput: Swift.Equatable {

    public init () { }
}

struct PingInputBody: Swift.Equatable {
}

extension PingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PingOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct PingOutputResponse: Swift.Equatable {
    /// Information about the health of the service.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct PingOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension PingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PrivateNetworksClientTypes.Position: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elevation
        case elevationReference
        case elevationUnit
        case latitude
        case longitude
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elevation = self.elevation {
            try encodeContainer.encode(elevation, forKey: .elevation)
        }
        if let elevationReference = self.elevationReference {
            try encodeContainer.encode(elevationReference.rawValue, forKey: .elevationReference)
        }
        if let elevationUnit = self.elevationUnit {
            try encodeContainer.encode(elevationUnit.rawValue, forKey: .elevationUnit)
        }
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .longitude)
        longitude = longitudeDecoded
        let elevationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .elevation)
        elevation = elevationDecoded
        let elevationUnitDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ElevationUnit.self, forKey: .elevationUnit)
        elevationUnit = elevationUnitDecoded
        let elevationReferenceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ElevationReference.self, forKey: .elevationReference)
        elevationReference = elevationReferenceDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a position.
    public struct Position: Swift.Equatable {
        /// The elevation of the equipment at this position.
        public var elevation: Swift.Double?
        /// The reference point from which elevation is reported.
        public var elevationReference: PrivateNetworksClientTypes.ElevationReference?
        /// The units used to measure the elevation of the position.
        public var elevationUnit: PrivateNetworksClientTypes.ElevationUnit?
        /// The latitude of the position.
        public var latitude: Swift.Double?
        /// The longitude of the position.
        public var longitude: Swift.Double?

        public init (
            elevation: Swift.Double? = nil,
            elevationReference: PrivateNetworksClientTypes.ElevationReference? = nil,
            elevationUnit: PrivateNetworksClientTypes.ElevationUnit? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.elevation = elevation
            self.elevationReference = elevationReference
            self.elevationUnit = elevationUnit
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the affected resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the affected resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension PrivateNetworksClientTypes.ReturnInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replacementOrderArn
        case returnReason
        case shippingAddress
        case shippingLabel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replacementOrderArn = self.replacementOrderArn {
            try encodeContainer.encode(replacementOrderArn, forKey: .replacementOrderArn)
        }
        if let returnReason = self.returnReason {
            try encodeContainer.encode(returnReason, forKey: .returnReason)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let shippingLabel = self.shippingLabel {
            try encodeContainer.encode(shippingLabel, forKey: .shippingLabel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let returnReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnReason)
        returnReason = returnReasonDecoded
        let replacementOrderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementOrderArn)
        replacementOrderArn = replacementOrderArnDecoded
        let shippingLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shippingLabel)
        shippingLabel = shippingLabelDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a request to return a network resource.
    public struct ReturnInformation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the replacement order.
        public var replacementOrderArn: Swift.String?
        /// The reason for the return. If the return request did not include a reason for the return, this value is null.
        public var returnReason: Swift.String?
        /// The shipping address.
        public var shippingAddress: PrivateNetworksClientTypes.Address?
        /// The URL of the shipping label. The shipping label is available for download only if the status of the network resource is PENDING_RETURN. For more information, see [Return a radio unit](https://docs.aws.amazon.com/private-networks/latest/userguide/radio-units.html#return-radio-unit).
        public var shippingLabel: Swift.String?

        public init (
            replacementOrderArn: Swift.String? = nil,
            returnReason: Swift.String? = nil,
            shippingAddress: PrivateNetworksClientTypes.Address? = nil,
            shippingLabel: Swift.String? = nil
        )
        {
            self.replacementOrderArn = replacementOrderArn
            self.returnReason = returnReason
            self.shippingAddress = shippingAddress
            self.shippingLabel = shippingLabel
        }
    }

}

extension PrivateNetworksClientTypes.SitePlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
        case resourceDefinitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for namevaluepair0 in options {
                try optionsContainer.encode(namevaluepair0)
            }
        }
        if let resourceDefinitions = resourceDefinitions {
            var resourceDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceDefinitions)
            for networkresourcedefinition0 in resourceDefinitions {
                try resourceDefinitionsContainer.encode(networkresourcedefinition0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDefinitionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NetworkResourceDefinition?].self, forKey: .resourceDefinitions)
        var resourceDefinitionsDecoded0:[PrivateNetworksClientTypes.NetworkResourceDefinition]? = nil
        if let resourceDefinitionsContainer = resourceDefinitionsContainer {
            resourceDefinitionsDecoded0 = [PrivateNetworksClientTypes.NetworkResourceDefinition]()
            for structure0 in resourceDefinitionsContainer {
                if let structure0 = structure0 {
                    resourceDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        resourceDefinitions = resourceDefinitionsDecoded0
        let optionsContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.NameValuePair?].self, forKey: .options)
        var optionsDecoded0:[PrivateNetworksClientTypes.NameValuePair]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [PrivateNetworksClientTypes.NameValuePair]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a site plan.
    public struct SitePlan: Swift.Equatable {
        /// The options of the plan.
        public var options: [PrivateNetworksClientTypes.NameValuePair]?
        /// The resource definitions of the plan.
        public var resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]?

        public init (
            options: [PrivateNetworksClientTypes.NameValuePair]? = nil,
            resourceDefinitions: [PrivateNetworksClientTypes.NetworkResourceDefinition]? = nil
        )
        {
            self.options = options
            self.resourceDefinitions = resourceDefinitions
        }
    }

}

extension StartNetworkResourceUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResourceArn
        case returnReason
        case shippingAddress
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkResourceArn = self.networkResourceArn {
            try encodeContainer.encode(networkResourceArn, forKey: .networkResourceArn)
        }
        if let returnReason = self.returnReason {
            try encodeContainer.encode(returnReason, forKey: .returnReason)
        }
        if let shippingAddress = self.shippingAddress {
            try encodeContainer.encode(shippingAddress, forKey: .shippingAddress)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }
}

extension StartNetworkResourceUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-resources/update"
    }
}

public struct StartNetworkResourceUpdateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the network resource.
    /// This member is required.
    public var networkResourceArn: Swift.String?
    /// The reason for the return. Providing a reason for a return is optional.
    public var returnReason: Swift.String?
    /// The shipping address. If you don't provide a shipping address when replacing or returning a network resource, we use the address from the original order for the network resource.
    public var shippingAddress: PrivateNetworksClientTypes.Address?
    /// The update type.
    ///
    /// * REPLACE - Submits a request to replace a defective radio unit. We provide a shipping label that you can use for the return process and we ship a replacement radio unit to you.
    ///
    /// * RETURN - Submits a request to replace a radio unit that you no longer need. We provide a shipping label that you can use for the return process.
    /// This member is required.
    public var updateType: PrivateNetworksClientTypes.UpdateType?

    public init (
        networkResourceArn: Swift.String? = nil,
        returnReason: Swift.String? = nil,
        shippingAddress: PrivateNetworksClientTypes.Address? = nil,
        updateType: PrivateNetworksClientTypes.UpdateType? = nil
    )
    {
        self.networkResourceArn = networkResourceArn
        self.returnReason = returnReason
        self.shippingAddress = shippingAddress
        self.updateType = updateType
    }
}

struct StartNetworkResourceUpdateInputBody: Swift.Equatable {
    let networkResourceArn: Swift.String?
    let updateType: PrivateNetworksClientTypes.UpdateType?
    let shippingAddress: PrivateNetworksClientTypes.Address?
    let returnReason: Swift.String?
}

extension StartNetworkResourceUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResourceArn
        case returnReason
        case shippingAddress
        case updateType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkResourceArn)
        networkResourceArn = networkResourceArnDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.UpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let shippingAddressDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.Address.self, forKey: .shippingAddress)
        shippingAddress = shippingAddressDecoded
        let returnReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnReason)
        returnReason = returnReasonDecoded
    }
}

extension StartNetworkResourceUpdateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartNetworkResourceUpdateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartNetworkResourceUpdateOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartNetworkResourceUpdateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartNetworkResourceUpdateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkResource = output.networkResource
        } else {
            self.networkResource = nil
        }
    }
}

public struct StartNetworkResourceUpdateOutputResponse: Swift.Equatable {
    /// The network resource.
    public var networkResource: PrivateNetworksClientTypes.NetworkResource?

    public init (
        networkResource: PrivateNetworksClientTypes.NetworkResource? = nil
    )
    {
        self.networkResource = networkResource
    }
}

struct StartNetworkResourceUpdateOutputResponseBody: Swift.Equatable {
    let networkResource: PrivateNetworksClientTypes.NetworkResource?
}

extension StartNetworkResourceUpdateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkResource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkResourceDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkResource.self, forKey: .networkResource)
        networkResource = networkResourceDecoded
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PrivateNetworksClientTypes.TrackingInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trackingNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trackingNumber = self.trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trackingNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about tracking a shipment.
    public struct TrackingInformation: Swift.Equatable {
        /// The tracking number of the shipment.
        public var trackingNumber: Swift.String?

        public init (
            trackingNumber: Swift.String? = nil
        )
        {
            self.trackingNumber = trackingNumber
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNetworkSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkSiteArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
    }
}

extension UpdateNetworkSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/site"
    }
}

public struct UpdateNetworkSiteInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.networkSiteArn = networkSiteArn
    }
}

struct UpdateNetworkSiteInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
}

extension UpdateNetworkSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case networkSiteArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateNetworkSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkSiteOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSiteOutputResponse(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNetworkSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct UpdateNetworkSiteOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct UpdateNetworkSiteOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateNetworkSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateNetworkSitePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case pendingPlan
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let networkSiteArn = self.networkSiteArn {
            try encodeContainer.encode(networkSiteArn, forKey: .networkSiteArn)
        }
        if let pendingPlan = self.pendingPlan {
            try encodeContainer.encode(pendingPlan, forKey: .pendingPlan)
        }
    }
}

extension UpdateNetworkSitePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/network-sites/plan"
    }
}

public struct UpdateNetworkSitePlanInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see [How to ensure idempotency](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the network site.
    /// This member is required.
    public var networkSiteArn: Swift.String?
    /// The pending plan.
    /// This member is required.
    public var pendingPlan: PrivateNetworksClientTypes.SitePlan?

    public init (
        clientToken: Swift.String? = nil,
        networkSiteArn: Swift.String? = nil,
        pendingPlan: PrivateNetworksClientTypes.SitePlan? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSiteArn = networkSiteArn
        self.pendingPlan = pendingPlan
    }
}

struct UpdateNetworkSitePlanInputBody: Swift.Equatable {
    let networkSiteArn: Swift.String?
    let pendingPlan: PrivateNetworksClientTypes.SitePlan?
    let clientToken: Swift.String?
}

extension UpdateNetworkSitePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case networkSiteArn
        case pendingPlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSiteArn)
        networkSiteArn = networkSiteArnDecoded
        let pendingPlanDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.SitePlan.self, forKey: .pendingPlan)
        pendingPlan = pendingPlanDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateNetworkSitePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkSitePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNetworkSitePlanOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkSitePlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSitePlanOutputResponse(networkSite: \(Swift.String(describing: networkSite)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkSitePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateNetworkSitePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSite = output.networkSite
            self.tags = output.tags
        } else {
            self.networkSite = nil
            self.tags = nil
        }
    }
}

public struct UpdateNetworkSitePlanOutputResponse: Swift.Equatable {
    /// Information about the network site.
    public var networkSite: PrivateNetworksClientTypes.NetworkSite?
    /// The network site tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        networkSite: PrivateNetworksClientTypes.NetworkSite? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.networkSite = networkSite
        self.tags = tags
    }
}

struct UpdateNetworkSitePlanOutputResponseBody: Swift.Equatable {
    let networkSite: PrivateNetworksClientTypes.NetworkSite?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateNetworkSitePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSite
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSiteDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.NetworkSite.self, forKey: .networkSite)
        networkSite = networkSiteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PrivateNetworksClientTypes {
    public enum UpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replace
        case `return`
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateType] {
            return [
                .replace,
                .return,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replace: return "REPLACE"
            case .return: return "RETURN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateType(rawValue: rawValue) ?? UpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed validation.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The list of fields that caused the error, if applicable.
    public var fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]?
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation.
    /// This member is required.
    public var reason: PrivateNetworksClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PrivateNetworksClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PrivateNetworksClientTypes.ValidationExceptionReason?
    let fieldList: [PrivateNetworksClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PrivateNetworksClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([PrivateNetworksClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[PrivateNetworksClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [PrivateNetworksClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension PrivateNetworksClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PrivateNetworksClientTypes {
    /// Information about a field that failed validation.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message about the validation failure.
        /// This member is required.
        public var message: Swift.String?
        /// The field name that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PrivateNetworksClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotAssumeRole
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotAssumeRole,
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotAssumeRole: return "CANNOT_ASSUME_ROLE"
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
