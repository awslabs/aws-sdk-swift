//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

///
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateEntityToThingInput {
    /// The ID of the device to be associated with the thing. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The name of the thing to which the entity is to be associated.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.namespaceVersion = namespaceVersion
        self.thingName = thingName
    }
}

public struct AssociateEntityToThingOutput {

    public init() { }
}

///
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTThingsGraphClientTypes {

    public enum DefinitionLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case graphql
        case sdkUnknown(Swift.String)

        public static var allCases: [DefinitionLanguage] {
            return [
                .graphql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .graphql: return "GRAPHQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// A document that defines an entity.
    public struct DefinitionDocument {
        /// The language used to define the entity. GRAPHQL is the only valid value.
        /// This member is required.
        public var language: IoTThingsGraphClientTypes.DefinitionLanguage?
        /// The GraphQL text that defines the entity.
        /// This member is required.
        public var text: Swift.String?

        public init(
            language: IoTThingsGraphClientTypes.DefinitionLanguage? = nil,
            text: Swift.String? = nil
        )
        {
            self.language = language
            self.text = text
        }
    }

}

public struct CreateFlowTemplateInput {
    /// The namespace version in which the workflow is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The workflow DefinitionDocument.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a workflow.
    public struct FlowTemplateSummary {
        /// The ARN of the workflow.
        public var arn: Swift.String?
        /// The date when the workflow was created.
        public var createdAt: Foundation.Date?
        /// The ID of the workflow.
        public var id: Swift.String?
        /// The revision number of the workflow.
        public var revisionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

public struct CreateFlowTemplateOutput {
    /// The summary object that describes the created workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public struct MetricsConfiguration {
        /// A Boolean that specifies whether cloud metrics are collected.
        public var cloudMetricEnabled: Swift.Bool
        /// The ARN of the role that is used to collect cloud metrics.
        public var metricRuleRoleArn: Swift.String?

        public init(
            cloudMetricEnabled: Swift.Bool = false,
            metricRuleRoleArn: Swift.String? = nil
        )
        {
            self.cloudMetricEnabled = cloudMetricEnabled
            self.metricRuleRoleArn = metricRuleRoleArn
        }
    }

}

extension IoTThingsGraphClientTypes {
    /// Metadata assigned to an AWS IoT Things Graph resource consisting of a key-value pair.
    public struct Tag {
        /// The required name of the tag. The string value can be from 1 to 128 Unicode characters in length.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value of the tag. The string value can be from 1 to 256 Unicode characters in length.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {

    public enum DeploymentTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloud
        case greengrass
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentTarget] {
            return [
                .cloud,
                .greengrass
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .greengrass: return "GREENGRASS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSystemInstanceInput {
    /// A document that defines an entity.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ARN of the IAM role that AWS IoT Things Graph will assume when it executes the flow. This role must have read and write access to AWS Lambda and AWS IoT and any other AWS services that the flow uses when it executes. This value is required if the value of the target parameter is CLOUD.
    public var flowActionsRoleArn: Swift.String?
    /// The name of the Greengrass group where the system instance will be deployed. This value is required if the value of the target parameter is GREENGRASS.
    public var greengrassGroupName: Swift.String?
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
    /// The name of the Amazon Simple Storage Service bucket that will be used to store and deploy the system instance's resource file. This value is required if the value of the target parameter is GREENGRASS.
    public var s3BucketName: Swift.String?
    /// Metadata, consisting of key-value pairs, that can be used to categorize your system instances.
    public var tags: [IoTThingsGraphClientTypes.Tag]?
    /// The target type of the deployment. Valid values are GREENGRASS and CLOUD.
    /// This member is required.
    public var target: IoTThingsGraphClientTypes.DeploymentTarget?

    public init(
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        flowActionsRoleArn: Swift.String? = nil,
        greengrassGroupName: Swift.String? = nil,
        metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
        s3BucketName: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil,
        target: IoTThingsGraphClientTypes.DeploymentTarget? = nil
    )
    {
        self.definition = definition
        self.flowActionsRoleArn = flowActionsRoleArn
        self.greengrassGroupName = greengrassGroupName
        self.metricsConfiguration = metricsConfiguration
        self.s3BucketName = s3BucketName
        self.tags = tags
        self.target = target
    }
}

extension IoTThingsGraphClientTypes {

    public enum SystemInstanceDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bootstrap
        case deletedInTarget
        case deployedInTarget
        case deployInProgress
        case failed
        case notDeployed
        case pendingDelete
        case undeployInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceDeploymentStatus] {
            return [
                .bootstrap,
                .deletedInTarget,
                .deployedInTarget,
                .deployInProgress,
                .failed,
                .notDeployed,
                .pendingDelete,
                .undeployInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bootstrap: return "BOOTSTRAP"
            case .deletedInTarget: return "DELETED_IN_TARGET"
            case .deployedInTarget: return "DEPLOYED_IN_TARGET"
            case .deployInProgress: return "DEPLOY_IN_PROGRESS"
            case .failed: return "FAILED"
            case .notDeployed: return "NOT_DEPLOYED"
            case .pendingDelete: return "PENDING_DELETE"
            case .undeployInProgress: return "UNDEPLOY_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a system instance.
    public struct SystemInstanceSummary {
        /// The ARN of the system instance.
        public var arn: Swift.String?
        /// The date when the system instance was created.
        public var createdAt: Foundation.Date?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupId: Swift.String?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupName: Swift.String?
        /// The version of the Greengrass group where the system instance is deployed.
        public var greengrassGroupVersionId: Swift.String?
        /// The ID of the system instance.
        public var id: Swift.String?
        /// The status of the system instance.
        public var status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus?
        /// The target of the system instance.
        public var target: IoTThingsGraphClientTypes.DeploymentTarget?
        /// The date and time when the system instance was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            greengrassGroupId: Swift.String? = nil,
            greengrassGroupName: Swift.String? = nil,
            greengrassGroupVersionId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus? = nil,
            target: IoTThingsGraphClientTypes.DeploymentTarget? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.greengrassGroupId = greengrassGroupId
            self.greengrassGroupName = greengrassGroupName
            self.greengrassGroupVersionId = greengrassGroupVersionId
            self.id = id
            self.status = status
            self.target = target
            self.updatedAt = updatedAt
        }
    }

}

public struct CreateSystemInstanceOutput {
    /// The summary object that describes the new system instance.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

public struct CreateSystemTemplateInput {
    /// The namespace version in which the system is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument used to create the system.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a system.
    public struct SystemTemplateSummary {
        /// The ARN of the system.
        public var arn: Swift.String?
        /// The date when the system was created.
        public var createdAt: Foundation.Date?
        /// The ID of the system.
        public var id: Swift.String?
        /// The revision number of the system.
        public var revisionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

public struct CreateSystemTemplateOutput {
    /// The summary object that describes the created system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

///
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFlowTemplateInput {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteFlowTemplateOutput {

    public init() { }
}

public struct DeleteNamespaceInput {

    public init() { }
}

public struct DeleteNamespaceOutput {
    /// The ARN of the namespace to be deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to be deleted.
    public var namespaceName: Swift.String?

    public init(
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
    }
}

public struct DeleteSystemInstanceInput {
    /// The ID of the system instance to be deleted.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteSystemInstanceOutput {

    public init() { }
}

public struct DeleteSystemTemplateInput {
    /// The ID of the system to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteSystemTemplateOutput {

    public init() { }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains the ID and revision number of a workflow or system that is part of a deployment.
    public struct DependencyRevision {
        /// The ID of the workflow or system.
        public var id: Swift.String?
        /// The revision number of the workflow or system.
        public var revisionNumber: Swift.Int?

        public init(
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

public struct DeploySystemInstanceInput {
    /// The ID of the system instance. This value is returned by the CreateSystemInstance action. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeploySystemInstanceOutput {
    /// The ID of the Greengrass deployment used to deploy the system instance.
    public var greengrassDeploymentId: Swift.String?
    /// An object that contains summary information about a system instance that was deployed.
    /// This member is required.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        greengrassDeploymentId: Swift.String? = nil,
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.greengrassDeploymentId = greengrassDeploymentId
        self.summary = summary
    }
}

public struct DeprecateFlowTemplateInput {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeprecateFlowTemplateOutput {

    public init() { }
}

public struct DeprecateSystemTemplateInput {
    /// The ID of the system to delete. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeprecateSystemTemplateOutput {

    public init() { }
}

public struct DescribeNamespaceInput {
    /// The name of the user's namespace. Set this to aws to get the public namespace.
    public var namespaceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

public struct DescribeNamespaceOutput {
    /// The ARN of the namespace.
    public var namespaceArn: Swift.String?
    /// The name of the namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace to describe.
    public var namespaceVersion: Swift.Int?
    /// The name of the public namespace that the latest namespace version is tracking.
    public var trackingNamespaceName: Swift.String?
    /// The version of the public namespace that the latest version is tracking.
    public var trackingNamespaceVersion: Swift.Int?

    public init(
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        trackingNamespaceName: Swift.String? = nil,
        trackingNamespaceVersion: Swift.Int? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.trackingNamespaceName = trackingNamespaceName
        self.trackingNamespaceVersion = trackingNamespaceVersion
    }
}

extension IoTThingsGraphClientTypes {

    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case action
        case capability
        case device
        case deviceModel
        case `enum`
        case event
        case mapping
        case property
        case service
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .action,
                .capability,
                .device,
                .deviceModel,
                .enum,
                .event,
                .mapping,
                .property,
                .service,
                .state
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .action: return "ACTION"
            case .capability: return "CAPABILITY"
            case .device: return "DEVICE"
            case .deviceModel: return "DEVICE_MODEL"
            case .enum: return "ENUM"
            case .event: return "EVENT"
            case .mapping: return "MAPPING"
            case .property: return "PROPERTY"
            case .service: return "SERVICE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DissociateEntityFromThingInput {
    /// The entity type from which to disassociate the thing.
    /// This member is required.
    public var entityType: IoTThingsGraphClientTypes.EntityType?
    /// The name of the thing to disassociate.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        entityType: IoTThingsGraphClientTypes.EntityType? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityType = entityType
        self.thingName = thingName
    }
}

public struct DissociateEntityFromThingOutput {

    public init() { }
}

extension IoTThingsGraphClientTypes {
    /// Describes the properties of an entity.
    public struct EntityDescription {
        /// The entity ARN.
        public var arn: Swift.String?
        /// The time at which the entity was created.
        public var createdAt: Foundation.Date?
        /// The definition document of the entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The entity ID.
        public var id: Swift.String?
        /// The entity type.
        public var type: IoTThingsGraphClientTypes.EntityType?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            id: Swift.String? = nil,
            type: IoTThingsGraphClientTypes.EntityType? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.definition = definition
            self.id = id
            self.type = type
        }
    }

}

extension IoTThingsGraphClientTypes {

    public enum EntityFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case namespace
        case referencedEntityId
        case semanticTypePath
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityFilterName] {
            return [
                .name,
                .namespace,
                .referencedEntityId,
                .semanticTypePath
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .namespace: return "NAMESPACE"
            case .referencedEntityId: return "REFERENCED_ENTITY_ID"
            case .semanticTypePath: return "SEMANTIC_TYPE_PATH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters an entity search. Multiple filters function as OR criteria in the search. For example a search that includes a NAMESPACE and a REFERENCED_ENTITY_ID filter searches for entities in the specified namespace that use the entity specified by the value of REFERENCED_ENTITY_ID.
    public struct EntityFilter {
        /// The name of the entity search filter field. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state.
        public var name: IoTThingsGraphClientTypes.EntityFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.EntityFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {

    public enum FlowExecutionEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledgeTaskMessage
        case activityFailed
        case activityScheduled
        case activityStarted
        case activitySucceeded
        case executionAborted
        case executionFailed
        case executionStarted
        case executionSucceeded
        case scheduleNextReadyStepsTask
        case startFlowExecutionTask
        case stepFailed
        case stepStarted
        case stepSucceeded
        case thingActionTask
        case thingActionTaskFailed
        case thingActionTaskSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionEventType] {
            return [
                .acknowledgeTaskMessage,
                .activityFailed,
                .activityScheduled,
                .activityStarted,
                .activitySucceeded,
                .executionAborted,
                .executionFailed,
                .executionStarted,
                .executionSucceeded,
                .scheduleNextReadyStepsTask,
                .startFlowExecutionTask,
                .stepFailed,
                .stepStarted,
                .stepSucceeded,
                .thingActionTask,
                .thingActionTaskFailed,
                .thingActionTaskSucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledgeTaskMessage: return "ACKNOWLEDGE_TASK_MESSAGE"
            case .activityFailed: return "ACTIVITY_FAILED"
            case .activityScheduled: return "ACTIVITY_SCHEDULED"
            case .activityStarted: return "ACTIVITY_STARTED"
            case .activitySucceeded: return "ACTIVITY_SUCCEEDED"
            case .executionAborted: return "EXECUTION_ABORTED"
            case .executionFailed: return "EXECUTION_FAILED"
            case .executionStarted: return "EXECUTION_STARTED"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .scheduleNextReadyStepsTask: return "SCHEDULE_NEXT_READY_STEPS_TASK"
            case .startFlowExecutionTask: return "START_FLOW_EXECUTION_TASK"
            case .stepFailed: return "STEP_FAILED"
            case .stepStarted: return "STEP_STARTED"
            case .stepSucceeded: return "STEP_SUCCEEDED"
            case .thingActionTask: return "THING_ACTION_TASK"
            case .thingActionTaskFailed: return "THING_ACTION_TASK_FAILED"
            case .thingActionTaskSucceeded: return "THING_ACTION_TASK_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a flow event.
    public struct FlowExecutionMessage {
        /// The type of flow event .
        public var eventType: IoTThingsGraphClientTypes.FlowExecutionEventType?
        /// The unique identifier of the message.
        public var messageId: Swift.String?
        /// A string containing information about the flow event.
        public var payload: Swift.String?
        /// The date and time when the message was last updated.
        public var timestamp: Foundation.Date?

        public init(
            eventType: IoTThingsGraphClientTypes.FlowExecutionEventType? = nil,
            messageId: Swift.String? = nil,
            payload: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.eventType = eventType
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }

}

extension IoTThingsGraphClientTypes {

    public enum FlowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionStatus] {
            return [
                .aborted,
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a flow execution.
    public struct FlowExecutionSummary {
        /// The date and time when the flow execution summary was created.
        public var createdAt: Foundation.Date?
        /// The ID of the flow execution.
        public var flowExecutionId: Swift.String?
        /// The ID of the flow.
        public var flowTemplateId: Swift.String?
        /// The current status of the flow execution.
        public var status: IoTThingsGraphClientTypes.FlowExecutionStatus?
        /// The ID of the system instance that contains the flow.
        public var systemInstanceId: Swift.String?
        /// The date and time when the flow execution summary was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            flowExecutionId: Swift.String? = nil,
            flowTemplateId: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.FlowExecutionStatus? = nil,
            systemInstanceId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.flowExecutionId = flowExecutionId
            self.flowTemplateId = flowTemplateId
            self.status = status
            self.systemInstanceId = systemInstanceId
            self.updatedAt = updatedAt
        }
    }

}

extension IoTThingsGraphClientTypes {
    /// An object that contains a workflow's definition and summary information.
    public struct FlowTemplateDescription {
        /// A workflow's definition document.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a workflow.
        public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
        /// The version of the user's namespace against which the workflow was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes {

    public enum FlowTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceModelId
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowTemplateFilterName] {
            return [
                .deviceModelId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceModelId: return "DEVICE_MODEL_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a workflow search.
    public struct FlowTemplateFilter {
        /// The name of the search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.FlowTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.FlowTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct GetEntitiesInput {
    /// An array of entity IDs. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var ids: [Swift.String]?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?

    public init(
        ids: [Swift.String]? = nil,
        namespaceVersion: Swift.Int? = nil
    )
    {
        self.ids = ids
        self.namespaceVersion = namespaceVersion
    }
}

public struct GetEntitiesOutput {
    /// An array of descriptions for the specified entities.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?

    public init(
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil
    )
    {
        self.descriptions = descriptions
    }
}

public struct GetFlowTemplateInput {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number of the workflow revision to retrieve.
    public var revisionNumber: Swift.Int?

    public init(
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

public struct GetFlowTemplateOutput {
    /// The object that describes the specified workflow.
    public var description: IoTThingsGraphClientTypes.FlowTemplateDescription?

    public init(
        description: IoTThingsGraphClientTypes.FlowTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

public struct GetFlowTemplateRevisionsInput {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetFlowTemplateRevisionsOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summary data about each revision.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct GetNamespaceDeletionStatusInput {

    public init() { }
}

extension IoTThingsGraphClientTypes {

    public enum NamespaceDeletionStatusErrorCodes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatusErrorCodes] {
            return [
                .validationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {

    public enum NamespaceDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNamespaceDeletionStatusOutput {
    /// An error code returned by the namespace deletion task.
    public var errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes?
    /// An error code returned by the namespace deletion task.
    public var errorMessage: Swift.String?
    /// The ARN of the namespace that is being deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace that is being deleted.
    public var namespaceName: Swift.String?
    /// The status of the deletion request.
    public var status: IoTThingsGraphClientTypes.NamespaceDeletionStatus?

    public init(
        errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes? = nil,
        errorMessage: Swift.String? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        status: IoTThingsGraphClientTypes.NamespaceDeletionStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.status = status
    }
}

public struct GetSystemInstanceInput {
    /// The ID of the system deployment instance. This value is returned by CreateSystemInstance. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system instance definition and summary information.
    public struct SystemInstanceDescription {
        /// A document that defines an entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The AWS Identity and Access Management (IAM) role that AWS IoT Things Graph assumes during flow execution in a cloud deployment. This role must have read and write permissionss to AWS Lambda and AWS IoT and to any other AWS services that the flow uses.
        public var flowActionsRoleArn: Swift.String?
        /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
        public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
        /// The Amazon Simple Storage Service bucket where information about a system instance is stored.
        public var s3BucketName: Swift.String?
        /// An object that contains summary information about a system instance.
        public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
        /// A list of objects that contain all of the IDs and revision numbers of workflows and systems that are used in a system instance.
        public var validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]?
        /// The version of the user's namespace against which the system instance was validated.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            flowActionsRoleArn: Swift.String? = nil,
            metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
            s3BucketName: Swift.String? = nil,
            summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil,
            validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.flowActionsRoleArn = flowActionsRoleArn
            self.metricsConfiguration = metricsConfiguration
            self.s3BucketName = s3BucketName
            self.summary = summary
            self.validatedDependencyRevisions = validatedDependencyRevisions
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

public struct GetSystemInstanceOutput {
    /// An object that describes the system instance.
    public var description: IoTThingsGraphClientTypes.SystemInstanceDescription?

    public init(
        description: IoTThingsGraphClientTypes.SystemInstanceDescription? = nil
    )
    {
        self.description = description
    }
}

public struct GetSystemTemplateInput {
    /// The ID of the system to get. This ID must be in the user's namespace. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number that specifies the revision of the system to get.
    public var revisionNumber: Swift.Int?

    public init(
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system's definition document and summary information.
    public struct SystemTemplateDescription {
        /// The definition document of a system.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a system.
        public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
        /// The namespace version against which the system was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

public struct GetSystemTemplateOutput {
    /// An object that contains summary data about the system.
    public var description: IoTThingsGraphClientTypes.SystemTemplateDescription?

    public init(
        description: IoTThingsGraphClientTypes.SystemTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

public struct GetSystemTemplateRevisionsInput {
    /// The ID of the system template. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetSystemTemplateRevisionsOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data about the system template revisions.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct GetUploadStatusInput {
    /// The ID of the upload. This value is returned by the UploadEntityDefinitions action.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

extension IoTThingsGraphClientTypes {

    public enum UploadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetUploadStatusOutput {
    /// The date at which the upload was created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The reason for an upload failure.
    public var failureReason: [Swift.String]?
    /// The ARN of the upload.
    public var namespaceArn: Swift.String?
    /// The name of the upload's namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The ID of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The status of the upload. The initial status is IN_PROGRESS. The response show all validation failures if the upload fails.
    /// This member is required.
    public var uploadStatus: IoTThingsGraphClientTypes.UploadStatus?

    public init(
        createdDate: Foundation.Date? = nil,
        failureReason: [Swift.String]? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        uploadId: Swift.String? = nil,
        uploadStatus: IoTThingsGraphClientTypes.UploadStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.uploadId = uploadId
        self.uploadStatus = uploadStatus
    }
}

public struct ListFlowExecutionMessagesInput {
    /// The ID of the flow execution.
    /// This member is required.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFlowExecutionMessagesOutput {
    /// A list of objects that contain information about events in the specified flow execution.
    public var messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init(
        messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The maximum number of tags to return.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be returned.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// List of tags returned by the ListTagsForResource operation.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct SearchEntitiesInput {
    /// The entity types for which to search.
    /// This member is required.
    public var entityTypes: [IoTThingsGraphClientTypes.EntityType]?
    /// Optional filter to apply to the search. Valid filters are NAMENAMESPACE, SEMANTIC_TYPE_PATH and REFERENCED_ENTITY_ID. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.EntityFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        entityTypes: [IoTThingsGraphClientTypes.EntityType]? = nil,
        filters: [IoTThingsGraphClientTypes.EntityFilter]? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.filters = filters
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

public struct SearchEntitiesOutput {
    /// An array of descriptions for each entity returned in the search result.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init(
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

public struct SearchFlowExecutionsInput {
    /// The date and time of the latest flow execution to return.
    public var endTime: Foundation.Date?
    /// The ID of a flow execution.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?
    /// The date and time of the earliest flow execution to return.
    public var startTime: Foundation.Date?
    /// The ID of the system instance that contains the flow.
    /// This member is required.
    public var systemInstanceId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        systemInstanceId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.systemInstanceId = systemInstanceId
    }
}

public struct SearchFlowExecutionsOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow execution in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct SearchFlowTemplatesInput {
    /// An array of objects that limit the result set. The only valid filter is DEVICE_MODEL_ID.
    public var filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchFlowTemplatesOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

extension IoTThingsGraphClientTypes {

    public enum SystemInstanceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrassGroupName
        case status
        case systemTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceFilterName] {
            return [
                .greengrassGroupName,
                .status,
                .systemTemplateId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrassGroupName: return "GREENGRASS_GROUP_NAME"
            case .status: return "STATUS"
            case .systemTemplateId: return "SYSTEM_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system instance search. Multiple filters function as OR criteria in the search. For example a search that includes a GREENGRASS_GROUP_NAME and a STATUS filter searches for system instances in the specified Greengrass group that have the specified status.
    public struct SystemInstanceFilter {
        /// The name of the search filter field.
        public var name: IoTThingsGraphClientTypes.SystemInstanceFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.SystemInstanceFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct SearchSystemInstancesInput {
    /// Optional filter to apply to the search. Valid filters are SYSTEM_TEMPLATE_ID, STATUS, and GREENGRASS_GROUP_NAME. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchSystemInstancesOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data abour the system instances in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

extension IoTThingsGraphClientTypes {

    public enum SystemTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flowTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemTemplateFilterName] {
            return [
                .flowTemplateId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flowTemplateId: return "FLOW_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system search.
    public struct SystemTemplateFilter {
        /// The name of the system search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.SystemTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.SystemTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct SearchSystemTemplatesInput {
    /// An array of filters that limit the result set. The only valid filter is FLOW_TEMPLATE_ID.
    public var filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchSystemTemplatesOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each system deployment in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct SearchThingsInput {
    /// The ID of the entity to which the things are associated. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

extension IoTThingsGraphClientTypes {
    /// An AWS IoT thing.
    public struct Thing {
        /// The ARN of the thing.
        public var thingArn: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?

        public init(
            thingArn: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.thingArn = thingArn
            self.thingName = thingName
        }
    }

}

public struct SearchThingsOutput {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of things in the result set.
    public var things: [IoTThingsGraphClientTypes.Thing]?

    public init(
        nextToken: Swift.String? = nil,
        things: [IoTThingsGraphClientTypes.Thing]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource whose tags are returned.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add to the resource.>
    /// This member is required.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UndeploySystemInstanceInput {
    /// The ID of the system instance to remove from its target.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct UndeploySystemInstanceOutput {
    /// An object that contains summary information about the system instance that was removed from its target.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed. This parameter to the API requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters.html#cli-using-param-json) in the AWS CLI User Guide.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateFlowTemplateInput {
    /// The version of the user's namespace. If no value is specified, the latest version is used by default. Use the GetFlowTemplateRevisions if you want to find earlier revisions of the flow to update.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated workflow definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the workflow to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

public struct UpdateFlowTemplateOutput {
    /// An object containing summary information about the updated workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

public struct UpdateSystemTemplateInput {
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated system definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the system to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

public struct UpdateSystemTemplateOutput {
    /// An object containing summary information about the updated system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

public struct UploadEntityDefinitionsInput {
    /// A Boolean that specifies whether to deprecate all entities in the latest version before uploading the new DefinitionDocument. If set to true, the upload will create a new namespace version.
    public var deprecateExistingEntities: Swift.Bool?
    /// The DefinitionDocument that defines the updated entities.
    public var document: IoTThingsGraphClientTypes.DefinitionDocument?
    /// A Boolean that specifies whether to synchronize with the latest version of the public namespace. If set to true, the upload will create a new namespace version.
    public var syncWithPublicNamespace: Swift.Bool?

    public init(
        deprecateExistingEntities: Swift.Bool? = false,
        document: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        syncWithPublicNamespace: Swift.Bool? = false
    )
    {
        self.deprecateExistingEntities = deprecateExistingEntities
        self.document = document
        self.syncWithPublicNamespace = syncWithPublicNamespace
    }
}

public struct UploadEntityDefinitionsOutput {
    /// The ID that specifies the upload action. You can use this to track the status of the upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

extension AssociateEntityToThingInput {

    static func urlPathProvider(_ value: AssociateEntityToThingInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFlowTemplateInput {

    static func urlPathProvider(_ value: CreateFlowTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSystemInstanceInput {

    static func urlPathProvider(_ value: CreateSystemInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSystemTemplateInput {

    static func urlPathProvider(_ value: CreateSystemTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFlowTemplateInput {

    static func urlPathProvider(_ value: DeleteFlowTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSystemInstanceInput {

    static func urlPathProvider(_ value: DeleteSystemInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSystemTemplateInput {

    static func urlPathProvider(_ value: DeleteSystemTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeploySystemInstanceInput {

    static func urlPathProvider(_ value: DeploySystemInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeprecateFlowTemplateInput {

    static func urlPathProvider(_ value: DeprecateFlowTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeprecateSystemTemplateInput {

    static func urlPathProvider(_ value: DeprecateSystemTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeNamespaceInput {

    static func urlPathProvider(_ value: DescribeNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension DissociateEntityFromThingInput {

    static func urlPathProvider(_ value: DissociateEntityFromThingInput) -> Swift.String? {
        return "/"
    }
}

extension GetEntitiesInput {

    static func urlPathProvider(_ value: GetEntitiesInput) -> Swift.String? {
        return "/"
    }
}

extension GetFlowTemplateInput {

    static func urlPathProvider(_ value: GetFlowTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetFlowTemplateRevisionsInput {

    static func urlPathProvider(_ value: GetFlowTemplateRevisionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetNamespaceDeletionStatusInput {

    static func urlPathProvider(_ value: GetNamespaceDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetSystemInstanceInput {

    static func urlPathProvider(_ value: GetSystemInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetSystemTemplateInput {

    static func urlPathProvider(_ value: GetSystemTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetSystemTemplateRevisionsInput {

    static func urlPathProvider(_ value: GetSystemTemplateRevisionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetUploadStatusInput {

    static func urlPathProvider(_ value: GetUploadStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListFlowExecutionMessagesInput {

    static func urlPathProvider(_ value: ListFlowExecutionMessagesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension SearchEntitiesInput {

    static func urlPathProvider(_ value: SearchEntitiesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchFlowExecutionsInput {

    static func urlPathProvider(_ value: SearchFlowExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchFlowTemplatesInput {

    static func urlPathProvider(_ value: SearchFlowTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchSystemInstancesInput {

    static func urlPathProvider(_ value: SearchSystemInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchSystemTemplatesInput {

    static func urlPathProvider(_ value: SearchSystemTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchThingsInput {

    static func urlPathProvider(_ value: SearchThingsInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UndeploySystemInstanceInput {

    static func urlPathProvider(_ value: UndeploySystemInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFlowTemplateInput {

    static func urlPathProvider(_ value: UpdateFlowTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSystemTemplateInput {

    static func urlPathProvider(_ value: UpdateSystemTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension UploadEntityDefinitionsInput {

    static func urlPathProvider(_ value: UploadEntityDefinitionsInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateEntityToThingInput {

    static func write(value: AssociateEntityToThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["namespaceVersion"].write(value.namespaceVersion)
        try writer["thingName"].write(value.thingName)
    }
}

extension CreateFlowTemplateInput {

    static func write(value: CreateFlowTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compatibleNamespaceVersion"].write(value.compatibleNamespaceVersion)
        try writer["definition"].write(value.definition, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
    }
}

extension CreateSystemInstanceInput {

    static func write(value: CreateSystemInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
        try writer["flowActionsRoleArn"].write(value.flowActionsRoleArn)
        try writer["greengrassGroupName"].write(value.greengrassGroupName)
        try writer["metricsConfiguration"].write(value.metricsConfiguration, with: IoTThingsGraphClientTypes.MetricsConfiguration.write(value:to:))
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTThingsGraphClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["target"].write(value.target)
    }
}

extension CreateSystemTemplateInput {

    static func write(value: CreateSystemTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compatibleNamespaceVersion"].write(value.compatibleNamespaceVersion)
        try writer["definition"].write(value.definition, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
    }
}

extension DeleteFlowTemplateInput {

    static func write(value: DeleteFlowTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DeleteNamespaceInput {

    static func write(value: DeleteNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteSystemInstanceInput {

    static func write(value: DeleteSystemInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DeleteSystemTemplateInput {

    static func write(value: DeleteSystemTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DeploySystemInstanceInput {

    static func write(value: DeploySystemInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DeprecateFlowTemplateInput {

    static func write(value: DeprecateFlowTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DeprecateSystemTemplateInput {

    static func write(value: DeprecateSystemTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension DescribeNamespaceInput {

    static func write(value: DescribeNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension DissociateEntityFromThingInput {

    static func write(value: DissociateEntityFromThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityType"].write(value.entityType)
        try writer["thingName"].write(value.thingName)
    }
}

extension GetEntitiesInput {

    static func write(value: GetEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["namespaceVersion"].write(value.namespaceVersion)
    }
}

extension GetFlowTemplateInput {

    static func write(value: GetFlowTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["revisionNumber"].write(value.revisionNumber)
    }
}

extension GetFlowTemplateRevisionsInput {

    static func write(value: GetFlowTemplateRevisionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetNamespaceDeletionStatusInput {

    static func write(value: GetNamespaceDeletionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetSystemInstanceInput {

    static func write(value: GetSystemInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension GetSystemTemplateInput {

    static func write(value: GetSystemTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["revisionNumber"].write(value.revisionNumber)
    }
}

extension GetSystemTemplateRevisionsInput {

    static func write(value: GetSystemTemplateRevisionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetUploadStatusInput {

    static func write(value: GetUploadStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uploadId"].write(value.uploadId)
    }
}

extension ListFlowExecutionMessagesInput {

    static func write(value: ListFlowExecutionMessagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowExecutionId"].write(value.flowExecutionId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension SearchEntitiesInput {

    static func write(value: SearchEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityTypes"].writeList(value.entityTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTThingsGraphClientTypes.EntityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTThingsGraphClientTypes.EntityFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["namespaceVersion"].write(value.namespaceVersion)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchFlowExecutionsInput {

    static func write(value: SearchFlowExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["flowExecutionId"].write(value.flowExecutionId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["systemInstanceId"].write(value.systemInstanceId)
    }
}

extension SearchFlowTemplatesInput {

    static func write(value: SearchFlowTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTThingsGraphClientTypes.FlowTemplateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchSystemInstancesInput {

    static func write(value: SearchSystemInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTThingsGraphClientTypes.SystemInstanceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchSystemTemplatesInput {

    static func write(value: SearchSystemTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTThingsGraphClientTypes.SystemTemplateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SearchThingsInput {

    static func write(value: SearchThingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["maxResults"].write(value.maxResults)
        try writer["namespaceVersion"].write(value.namespaceVersion)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTThingsGraphClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UndeploySystemInstanceInput {

    static func write(value: UndeploySystemInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFlowTemplateInput {

    static func write(value: UpdateFlowTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compatibleNamespaceVersion"].write(value.compatibleNamespaceVersion)
        try writer["definition"].write(value.definition, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
        try writer["id"].write(value.id)
    }
}

extension UpdateSystemTemplateInput {

    static func write(value: UpdateSystemTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["compatibleNamespaceVersion"].write(value.compatibleNamespaceVersion)
        try writer["definition"].write(value.definition, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
        try writer["id"].write(value.id)
    }
}

extension UploadEntityDefinitionsInput {

    static func write(value: UploadEntityDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deprecateExistingEntities"].write(value.deprecateExistingEntities)
        try writer["document"].write(value.document, with: IoTThingsGraphClientTypes.DefinitionDocument.write(value:to:))
        try writer["syncWithPublicNamespace"].write(value.syncWithPublicNamespace)
    }
}

extension AssociateEntityToThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateEntityToThingOutput {
        return AssociateEntityToThingOutput()
    }
}

extension CreateFlowTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowTemplateOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.FlowTemplateSummary.read(from:))
        return value
    }
}

extension CreateSystemInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSystemInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSystemInstanceOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemInstanceSummary.read(from:))
        return value
    }
}

extension CreateSystemTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSystemTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSystemTemplateOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemTemplateSummary.read(from:))
        return value
    }
}

extension DeleteFlowTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowTemplateOutput {
        return DeleteFlowTemplateOutput()
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNamespaceOutput()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        return value
    }
}

extension DeleteSystemInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSystemInstanceOutput {
        return DeleteSystemInstanceOutput()
    }
}

extension DeleteSystemTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSystemTemplateOutput {
        return DeleteSystemTemplateOutput()
    }
}

extension DeploySystemInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeploySystemInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeploySystemInstanceOutput()
        value.greengrassDeploymentId = try reader["greengrassDeploymentId"].readIfPresent()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemInstanceSummary.read(from:))
        return value
    }
}

extension DeprecateFlowTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeprecateFlowTemplateOutput {
        return DeprecateFlowTemplateOutput()
    }
}

extension DeprecateSystemTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeprecateSystemTemplateOutput {
        return DeprecateSystemTemplateOutput()
    }
}

extension DescribeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNamespaceOutput()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.namespaceVersion = try reader["namespaceVersion"].readIfPresent()
        value.trackingNamespaceName = try reader["trackingNamespaceName"].readIfPresent()
        value.trackingNamespaceVersion = try reader["trackingNamespaceVersion"].readIfPresent()
        return value
    }
}

extension DissociateEntityFromThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DissociateEntityFromThingOutput {
        return DissociateEntityFromThingOutput()
    }
}

extension GetEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEntitiesOutput()
        value.descriptions = try reader["descriptions"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.EntityDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFlowTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowTemplateOutput()
        value.description = try reader["description"].readIfPresent(with: IoTThingsGraphClientTypes.FlowTemplateDescription.read(from:))
        return value
    }
}

extension GetFlowTemplateRevisionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowTemplateRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowTemplateRevisionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.FlowTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetNamespaceDeletionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNamespaceDeletionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamespaceDeletionStatusOutput()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetSystemInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSystemInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSystemInstanceOutput()
        value.description = try reader["description"].readIfPresent(with: IoTThingsGraphClientTypes.SystemInstanceDescription.read(from:))
        return value
    }
}

extension GetSystemTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSystemTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSystemTemplateOutput()
        value.description = try reader["description"].readIfPresent(with: IoTThingsGraphClientTypes.SystemTemplateDescription.read(from:))
        return value
    }
}

extension GetSystemTemplateRevisionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSystemTemplateRevisionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSystemTemplateRevisionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.SystemTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetUploadStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUploadStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUploadStatusOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReason = try reader["failureReason"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.namespaceVersion = try reader["namespaceVersion"].readIfPresent()
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.uploadStatus = try reader["uploadStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListFlowExecutionMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowExecutionMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowExecutionMessagesOutput()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.FlowExecutionMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchEntitiesOutput()
        value.descriptions = try reader["descriptions"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.EntityDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchFlowExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchFlowExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchFlowExecutionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.FlowExecutionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchFlowTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchFlowTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchFlowTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.FlowTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchSystemInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSystemInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSystemInstancesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.SystemInstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchSystemTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSystemTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSystemTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.SystemTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchThingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchThingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchThingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.Thing.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UndeploySystemInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UndeploySystemInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UndeploySystemInstanceOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemInstanceSummary.read(from:))
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateFlowTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowTemplateOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.FlowTemplateSummary.read(from:))
        return value
    }
}

extension UpdateSystemTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSystemTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSystemTemplateOutput()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemTemplateSummary.read(from:))
        return value
    }
}

extension UploadEntityDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UploadEntityDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UploadEntityDefinitionsOutput()
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        return value
    }
}

enum AssociateEntityToThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSystemInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSystemTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSystemInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSystemTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeploySystemInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeprecateFlowTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeprecateSystemTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DissociateEntityFromThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowTemplateRevisionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNamespaceDeletionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSystemInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSystemTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSystemTemplateRevisionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUploadStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowExecutionMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchFlowExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchFlowTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSystemInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSystemTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchThingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UndeploySystemInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSystemTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UploadEntityDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTThingsGraphClientTypes.FlowTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.FlowTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.FlowTemplateSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.revisionNumber = try reader["revisionNumber"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.SystemInstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.SystemInstanceSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        value.greengrassGroupName = try reader["greengrassGroupName"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.greengrassGroupId = try reader["greengrassGroupId"].readIfPresent()
        value.greengrassGroupVersionId = try reader["greengrassGroupVersionId"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.SystemTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.SystemTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.SystemTemplateSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.revisionNumber = try reader["revisionNumber"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTThingsGraphClientTypes.EntityDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.EntityDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.EntityDescription()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.definition = try reader["definition"].readIfPresent(with: IoTThingsGraphClientTypes.DefinitionDocument.read(from:))
        return value
    }
}

extension IoTThingsGraphClientTypes.DefinitionDocument {

    static func write(value: IoTThingsGraphClientTypes.DefinitionDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["language"].write(value.language)
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.DefinitionDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.DefinitionDocument()
        value.language = try reader["language"].readIfPresent() ?? .sdkUnknown("")
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension IoTThingsGraphClientTypes.FlowTemplateDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.FlowTemplateDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.FlowTemplateDescription()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.FlowTemplateSummary.read(from:))
        value.definition = try reader["definition"].readIfPresent(with: IoTThingsGraphClientTypes.DefinitionDocument.read(from:))
        value.validatedNamespaceVersion = try reader["validatedNamespaceVersion"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.SystemInstanceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.SystemInstanceDescription()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemInstanceSummary.read(from:))
        value.definition = try reader["definition"].readIfPresent(with: IoTThingsGraphClientTypes.DefinitionDocument.read(from:))
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.metricsConfiguration = try reader["metricsConfiguration"].readIfPresent(with: IoTThingsGraphClientTypes.MetricsConfiguration.read(from:))
        value.validatedNamespaceVersion = try reader["validatedNamespaceVersion"].readIfPresent()
        value.validatedDependencyRevisions = try reader["validatedDependencyRevisions"].readListIfPresent(memberReadingClosure: IoTThingsGraphClientTypes.DependencyRevision.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.flowActionsRoleArn = try reader["flowActionsRoleArn"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.DependencyRevision {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.DependencyRevision {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.DependencyRevision()
        value.id = try reader["id"].readIfPresent()
        value.revisionNumber = try reader["revisionNumber"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.MetricsConfiguration {

    static func write(value: IoTThingsGraphClientTypes.MetricsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudMetricEnabled"].write(value.cloudMetricEnabled)
        try writer["metricRuleRoleArn"].write(value.metricRuleRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.MetricsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.MetricsConfiguration()
        value.cloudMetricEnabled = try reader["cloudMetricEnabled"].readIfPresent() ?? false
        value.metricRuleRoleArn = try reader["metricRuleRoleArn"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.SystemTemplateDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.SystemTemplateDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.SystemTemplateDescription()
        value.summary = try reader["summary"].readIfPresent(with: IoTThingsGraphClientTypes.SystemTemplateSummary.read(from:))
        value.definition = try reader["definition"].readIfPresent(with: IoTThingsGraphClientTypes.DefinitionDocument.read(from:))
        value.validatedNamespaceVersion = try reader["validatedNamespaceVersion"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.FlowExecutionMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.FlowExecutionMessage()
        value.messageId = try reader["messageId"].readIfPresent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.payload = try reader["payload"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.Tag {

    static func write(value: IoTThingsGraphClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.FlowExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.FlowExecutionSummary()
        value.flowExecutionId = try reader["flowExecutionId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.systemInstanceId = try reader["systemInstanceId"].readIfPresent()
        value.flowTemplateId = try reader["flowTemplateId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTThingsGraphClientTypes.Thing {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTThingsGraphClientTypes.Thing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTThingsGraphClientTypes.Thing()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        return value
    }
}

extension IoTThingsGraphClientTypes.EntityFilter {

    static func write(value: IoTThingsGraphClientTypes.EntityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTThingsGraphClientTypes.FlowTemplateFilter {

    static func write(value: IoTThingsGraphClientTypes.FlowTemplateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceFilter {

    static func write(value: IoTThingsGraphClientTypes.SystemInstanceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTThingsGraphClientTypes.SystemTemplateFilter {

    static func write(value: IoTThingsGraphClientTypes.SystemTemplateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum IoTThingsGraphClientTypes {}
