// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateEntityToThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension AssociateEntityToThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateEntityToThingInput: Swift.Equatable {
    /// The ID of the device to be associated with the thing. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The name of the thing to which the entity is to be associated.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.namespaceVersion = namespaceVersion
        self.thingName = thingName
    }
}

struct AssociateEntityToThingInputBody: Swift.Equatable {
    let thingName: Swift.String?
    let entityId: Swift.String?
    let namespaceVersion: Swift.Int?
}

extension AssociateEntityToThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case namespaceVersion
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension AssociateEntityToThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateEntityToThingOutput: Swift.Equatable {

    public init() { }
}

enum AssociateEntityToThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

extension CreateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFlowTemplateInput: Swift.Equatable {
    /// The namespace version in which the workflow is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The workflow DefinitionDocument.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateFlowTemplateInputBody: Swift.Equatable {
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension CreateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateFlowTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFlowTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateFlowTemplateOutput: Swift.Equatable {
    /// The summary object that describes the created workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateFlowTemplateOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
}

extension CreateFlowTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum CreateFlowTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = self.flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let greengrassGroupName = self.greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let metricsConfiguration = self.metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }
}

extension CreateSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSystemInstanceInput: Swift.Equatable {
    /// A document that defines an entity.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ARN of the IAM role that AWS IoT Things Graph will assume when it executes the flow. This role must have read and write access to AWS Lambda and AWS IoT and any other AWS services that the flow uses when it executes. This value is required if the value of the target parameter is CLOUD.
    public var flowActionsRoleArn: Swift.String?
    /// The name of the Greengrass group where the system instance will be deployed. This value is required if the value of the target parameter is GREENGRASS.
    public var greengrassGroupName: Swift.String?
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
    /// The name of the Amazon Simple Storage Service bucket that will be used to store and deploy the system instance's resource file. This value is required if the value of the target parameter is GREENGRASS.
    public var s3BucketName: Swift.String?
    /// Metadata, consisting of key-value pairs, that can be used to categorize your system instances.
    public var tags: [IoTThingsGraphClientTypes.Tag]?
    /// The target type of the deployment. Valid values are GREENGRASS and CLOUD.
    /// This member is required.
    public var target: IoTThingsGraphClientTypes.DeploymentTarget?

    public init(
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        flowActionsRoleArn: Swift.String? = nil,
        greengrassGroupName: Swift.String? = nil,
        metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
        s3BucketName: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil,
        target: IoTThingsGraphClientTypes.DeploymentTarget? = nil
    )
    {
        self.definition = definition
        self.flowActionsRoleArn = flowActionsRoleArn
        self.greengrassGroupName = greengrassGroupName
        self.metricsConfiguration = metricsConfiguration
        self.s3BucketName = s3BucketName
        self.tags = tags
        self.target = target
    }
}

struct CreateSystemInstanceInputBody: Swift.Equatable {
    let tags: [IoTThingsGraphClientTypes.Tag]?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let target: IoTThingsGraphClientTypes.DeploymentTarget?
    let greengrassGroupName: Swift.String?
    let s3BucketName: Swift.String?
    let metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
    let flowActionsRoleArn: Swift.String?
}

extension CreateSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case greengrassGroupName
        case metricsConfiguration
        case s3BucketName
        case tags
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension CreateSystemInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSystemInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemInstanceOutput: Swift.Equatable {
    /// The summary object that describes the new system instance.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemInstanceOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
}

extension CreateSystemInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum CreateSystemInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
    }
}

extension CreateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSystemTemplateInput: Swift.Equatable {
    /// The namespace version in which the system is to be created. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument used to create the system.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
    }
}

struct CreateSystemTemplateInputBody: Swift.Equatable {
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension CreateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension CreateSystemTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSystemTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateSystemTemplateOutput: Swift.Equatable {
    /// The summary object that describes the created system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateSystemTemplateOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
}

extension CreateSystemTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum CreateSystemTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes.DefinitionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionLanguage.self, forKey: .language)
        language = languageDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// A document that defines an entity.
    public struct DefinitionDocument: Swift.Equatable {
        /// The language used to define the entity. GRAPHQL is the only valid value.
        /// This member is required.
        public var language: IoTThingsGraphClientTypes.DefinitionLanguage?
        /// The GraphQL text that defines the entity.
        /// This member is required.
        public var text: Swift.String?

        public init(
            language: IoTThingsGraphClientTypes.DefinitionLanguage? = nil,
            text: Swift.String? = nil
        )
        {
            self.language = language
            self.text = text
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum DefinitionLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphql
        case sdkUnknown(Swift.String)

        public static var allCases: [DefinitionLanguage] {
            return [
                .graphql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphql: return "GRAPHQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefinitionLanguage(rawValue: rawValue) ?? DefinitionLanguage.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteFlowTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFlowTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFlowTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNamespaceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {

    public init() { }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
}

extension DeleteNamespaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
        }
    }
}

public struct DeleteNamespaceOutput: Swift.Equatable {
    /// The ARN of the namespace to be deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to be deleted.
    public var namespaceName: Swift.String?

    public init(
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
    }
}

struct DeleteNamespaceOutputBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
}

extension DeleteNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

enum DeleteNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance to be deleted.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSystemInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSystemInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSystemTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSystemTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSystemTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes.DependencyRevision: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains the ID and revision number of a workflow or system that is part of a deployment.
    public struct DependencyRevision: Swift.Equatable {
        /// The ID of the workflow or system.
        public var id: Swift.String?
        /// The revision number of the workflow or system.
        public var revisionNumber: Swift.Int?

        public init(
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension DeploySystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeploySystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeploySystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance. This value is returned by the CreateSystemInstance action. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeploySystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeploySystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeploySystemInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeploySystemInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.greengrassDeploymentId = output.greengrassDeploymentId
            self.summary = output.summary
        } else {
            self.greengrassDeploymentId = nil
            self.summary = nil
        }
    }
}

public struct DeploySystemInstanceOutput: Swift.Equatable {
    /// The ID of the Greengrass deployment used to deploy the system instance.
    public var greengrassDeploymentId: Swift.String?
    /// An object that contains summary information about a system instance that was deployed.
    /// This member is required.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        greengrassDeploymentId: Swift.String? = nil,
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.greengrassDeploymentId = greengrassDeploymentId
        self.summary = summary
    }
}

struct DeploySystemInstanceOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
    let greengrassDeploymentId: Swift.String?
}

extension DeploySystemInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrassDeploymentId
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let greengrassDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassDeploymentId)
        greengrassDeploymentId = greengrassDeploymentIdDecoded
    }
}

enum DeploySystemInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum DeploymentTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case greengrass
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentTarget] {
            return [
                .cloud,
                .greengrass,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .greengrass: return "GREENGRASS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentTarget(rawValue: rawValue) ?? DeploymentTarget.sdkUnknown(rawValue)
        }
    }
}

extension DeprecateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeprecateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprecateFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow to be deleted. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeprecateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateFlowTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeprecateFlowTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeprecateFlowTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeprecateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeprecateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeprecateSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to delete. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeprecateSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeprecateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeprecateSystemTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeprecateSystemTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeprecateSystemTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespaceName = self.namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
    }
}

extension DescribeNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeNamespaceInput: Swift.Equatable {
    /// The name of the user's namespace. Set this to aws to get the public namespace.
    public var namespaceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

struct DescribeNamespaceInputBody: Swift.Equatable {
    let namespaceName: Swift.String?
}

extension DescribeNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
    }
}

extension DescribeNamespaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNamespaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.trackingNamespaceName = output.trackingNamespaceName
            self.trackingNamespaceVersion = output.trackingNamespaceVersion
        } else {
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.trackingNamespaceName = nil
            self.trackingNamespaceVersion = nil
        }
    }
}

public struct DescribeNamespaceOutput: Swift.Equatable {
    /// The ARN of the namespace.
    public var namespaceArn: Swift.String?
    /// The name of the namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace to describe.
    public var namespaceVersion: Swift.Int?
    /// The name of the public namespace that the latest namespace version is tracking.
    public var trackingNamespaceName: Swift.String?
    /// The version of the public namespace that the latest version is tracking.
    public var trackingNamespaceVersion: Swift.Int?

    public init(
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        trackingNamespaceName: Swift.String? = nil,
        trackingNamespaceVersion: Swift.Int? = nil
    )
    {
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.trackingNamespaceName = trackingNamespaceName
        self.trackingNamespaceVersion = trackingNamespaceVersion
    }
}

struct DescribeNamespaceOutputBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let trackingNamespaceName: Swift.String?
    let trackingNamespaceVersion: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension DescribeNamespaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case trackingNamespaceName
        case trackingNamespaceVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let trackingNamespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNamespaceName)
        trackingNamespaceName = trackingNamespaceNameDecoded
        let trackingNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .trackingNamespaceVersion)
        trackingNamespaceVersion = trackingNamespaceVersionDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

enum DescribeNamespaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DissociateEntityFromThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityType
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType.rawValue, forKey: .entityType)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension DissociateEntityFromThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DissociateEntityFromThingInput: Swift.Equatable {
    /// The entity type from which to disassociate the thing.
    /// This member is required.
    public var entityType: IoTThingsGraphClientTypes.EntityType?
    /// The name of the thing to disassociate.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        entityType: IoTThingsGraphClientTypes.EntityType? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.entityType = entityType
        self.thingName = thingName
    }
}

struct DissociateEntityFromThingInputBody: Swift.Equatable {
    let thingName: Swift.String?
    let entityType: IoTThingsGraphClientTypes.EntityType?
}

extension DissociateEntityFromThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityType
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityType.self, forKey: .entityType)
        entityType = entityTypeDecoded
    }
}

extension DissociateEntityFromThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DissociateEntityFromThingOutput: Swift.Equatable {

    public init() { }
}

enum DissociateEntityFromThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes.EntityDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case definition
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// Describes the properties of an entity.
    public struct EntityDescription: Swift.Equatable {
        /// The entity ARN.
        public var arn: Swift.String?
        /// The time at which the entity was created.
        public var createdAt: ClientRuntime.Date?
        /// The definition document of the entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The entity ID.
        public var id: Swift.String?
        /// The entity type.
        public var type: IoTThingsGraphClientTypes.EntityType?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            id: Swift.String? = nil,
            type: IoTThingsGraphClientTypes.EntityType? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.definition = definition
            self.id = id
            self.type = type
        }
    }

}

extension IoTThingsGraphClientTypes.EntityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for entityfiltervalue0 in value {
                try valueContainer.encode(entityfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.EntityFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters an entity search. Multiple filters function as OR criteria in the search. For example a search that includes a NAMESPACE and a REFERENCED_ENTITY_ID filter searches for entities in the specified namespace that use the entity specified by the value of REFERENCED_ENTITY_ID.
    public struct EntityFilter: Swift.Equatable {
        /// The name of the entity search filter field. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state.
        public var name: IoTThingsGraphClientTypes.EntityFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.EntityFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum EntityFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case namespace
        case referencedEntityId
        case semanticTypePath
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityFilterName] {
            return [
                .name,
                .namespace,
                .referencedEntityId,
                .semanticTypePath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .namespace: return "NAMESPACE"
            case .referencedEntityId: return "REFERENCED_ENTITY_ID"
            case .semanticTypePath: return "SEMANTIC_TYPE_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityFilterName(rawValue: rawValue) ?? EntityFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case action
        case capability
        case device
        case deviceModel
        case `enum`
        case event
        case mapping
        case property
        case service
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .action,
                .capability,
                .device,
                .deviceModel,
                .enum,
                .event,
                .mapping,
                .property,
                .service,
                .state,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .action: return "ACTION"
            case .capability: return "CAPABILITY"
            case .device: return "DEVICE"
            case .deviceModel: return "DEVICE_MODEL"
            case .enum: return "ENUM"
            case .event: return "EVENT"
            case .mapping: return "MAPPING"
            case .property: return "PROPERTY"
            case .service: return "SERVICE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum FlowExecutionEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledgeTaskMessage
        case activityFailed
        case activityScheduled
        case activityStarted
        case activitySucceeded
        case executionAborted
        case executionFailed
        case executionStarted
        case executionSucceeded
        case scheduleNextReadyStepsTask
        case startFlowExecutionTask
        case stepFailed
        case stepStarted
        case stepSucceeded
        case thingActionTask
        case thingActionTaskFailed
        case thingActionTaskSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionEventType] {
            return [
                .acknowledgeTaskMessage,
                .activityFailed,
                .activityScheduled,
                .activityStarted,
                .activitySucceeded,
                .executionAborted,
                .executionFailed,
                .executionStarted,
                .executionSucceeded,
                .scheduleNextReadyStepsTask,
                .startFlowExecutionTask,
                .stepFailed,
                .stepStarted,
                .stepSucceeded,
                .thingActionTask,
                .thingActionTaskFailed,
                .thingActionTaskSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledgeTaskMessage: return "ACKNOWLEDGE_TASK_MESSAGE"
            case .activityFailed: return "ACTIVITY_FAILED"
            case .activityScheduled: return "ACTIVITY_SCHEDULED"
            case .activityStarted: return "ACTIVITY_STARTED"
            case .activitySucceeded: return "ACTIVITY_SUCCEEDED"
            case .executionAborted: return "EXECUTION_ABORTED"
            case .executionFailed: return "EXECUTION_FAILED"
            case .executionStarted: return "EXECUTION_STARTED"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .scheduleNextReadyStepsTask: return "SCHEDULE_NEXT_READY_STEPS_TASK"
            case .startFlowExecutionTask: return "START_FLOW_EXECUTION_TASK"
            case .stepFailed: return "STEP_FAILED"
            case .stepStarted: return "STEP_STARTED"
            case .stepSucceeded: return "STEP_SUCCEEDED"
            case .thingActionTask: return "THING_ACTION_TASK"
            case .thingActionTaskFailed: return "THING_ACTION_TASK_FAILED"
            case .thingActionTaskSucceeded: return "THING_ACTION_TASK_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowExecutionEventType(rawValue: rawValue) ?? FlowExecutionEventType.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowExecutionEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a flow event.
    public struct FlowExecutionMessage: Swift.Equatable {
        /// The type of flow event .
        public var eventType: IoTThingsGraphClientTypes.FlowExecutionEventType?
        /// The unique identifier of the message.
        public var messageId: Swift.String?
        /// A string containing information about the flow event.
        public var payload: Swift.String?
        /// The date and time when the message was last updated.
        public var timestamp: ClientRuntime.Date?

        public init(
            eventType: IoTThingsGraphClientTypes.FlowExecutionEventType? = nil,
            messageId: Swift.String? = nil,
            payload: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.eventType = eventType
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum FlowExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowExecutionStatus] {
            return [
                .aborted,
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowExecutionStatus(rawValue: rawValue) ?? FlowExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case flowExecutionId
        case flowTemplateId
        case status
        case systemInstanceId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let flowTemplateId = self.flowTemplateId {
            try encodeContainer.encode(flowTemplateId, forKey: .flowTemplateId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let systemInstanceId = self.systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowTemplateId)
        flowTemplateId = flowTemplateIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a flow execution.
    public struct FlowExecutionSummary: Swift.Equatable {
        /// The date and time when the flow execution summary was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the flow execution.
        public var flowExecutionId: Swift.String?
        /// The ID of the flow.
        public var flowTemplateId: Swift.String?
        /// The current status of the flow execution.
        public var status: IoTThingsGraphClientTypes.FlowExecutionStatus?
        /// The ID of the system instance that contains the flow.
        public var systemInstanceId: Swift.String?
        /// The date and time when the flow execution summary was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            flowExecutionId: Swift.String? = nil,
            flowTemplateId: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.FlowExecutionStatus? = nil,
            systemInstanceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.flowExecutionId = flowExecutionId
            self.flowTemplateId = flowTemplateId
            self.status = status
            self.systemInstanceId = systemInstanceId
            self.updatedAt = updatedAt
        }
    }

}

extension IoTThingsGraphClientTypes.FlowTemplateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a workflow's definition and summary information.
    public struct FlowTemplateDescription: Swift.Equatable {
        /// A workflow's definition document.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a workflow.
        public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
        /// The version of the user's namespace against which the workflow was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.FlowTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for flowtemplatefiltervalue0 in value {
                try valueContainer.encode(flowtemplatefiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a workflow search.
    public struct FlowTemplateFilter: Swift.Equatable {
        /// The name of the search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.FlowTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.FlowTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum FlowTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceModelId
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowTemplateFilterName] {
            return [
                .deviceModelId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceModelId: return "DEVICE_MODEL_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowTemplateFilterName(rawValue: rawValue) ?? FlowTemplateFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.FlowTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a workflow.
    public struct FlowTemplateSummary: Swift.Equatable {
        /// The ARN of the workflow.
        public var arn: Swift.String?
        /// The date when the workflow was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the workflow.
        public var id: Swift.String?
        /// The revision number of the workflow.
        public var revisionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension GetEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case namespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for urn0 in ids {
                try idsContainer.encode(urn0)
            }
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
    }
}

extension GetEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEntitiesInput: Swift.Equatable {
    /// An array of entity IDs. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var ids: [Swift.String]?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?

    public init(
        ids: [Swift.String]? = nil,
        namespaceVersion: Swift.Int? = nil
    )
    {
        self.ids = ids
        self.namespaceVersion = namespaceVersion
    }
}

struct GetEntitiesInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let namespaceVersion: Swift.Int?
}

extension GetEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case namespaceVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension GetEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
        } else {
            self.descriptions = nil
        }
    }
}

public struct GetEntitiesOutput: Swift.Equatable {
    /// An array of descriptions for the specified entities.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?

    public init(
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil
    )
    {
        self.descriptions = descriptions
    }
}

struct GetEntitiesOutputBody: Swift.Equatable {
    let descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
}

extension GetEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[IoTThingsGraphClientTypes.EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [IoTThingsGraphClientTypes.EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
    }
}

enum GetEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

extension GetFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFlowTemplateInput: Swift.Equatable {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number of the workflow revision to retrieve.
    public var revisionNumber: Swift.Int?

    public init(
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let revisionNumber: Swift.Int?
}

extension GetFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetFlowTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFlowTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetFlowTemplateOutput: Swift.Equatable {
    /// The object that describes the specified workflow.
    public var description: IoTThingsGraphClientTypes.FlowTemplateDescription?

    public init(
        description: IoTThingsGraphClientTypes.FlowTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetFlowTemplateOutputBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.FlowTemplateDescription?
}

extension GetFlowTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetFlowTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFlowTemplateRevisionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetFlowTemplateRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFlowTemplateRevisionsInput: Swift.Equatable {
    /// The ID of the workflow. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFlowTemplateRevisionsInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetFlowTemplateRevisionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetFlowTemplateRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFlowTemplateRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetFlowTemplateRevisionsOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summary data about each revision.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetFlowTemplateRevisionsOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?
    let nextToken: Swift.String?
}

extension GetFlowTemplateRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetFlowTemplateRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNamespaceDeletionStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetNamespaceDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamespaceDeletionStatusInput: Swift.Equatable {

    public init() { }
}

struct GetNamespaceDeletionStatusInputBody: Swift.Equatable {
}

extension GetNamespaceDeletionStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNamespaceDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNamespaceDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.status = output.status
        } else {
            self.errorCode = nil
            self.errorMessage = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.status = nil
        }
    }
}

public struct GetNamespaceDeletionStatusOutput: Swift.Equatable {
    /// An error code returned by the namespace deletion task.
    public var errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes?
    /// An error code returned by the namespace deletion task.
    public var errorMessage: Swift.String?
    /// The ARN of the namespace that is being deleted.
    public var namespaceArn: Swift.String?
    /// The name of the namespace that is being deleted.
    public var namespaceName: Swift.String?
    /// The status of the deletion request.
    public var status: IoTThingsGraphClientTypes.NamespaceDeletionStatus?

    public init(
        errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes? = nil,
        errorMessage: Swift.String? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        status: IoTThingsGraphClientTypes.NamespaceDeletionStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.status = status
    }
}

struct GetNamespaceDeletionStatusOutputBody: Swift.Equatable {
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let status: IoTThingsGraphClientTypes.NamespaceDeletionStatus?
    let errorCode: IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes?
    let errorMessage: Swift.String?
}

extension GetNamespaceDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case namespaceArn
        case namespaceName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.NamespaceDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.NamespaceDeletionStatusErrorCodes.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum GetNamespaceDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetSystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemInstanceInput: Swift.Equatable {
    /// The ID of the system deployment instance. This value is returned by CreateSystemInstance. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:deployment:DEPLOYMENTNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetSystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetSystemInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSystemInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemInstanceOutput: Swift.Equatable {
    /// An object that describes the system instance.
    public var description: IoTThingsGraphClientTypes.SystemInstanceDescription?

    public init(
        description: IoTThingsGraphClientTypes.SystemInstanceDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemInstanceOutputBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.SystemInstanceDescription?
}

extension GetSystemInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetSystemInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }
}

extension GetSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemTemplateInput: Swift.Equatable {
    /// The ID of the system to get. This ID must be in the user's namespace. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The number that specifies the revision of the system to get.
    public var revisionNumber: Swift.Int?

    public init(
        id: Swift.String? = nil,
        revisionNumber: Swift.Int? = nil
    )
    {
        self.id = id
        self.revisionNumber = revisionNumber
    }
}

struct GetSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let revisionNumber: Swift.Int?
}

extension GetSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case revisionNumber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
    }
}

extension GetSystemTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSystemTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct GetSystemTemplateOutput: Swift.Equatable {
    /// An object that contains summary data about the system.
    public var description: IoTThingsGraphClientTypes.SystemTemplateDescription?

    public init(
        description: IoTThingsGraphClientTypes.SystemTemplateDescription? = nil
    )
    {
        self.description = description
    }
}

struct GetSystemTemplateOutputBody: Swift.Equatable {
    let description: IoTThingsGraphClientTypes.SystemTemplateDescription?
}

extension GetSystemTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetSystemTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSystemTemplateRevisionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetSystemTemplateRevisionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSystemTemplateRevisionsInput: Swift.Equatable {
    /// The ID of the system template. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetSystemTemplateRevisionsInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetSystemTemplateRevisionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetSystemTemplateRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSystemTemplateRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetSystemTemplateRevisionsOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data about the system template revisions.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetSystemTemplateRevisionsOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?
    let nextToken: Swift.String?
}

extension GetSystemTemplateRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSystemTemplateRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUploadStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension GetUploadStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUploadStatusInput: Swift.Equatable {
    /// The ID of the upload. This value is returned by the UploadEntityDefinitions action.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct GetUploadStatusInputBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension GetUploadStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension GetUploadStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUploadStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.failureReason = output.failureReason
            self.namespaceArn = output.namespaceArn
            self.namespaceName = output.namespaceName
            self.namespaceVersion = output.namespaceVersion
            self.uploadId = output.uploadId
            self.uploadStatus = output.uploadStatus
        } else {
            self.createdDate = nil
            self.failureReason = nil
            self.namespaceArn = nil
            self.namespaceName = nil
            self.namespaceVersion = nil
            self.uploadId = nil
            self.uploadStatus = nil
        }
    }
}

public struct GetUploadStatusOutput: Swift.Equatable {
    /// The date at which the upload was created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The reason for an upload failure.
    public var failureReason: [Swift.String]?
    /// The ARN of the upload.
    public var namespaceArn: Swift.String?
    /// The name of the upload's namespace.
    public var namespaceName: Swift.String?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The ID of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The status of the upload. The initial status is IN_PROGRESS. The response show all validation failures if the upload fails.
    /// This member is required.
    public var uploadStatus: IoTThingsGraphClientTypes.UploadStatus?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        failureReason: [Swift.String]? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        namespaceVersion: Swift.Int? = nil,
        uploadId: Swift.String? = nil,
        uploadStatus: IoTThingsGraphClientTypes.UploadStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.failureReason = failureReason
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.namespaceVersion = namespaceVersion
        self.uploadId = uploadId
        self.uploadStatus = uploadStatus
    }
}

struct GetUploadStatusOutputBody: Swift.Equatable {
    let uploadId: Swift.String?
    let uploadStatus: IoTThingsGraphClientTypes.UploadStatus?
    let namespaceArn: Swift.String?
    let namespaceName: Swift.String?
    let namespaceVersion: Swift.Int?
    let failureReason: [Swift.String]?
    let createdDate: ClientRuntime.Date?
}

extension GetUploadStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case failureReason
        case namespaceArn
        case namespaceName
        case namespaceVersion
        case uploadId
        case uploadStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let uploadStatusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.UploadStatus.self, forKey: .uploadStatus)
        uploadStatus = uploadStatusDecoded
        let namespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceArn)
        namespaceArn = namespaceArnDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
        let failureReasonContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReason)
        var failureReasonDecoded0:[Swift.String]? = nil
        if let failureReasonContainer = failureReasonContainer {
            failureReasonDecoded0 = [Swift.String]()
            for string0 in failureReasonContainer {
                if let string0 = string0 {
                    failureReasonDecoded0?.append(string0)
                }
            }
        }
        failureReason = failureReasonDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

enum GetUploadStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFlowExecutionMessagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFlowExecutionMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFlowExecutionMessagesInput: Swift.Equatable {
    /// The ID of the flow execution.
    /// This member is required.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesInputBody: Swift.Equatable {
    let flowExecutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFlowExecutionMessagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutionId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFlowExecutionMessagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFlowExecutionMessagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
        } else {
            self.messages = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowExecutionMessagesOutput: Swift.Equatable {
    /// A list of objects that contain information about events in the specified flow execution.
    public var messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init(
        messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
    }
}

struct ListFlowExecutionMessagesOutputBody: Swift.Equatable {
    let messages: [IoTThingsGraphClientTypes.FlowExecutionMessage]?
    let nextToken: Swift.String?
}

extension ListFlowExecutionMessagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowExecutionMessage?].self, forKey: .messages)
        var messagesDecoded0:[IoTThingsGraphClientTypes.FlowExecutionMessage]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [IoTThingsGraphClientTypes.FlowExecutionMessage]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFlowExecutionMessagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags to return.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be returned.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The token that specifies the next page of results to return.
    public var nextToken: Swift.String?
    /// List of tags returned by the ListTagsForResource operation.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [IoTThingsGraphClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes.MetricsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudMetricEnabled
        case metricRuleRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudMetricEnabled != false {
            try encodeContainer.encode(cloudMetricEnabled, forKey: .cloudMetricEnabled)
        }
        if let metricRuleRoleArn = self.metricRuleRoleArn {
            try encodeContainer.encode(metricRuleRoleArn, forKey: .metricRuleRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudMetricEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudMetricEnabled) ?? false
        cloudMetricEnabled = cloudMetricEnabledDecoded
        let metricRuleRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricRuleRoleArn)
        metricRuleRoleArn = metricRuleRoleArnDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
    public struct MetricsConfiguration: Swift.Equatable {
        /// A Boolean that specifies whether cloud metrics are collected.
        public var cloudMetricEnabled: Swift.Bool
        /// The ARN of the role that is used to collect cloud metrics.
        public var metricRuleRoleArn: Swift.String?

        public init(
            cloudMetricEnabled: Swift.Bool = false,
            metricRuleRoleArn: Swift.String? = nil
        )
        {
            self.cloudMetricEnabled = cloudMetricEnabled
            self.metricRuleRoleArn = metricRuleRoleArn
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum NamespaceDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceDeletionStatus(rawValue: rawValue) ?? NamespaceDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum NamespaceDeletionStatusErrorCodes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceDeletionStatusErrorCodes] {
            return [
                .validationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceDeletionStatusErrorCodes(rawValue: rawValue) ?? NamespaceDeletionStatusErrorCodes.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SearchEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytype0 in entityTypes {
                try entityTypesContainer.encode(entitytype0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for entityfilter0 in filters {
                try filtersContainer.encode(entityfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchEntitiesInput: Swift.Equatable {
    /// The entity types for which to search.
    /// This member is required.
    public var entityTypes: [IoTThingsGraphClientTypes.EntityType]?
    /// Optional filter to apply to the search. Valid filters are NAMENAMESPACE, SEMANTIC_TYPE_PATH and REFERENCED_ENTITY_ID. REFERENCED_ENTITY_ID filters on entities that are used by the entity in the result set. For example, you can filter on the ID of a property that is used in a state. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.EntityFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        entityTypes: [IoTThingsGraphClientTypes.EntityType]? = nil,
        filters: [IoTThingsGraphClientTypes.EntityFilter]? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.filters = filters
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchEntitiesInputBody: Swift.Equatable {
    let entityTypes: [IoTThingsGraphClientTypes.EntityType]?
    let filters: [IoTThingsGraphClientTypes.EntityFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension SearchEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case filters
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[IoTThingsGraphClientTypes.EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [IoTThingsGraphClientTypes.EntityType]()
            for enum0 in entityTypesContainer {
                if let enum0 = enum0 {
                    entityTypesDecoded0?.append(enum0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.EntityFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.EntityFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct SearchEntitiesOutput: Swift.Equatable {
    /// An array of descriptions for each entity returned in the search result.
    public var descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?

    public init(
        descriptions: [IoTThingsGraphClientTypes.EntityDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct SearchEntitiesOutputBody: Swift.Equatable {
    let descriptions: [IoTThingsGraphClientTypes.EntityDescription]?
    let nextToken: Swift.String?
}

extension SearchEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.EntityDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[IoTThingsGraphClientTypes.EntityDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [IoTThingsGraphClientTypes.EntityDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchFlowExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let flowExecutionId = self.flowExecutionId {
            try encodeContainer.encode(flowExecutionId, forKey: .flowExecutionId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let systemInstanceId = self.systemInstanceId {
            try encodeContainer.encode(systemInstanceId, forKey: .systemInstanceId)
        }
    }
}

extension SearchFlowExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchFlowExecutionsInput: Swift.Equatable {
    /// The date and time of the latest flow execution to return.
    public var endTime: ClientRuntime.Date?
    /// The ID of a flow execution.
    public var flowExecutionId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?
    /// The date and time of the earliest flow execution to return.
    public var startTime: ClientRuntime.Date?
    /// The ID of the system instance that contains the flow.
    /// This member is required.
    public var systemInstanceId: Swift.String?

    public init(
        endTime: ClientRuntime.Date? = nil,
        flowExecutionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        systemInstanceId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.flowExecutionId = flowExecutionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.systemInstanceId = systemInstanceId
    }
}

struct SearchFlowExecutionsInputBody: Swift.Equatable {
    let systemInstanceId: Swift.String?
    let flowExecutionId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchFlowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case flowExecutionId
        case maxResults
        case nextToken
        case startTime
        case systemInstanceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemInstanceId)
        systemInstanceId = systemInstanceIdDecoded
        let flowExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowExecutionId)
        flowExecutionId = flowExecutionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchFlowExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowExecutionsOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow execution in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowExecutionsOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowExecutionSummary]?
    let nextToken: Swift.String?
}

extension SearchFlowExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowExecutionSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowExecutionSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowExecutionSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchFlowExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchFlowTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for flowtemplatefilter0 in filters {
                try filtersContainer.encode(flowtemplatefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchFlowTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchFlowTemplatesInput: Swift.Equatable {
    /// An array of objects that limit the result set. The only valid filter is DEVICE_MODEL_ID.
    public var filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchFlowTemplatesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.FlowTemplateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchFlowTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.FlowTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFlowTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchFlowTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchFlowTemplatesOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each workflow in the result set.
    public var summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchFlowTemplatesOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.FlowTemplateSummary]?
    let nextToken: Swift.String?
}

extension SearchFlowTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.FlowTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.FlowTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.FlowTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchFlowTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchSystemInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systeminstancefilter0 in filters {
                try filtersContainer.encode(systeminstancefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchSystemInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSystemInstancesInput: Swift.Equatable {
    /// Optional filter to apply to the search. Valid filters are SYSTEM_TEMPLATE_ID, STATUS, and GREENGRASS_GROUP_NAME. Multiple filters function as OR criteria in the query. Multiple values passed inside the filter function as AND criteria.
    public var filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemInstancesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.SystemInstanceFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchSystemInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemInstanceFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.SystemInstanceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.SystemInstanceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSystemInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemInstancesOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary data abour the system instances in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemInstancesOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemInstanceSummary]?
    let nextToken: Swift.String?
}

extension SearchSystemInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemInstanceSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemInstanceSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemInstanceSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchSystemInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchSystemTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for systemtemplatefilter0 in filters {
                try filtersContainer.encode(systemtemplatefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchSystemTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSystemTemplatesInput: Swift.Equatable {
    /// An array of filters that limit the result set. The only valid filter is FLOW_TEMPLATE_ID.
    public var filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchSystemTemplatesInputBody: Swift.Equatable {
    let filters: [IoTThingsGraphClientTypes.SystemTemplateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchSystemTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTThingsGraphClientTypes.SystemTemplateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchSystemTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSystemTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct SearchSystemTemplatesOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain summary information about each system deployment in the result set.
    public var summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct SearchSystemTemplatesOutputBody: Swift.Equatable {
    let summaries: [IoTThingsGraphClientTypes.SystemTemplateSummary]?
    let nextToken: Swift.String?
}

extension SearchSystemTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.SystemTemplateSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTThingsGraphClientTypes.SystemTemplateSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTThingsGraphClientTypes.SystemTemplateSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchSystemTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchThingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceVersion = self.namespaceVersion {
            try encodeContainer.encode(namespaceVersion, forKey: .namespaceVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchThingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchThingsInput: Swift.Equatable {
    /// The ID of the entity to which the things are associated. The IDs should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:device:DEVICENAME
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace.
    public var namespaceVersion: Swift.Int?
    /// The string that specifies the next page of results. Use this when you're paginating results.
    public var nextToken: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespaceVersion: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.namespaceVersion = namespaceVersion
        self.nextToken = nextToken
    }
}

struct SearchThingsInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let namespaceVersion: Swift.Int?
}

extension SearchThingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case maxResults
        case namespaceVersion
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let namespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespaceVersion)
        namespaceVersion = namespaceVersionDecoded
    }
}

extension SearchThingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchThingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct SearchThingsOutput: Swift.Equatable {
    /// The string to specify as nextToken when you request the next page of results.
    public var nextToken: Swift.String?
    /// An array of things in the result set.
    public var things: [IoTThingsGraphClientTypes.Thing]?

    public init(
        nextToken: Swift.String? = nil,
        things: [IoTThingsGraphClientTypes.Thing]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct SearchThingsOutputBody: Swift.Equatable {
    let things: [IoTThingsGraphClientTypes.Thing]?
    let nextToken: Swift.String?
}

extension SearchThingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Thing?].self, forKey: .things)
        var thingsDecoded0:[IoTThingsGraphClientTypes.Thing]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [IoTThingsGraphClientTypes.Thing]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchThingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum SystemInstanceDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bootstrap
        case deletedInTarget
        case deployedInTarget
        case deployInProgress
        case failed
        case notDeployed
        case pendingDelete
        case undeployInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceDeploymentStatus] {
            return [
                .bootstrap,
                .deletedInTarget,
                .deployedInTarget,
                .deployInProgress,
                .failed,
                .notDeployed,
                .pendingDelete,
                .undeployInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bootstrap: return "BOOTSTRAP"
            case .deletedInTarget: return "DELETED_IN_TARGET"
            case .deployedInTarget: return "DEPLOYED_IN_TARGET"
            case .deployInProgress: return "DEPLOY_IN_PROGRESS"
            case .failed: return "FAILED"
            case .notDeployed: return "NOT_DEPLOYED"
            case .pendingDelete: return "PENDING_DELETE"
            case .undeployInProgress: return "UNDEPLOY_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemInstanceDeploymentStatus(rawValue: rawValue) ?? SystemInstanceDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case flowActionsRoleArn
        case metricsConfiguration
        case s3BucketName
        case summary
        case validatedDependencyRevisions
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let flowActionsRoleArn = self.flowActionsRoleArn {
            try encodeContainer.encode(flowActionsRoleArn, forKey: .flowActionsRoleArn)
        }
        if let metricsConfiguration = self.metricsConfiguration {
            try encodeContainer.encode(metricsConfiguration, forKey: .metricsConfiguration)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedDependencyRevisions = validatedDependencyRevisions {
            var validatedDependencyRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatedDependencyRevisions)
            for dependencyrevision0 in validatedDependencyRevisions {
                try validatedDependencyRevisionsContainer.encode(dependencyrevision0)
            }
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let metricsConfigurationDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.MetricsConfiguration.self, forKey: .metricsConfiguration)
        metricsConfiguration = metricsConfigurationDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
        let validatedDependencyRevisionsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.DependencyRevision?].self, forKey: .validatedDependencyRevisions)
        var validatedDependencyRevisionsDecoded0:[IoTThingsGraphClientTypes.DependencyRevision]? = nil
        if let validatedDependencyRevisionsContainer = validatedDependencyRevisionsContainer {
            validatedDependencyRevisionsDecoded0 = [IoTThingsGraphClientTypes.DependencyRevision]()
            for structure0 in validatedDependencyRevisionsContainer {
                if let structure0 = structure0 {
                    validatedDependencyRevisionsDecoded0?.append(structure0)
                }
            }
        }
        validatedDependencyRevisions = validatedDependencyRevisionsDecoded0
        let flowActionsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowActionsRoleArn)
        flowActionsRoleArn = flowActionsRoleArnDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system instance definition and summary information.
    public struct SystemInstanceDescription: Swift.Equatable {
        /// A document that defines an entity.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// The AWS Identity and Access Management (IAM) role that AWS IoT Things Graph assumes during flow execution in a cloud deployment. This role must have read and write permissionss to AWS Lambda and AWS IoT and to any other AWS services that the flow uses.
        public var flowActionsRoleArn: Swift.String?
        /// An object that specifies whether cloud metrics are collected in a deployment and, if so, what role is used to collect metrics.
        public var metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration?
        /// The Amazon Simple Storage Service bucket where information about a system instance is stored.
        public var s3BucketName: Swift.String?
        /// An object that contains summary information about a system instance.
        public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
        /// A list of objects that contain all of the IDs and revision numbers of workflows and systems that are used in a system instance.
        public var validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]?
        /// The version of the user's namespace against which the system instance was validated.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            flowActionsRoleArn: Swift.String? = nil,
            metricsConfiguration: IoTThingsGraphClientTypes.MetricsConfiguration? = nil,
            s3BucketName: Swift.String? = nil,
            summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil,
            validatedDependencyRevisions: [IoTThingsGraphClientTypes.DependencyRevision]? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.flowActionsRoleArn = flowActionsRoleArn
            self.metricsConfiguration = metricsConfiguration
            self.s3BucketName = s3BucketName
            self.summary = summary
            self.validatedDependencyRevisions = validatedDependencyRevisions
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.SystemInstanceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systeminstancefiltervalue0 in value {
                try valueContainer.encode(systeminstancefiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system instance search. Multiple filters function as OR criteria in the search. For example a search that includes a GREENGRASS_GROUP_NAME and a STATUS filter searches for system instances in the specified Greengrass group that have the specified status.
    public struct SystemInstanceFilter: Swift.Equatable {
        /// The name of the search filter field.
        public var name: IoTThingsGraphClientTypes.SystemInstanceFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.SystemInstanceFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum SystemInstanceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrassGroupName
        case status
        case systemTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemInstanceFilterName] {
            return [
                .greengrassGroupName,
                .status,
                .systemTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrassGroupName: return "GREENGRASS_GROUP_NAME"
            case .status: return "STATUS"
            case .systemTemplateId: return "SYSTEM_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemInstanceFilterName(rawValue: rawValue) ?? SystemInstanceFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case greengrassGroupId
        case greengrassGroupName
        case greengrassGroupVersionId
        case id
        case status
        case target
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let greengrassGroupId = self.greengrassGroupId {
            try encodeContainer.encode(greengrassGroupId, forKey: .greengrassGroupId)
        }
        if let greengrassGroupName = self.greengrassGroupName {
            try encodeContainer.encode(greengrassGroupName, forKey: .greengrassGroupName)
        }
        if let greengrassGroupVersionId = self.greengrassGroupVersionId {
            try encodeContainer.encode(greengrassGroupVersionId, forKey: .greengrassGroupVersionId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DeploymentTarget.self, forKey: .target)
        target = targetDecoded
        let greengrassGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupName)
        greengrassGroupName = greengrassGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let greengrassGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupId)
        greengrassGroupId = greengrassGroupIdDecoded
        let greengrassGroupVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .greengrassGroupVersionId)
        greengrassGroupVersionId = greengrassGroupVersionIdDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains summary information about a system instance.
    public struct SystemInstanceSummary: Swift.Equatable {
        /// The ARN of the system instance.
        public var arn: Swift.String?
        /// The date when the system instance was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupId: Swift.String?
        /// The ID of the Greengrass group where the system instance is deployed.
        public var greengrassGroupName: Swift.String?
        /// The version of the Greengrass group where the system instance is deployed.
        public var greengrassGroupVersionId: Swift.String?
        /// The ID of the system instance.
        public var id: Swift.String?
        /// The status of the system instance.
        public var status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus?
        /// The target of the system instance.
        public var target: IoTThingsGraphClientTypes.DeploymentTarget?
        /// The date and time when the system instance was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            greengrassGroupId: Swift.String? = nil,
            greengrassGroupName: Swift.String? = nil,
            greengrassGroupVersionId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: IoTThingsGraphClientTypes.SystemInstanceDeploymentStatus? = nil,
            target: IoTThingsGraphClientTypes.DeploymentTarget? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.greengrassGroupId = greengrassGroupId
            self.greengrassGroupName = greengrassGroupName
            self.greengrassGroupVersionId = greengrassGroupVersionId
            self.id = id
            self.status = status
            self.target = target
            self.updatedAt = updatedAt
        }
    }

}

extension IoTThingsGraphClientTypes.SystemTemplateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case summary
        case validatedNamespaceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let validatedNamespaceVersion = self.validatedNamespaceVersion {
            try encodeContainer.encode(validatedNamespaceVersion, forKey: .validatedNamespaceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let validatedNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validatedNamespaceVersion)
        validatedNamespaceVersion = validatedNamespaceVersionDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains a system's definition document and summary information.
    public struct SystemTemplateDescription: Swift.Equatable {
        /// The definition document of a system.
        public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
        /// An object that contains summary information about a system.
        public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
        /// The namespace version against which the system was validated. Use this value in your system instance.
        public var validatedNamespaceVersion: Swift.Int?

        public init(
            definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
            summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil,
            validatedNamespaceVersion: Swift.Int? = nil
        )
        {
            self.definition = definition
            self.summary = summary
            self.validatedNamespaceVersion = validatedNamespaceVersion
        }
    }

}

extension IoTThingsGraphClientTypes.SystemTemplateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for systemtemplatefiltervalue0 in value {
                try valueContainer.encode(systemtemplatefiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that filters a system search.
    public struct SystemTemplateFilter: Swift.Equatable {
        /// The name of the system search filter field.
        /// This member is required.
        public var name: IoTThingsGraphClientTypes.SystemTemplateFilterName?
        /// An array of string values for the search filter field. Multiple values function as AND criteria in the search.
        /// This member is required.
        public var value: [Swift.String]?

        public init(
            name: IoTThingsGraphClientTypes.SystemTemplateFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTThingsGraphClientTypes {
    public enum SystemTemplateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flowTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [SystemTemplateFilterName] {
            return [
                .flowTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flowTemplateId: return "FLOW_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SystemTemplateFilterName(rawValue: rawValue) ?? SystemTemplateFilterName.sdkUnknown(rawValue)
        }
    }
}

extension IoTThingsGraphClientTypes.SystemTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case revisionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revisionNumber = self.revisionNumber {
            try encodeContainer.encode(revisionNumber, forKey: .revisionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revisionNumber)
        revisionNumber = revisionNumberDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An object that contains information about a system.
    public struct SystemTemplateSummary: Swift.Equatable {
        /// The ARN of the system.
        public var arn: Swift.String?
        /// The date when the system was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the system.
        public var id: Swift.String?
        /// The revision number of the system.
        public var revisionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            revisionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.revisionNumber = revisionNumber
        }
    }

}

extension IoTThingsGraphClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// Metadata assigned to an AWS IoT Things Graph resource consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The required name of the tag. The string value can be from 1 to 128 Unicode characters in length.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value of the tag. The string value can be from 1 to 256 Unicode characters in length.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags are returned.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add to the resource.>
    /// This member is required.
    public var tags: [IoTThingsGraphClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTThingsGraphClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [IoTThingsGraphClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTThingsGraphClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTThingsGraphClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTThingsGraphClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes.Thing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension IoTThingsGraphClientTypes {
    /// An AWS IoT thing.
    public struct Thing: Swift.Equatable {
        /// The ARN of the thing.
        public var thingArn: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?

        public init(
            thingArn: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.thingArn = thingArn
            self.thingName = thingName
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UndeploySystemInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UndeploySystemInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UndeploySystemInstanceInput: Swift.Equatable {
    /// The ID of the system instance to remove from its target.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct UndeploySystemInstanceInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension UndeploySystemInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension UndeploySystemInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UndeploySystemInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UndeploySystemInstanceOutput: Swift.Equatable {
    /// An object that contains summary information about the system instance that was removed from its target.
    public var summary: IoTThingsGraphClientTypes.SystemInstanceSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemInstanceSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UndeploySystemInstanceOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemInstanceSummary?
}

extension UndeploySystemInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemInstanceSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum UndeploySystemInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed. This parameter to the API requires a JSON text string argument. For information on how to format a JSON parameter for the various command line tool environments, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters.html#cli-using-param-json) in the AWS CLI User Guide.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateFlowTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFlowTemplateInput: Swift.Equatable {
    /// The version of the user's namespace. If no value is specified, the latest version is used by default. Use the GetFlowTemplateRevisions if you want to find earlier revisions of the flow to update.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated workflow definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the workflow to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:workflow:WORKFLOWNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateFlowTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension UpdateFlowTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateFlowTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateFlowTemplateOutput: Swift.Equatable {
    /// An object containing summary information about the updated workflow.
    public var summary: IoTThingsGraphClientTypes.FlowTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.FlowTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateFlowTemplateOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.FlowTemplateSummary?
}

extension UpdateFlowTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.FlowTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum UpdateFlowTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSystemTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleNamespaceVersion = self.compatibleNamespaceVersion {
            try encodeContainer.encode(compatibleNamespaceVersion, forKey: .compatibleNamespaceVersion)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateSystemTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSystemTemplateInput: Swift.Equatable {
    /// The version of the user's namespace. Defaults to the latest version of the user's namespace. If no value is specified, the latest version is used by default.
    public var compatibleNamespaceVersion: Swift.Int?
    /// The DefinitionDocument that contains the updated system definition.
    /// This member is required.
    public var definition: IoTThingsGraphClientTypes.DefinitionDocument?
    /// The ID of the system to be updated. The ID should be in the following format. urn:tdm:REGION/ACCOUNT ID/default:system:SYSTEMNAME
    /// This member is required.
    public var id: Swift.String?

    public init(
        compatibleNamespaceVersion: Swift.Int? = nil,
        definition: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        id: Swift.String? = nil
    )
    {
        self.compatibleNamespaceVersion = compatibleNamespaceVersion
        self.definition = definition
        self.id = id
    }
}

struct UpdateSystemTemplateInputBody: Swift.Equatable {
    let id: Swift.String?
    let definition: IoTThingsGraphClientTypes.DefinitionDocument?
    let compatibleNamespaceVersion: Swift.Int?
}

extension UpdateSystemTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleNamespaceVersion
        case definition
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .definition)
        definition = definitionDecoded
        let compatibleNamespaceVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNamespaceVersion)
        compatibleNamespaceVersion = compatibleNamespaceVersionDecoded
    }
}

extension UpdateSystemTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSystemTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct UpdateSystemTemplateOutput: Swift.Equatable {
    /// An object containing summary information about the updated system.
    public var summary: IoTThingsGraphClientTypes.SystemTemplateSummary?

    public init(
        summary: IoTThingsGraphClientTypes.SystemTemplateSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct UpdateSystemTemplateOutputBody: Swift.Equatable {
    let summary: IoTThingsGraphClientTypes.SystemTemplateSummary?
}

extension UpdateSystemTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.SystemTemplateSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum UpdateSystemTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UploadEntityDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deprecateExistingEntities = self.deprecateExistingEntities {
            try encodeContainer.encode(deprecateExistingEntities, forKey: .deprecateExistingEntities)
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let syncWithPublicNamespace = self.syncWithPublicNamespace {
            try encodeContainer.encode(syncWithPublicNamespace, forKey: .syncWithPublicNamespace)
        }
    }
}

extension UploadEntityDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadEntityDefinitionsInput: Swift.Equatable {
    /// A Boolean that specifies whether to deprecate all entities in the latest version before uploading the new DefinitionDocument. If set to true, the upload will create a new namespace version.
    public var deprecateExistingEntities: Swift.Bool?
    /// The DefinitionDocument that defines the updated entities.
    public var document: IoTThingsGraphClientTypes.DefinitionDocument?
    /// A Boolean that specifies whether to synchronize with the latest version of the public namespace. If set to true, the upload will create a new namespace version.
    public var syncWithPublicNamespace: Swift.Bool?

    public init(
        deprecateExistingEntities: Swift.Bool? = nil,
        document: IoTThingsGraphClientTypes.DefinitionDocument? = nil,
        syncWithPublicNamespace: Swift.Bool? = nil
    )
    {
        self.deprecateExistingEntities = deprecateExistingEntities
        self.document = document
        self.syncWithPublicNamespace = syncWithPublicNamespace
    }
}

struct UploadEntityDefinitionsInputBody: Swift.Equatable {
    let document: IoTThingsGraphClientTypes.DefinitionDocument?
    let syncWithPublicNamespace: Swift.Bool?
    let deprecateExistingEntities: Swift.Bool?
}

extension UploadEntityDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecateExistingEntities
        case document
        case syncWithPublicNamespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(IoTThingsGraphClientTypes.DefinitionDocument.self, forKey: .document)
        document = documentDecoded
        let syncWithPublicNamespaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncWithPublicNamespace)
        syncWithPublicNamespace = syncWithPublicNamespaceDecoded
        let deprecateExistingEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deprecateExistingEntities)
        deprecateExistingEntities = deprecateExistingEntitiesDecoded
    }
}

extension UploadEntityDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadEntityDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.uploadId = output.uploadId
        } else {
            self.uploadId = nil
        }
    }
}

public struct UploadEntityDefinitionsOutput: Swift.Equatable {
    /// The ID that specifies the upload action. You can use this to track the status of the upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        uploadId: Swift.String? = nil
    )
    {
        self.uploadId = uploadId
    }
}

struct UploadEntityDefinitionsOutputBody: Swift.Equatable {
    let uploadId: Swift.String?
}

extension UploadEntityDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

enum UploadEntityDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTThingsGraphClientTypes {
    public enum UploadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
        }
    }
}
