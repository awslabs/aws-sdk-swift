// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource with the name requested already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelResourceRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestToken = "RequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestToken = self.requestToken {
            try encodeContainer.encode(requestToken, forKey: .requestToken)
        }
    }
}

extension CancelResourceRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelResourceRequestInput: Swift.Equatable {
    /// The RequestToken of the ProgressEvent object returned by the resource operation request.
    /// This member is required.
    public var requestToken: Swift.String?

    public init (
        requestToken: Swift.String? = nil
    )
    {
        self.requestToken = requestToken
    }
}

struct CancelResourceRequestInputBody: Swift.Equatable {
    let requestToken: Swift.String?
}

extension CancelResourceRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestToken = "RequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestToken)
        requestToken = requestTokenDecoded
    }
}

extension CancelResourceRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelResourceRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTokenNotFoundException" : self = .requestTokenNotFoundException(try RequestTokenNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelResourceRequestOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case requestTokenNotFoundException(RequestTokenNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelResourceRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelResourceRequestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.progressEvent = output.progressEvent
        } else {
            self.progressEvent = nil
        }
    }
}

public struct CancelResourceRequestOutputResponse: Swift.Equatable {
    /// Represents the current status of a resource operation request. For more information, see [Managing resource operation requests](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations-manage-requests.html) in the Amazon Web Services Cloud Control API User Guide.
    public var progressEvent: CloudControlClientTypes.ProgressEvent?

    public init (
        progressEvent: CloudControlClientTypes.ProgressEvent? = nil
    )
    {
        self.progressEvent = progressEvent
    }
}

struct CancelResourceRequestOutputResponseBody: Swift.Equatable {
    let progressEvent: CloudControlClientTypes.ProgressEvent?
}

extension CancelResourceRequestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressEvent = "ProgressEvent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressEventDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ProgressEvent.self, forKey: .progressEvent)
        progressEvent = progressEventDecoded
    }
}

extension ClientTokenConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClientTokenConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified client token has already been used in another resource request. It's best practice for client tokens to be unique for each resource operation request. However, client token expire after 36 hours.
public struct ClientTokenConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientTokenConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientTokenConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is currently being modified by another operation.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another resource operation is currently being performed on this resource.
public struct ConcurrentOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceInput(clientToken: \(Swift.String(describing: clientToken)), roleArn: \(Swift.String(describing: roleArn)), typeName: \(Swift.String(describing: typeName)), typeVersionId: \(Swift.String(describing: typeVersionId)), desiredState: \"CONTENT_REDACTED\")"}
}

extension CreateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case desiredState = "DesiredState"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState, forKey: .desiredState)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeVersionId = self.typeVersionId {
            try encodeContainer.encode(typeVersionId, forKey: .typeVersionId)
        }
    }
}

extension CreateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResourceInput: Swift.Equatable {
    /// A unique identifier to ensure the idempotency of the resource request. As a best practice, specify this token to ensure idempotency, so that Amazon Web Services Cloud Control API can accurately distinguish between request retries and new resource requests. You might retry a resource request to ensure that it was successfully received. A client token is valid for 36 hours once used. After that, a resource request with the same client token is treated as a new request. If you do not specify a client token, one is generated for inclusion in the request. For more information, see [Ensuring resource operation requests are unique](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-idempotency) in the Amazon Web Services Cloud Control API User Guide.
    public var clientToken: Swift.String?
    /// Structured data format representing the desired state of the resource, consisting of that resource's properties and their desired values. Cloud Control API currently supports JSON as a structured data format. Specify the desired state as one of the following:
    ///
    /// * A JSON blob
    ///
    /// * A local path containing the desired state in JSON data format
    ///
    ///
    /// For more information, see [Composing the desired state of the resource](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations-create.html#resource-operations-create-desiredstate) in the Amazon Web Services Cloud Control API User Guide. For more information about the properties of a specific resource, refer to the related topic for the resource in the [Resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation Users Guide.
    /// This member is required.
    public var desiredState: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role for Cloud Control API to use when performing this resource operation. The role specified must have the permissions required for this operation. The necessary permissions for each event handler are defined in the [handlers](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html#schema-properties-handlers) section of the [resource type definition schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html). If you do not specify a role, Cloud Control API uses a temporary session created using your Amazon Web Services user credentials. For more information, see [Specifying credentials](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-permissions) in the Amazon Web Services Cloud Control API User Guide.
    public var roleArn: Swift.String?
    /// The name of the resource type.
    /// This member is required.
    public var typeName: Swift.String?
    /// For private resource types, the type version to use in this resource operation. If you do not specify a resource version, CloudFormation uses the default version.
    public var typeVersionId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        desiredState: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeVersionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.desiredState = desiredState
        self.roleArn = roleArn
        self.typeName = typeName
        self.typeVersionId = typeVersionId
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let typeVersionId: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let desiredState: Swift.String?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case desiredState = "DesiredState"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeVersionId)
        typeVersionId = typeVersionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let desiredStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
    }
}

extension CreateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientTokenConflictException" : self = .clientTokenConflictException(try ClientTokenConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentOperationException" : self = .concurrentOperationException(try ConcurrentOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GeneralServiceException" : self = .generalServiceException(try GeneralServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerFailureException" : self = .handlerFailureException(try HandlerFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerInternalFailureException" : self = .handlerInternalFailureException(try HandlerInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCredentialsException" : self = .invalidCredentialsException(try InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkFailureException" : self = .networkFailureException(try NetworkFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotStabilizedException" : self = .notStabilizedException(try NotStabilizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotUpdatableException" : self = .notUpdatableException(try NotUpdatableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PrivateTypeException" : self = .privateTypeException(try PrivateTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalErrorException" : self = .serviceInternalErrorException(try ServiceInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedActionException" : self = .unsupportedActionException(try UnsupportedActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case clientTokenConflictException(ClientTokenConflictException)
    case concurrentOperationException(ConcurrentOperationException)
    case generalServiceException(GeneralServiceException)
    case handlerFailureException(HandlerFailureException)
    case handlerInternalFailureException(HandlerInternalFailureException)
    case invalidCredentialsException(InvalidCredentialsException)
    case invalidRequestException(InvalidRequestException)
    case networkFailureException(NetworkFailureException)
    case notStabilizedException(NotStabilizedException)
    case notUpdatableException(NotUpdatableException)
    case privateTypeException(PrivateTypeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceInternalErrorException(ServiceInternalErrorException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case typeNotFoundException(TypeNotFoundException)
    case unsupportedActionException(UnsupportedActionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.progressEvent = output.progressEvent
        } else {
            self.progressEvent = nil
        }
    }
}

public struct CreateResourceOutputResponse: Swift.Equatable {
    /// Represents the current status of the resource creation request. After you have initiated a resource creation request, you can monitor the progress of your request by calling [GetResourceRequestStatus](https://docs.aws.amazon.com/cloudcontrolapi/latest/APIReference/API_GetResourceRequestStatus.html) using the RequestToken of the ProgressEvent returned by CreateResource.
    public var progressEvent: CloudControlClientTypes.ProgressEvent?

    public init (
        progressEvent: CloudControlClientTypes.ProgressEvent? = nil
    )
    {
        self.progressEvent = progressEvent
    }
}

struct CreateResourceOutputResponseBody: Swift.Equatable {
    let progressEvent: CloudControlClientTypes.ProgressEvent?
}

extension CreateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressEvent = "ProgressEvent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressEventDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ProgressEvent.self, forKey: .progressEvent)
        progressEvent = progressEventDecoded
    }
}

extension DeleteResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case identifier = "Identifier"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeVersionId = self.typeVersionId {
            try encodeContainer.encode(typeVersionId, forKey: .typeVersionId)
        }
    }
}

extension DeleteResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceInput: Swift.Equatable {
    /// A unique identifier to ensure the idempotency of the resource request. As a best practice, specify this token to ensure idempotency, so that Amazon Web Services Cloud Control API can accurately distinguish between request retries and new resource requests. You might retry a resource request to ensure that it was successfully received. A client token is valid for 36 hours once used. After that, a resource request with the same client token is treated as a new request. If you do not specify a client token, one is generated for inclusion in the request. For more information, see [Ensuring resource operation requests are unique](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-idempotency) in the Amazon Web Services Cloud Control API User Guide.
    public var clientToken: Swift.String?
    /// The identifier for the resource. You can specify the primary identifier, or any secondary identifier defined for the resource type in its resource schema. You can only specify one identifier. Primary identifiers can be specified as a string or JSON; secondary identifiers must be specified as JSON. For compound primary identifiers (that is, one that consists of multiple resource properties strung together), to specify the primary identifier as a string, list the property values in the order they are specified in the primary identifier definition, separated by |. For more information, see [Identifying resources](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-identifier.html) in the Amazon Web Services Cloud Control API User Guide.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role for Cloud Control API to use when performing this resource operation. The role specified must have the permissions required for this operation. The necessary permissions for each event handler are defined in the [handlers](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html#schema-properties-handlers) section of the [resource type definition schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html). If you do not specify a role, Cloud Control API uses a temporary session created using your Amazon Web Services user credentials. For more information, see [Specifying credentials](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-permissions) in the Amazon Web Services Cloud Control API User Guide.
    public var roleArn: Swift.String?
    /// The name of the resource type.
    /// This member is required.
    public var typeName: Swift.String?
    /// For private resource types, the type version to use in this resource operation. If you do not specify a resource version, CloudFormation uses the default version.
    public var typeVersionId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeVersionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identifier = identifier
        self.roleArn = roleArn
        self.typeName = typeName
        self.typeVersionId = typeVersionId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let typeVersionId: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let identifier: Swift.String?
}

extension DeleteResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case identifier = "Identifier"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeVersionId)
        typeVersionId = typeVersionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientTokenConflictException" : self = .clientTokenConflictException(try ClientTokenConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentOperationException" : self = .concurrentOperationException(try ConcurrentOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GeneralServiceException" : self = .generalServiceException(try GeneralServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerFailureException" : self = .handlerFailureException(try HandlerFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerInternalFailureException" : self = .handlerInternalFailureException(try HandlerInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCredentialsException" : self = .invalidCredentialsException(try InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkFailureException" : self = .networkFailureException(try NetworkFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotStabilizedException" : self = .notStabilizedException(try NotStabilizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotUpdatableException" : self = .notUpdatableException(try NotUpdatableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PrivateTypeException" : self = .privateTypeException(try PrivateTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalErrorException" : self = .serviceInternalErrorException(try ServiceInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedActionException" : self = .unsupportedActionException(try UnsupportedActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case clientTokenConflictException(ClientTokenConflictException)
    case concurrentOperationException(ConcurrentOperationException)
    case generalServiceException(GeneralServiceException)
    case handlerFailureException(HandlerFailureException)
    case handlerInternalFailureException(HandlerInternalFailureException)
    case invalidCredentialsException(InvalidCredentialsException)
    case invalidRequestException(InvalidRequestException)
    case networkFailureException(NetworkFailureException)
    case notStabilizedException(NotStabilizedException)
    case notUpdatableException(NotUpdatableException)
    case privateTypeException(PrivateTypeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceInternalErrorException(ServiceInternalErrorException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case typeNotFoundException(TypeNotFoundException)
    case unsupportedActionException(UnsupportedActionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.progressEvent = output.progressEvent
        } else {
            self.progressEvent = nil
        }
    }
}

public struct DeleteResourceOutputResponse: Swift.Equatable {
    /// Represents the current status of the resource deletion request. After you have initiated a resource deletion request, you can monitor the progress of your request by calling [GetResourceRequestStatus](https://docs.aws.amazon.com/cloudcontrolapi/latest/APIReference/API_GetResourceRequestStatus.html) using the RequestToken of the ProgressEvent returned by DeleteResource.
    public var progressEvent: CloudControlClientTypes.ProgressEvent?

    public init (
        progressEvent: CloudControlClientTypes.ProgressEvent? = nil
    )
    {
        self.progressEvent = progressEvent
    }
}

struct DeleteResourceOutputResponseBody: Swift.Equatable {
    let progressEvent: CloudControlClientTypes.ProgressEvent?
}

extension DeleteResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressEvent = "ProgressEvent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressEventDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ProgressEvent.self, forKey: .progressEvent)
        progressEvent = progressEventDecoded
    }
}

extension GeneralServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GeneralServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that the downstream service generated an error that doesn't map to any other handler error code.
public struct GeneralServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GeneralServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GeneralServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeVersionId = self.typeVersionId {
            try encodeContainer.encode(typeVersionId, forKey: .typeVersionId)
        }
    }
}

extension GetResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceInput: Swift.Equatable {
    /// The identifier for the resource. You can specify the primary identifier, or any secondary identifier defined for the resource type in its resource schema. You can only specify one identifier. Primary identifiers can be specified as a string or JSON; secondary identifiers must be specified as JSON. For compound primary identifiers (that is, one that consists of multiple resource properties strung together), to specify the primary identifier as a string, list the property values in the order they are specified in the primary identifier definition, separated by |. For more information, see [Identifying resources](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-identifier.html) in the Amazon Web Services Cloud Control API User Guide.
    /// This member is required.
    public var identifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role for Cloud Control API to use when performing this resource operation. The role specified must have the permissions required for this operation. The necessary permissions for each event handler are defined in the [handlers](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html#schema-properties-handlers) section of the [resource type definition schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html). If you do not specify a role, Cloud Control API uses a temporary session created using your Amazon Web Services user credentials. For more information, see [Specifying credentials](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-permissions) in the Amazon Web Services Cloud Control API User Guide.
    public var roleArn: Swift.String?
    /// The name of the resource type.
    /// This member is required.
    public var typeName: Swift.String?
    /// For private resource types, the type version to use in this resource operation. If you do not specify a resource version, CloudFormation uses the default version.
    public var typeVersionId: Swift.String?

    public init (
        identifier: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeVersionId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.roleArn = roleArn
        self.typeName = typeName
        self.typeVersionId = typeVersionId
    }
}

struct GetResourceInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let typeVersionId: Swift.String?
    let roleArn: Swift.String?
    let identifier: Swift.String?
}

extension GetResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeVersionId)
        typeVersionId = typeVersionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GeneralServiceException" : self = .generalServiceException(try GeneralServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerFailureException" : self = .handlerFailureException(try HandlerFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerInternalFailureException" : self = .handlerInternalFailureException(try HandlerInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCredentialsException" : self = .invalidCredentialsException(try InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkFailureException" : self = .networkFailureException(try NetworkFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotStabilizedException" : self = .notStabilizedException(try NotStabilizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotUpdatableException" : self = .notUpdatableException(try NotUpdatableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PrivateTypeException" : self = .privateTypeException(try PrivateTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalErrorException" : self = .serviceInternalErrorException(try ServiceInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedActionException" : self = .unsupportedActionException(try UnsupportedActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case generalServiceException(GeneralServiceException)
    case handlerFailureException(HandlerFailureException)
    case handlerInternalFailureException(HandlerInternalFailureException)
    case invalidCredentialsException(InvalidCredentialsException)
    case invalidRequestException(InvalidRequestException)
    case networkFailureException(NetworkFailureException)
    case notStabilizedException(NotStabilizedException)
    case notUpdatableException(NotUpdatableException)
    case privateTypeException(PrivateTypeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceInternalErrorException(ServiceInternalErrorException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case typeNotFoundException(TypeNotFoundException)
    case unsupportedActionException(UnsupportedActionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceDescription = output.resourceDescription
            self.typeName = output.typeName
        } else {
            self.resourceDescription = nil
            self.typeName = nil
        }
    }
}

public struct GetResourceOutputResponse: Swift.Equatable {
    /// Represents information about a provisioned resource.
    public var resourceDescription: CloudControlClientTypes.ResourceDescription?
    /// The name of the resource type.
    public var typeName: Swift.String?

    public init (
        resourceDescription: CloudControlClientTypes.ResourceDescription? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.resourceDescription = resourceDescription
        self.typeName = typeName
    }
}

struct GetResourceOutputResponseBody: Swift.Equatable {
    let typeName: Swift.String?
    let resourceDescription: CloudControlClientTypes.ResourceDescription?
}

extension GetResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceDescription = "ResourceDescription"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let resourceDescriptionDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ResourceDescription.self, forKey: .resourceDescription)
        resourceDescription = resourceDescriptionDecoded
    }
}

extension GetResourceRequestStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestToken = "RequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestToken = self.requestToken {
            try encodeContainer.encode(requestToken, forKey: .requestToken)
        }
    }
}

extension GetResourceRequestStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceRequestStatusInput: Swift.Equatable {
    /// A unique token used to track the progress of the resource operation request. Request tokens are included in the ProgressEvent type returned by a resource operation request.
    /// This member is required.
    public var requestToken: Swift.String?

    public init (
        requestToken: Swift.String? = nil
    )
    {
        self.requestToken = requestToken
    }
}

struct GetResourceRequestStatusInputBody: Swift.Equatable {
    let requestToken: Swift.String?
}

extension GetResourceRequestStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestToken = "RequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestToken)
        requestToken = requestTokenDecoded
    }
}

extension GetResourceRequestStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceRequestStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RequestTokenNotFoundException" : self = .requestTokenNotFoundException(try RequestTokenNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceRequestStatusOutputError: Swift.Error, Swift.Equatable {
    case requestTokenNotFoundException(RequestTokenNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceRequestStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceRequestStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.progressEvent = output.progressEvent
        } else {
            self.progressEvent = nil
        }
    }
}

public struct GetResourceRequestStatusOutputResponse: Swift.Equatable {
    /// Represents the current status of the resource operation request.
    public var progressEvent: CloudControlClientTypes.ProgressEvent?

    public init (
        progressEvent: CloudControlClientTypes.ProgressEvent? = nil
    )
    {
        self.progressEvent = progressEvent
    }
}

struct GetResourceRequestStatusOutputResponseBody: Swift.Equatable {
    let progressEvent: CloudControlClientTypes.ProgressEvent?
}

extension GetResourceRequestStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressEvent = "ProgressEvent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressEventDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ProgressEvent.self, forKey: .progressEvent)
        progressEvent = progressEventDecoded
    }
}

extension CloudControlClientTypes {
    public enum HandlerErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case alreadyExists
        case generalServiceException
        case internalFailure
        case invalidCredentials
        case invalidRequest
        case networkFailure
        case notFound
        case notStabilized
        case notUpdatable
        case resourceConflict
        case serviceInternalError
        case serviceLimitExceeded
        case serviceTimeout
        case throttling
        case sdkUnknown(Swift.String)

        public static var allCases: [HandlerErrorCode] {
            return [
                .accessDenied,
                .alreadyExists,
                .generalServiceException,
                .internalFailure,
                .invalidCredentials,
                .invalidRequest,
                .networkFailure,
                .notFound,
                .notStabilized,
                .notUpdatable,
                .resourceConflict,
                .serviceInternalError,
                .serviceLimitExceeded,
                .serviceTimeout,
                .throttling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "AccessDenied"
            case .alreadyExists: return "AlreadyExists"
            case .generalServiceException: return "GeneralServiceException"
            case .internalFailure: return "InternalFailure"
            case .invalidCredentials: return "InvalidCredentials"
            case .invalidRequest: return "InvalidRequest"
            case .networkFailure: return "NetworkFailure"
            case .notFound: return "NotFound"
            case .notStabilized: return "NotStabilized"
            case .notUpdatable: return "NotUpdatable"
            case .resourceConflict: return "ResourceConflict"
            case .serviceInternalError: return "ServiceInternalError"
            case .serviceLimitExceeded: return "ServiceLimitExceeded"
            case .serviceTimeout: return "ServiceTimeout"
            case .throttling: return "Throttling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HandlerErrorCode(rawValue: rawValue) ?? HandlerErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension HandlerFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: HandlerFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has failed without a returning a more specific error code. This can include timeouts.
public struct HandlerFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HandlerFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HandlerFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HandlerInternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: HandlerInternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that an unexpected error occurred within the resource handler.
public struct HandlerInternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HandlerInternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HandlerInternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCredentialsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCredentialsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that the credentials provided by the user are invalid.
public struct InvalidCredentialsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCredentialsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCredentialsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that invalid input from the user has generated a generic exception.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListResourceRequestsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceRequestStatusFilter = "ResourceRequestStatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceRequestStatusFilter = self.resourceRequestStatusFilter {
            try encodeContainer.encode(resourceRequestStatusFilter, forKey: .resourceRequestStatusFilter)
        }
    }
}

extension ListResourceRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceRequestsInput: Swift.Equatable {
    /// The maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The filter criteria to apply to the requests returned.
    public var resourceRequestStatusFilter: CloudControlClientTypes.ResourceRequestStatusFilter?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceRequestStatusFilter: CloudControlClientTypes.ResourceRequestStatusFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceRequestStatusFilter = resourceRequestStatusFilter
    }
}

struct ListResourceRequestsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let resourceRequestStatusFilter: CloudControlClientTypes.ResourceRequestStatusFilter?
}

extension ListResourceRequestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceRequestStatusFilter = "ResourceRequestStatusFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceRequestStatusFilterDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ResourceRequestStatusFilter.self, forKey: .resourceRequestStatusFilter)
        resourceRequestStatusFilter = resourceRequestStatusFilterDecoded
    }
}

extension ListResourceRequestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceRequestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceRequestsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceRequestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceRequestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceRequestStatusSummaries = output.resourceRequestStatusSummaries
        } else {
            self.nextToken = nil
            self.resourceRequestStatusSummaries = nil
        }
    }
}

public struct ListResourceRequestsOutputResponse: Swift.Equatable {
    /// If the request doesn't return all of the remaining results, NextToken is set to a token. To retrieve the next set of results, call ListResources again and assign that token to the request object's NextToken parameter. If the request returns all results, NextToken is set to null.
    public var nextToken: Swift.String?
    /// The requests that match the specified filter criteria.
    public var resourceRequestStatusSummaries: [CloudControlClientTypes.ProgressEvent]?

    public init (
        nextToken: Swift.String? = nil,
        resourceRequestStatusSummaries: [CloudControlClientTypes.ProgressEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceRequestStatusSummaries = resourceRequestStatusSummaries
    }
}

struct ListResourceRequestsOutputResponseBody: Swift.Equatable {
    let resourceRequestStatusSummaries: [CloudControlClientTypes.ProgressEvent]?
    let nextToken: Swift.String?
}

extension ListResourceRequestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceRequestStatusSummaries = "ResourceRequestStatusSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceRequestStatusSummariesContainer = try containerValues.decodeIfPresent([CloudControlClientTypes.ProgressEvent?].self, forKey: .resourceRequestStatusSummaries)
        var resourceRequestStatusSummariesDecoded0:[CloudControlClientTypes.ProgressEvent]? = nil
        if let resourceRequestStatusSummariesContainer = resourceRequestStatusSummariesContainer {
            resourceRequestStatusSummariesDecoded0 = [CloudControlClientTypes.ProgressEvent]()
            for structure0 in resourceRequestStatusSummariesContainer {
                if let structure0 = structure0 {
                    resourceRequestStatusSummariesDecoded0?.append(structure0)
                }
            }
        }
        resourceRequestStatusSummaries = resourceRequestStatusSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), roleArn: \(Swift.String(describing: roleArn)), typeName: \(Swift.String(describing: typeName)), typeVersionId: \(Swift.String(describing: typeVersionId)), resourceModel: \"CONTENT_REDACTED\")"}
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceModel = "ResourceModel"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceModel = self.resourceModel {
            try encodeContainer.encode(resourceModel, forKey: .resourceModel)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeVersionId = self.typeVersionId {
            try encodeContainer.encode(typeVersionId, forKey: .typeVersionId)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// Reserved.
    public var maxResults: Swift.Int?
    /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// The resource model to use to select the resources to return.
    public var resourceModel: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role for Cloud Control API to use when performing this resource operation. The role specified must have the permissions required for this operation. The necessary permissions for each event handler are defined in the [handlers](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html#schema-properties-handlers) section of the [resource type definition schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html). If you do not specify a role, Cloud Control API uses a temporary session created using your Amazon Web Services user credentials. For more information, see [Specifying credentials](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-permissions) in the Amazon Web Services Cloud Control API User Guide.
    public var roleArn: Swift.String?
    /// The name of the resource type.
    /// This member is required.
    public var typeName: Swift.String?
    /// For private resource types, the type version to use in this resource operation. If you do not specify a resource version, CloudFormation uses the default version.
    public var typeVersionId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceModel: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeVersionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceModel = resourceModel
        self.roleArn = roleArn
        self.typeName = typeName
        self.typeVersionId = typeVersionId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let typeVersionId: Swift.String?
    let roleArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceModel: Swift.String?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceModel = "ResourceModel"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeVersionId)
        typeVersionId = typeVersionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceModel)
        resourceModel = resourceModelDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GeneralServiceException" : self = .generalServiceException(try GeneralServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerFailureException" : self = .handlerFailureException(try HandlerFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerInternalFailureException" : self = .handlerInternalFailureException(try HandlerInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCredentialsException" : self = .invalidCredentialsException(try InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkFailureException" : self = .networkFailureException(try NetworkFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotStabilizedException" : self = .notStabilizedException(try NotStabilizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotUpdatableException" : self = .notUpdatableException(try NotUpdatableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PrivateTypeException" : self = .privateTypeException(try PrivateTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalErrorException" : self = .serviceInternalErrorException(try ServiceInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedActionException" : self = .unsupportedActionException(try UnsupportedActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case generalServiceException(GeneralServiceException)
    case handlerFailureException(HandlerFailureException)
    case handlerInternalFailureException(HandlerInternalFailureException)
    case invalidCredentialsException(InvalidCredentialsException)
    case invalidRequestException(InvalidRequestException)
    case networkFailureException(NetworkFailureException)
    case notStabilizedException(NotStabilizedException)
    case notUpdatableException(NotUpdatableException)
    case privateTypeException(PrivateTypeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceInternalErrorException(ServiceInternalErrorException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case typeNotFoundException(TypeNotFoundException)
    case unsupportedActionException(UnsupportedActionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceDescriptions = output.resourceDescriptions
            self.typeName = output.typeName
        } else {
            self.nextToken = nil
            self.resourceDescriptions = nil
            self.typeName = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// If the request doesn't return all of the remaining results, NextToken is set to a token. To retrieve the next set of results, call ListResources again and assign that token to the request object's NextToken parameter. If the request returns all results, NextToken is set to null.
    public var nextToken: Swift.String?
    /// Information about the specified resources, including primary identifier and resource model.
    public var resourceDescriptions: [CloudControlClientTypes.ResourceDescription]?
    /// The name of the resource type.
    public var typeName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceDescriptions: [CloudControlClientTypes.ResourceDescription]? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceDescriptions = resourceDescriptions
        self.typeName = typeName
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    let typeName: Swift.String?
    let resourceDescriptions: [CloudControlClientTypes.ResourceDescription]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceDescriptions = "ResourceDescriptions"
        case typeName = "TypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let resourceDescriptionsContainer = try containerValues.decodeIfPresent([CloudControlClientTypes.ResourceDescription?].self, forKey: .resourceDescriptions)
        var resourceDescriptionsDecoded0:[CloudControlClientTypes.ResourceDescription]? = nil
        if let resourceDescriptionsContainer = resourceDescriptionsContainer {
            resourceDescriptionsDecoded0 = [CloudControlClientTypes.ResourceDescription]()
            for structure0 in resourceDescriptionsContainer {
                if let structure0 = structure0 {
                    resourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        resourceDescriptions = resourceDescriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NetworkFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NetworkFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that the request couldn't be completed due to networking issues, such as a failure to receive a response from the server.
public struct NetworkFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NetworkFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NetworkFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotStabilizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotStabilizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that the downstream resource failed to complete all of its ready-state checks.
public struct NotStabilizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotStabilizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotStabilizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotUpdatableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotUpdatableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more properties included in this resource operation are defined as create-only, and therefore can't be updated.
public struct NotUpdatableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotUpdatableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotUpdatableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudControlClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension CloudControlClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelComplete
        case cancelInProgress
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .cancelComplete,
                .cancelInProgress,
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelComplete: return "CANCEL_COMPLETE"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension PrivateTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PrivateTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cloud Control API hasn't received a valid response from the resource handler, due to a configuration error. This includes issues such as the resource handler returning an invalid response, or timing out.
public struct PrivateTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PrivateTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PrivateTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudControlClientTypes.ProgressEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case eventTime = "EventTime"
        case identifier = "Identifier"
        case operation = "Operation"
        case operationStatus = "OperationStatus"
        case requestToken = "RequestToken"
        case resourceModel = "ResourceModel"
        case retryAfter = "RetryAfter"
        case statusMessage = "StatusMessage"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let operationStatus = self.operationStatus {
            try encodeContainer.encode(operationStatus.rawValue, forKey: .operationStatus)
        }
        if let requestToken = self.requestToken {
            try encodeContainer.encode(requestToken, forKey: .requestToken)
        }
        if let resourceModel = self.resourceModel {
            try encodeContainer.encode(resourceModel, forKey: .resourceModel)
        }
        if let retryAfter = self.retryAfter {
            try encodeContainer.encodeTimestamp(retryAfter, format: .epochSeconds, forKey: .retryAfter)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let requestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestToken)
        requestToken = requestTokenDecoded
        let operationDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
        let operationStatusDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.OperationStatus.self, forKey: .operationStatus)
        operationStatus = operationStatusDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let resourceModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceModel)
        resourceModel = resourceModelDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.HandlerErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let retryAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retryAfter)
        retryAfter = retryAfterDecoded
    }
}

extension CloudControlClientTypes.ProgressEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProgressEvent(errorCode: \(Swift.String(describing: errorCode)), eventTime: \(Swift.String(describing: eventTime)), identifier: \(Swift.String(describing: identifier)), operation: \(Swift.String(describing: operation)), operationStatus: \(Swift.String(describing: operationStatus)), requestToken: \(Swift.String(describing: requestToken)), retryAfter: \(Swift.String(describing: retryAfter)), statusMessage: \(Swift.String(describing: statusMessage)), typeName: \(Swift.String(describing: typeName)), resourceModel: \"CONTENT_REDACTED\")"}
}

extension CloudControlClientTypes {
    /// Represents the current status of a resource operation request. For more information, see [Managing resource operation requests](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations-manage-requests.html) in the Amazon Web Services Cloud Control API User Guide.
    public struct ProgressEvent: Swift.Equatable {
        /// For requests with a status of FAILED, the associated error code. For error code definitions, see [Handler error codes](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-test-contract-errors.html) in the CloudFormation Command Line Interface User Guide for Extension Development.
        public var errorCode: CloudControlClientTypes.HandlerErrorCode?
        /// When the resource operation request was initiated.
        public var eventTime: ClientRuntime.Date?
        /// The primary identifier for the resource. In some cases, the resource identifier may be available before the resource operation has reached a status of SUCCESS.
        public var identifier: Swift.String?
        /// The resource operation type.
        public var operation: CloudControlClientTypes.Operation?
        /// The current status of the resource operation request.
        ///
        /// * PENDING: The resource operation hasn't yet started.
        ///
        /// * IN_PROGRESS: The resource operation is currently in progress.
        ///
        /// * SUCCESS: The resource operation has successfully completed.
        ///
        /// * FAILED: The resource operation has failed. Refer to the error code and status message for more information.
        ///
        /// * CANCEL_IN_PROGRESS: The resource operation is in the process of being canceled.
        ///
        /// * CANCEL_COMPLETE: The resource operation has been canceled.
        public var operationStatus: CloudControlClientTypes.OperationStatus?
        /// The unique token representing this resource operation request. Use the RequestToken with [GetResourceRequestStatus](https://docs.aws.amazon.com/cloudcontrolapi/latest/APIReference/API_GetResourceRequestStatus.html) to return the current status of a resource operation request.
        public var requestToken: Swift.String?
        /// A JSON string containing the resource model, consisting of each resource property and its current value.
        public var resourceModel: Swift.String?
        /// When to next request the status of this resource operation request.
        public var retryAfter: ClientRuntime.Date?
        /// Any message explaining the current status.
        public var statusMessage: Swift.String?
        /// The name of the resource type used in the operation.
        public var typeName: Swift.String?

        public init (
            errorCode: CloudControlClientTypes.HandlerErrorCode? = nil,
            eventTime: ClientRuntime.Date? = nil,
            identifier: Swift.String? = nil,
            operation: CloudControlClientTypes.Operation? = nil,
            operationStatus: CloudControlClientTypes.OperationStatus? = nil,
            requestToken: Swift.String? = nil,
            resourceModel: Swift.String? = nil,
            retryAfter: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.identifier = identifier
            self.operation = operation
            self.operationStatus = operationStatus
            self.requestToken = requestToken
            self.resourceModel = resourceModel
            self.retryAfter = retryAfter
            self.statusMessage = statusMessage
            self.typeName = typeName
        }
    }

}

extension RequestTokenNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestTokenNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource operation with the specified request token can't be found.
public struct RequestTokenNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestTokenNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTokenNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is temporarily unavailable to be acted upon. For example, if the resource is currently undergoing an operation and can't be acted upon until that operation is finished.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudControlClientTypes.ResourceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case properties = "Properties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CloudControlClientTypes.ResourceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDescription(identifier: \(Swift.String(describing: identifier)), properties: \"CONTENT_REDACTED\")"}
}

extension CloudControlClientTypes {
    /// Represents information about a provisioned resource.
    public struct ResourceDescription: Swift.Equatable {
        /// The primary identifier for the resource. For more information, see [Identifying resources](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-identifier.html) in the Amazon Web Services Cloud Control API User Guide.
        public var identifier: Swift.String?
        /// A list of the resource properties and their current values.
        public var properties: Swift.String?

        public init (
            identifier: Swift.String? = nil,
            properties: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.properties = properties
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource with the specified identifier can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudControlClientTypes.ResourceRequestStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationStatuses = "OperationStatuses"
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationStatuses = operationStatuses {
            var operationStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationStatuses)
            for operationstatus0 in operationStatuses {
                try operationStatusesContainer.encode(operationstatus0.rawValue)
            }
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for operation0 in operations {
                try operationsContainer.encode(operation0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([CloudControlClientTypes.Operation?].self, forKey: .operations)
        var operationsDecoded0:[CloudControlClientTypes.Operation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [CloudControlClientTypes.Operation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let operationStatusesContainer = try containerValues.decodeIfPresent([CloudControlClientTypes.OperationStatus?].self, forKey: .operationStatuses)
        var operationStatusesDecoded0:[CloudControlClientTypes.OperationStatus]? = nil
        if let operationStatusesContainer = operationStatusesContainer {
            operationStatusesDecoded0 = [CloudControlClientTypes.OperationStatus]()
            for string0 in operationStatusesContainer {
                if let string0 = string0 {
                    operationStatusesDecoded0?.append(string0)
                }
            }
        }
        operationStatuses = operationStatusesDecoded0
    }
}

extension CloudControlClientTypes {
    /// The filter criteria to use in determining the requests returned.
    public struct ResourceRequestStatusFilter: Swift.Equatable {
        /// The operation statuses to include in the filter.
        ///
        /// * PENDING: The operation has been requested, but not yet initiated.
        ///
        /// * IN_PROGRESS: The operation is in progress.
        ///
        /// * SUCCESS: The operation completed.
        ///
        /// * FAILED: The operation failed.
        ///
        /// * CANCEL_IN_PROGRESS: The operation is in the process of being canceled.
        ///
        /// * CANCEL_COMPLETE: The operation has been canceled.
        public var operationStatuses: [CloudControlClientTypes.OperationStatus]?
        /// The operation types to include in the filter.
        public var operations: [CloudControlClientTypes.Operation]?

        public init (
            operationStatuses: [CloudControlClientTypes.OperationStatus]? = nil,
            operations: [CloudControlClientTypes.Operation]? = nil
        )
        {
            self.operationStatuses = operationStatuses
            self.operations = operations
        }
    }

}

extension ServiceInternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceInternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that the downstream service returned an internal error, typically with a 5XX HTTP status code.
public struct ServiceInternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceInternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceInternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource handler has returned that a non-transient resource limit was reached on the service side.
public struct ServiceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TypeNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TypeNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified extension doesn't exist in the CloudFormation registry.
public struct TypeNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TypeNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TypeNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedActionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedActionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource doesn't support this resource operation.
public struct UnsupportedActionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedActionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedActionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceInput(clientToken: \(Swift.String(describing: clientToken)), identifier: \(Swift.String(describing: identifier)), roleArn: \(Swift.String(describing: roleArn)), typeName: \(Swift.String(describing: typeName)), typeVersionId: \(Swift.String(describing: typeVersionId)), patchDocument: \"CONTENT_REDACTED\")"}
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case identifier = "Identifier"
        case patchDocument = "PatchDocument"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let patchDocument = self.patchDocument {
            try encodeContainer.encode(patchDocument, forKey: .patchDocument)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let typeVersionId = self.typeVersionId {
            try encodeContainer.encode(typeVersionId, forKey: .typeVersionId)
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResourceInput: Swift.Equatable {
    /// A unique identifier to ensure the idempotency of the resource request. As a best practice, specify this token to ensure idempotency, so that Amazon Web Services Cloud Control API can accurately distinguish between request retries and new resource requests. You might retry a resource request to ensure that it was successfully received. A client token is valid for 36 hours once used. After that, a resource request with the same client token is treated as a new request. If you do not specify a client token, one is generated for inclusion in the request. For more information, see [Ensuring resource operation requests are unique](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-idempotency) in the Amazon Web Services Cloud Control API User Guide.
    public var clientToken: Swift.String?
    /// The identifier for the resource. You can specify the primary identifier, or any secondary identifier defined for the resource type in its resource schema. You can only specify one identifier. Primary identifiers can be specified as a string or JSON; secondary identifiers must be specified as JSON. For compound primary identifiers (that is, one that consists of multiple resource properties strung together), to specify the primary identifier as a string, list the property values in the order they are specified in the primary identifier definition, separated by |. For more information, see [Identifying resources](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-identifier.html) in the Amazon Web Services Cloud Control API User Guide.
    /// This member is required.
    public var identifier: Swift.String?
    /// A JavaScript Object Notation (JSON) document listing the patch operations that represent the updates to apply to the current resource properties. For details, see [Composing the patch document](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations-update.html#resource-operations-update-patch) in the Amazon Web Services Cloud Control API User Guide.
    /// This member is required.
    public var patchDocument: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role for Cloud Control API to use when performing this resource operation. The role specified must have the permissions required for this operation. The necessary permissions for each event handler are defined in the [handlers](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html#schema-properties-handlers) section of the [resource type definition schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html). If you do not specify a role, Cloud Control API uses a temporary session created using your Amazon Web Services user credentials. For more information, see [Specifying credentials](https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/resource-operations.html#resource-operations-permissions) in the Amazon Web Services Cloud Control API User Guide.
    public var roleArn: Swift.String?
    /// The name of the resource type.
    /// This member is required.
    public var typeName: Swift.String?
    /// For private resource types, the type version to use in this resource operation. If you do not specify a resource version, CloudFormation uses the default version.
    public var typeVersionId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        patchDocument: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        typeName: Swift.String? = nil,
        typeVersionId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identifier = identifier
        self.patchDocument = patchDocument
        self.roleArn = roleArn
        self.typeName = typeName
        self.typeVersionId = typeVersionId
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let typeName: Swift.String?
    let typeVersionId: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let identifier: Swift.String?
    let patchDocument: Swift.String?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case identifier = "Identifier"
        case patchDocument = "PatchDocument"
        case roleArn = "RoleArn"
        case typeName = "TypeName"
        case typeVersionId = "TypeVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let typeVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeVersionId)
        typeVersionId = typeVersionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let patchDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchDocument)
        patchDocument = patchDocumentDecoded
    }
}

extension UpdateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientTokenConflictException" : self = .clientTokenConflictException(try ClientTokenConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentOperationException" : self = .concurrentOperationException(try ConcurrentOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GeneralServiceException" : self = .generalServiceException(try GeneralServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerFailureException" : self = .handlerFailureException(try HandlerFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HandlerInternalFailureException" : self = .handlerInternalFailureException(try HandlerInternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCredentialsException" : self = .invalidCredentialsException(try InvalidCredentialsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NetworkFailureException" : self = .networkFailureException(try NetworkFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotStabilizedException" : self = .notStabilizedException(try NotStabilizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotUpdatableException" : self = .notUpdatableException(try NotUpdatableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PrivateTypeException" : self = .privateTypeException(try PrivateTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceInternalErrorException" : self = .serviceInternalErrorException(try ServiceInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TypeNotFoundException" : self = .typeNotFoundException(try TypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedActionException" : self = .unsupportedActionException(try UnsupportedActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case clientTokenConflictException(ClientTokenConflictException)
    case concurrentOperationException(ConcurrentOperationException)
    case generalServiceException(GeneralServiceException)
    case handlerFailureException(HandlerFailureException)
    case handlerInternalFailureException(HandlerInternalFailureException)
    case invalidCredentialsException(InvalidCredentialsException)
    case invalidRequestException(InvalidRequestException)
    case networkFailureException(NetworkFailureException)
    case notStabilizedException(NotStabilizedException)
    case notUpdatableException(NotUpdatableException)
    case privateTypeException(PrivateTypeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceInternalErrorException(ServiceInternalErrorException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case typeNotFoundException(TypeNotFoundException)
    case unsupportedActionException(UnsupportedActionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.progressEvent = output.progressEvent
        } else {
            self.progressEvent = nil
        }
    }
}

public struct UpdateResourceOutputResponse: Swift.Equatable {
    /// Represents the current status of the resource update request. Use the RequestToken of the ProgressEvent with [GetResourceRequestStatus](https://docs.aws.amazon.com/cloudcontrolapi/latest/APIReference/API_GetResourceRequestStatus.html) to return the current status of a resource operation request.
    public var progressEvent: CloudControlClientTypes.ProgressEvent?

    public init (
        progressEvent: CloudControlClientTypes.ProgressEvent? = nil
    )
    {
        self.progressEvent = progressEvent
    }
}

struct UpdateResourceOutputResponseBody: Swift.Equatable {
    let progressEvent: CloudControlClientTypes.ProgressEvent?
}

extension UpdateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressEvent = "ProgressEvent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressEventDecoded = try containerValues.decodeIfPresent(CloudControlClientTypes.ProgressEvent.self, forKey: .progressEvent)
        progressEvent = progressEventDecoded
    }
}
