// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DLMClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossRegionCopy = "CrossRegionCopy"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossRegionCopy = crossRegionCopy {
            var crossRegionCopyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopy)
            for crossregioncopyaction0 in crossRegionCopy {
                try crossRegionCopyContainer.encode(crossregioncopyaction0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let crossRegionCopyContainer = try containerValues.decodeIfPresent([DLMClientTypes.CrossRegionCopyAction?].self, forKey: .crossRegionCopy)
        var crossRegionCopyDecoded0:[DLMClientTypes.CrossRegionCopyAction]? = nil
        if let crossRegionCopyContainer = crossRegionCopyContainer {
            crossRegionCopyDecoded0 = [DLMClientTypes.CrossRegionCopyAction]()
            for structure0 in crossRegionCopyContainer {
                if let structure0 = structure0 {
                    crossRegionCopyDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopy = crossRegionCopyDecoded0
    }
}

extension DLMClientTypes {
    /// [Event-based policies only] Specifies an action for an event-based policy.
    public struct Action: Swift.Equatable {
        /// The rule for copying shared snapshots across Regions.
        /// This member is required.
        public var crossRegionCopy: [DLMClientTypes.CrossRegionCopyAction]?
        /// A descriptive name for the action.
        /// This member is required.
        public var name: Swift.String?

        public init(
            crossRegionCopy: [DLMClientTypes.CrossRegionCopyAction]? = nil,
            name: Swift.String? = nil
        )
        {
            self.crossRegionCopy = crossRegionCopy
            self.name = name
        }
    }

}

extension DLMClientTypes.ArchiveRetainRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionArchiveTier = "RetentionArchiveTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionArchiveTier = self.retentionArchiveTier {
            try encodeContainer.encode(retentionArchiveTier, forKey: .retentionArchiveTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionArchiveTierDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionArchiveTier.self, forKey: .retentionArchiveTier)
        retentionArchiveTier = retentionArchiveTierDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies only] Specifies information about the archive storage tier retention period.
    public struct ArchiveRetainRule: Swift.Equatable {
        /// Information about retention period in the Amazon EBS Snapshots Archive. For more information, see [Archive Amazon EBS snapshots](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/snapshot-archive.html).
        /// This member is required.
        public var retentionArchiveTier: DLMClientTypes.RetentionArchiveTier?

        public init(
            retentionArchiveTier: DLMClientTypes.RetentionArchiveTier? = nil
        )
        {
            self.retentionArchiveTier = retentionArchiveTier
        }
    }

}

extension DLMClientTypes.ArchiveRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retainRule = "RetainRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retainRule = self.retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.ArchiveRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies only] Specifies a snapshot archiving rule for a schedule.
    public struct ArchiveRule: Swift.Equatable {
        /// Information about the retention period for the snapshot archiving rule.
        /// This member is required.
        public var retainRule: DLMClientTypes.ArchiveRetainRule?

        public init(
            retainRule: DLMClientTypes.ArchiveRetainRule? = nil
        )
        {
            self.retainRule = retainRule
        }
    }

}

extension CreateLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case createInterval = "CreateInterval"
        case crossRegionCopyTargets = "CrossRegionCopyTargets"
        case defaultPolicy = "DefaultPolicy"
        case description = "Description"
        case exclusions = "Exclusions"
        case executionRoleArn = "ExecutionRoleArn"
        case extendDeletion = "ExtendDeletion"
        case policyDetails = "PolicyDetails"
        case retainInterval = "RetainInterval"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createInterval = self.createInterval {
            try encodeContainer.encode(createInterval, forKey: .createInterval)
        }
        if let crossRegionCopyTargets = crossRegionCopyTargets {
            var crossRegionCopyTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyTargets)
            for crossregioncopytarget0 in crossRegionCopyTargets {
                try crossRegionCopyTargetsContainer.encode(crossregioncopytarget0)
            }
        }
        if let defaultPolicy = self.defaultPolicy {
            try encodeContainer.encode(defaultPolicy.rawValue, forKey: .defaultPolicy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let exclusions = self.exclusions {
            try encodeContainer.encode(exclusions, forKey: .exclusions)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let extendDeletion = self.extendDeletion {
            try encodeContainer.encode(extendDeletion, forKey: .extendDeletion)
        }
        if let policyDetails = self.policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let retainInterval = self.retainInterval {
            try encodeContainer.encode(retainInterval, forKey: .retainInterval)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLifecyclePolicyInput {

    static func urlPathProvider(_ value: CreateLifecyclePolicyInput) -> Swift.String? {
        return "/policies"
    }
}

public struct CreateLifecyclePolicyInput: Swift.Equatable {
    /// [Default policies only] Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. If you do not specify a value, the default is false. Default: false
    public var copyTags: Swift.Bool?
    /// [Default policies only] Specifies how often the policy should run and create snapshots or AMIs. The creation frequency can range from 1 to 7 days. If you do not specify a value, the default is 1. Default: 1
    public var createInterval: Swift.Int?
    /// [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify up to 3 destination Regions. If you do not want to create cross-Region copies, omit this parameter.
    public var crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]?
    /// [Default policies only] Specify the type of default policy to create.
    ///
    /// * To create a default policy for EBS snapshots, that creates snapshots of all volumes in the Region that do not have recent backups, specify VOLUME.
    ///
    /// * To create a default policy for EBS-backed AMIs, that creates EBS-backed AMIs from all instances in the Region that do not have recent backups, specify INSTANCE.
    public var defaultPolicy: DLMClientTypes.DefaultPolicyTypeValues?
    /// A description of the lifecycle policy. The characters ^[0-9A-Za-z _-]+$ are supported.
    /// This member is required.
    public var description: Swift.String?
    /// [Default policies only] Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs for target resources that match any of the specified exclusion parameters.
    public var exclusions: DLMClientTypes.Exclusions?
    /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by the lifecycle policy.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the source volume or instance is deleted, or if the policy enters the error, disabled, or deleted state. By default (ExtendDeletion=false):
    ///
    /// * If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously created snapshots or AMIs, up to but not including the last one, based on the specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs, including the last one, specify true.
    ///
    /// * If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs, including the last one, if the policy enters one of these states, specify true.
    ///
    ///
    /// If you enable extended deletion (ExtendDeletion=true), you override both default behaviors simultaneously. If you do not specify a value, the default is false. Default: false
    public var extendDeletion: Swift.Bool?
    /// The configuration details of the lifecycle policy. If you create a default policy, you can specify the request parameters either in the request body, or in the PolicyDetails request structure, but not both.
    public var policyDetails: DLMClientTypes.PolicyDetails?
    /// [Default policies only] Specifies how long the policy should retain snapshots or AMIs before deleting them. The retention period can range from 2 to 14 days, but it must be greater than the creation frequency to ensure that the policy retains at least 1 snapshot or AMI at any given time. If you do not specify a value, the default is 7. Default: 7
    public var retainInterval: Swift.Int?
    /// The activation state of the lifecycle policy after creation.
    /// This member is required.
    public var state: DLMClientTypes.SettablePolicyStateValues?
    /// The tags to apply to the lifecycle policy during creation.
    public var tags: [Swift.String:Swift.String]?

    public init(
        copyTags: Swift.Bool? = nil,
        createInterval: Swift.Int? = nil,
        crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]? = nil,
        defaultPolicy: DLMClientTypes.DefaultPolicyTypeValues? = nil,
        description: Swift.String? = nil,
        exclusions: DLMClientTypes.Exclusions? = nil,
        executionRoleArn: Swift.String? = nil,
        extendDeletion: Swift.Bool? = nil,
        policyDetails: DLMClientTypes.PolicyDetails? = nil,
        retainInterval: Swift.Int? = nil,
        state: DLMClientTypes.SettablePolicyStateValues? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.copyTags = copyTags
        self.createInterval = createInterval
        self.crossRegionCopyTargets = crossRegionCopyTargets
        self.defaultPolicy = defaultPolicy
        self.description = description
        self.exclusions = exclusions
        self.executionRoleArn = executionRoleArn
        self.extendDeletion = extendDeletion
        self.policyDetails = policyDetails
        self.retainInterval = retainInterval
        self.state = state
        self.tags = tags
    }
}

struct CreateLifecyclePolicyInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let description: Swift.String?
    let state: DLMClientTypes.SettablePolicyStateValues?
    let policyDetails: DLMClientTypes.PolicyDetails?
    let tags: [Swift.String:Swift.String]?
    let defaultPolicy: DLMClientTypes.DefaultPolicyTypeValues?
    let createInterval: Swift.Int?
    let retainInterval: Swift.Int?
    let copyTags: Swift.Bool?
    let extendDeletion: Swift.Bool?
    let crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]?
    let exclusions: DLMClientTypes.Exclusions?
}

extension CreateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case createInterval = "CreateInterval"
        case crossRegionCopyTargets = "CrossRegionCopyTargets"
        case defaultPolicy = "DefaultPolicy"
        case description = "Description"
        case exclusions = "Exclusions"
        case executionRoleArn = "ExecutionRoleArn"
        case extendDeletion = "ExtendDeletion"
        case policyDetails = "PolicyDetails"
        case retainInterval = "RetainInterval"
        case state = "State"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DLMClientTypes.SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let defaultPolicyDecoded = try containerValues.decodeIfPresent(DLMClientTypes.DefaultPolicyTypeValues.self, forKey: .defaultPolicy)
        defaultPolicy = defaultPolicyDecoded
        let createIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createInterval)
        createInterval = createIntervalDecoded
        let retainIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retainInterval)
        retainInterval = retainIntervalDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let extendDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extendDeletion)
        extendDeletion = extendDeletionDecoded
        let crossRegionCopyTargetsContainer = try containerValues.decodeIfPresent([DLMClientTypes.CrossRegionCopyTarget?].self, forKey: .crossRegionCopyTargets)
        var crossRegionCopyTargetsDecoded0:[DLMClientTypes.CrossRegionCopyTarget]? = nil
        if let crossRegionCopyTargetsContainer = crossRegionCopyTargetsContainer {
            crossRegionCopyTargetsDecoded0 = [DLMClientTypes.CrossRegionCopyTarget]()
            for structure0 in crossRegionCopyTargetsContainer {
                if let structure0 = structure0 {
                    crossRegionCopyTargetsDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyTargets = crossRegionCopyTargetsDecoded0
        let exclusionsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.Exclusions.self, forKey: .exclusions)
        exclusions = exclusionsDecoded
    }
}

extension CreateLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyId = output.policyId
        } else {
            self.policyId = nil
        }
    }
}

public struct CreateLifecyclePolicyOutput: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    public var policyId: Swift.String?

    public init(
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct CreateLifecyclePolicyOutputBody: Swift.Equatable {
    let policyId: Swift.String?
}

extension CreateLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

enum CreateLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DLMClientTypes.CreateRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
        case location = "Location"
        case scripts = "Scripts"
        case times = "Times"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = self.cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
        if let location = self.location {
            try encodeContainer.encode(location.rawValue, forKey: .location)
        }
        if let scripts = scripts {
            var scriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scripts)
            for script0 in scripts {
                try scriptsContainer.encode(script0)
            }
        }
        if let times = times {
            var timesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .times)
            for time0 in times {
                try timesContainer.encode(time0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(DLMClientTypes.LocationValues.self, forKey: .location)
        location = locationDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.IntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let timesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .times)
        var timesDecoded0:[Swift.String]? = nil
        if let timesContainer = timesContainer {
            timesDecoded0 = [Swift.String]()
            for string0 in timesContainer {
                if let string0 = string0 {
                    timesDecoded0?.append(string0)
                }
            }
        }
        times = timesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let scriptsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Script?].self, forKey: .scripts)
        var scriptsDecoded0:[DLMClientTypes.Script]? = nil
        if let scriptsContainer = scriptsContainer {
            scriptsDecoded0 = [DLMClientTypes.Script]()
            for structure0 in scriptsContainer {
                if let structure0 = structure0 {
                    scriptsDecoded0?.append(structure0)
                }
            }
        }
        scripts = scriptsDecoded0
    }
}

extension DLMClientTypes {
    /// [Custom snapshot and AMI policies only] Specifies when the policy should create snapshots or AMIs.
    ///
    /// * You must specify either CronExpression, or Interval, IntervalUnit, and Times.
    ///
    /// * If you need to specify an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html) for the schedule, then you must specify a creation frequency of at least 28 days.
    public struct CreateRule: Swift.Equatable {
        /// The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year. For more information, see [Cron expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch User Guide.
        public var cronExpression: Swift.String?
        /// The interval between snapshots. The supported values are 1, 2, 3, 4, 6, 8, 12, and 24.
        public var interval: Swift.Int?
        /// The interval unit.
        public var intervalUnit: DLMClientTypes.IntervalUnitValues?
        /// [Custom snapshot policies only] Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify CLOUD. To create snapshots on the same Outpost as the source resource, specify OUTPOST_LOCAL. If you omit this parameter, CLOUD is used by default. If the policy targets resources in an Amazon Web Services Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost.
        public var location: DLMClientTypes.LocationValues?
        /// [Custom snapshot policies that target instances only] Specifies pre and/or post scripts for a snapshot lifecycle policy that targets instances. This is useful for creating application-consistent snapshots, or for performing specific administrative tasks before or after Amazon Data Lifecycle Manager initiates snapshot creation. For more information, see [Automating application-consistent snapshots with pre and post scripts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/automate-app-consistent-backups.html).
        public var scripts: [DLMClientTypes.Script]?
        /// The time, in UTC, to start the operation. The supported format is hh:mm. The operation occurs within a one-hour window following the specified time. If you do not specify a time, Amazon Data Lifecycle Manager selects a time within the next 24 hours.
        public var times: [Swift.String]?

        public init(
            cronExpression: Swift.String? = nil,
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.IntervalUnitValues? = nil,
            location: DLMClientTypes.LocationValues? = nil,
            scripts: [DLMClientTypes.Script]? = nil,
            times: [Swift.String]? = nil
        )
        {
            self.cronExpression = cronExpression
            self.interval = interval
            self.intervalUnit = intervalUnit
            self.location = location
            self.scripts = scripts
            self.times = times
        }
    }

}

extension DLMClientTypes.CrossRegionCopyAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case retainRule = "RetainRule"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let retainRule = self.retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(DLMClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
    }
}

extension DLMClientTypes {
    /// [Event-based policies only] Specifies a cross-Region copy action for event-based policies. To specify a cross-Region copy rule for snapshot and AMI policies, use [CrossRegionCopyRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_CrossRegionCopyRule.html).
    public struct CrossRegionCopyAction: Swift.Equatable {
        /// The encryption settings for the copied snapshot.
        /// This member is required.
        public var encryptionConfiguration: DLMClientTypes.EncryptionConfiguration?
        /// Specifies a retention rule for cross-Region snapshot copies created by snapshot or event-based policies, or cross-Region AMI copies created by AMI policies. After the retention period expires, the cross-Region copy is deleted.
        public var retainRule: DLMClientTypes.CrossRegionCopyRetainRule?
        /// The target Region.
        /// This member is required.
        public var target: Swift.String?

        public init(
            encryptionConfiguration: DLMClientTypes.EncryptionConfiguration? = nil,
            retainRule: DLMClientTypes.CrossRegionCopyRetainRule? = nil,
            target: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.retainRule = retainRule
            self.target = target
        }
    }

}

extension DLMClientTypes.CrossRegionCopyDeprecateRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// [Custom AMI policies only] Specifies an AMI deprecation rule for cross-Region AMI copies created by an AMI policy.
    public struct CrossRegionCopyDeprecateRule: Swift.Equatable {
        /// The period after which to deprecate the cross-Region AMI copies. The period must be less than or equal to the cross-Region AMI copy retention period, and it can't be greater than 10 years. This is equivalent to 120 months, 520 weeks, or 3650 days.
        public var interval: Swift.Int?
        /// The unit of time in which to measure the Interval. For example, to deprecate a cross-Region AMI copy after 3 months, specify Interval=3 and IntervalUnit=MONTHS.
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DLMClientTypes.CrossRegionCopyRetainRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// Specifies a retention rule for cross-Region snapshot copies created by snapshot or event-based policies, or cross-Region AMI copies created by AMI policies. After the retention period expires, the cross-Region copy is deleted.
    public struct CrossRegionCopyRetainRule: Swift.Equatable {
        /// The amount of time to retain a cross-Region snapshot or AMI copy. The maximum is 100 years. This is equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int?
        /// The unit of time for time-based retention. For example, to retain a cross-Region copy for 3 months, specify Interval=3 and IntervalUnit=MONTHS.
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DLMClientTypes.CrossRegionCopyRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkArn = "CmkArn"
        case copyTags = "CopyTags"
        case deprecateRule = "DeprecateRule"
        case encrypted = "Encrypted"
        case retainRule = "RetainRule"
        case target = "Target"
        case targetRegion = "TargetRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = self.cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let deprecateRule = self.deprecateRule {
            try encodeContainer.encode(deprecateRule, forKey: .deprecateRule)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let retainRule = self.retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetRegion = self.targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
        let deprecateRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.CrossRegionCopyDeprecateRule.self, forKey: .deprecateRule)
        deprecateRule = deprecateRuleDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot and AMI policies only] Specifies a cross-Region copy rule for a snapshot and AMI policies. To specify a cross-Region copy action for event-based polices, use [CrossRegionCopyAction](https://docs.aws.amazon.com/dlm/latest/APIReference/API_CrossRegionCopyAction.html).
    public struct CrossRegionCopyRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
        public var cmkArn: Swift.String?
        /// Indicates whether to copy all user-defined tags from the source snapshot or AMI to the cross-Region copy.
        public var copyTags: Swift.Bool?
        /// [Custom AMI policies only] The AMI deprecation rule for cross-Region AMI copies created by the rule.
        public var deprecateRule: DLMClientTypes.CrossRegionCopyDeprecateRule?
        /// To encrypt a copy of an unencrypted snapshot if encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or if encryption by default is not enabled.
        /// This member is required.
        public var encrypted: Swift.Bool?
        /// The retention rule that indicates how long the cross-Region snapshot or AMI copies are to be retained in the destination Region.
        public var retainRule: DLMClientTypes.CrossRegionCopyRetainRule?
        /// Use this parameter for snapshot policies only. For AMI policies, use TargetRegion instead. [Custom snapshot policies only] The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
        public var target: Swift.String?
        /// Use this parameter for AMI policies only. For snapshot policies, use Target instead. For snapshot policies created before the Target parameter was introduced, this parameter indicates the target Region for snapshot copies. [Custom AMI policies only] The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
        public var targetRegion: Swift.String?

        public init(
            cmkArn: Swift.String? = nil,
            copyTags: Swift.Bool? = nil,
            deprecateRule: DLMClientTypes.CrossRegionCopyDeprecateRule? = nil,
            encrypted: Swift.Bool? = nil,
            retainRule: DLMClientTypes.CrossRegionCopyRetainRule? = nil,
            target: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.cmkArn = cmkArn
            self.copyTags = copyTags
            self.deprecateRule = deprecateRule
            self.encrypted = encrypted
            self.retainRule = retainRule
            self.target = target
            self.targetRegion = targetRegion
        }
    }

}

extension DLMClientTypes.CrossRegionCopyTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetRegion = "TargetRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetRegion = self.targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
    }
}

extension DLMClientTypes {
    /// [Default policies only] Specifies a destination Region for cross-Region copy actions.
    public struct CrossRegionCopyTarget: Swift.Equatable {
        /// The target Region, for example us-east-1.
        public var targetRegion: Swift.String?

        public init(
            targetRegion: Swift.String? = nil
        )
        {
            self.targetRegion = targetRegion
        }
    }

}

public enum DLMClientTypes {}

extension DLMClientTypes {
    public enum DefaultPoliciesTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case instance
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultPoliciesTypeValues] {
            return [
                .all,
                .instance,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .instance: return "INSTANCE"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultPoliciesTypeValues(rawValue: rawValue) ?? DefaultPoliciesTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes {
    public enum DefaultPolicyTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultPolicyTypeValues] {
            return [
                .instance,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefaultPolicyTypeValues(rawValue: rawValue) ?? DefaultPolicyTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DeleteLifecyclePolicyInput {

    static func urlPathProvider(_ value: DeleteLifecyclePolicyInput) -> Swift.String? {
        guard let policyId = value.policyId else {
            return nil
        }
        return "/policies/\(policyId.urlPercentEncoding())"
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DLMClientTypes.DeprecateRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// [Custom AMI policies only] Specifies an AMI deprecation rule for AMIs created by an AMI lifecycle policy. For age-based schedules, you must specify Interval and IntervalUnit. For count-based schedules, you must specify Count.
    public struct DeprecateRule: Swift.Equatable {
        /// If the schedule has a count-based retention rule, this parameter specifies the number of oldest AMIs to deprecate. The count must be less than or equal to the schedule's retention count, and it can't be greater than 1000.
        public var count: Swift.Int?
        /// If the schedule has an age-based retention rule, this parameter specifies the period after which to deprecate AMIs created by the schedule. The period must be less than or equal to the schedule's retention period, and it can't be greater than 10 years. This is equivalent to 120 months, 520 weeks, or 3650 days.
        public var interval: Swift.Int?
        /// The unit of time in which to measure the Interval.
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            count: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DLMClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkArn = "CmkArn"
        case encrypted = "Encrypted"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = self.cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
    }
}

extension DLMClientTypes {
    /// [Event-based policies only] Specifies the encryption settings for cross-Region snapshot copies created by event-based policies.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
        public var cmkArn: Swift.String?
        /// To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled.
        /// This member is required.
        public var encrypted: Swift.Bool?

        public init(
            cmkArn: Swift.String? = nil,
            encrypted: Swift.Bool? = nil
        )
        {
            self.cmkArn = cmkArn
            self.encrypted = encrypted
        }
    }

}

extension DLMClientTypes.EventParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptionRegex = "DescriptionRegex"
        case eventType = "EventType"
        case snapshotOwner = "SnapshotOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let descriptionRegex = self.descriptionRegex {
            try encodeContainer.encode(descriptionRegex, forKey: .descriptionRegex)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let snapshotOwner = snapshotOwner {
            var snapshotOwnerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotOwner)
            for awsaccountid0 in snapshotOwner {
                try snapshotOwnerContainer.encode(awsaccountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(DLMClientTypes.EventTypeValues.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let snapshotOwnerContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .snapshotOwner)
        var snapshotOwnerDecoded0:[Swift.String]? = nil
        if let snapshotOwnerContainer = snapshotOwnerContainer {
            snapshotOwnerDecoded0 = [Swift.String]()
            for string0 in snapshotOwnerContainer {
                if let string0 = string0 {
                    snapshotOwnerDecoded0?.append(string0)
                }
            }
        }
        snapshotOwner = snapshotOwnerDecoded0
        let descriptionRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptionRegex)
        descriptionRegex = descriptionRegexDecoded
    }
}

extension DLMClientTypes {
    /// [Event-based policies only] Specifies an event that activates an event-based policy.
    public struct EventParameters: Swift.Equatable {
        /// The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account. For example, specifying ^.*Created for policy: policy-1234567890abcdef0.*$ configures the policy to run only if snapshots created by policy policy-1234567890abcdef0 are shared with your account.
        /// This member is required.
        public var descriptionRegex: Swift.String?
        /// The type of event. Currently, only snapshot sharing events are supported.
        /// This member is required.
        public var eventType: DLMClientTypes.EventTypeValues?
        /// The IDs of the Amazon Web Services accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified Amazon Web Services accounts shares a snapshot with your account.
        /// This member is required.
        public var snapshotOwner: [Swift.String]?

        public init(
            descriptionRegex: Swift.String? = nil,
            eventType: DLMClientTypes.EventTypeValues? = nil,
            snapshotOwner: [Swift.String]? = nil
        )
        {
            self.descriptionRegex = descriptionRegex
            self.eventType = eventType
            self.snapshotOwner = snapshotOwner
        }
    }

}

extension DLMClientTypes.EventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DLMClientTypes.EventSourceValues.self, forKey: .type)
        type = typeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(DLMClientTypes.EventParameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension DLMClientTypes {
    /// [Event-based policies only] Specifies an event that activates an event-based policy.
    public struct EventSource: Swift.Equatable {
        /// Information about the event.
        public var parameters: DLMClientTypes.EventParameters?
        /// The source of the event. Currently only managed CloudWatch Events rules are supported.
        /// This member is required.
        public var type: DLMClientTypes.EventSourceValues?

        public init(
            parameters: DLMClientTypes.EventParameters? = nil,
            type: DLMClientTypes.EventSourceValues? = nil
        )
        {
            self.parameters = parameters
            self.type = type
        }
    }

}

extension DLMClientTypes {
    public enum EventSourceValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case managedCwe
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceValues] {
            return [
                .managedCwe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .managedCwe: return "MANAGED_CWE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceValues(rawValue: rawValue) ?? EventSourceValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes {
    public enum EventTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shareSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTypeValues] {
            return [
                .shareSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shareSnapshot: return "shareSnapshot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventTypeValues(rawValue: rawValue) ?? EventTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.Exclusions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeBootVolumes = "ExcludeBootVolumes"
        case excludeTags = "ExcludeTags"
        case excludeVolumeTypes = "ExcludeVolumeTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeBootVolumes = self.excludeBootVolumes {
            try encodeContainer.encode(excludeBootVolumes, forKey: .excludeBootVolumes)
        }
        if let excludeTags = excludeTags {
            var excludeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeTags)
            for tag0 in excludeTags {
                try excludeTagsContainer.encode(tag0)
            }
        }
        if let excludeVolumeTypes = excludeVolumeTypes {
            var excludeVolumeTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeVolumeTypes)
            for volumetypevalues0 in excludeVolumeTypes {
                try excludeVolumeTypesContainer.encode(volumetypevalues0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludeBootVolumesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeBootVolumes)
        excludeBootVolumes = excludeBootVolumesDecoded
        let excludeVolumeTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeVolumeTypes)
        var excludeVolumeTypesDecoded0:[Swift.String]? = nil
        if let excludeVolumeTypesContainer = excludeVolumeTypesContainer {
            excludeVolumeTypesDecoded0 = [Swift.String]()
            for string0 in excludeVolumeTypesContainer {
                if let string0 = string0 {
                    excludeVolumeTypesDecoded0?.append(string0)
                }
            }
        }
        excludeVolumeTypes = excludeVolumeTypesDecoded0
        let excludeTagsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Tag?].self, forKey: .excludeTags)
        var excludeTagsDecoded0:[DLMClientTypes.Tag]? = nil
        if let excludeTagsContainer = excludeTagsContainer {
            excludeTagsDecoded0 = [DLMClientTypes.Tag]()
            for structure0 in excludeTagsContainer {
                if let structure0 = structure0 {
                    excludeTagsDecoded0?.append(structure0)
                }
            }
        }
        excludeTags = excludeTagsDecoded0
    }
}

extension DLMClientTypes {
    /// [Default policies only] Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs for target resources that match any of the specified exclusion parameters.
    public struct Exclusions: Swift.Equatable {
        /// [Default policies for EBS snapshots only] Indicates whether to exclude volumes that are attached to instances as the boot volume. If you exclude boot volumes, only volumes attached as data (non-boot) volumes will be backed up by the policy. To exclude boot volumes, specify true.
        public var excludeBootVolumes: Swift.Bool?
        /// [Default policies for EBS-backed AMIs only] Specifies whether to exclude volumes that have specific tags.
        public var excludeTags: [DLMClientTypes.Tag]?
        /// [Default policies for EBS snapshots only] Specifies the volume types to exclude. Volumes of the specified types will not be targeted by the policy.
        public var excludeVolumeTypes: [Swift.String]?

        public init(
            excludeBootVolumes: Swift.Bool? = nil,
            excludeTags: [DLMClientTypes.Tag]? = nil,
            excludeVolumeTypes: [Swift.String]? = nil
        )
        {
            self.excludeBootVolumes = excludeBootVolumes
            self.excludeTags = excludeTags
            self.excludeVolumeTypes = excludeVolumeTypes
        }
    }

}

extension DLMClientTypes {
    public enum ExecutionHandlerServiceValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsSystemsManager
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionHandlerServiceValues] {
            return [
                .awsSystemsManager,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSystemsManager: return "AWS_SYSTEMS_MANAGER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionHandlerServiceValues(rawValue: rawValue) ?? ExecutionHandlerServiceValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.FastRestoreRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies only] Specifies a rule for enabling fast snapshot restore for snapshots created by snapshot policies. You can enable fast snapshot restore based on either a count or a time interval.
    public struct FastRestoreRule: Swift.Equatable {
        /// The Availability Zones in which to enable fast snapshot restore.
        /// This member is required.
        public var availabilityZones: [Swift.String]?
        /// The number of snapshots to be enabled with fast snapshot restore.
        public var count: Swift.Int?
        /// The amount of time to enable fast snapshot restore. The maximum is 100 years. This is equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int?
        /// The unit of time for enabling fast snapshot restore.
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            availabilityZones: [Swift.String]? = nil,
            count: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension GetLifecyclePoliciesInput {

    static func queryItemProvider(_ value: GetLifecyclePoliciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let resourceTypes = value.resourceTypes {
            resourceTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "resourceTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let tagsToAdd = value.tagsToAdd {
            tagsToAdd.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagsToAdd".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let state = value.state {
            let stateQueryItem = ClientRuntime.SDKURLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let policyIds = value.policyIds {
            policyIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "policyIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let targetTags = value.targetTags {
            targetTags.forEach { queryItemValue in
                let queryItem = ClientRuntime.SDKURLQueryItem(name: "targetTags".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let defaultPolicyType = value.defaultPolicyType {
            let defaultPolicyTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "defaultPolicyType".urlPercentEncoding(), value: Swift.String(defaultPolicyType.rawValue).urlPercentEncoding())
            items.append(defaultPolicyTypeQueryItem)
        }
        return items
    }
}

extension GetLifecyclePoliciesInput {

    static func urlPathProvider(_ value: GetLifecyclePoliciesInput) -> Swift.String? {
        return "/policies"
    }
}

public struct GetLifecyclePoliciesInput: Swift.Equatable {
    /// [Default policies only] Specifies the type of default policy to get. Specify one of the following:
    ///
    /// * VOLUME - To get only the default policy for EBS snapshots
    ///
    /// * INSTANCE - To get only the default policy for EBS-backed AMIs
    ///
    /// * ALL - To get all default policies
    public var defaultPolicyType: DLMClientTypes.DefaultPoliciesTypeValues?
    /// The identifiers of the data lifecycle policies.
    public var policyIds: [Swift.String]?
    /// The resource type.
    public var resourceTypes: [DLMClientTypes.ResourceTypeValues]?
    /// The activation state.
    public var state: DLMClientTypes.GettablePolicyStateValues?
    /// The tags to add to objects created by the policy. Tags are strings in the format key=value. These user-defined tags are added in addition to the Amazon Web Services-added lifecycle tags.
    public var tagsToAdd: [Swift.String]?
    /// The target tag for a policy. Tags are strings in the format key=value.
    public var targetTags: [Swift.String]?

    public init(
        defaultPolicyType: DLMClientTypes.DefaultPoliciesTypeValues? = nil,
        policyIds: [Swift.String]? = nil,
        resourceTypes: [DLMClientTypes.ResourceTypeValues]? = nil,
        state: DLMClientTypes.GettablePolicyStateValues? = nil,
        tagsToAdd: [Swift.String]? = nil,
        targetTags: [Swift.String]? = nil
    )
    {
        self.defaultPolicyType = defaultPolicyType
        self.policyIds = policyIds
        self.resourceTypes = resourceTypes
        self.state = state
        self.tagsToAdd = tagsToAdd
        self.targetTags = targetTags
    }
}

struct GetLifecyclePoliciesInputBody: Swift.Equatable {
}

extension GetLifecyclePoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecyclePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.policies = output.policies
        } else {
            self.policies = nil
        }
    }
}

public struct GetLifecyclePoliciesOutput: Swift.Equatable {
    /// Summary information about the lifecycle policies.
    public var policies: [DLMClientTypes.LifecyclePolicySummary]?

    public init(
        policies: [DLMClientTypes.LifecyclePolicySummary]? = nil
    )
    {
        self.policies = policies
    }
}

struct GetLifecyclePoliciesOutputBody: Swift.Equatable {
    let policies: [DLMClientTypes.LifecyclePolicySummary]?
}

extension GetLifecyclePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies = "Policies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([DLMClientTypes.LifecyclePolicySummary?].self, forKey: .policies)
        var policiesDecoded0:[DLMClientTypes.LifecyclePolicySummary]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [DLMClientTypes.LifecyclePolicySummary]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

enum GetLifecyclePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecyclePolicyInput {

    static func urlPathProvider(_ value: GetLifecyclePolicyInput) -> Swift.String? {
        guard let policyId = value.policyId else {
            return nil
        }
        return "/policies/\(policyId.urlPercentEncoding())"
    }
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetLifecyclePolicyOutput: Swift.Equatable {
    /// Detailed information about the lifecycle policy.
    public var policy: DLMClientTypes.LifecyclePolicy?

    public init(
        policy: DLMClientTypes.LifecyclePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetLifecyclePolicyOutputBody: Swift.Equatable {
    let policy: DLMClientTypes.LifecyclePolicy?
}

extension GetLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(DLMClientTypes.LifecyclePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DLMClientTypes {
    public enum GettablePolicyStateValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [GettablePolicyStateValues] {
            return [
                .disabled,
                .enabled,
                .error,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GettablePolicyStateValues(rawValue: rawValue) ?? GettablePolicyStateValues.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service failed in an unexpected way.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DLMClientTypes {
    public enum IntervalUnitValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hours
        case sdkUnknown(Swift.String)

        public static var allCases: [IntervalUnitValues] {
            return [
                .hours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hours: return "HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntervalUnitValues(rawValue: rawValue) ?? IntervalUnitValues.sdkUnknown(rawValue)
        }
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.mutuallyExclusiveParameters = output.mutuallyExclusiveParameters
            self.properties.requiredParameters = output.requiredParameters
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.mutuallyExclusiveParameters = nil
            self.properties.requiredParameters = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Bad request. The request is missing required parameters or has invalid parameters.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request included parameters that cannot be provided together.
        public internal(set) var mutuallyExclusiveParameters: [Swift.String]? = nil
        /// The request omitted one or more required parameters.
        public internal(set) var requiredParameters: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        mutuallyExclusiveParameters: [Swift.String]? = nil,
        requiredParameters: [Swift.String]? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.mutuallyExclusiveParameters = mutuallyExclusiveParameters
        self.properties.requiredParameters = requiredParameters
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let requiredParameters: [Swift.String]?
    let mutuallyExclusiveParameters: [Swift.String]?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case mutuallyExclusiveParameters = "MutuallyExclusiveParameters"
        case requiredParameters = "RequiredParameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let requiredParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredParameters)
        var requiredParametersDecoded0:[Swift.String]? = nil
        if let requiredParametersContainer = requiredParametersContainer {
            requiredParametersDecoded0 = [Swift.String]()
            for string0 in requiredParametersContainer {
                if let string0 = string0 {
                    requiredParametersDecoded0?.append(string0)
                }
            }
        }
        requiredParameters = requiredParametersDecoded0
        let mutuallyExclusiveParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .mutuallyExclusiveParameters)
        var mutuallyExclusiveParametersDecoded0:[Swift.String]? = nil
        if let mutuallyExclusiveParametersContainer = mutuallyExclusiveParametersContainer {
            mutuallyExclusiveParametersDecoded0 = [Swift.String]()
            for string0 in mutuallyExclusiveParametersContainer {
                if let string0 = string0 {
                    mutuallyExclusiveParametersDecoded0?.append(string0)
                }
            }
        }
        mutuallyExclusiveParameters = mutuallyExclusiveParametersDecoded0
    }
}

extension DLMClientTypes.LifecyclePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case defaultPolicy = "DefaultPolicy"
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyArn = "PolicyArn"
        case policyDetails = "PolicyDetails"
        case policyId = "PolicyId"
        case state = "State"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = self.dateCreated {
            try encodeContainer.encodeTimestamp(dateCreated, format: .dateTime, forKey: .dateCreated)
        }
        if let dateModified = self.dateModified {
            try encodeContainer.encodeTimestamp(dateModified, format: .dateTime, forKey: .dateModified)
        }
        if let defaultPolicy = self.defaultPolicy {
            try encodeContainer.encode(defaultPolicy, forKey: .defaultPolicy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDetails = self.policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DLMClientTypes.GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let dateCreatedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .dateModified)
        dateModified = dateModifiedDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let defaultPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultPolicy)
        defaultPolicy = defaultPolicyDecoded
    }
}

extension DLMClientTypes {
    /// [Custom policies only] Detailed information about a snapshot, AMI, or event-based lifecycle policy.
    public struct LifecyclePolicy: Swift.Equatable {
        /// The local date and time when the lifecycle policy was created.
        public var dateCreated: ClientRuntime.Date?
        /// The local date and time when the lifecycle policy was last modified.
        public var dateModified: ClientRuntime.Date?
        /// [Default policies only] The type of default policy. Values include:
        ///
        /// * VOLUME - Default policy for EBS snapshots
        ///
        /// * INSTANCE - Default policy for EBS-backed AMIs
        public var defaultPolicy: Swift.Bool?
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by the lifecycle policy.
        public var executionRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        public var policyArn: Swift.String?
        /// The configuration of the lifecycle policy
        public var policyDetails: DLMClientTypes.PolicyDetails?
        /// The identifier of the lifecycle policy.
        public var policyId: Swift.String?
        /// The activation state of the lifecycle policy.
        public var state: DLMClientTypes.GettablePolicyStateValues?
        /// The description of the status.
        public var statusMessage: Swift.String?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            defaultPolicy: Swift.Bool? = nil,
            description: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            policyDetails: DLMClientTypes.PolicyDetails? = nil,
            policyId: Swift.String? = nil,
            state: DLMClientTypes.GettablePolicyStateValues? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.defaultPolicy = defaultPolicy
            self.description = description
            self.executionRoleArn = executionRoleArn
            self.policyArn = policyArn
            self.policyDetails = policyDetails
            self.policyId = policyId
            self.state = state
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension DLMClientTypes.LifecyclePolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultPolicy = "DefaultPolicy"
        case description = "Description"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultPolicy = self.defaultPolicy {
            try encodeContainer.encode(defaultPolicy, forKey: .defaultPolicy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DLMClientTypes.GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyTypeDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let defaultPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultPolicy)
        defaultPolicy = defaultPolicyDecoded
    }
}

extension DLMClientTypes {
    /// Summary information about a lifecycle policy.
    public struct LifecyclePolicySummary: Swift.Equatable {
        /// [Default policies only] The type of default policy. Values include:
        ///
        /// * VOLUME - Default policy for EBS snapshots
        ///
        /// * INSTANCE - Default policy for EBS-backed AMIs
        public var defaultPolicy: Swift.Bool?
        /// The description of the lifecycle policy.
        public var description: Swift.String?
        /// The identifier of the lifecycle policy.
        public var policyId: Swift.String?
        /// The type of policy. EBS_SNAPSHOT_MANAGEMENT indicates that the policy manages the lifecycle of Amazon EBS snapshots. IMAGE_MANAGEMENT indicates that the policy manages the lifecycle of EBS-backed AMIs. EVENT_BASED_POLICY indicates that the policy automates cross-account snapshot copies for snapshots that are shared with your account.
        public var policyType: DLMClientTypes.PolicyTypeValues?
        /// The activation state of the lifecycle policy.
        public var state: DLMClientTypes.GettablePolicyStateValues?
        /// The tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            defaultPolicy: Swift.Bool? = nil,
            description: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyType: DLMClientTypes.PolicyTypeValues? = nil,
            state: DLMClientTypes.GettablePolicyStateValues? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.defaultPolicy = defaultPolicy
            self.description = description
            self.policyId = policyId
            self.policyType = policyType
            self.state = state
            self.tags = tags
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because a limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Value is the type of resource for which a limit was exceeded.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DLMClientTypes {
    public enum LocationValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case outpostLocal
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationValues] {
            return [
                .cloud,
                .outpostLocal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .outpostLocal: return "OUTPOST_LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationValues(rawValue: rawValue) ?? LocationValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludeBootVolume = "ExcludeBootVolume"
        case excludeDataVolumeTags = "ExcludeDataVolumeTags"
        case noReboot = "NoReboot"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeBootVolume = self.excludeBootVolume {
            try encodeContainer.encode(excludeBootVolume, forKey: .excludeBootVolume)
        }
        if let excludeDataVolumeTags = excludeDataVolumeTags {
            var excludeDataVolumeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeDataVolumeTags)
            for tag0 in excludeDataVolumeTags {
                try excludeDataVolumeTagsContainer.encode(tag0)
            }
        }
        if let noReboot = self.noReboot {
            try encodeContainer.encode(noReboot, forKey: .noReboot)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludeBootVolumeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excludeBootVolume)
        excludeBootVolume = excludeBootVolumeDecoded
        let noRebootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noReboot)
        noReboot = noRebootDecoded
        let excludeDataVolumeTagsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Tag?].self, forKey: .excludeDataVolumeTags)
        var excludeDataVolumeTagsDecoded0:[DLMClientTypes.Tag]? = nil
        if let excludeDataVolumeTagsContainer = excludeDataVolumeTagsContainer {
            excludeDataVolumeTagsDecoded0 = [DLMClientTypes.Tag]()
            for structure0 in excludeDataVolumeTagsContainer {
                if let structure0 = structure0 {
                    excludeDataVolumeTagsDecoded0?.append(structure0)
                }
            }
        }
        excludeDataVolumeTags = excludeDataVolumeTagsDecoded0
    }
}

extension DLMClientTypes {
    /// [Custom snapshot and AMI policies only] Specifies optional parameters for snapshot and AMI policies. The set of valid parameters depends on the combination of policy type and target resource type. If you choose to exclude boot volumes and you specify tags that consequently exclude all of the additional data volumes attached to an instance, then Amazon Data Lifecycle Manager will not create any snapshots for the affected instance, and it will emit a SnapshotsCreateFailed Amazon CloudWatch metric. For more information, see [Monitor your policies using Amazon CloudWatch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/monitor-dlm-cw-metrics.html).
    public struct Parameters: Swift.Equatable {
        /// [Custom snapshot policies that target instances only] Indicates whether to exclude the root volume from multi-volume snapshot sets. The default is false. If you specify true, then the root volumes attached to targeted instances will be excluded from the multi-volume snapshot sets created by the policy.
        public var excludeBootVolume: Swift.Bool?
        /// [Custom snapshot policies that target instances only] The tags used to identify data (non-root) volumes to exclude from multi-volume snapshot sets. If you create a snapshot lifecycle policy that targets instances and you specify tags for this parameter, then data volumes with the specified tags that are attached to targeted instances will be excluded from the multi-volume snapshot sets created by the policy.
        public var excludeDataVolumeTags: [DLMClientTypes.Tag]?
        /// [Custom AMI policies only] Indicates whether targeted instances are rebooted when the lifecycle policy runs. true indicates that targeted instances are not rebooted when the policy runs. false indicates that target instances are rebooted when the policy runs. The default is true (instances are not rebooted).
        public var noReboot: Swift.Bool?

        public init(
            excludeBootVolume: Swift.Bool? = nil,
            excludeDataVolumeTags: [DLMClientTypes.Tag]? = nil,
            noReboot: Swift.Bool? = nil
        )
        {
            self.excludeBootVolume = excludeBootVolume
            self.excludeDataVolumeTags = excludeDataVolumeTags
            self.noReboot = noReboot
        }
    }

}

extension DLMClientTypes.PolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case copyTags = "CopyTags"
        case createInterval = "CreateInterval"
        case crossRegionCopyTargets = "CrossRegionCopyTargets"
        case eventSource = "EventSource"
        case exclusions = "Exclusions"
        case extendDeletion = "ExtendDeletion"
        case parameters = "Parameters"
        case policyLanguage = "PolicyLanguage"
        case policyType = "PolicyType"
        case resourceLocations = "ResourceLocations"
        case resourceType = "ResourceType"
        case resourceTypes = "ResourceTypes"
        case retainInterval = "RetainInterval"
        case schedules = "Schedules"
        case targetTags = "TargetTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createInterval = self.createInterval {
            try encodeContainer.encode(createInterval, forKey: .createInterval)
        }
        if let crossRegionCopyTargets = crossRegionCopyTargets {
            var crossRegionCopyTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyTargets)
            for crossregioncopytarget0 in crossRegionCopyTargets {
                try crossRegionCopyTargetsContainer.encode(crossregioncopytarget0)
            }
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let exclusions = self.exclusions {
            try encodeContainer.encode(exclusions, forKey: .exclusions)
        }
        if let extendDeletion = self.extendDeletion {
            try encodeContainer.encode(extendDeletion, forKey: .extendDeletion)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let policyLanguage = self.policyLanguage {
            try encodeContainer.encode(policyLanguage.rawValue, forKey: .policyLanguage)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let resourceLocations = resourceLocations {
            var resourceLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceLocations)
            for resourcelocationvalues0 in resourceLocations {
                try resourceLocationsContainer.encode(resourcelocationvalues0.rawValue)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypevalues0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypevalues0.rawValue)
            }
        }
        if let retainInterval = self.retainInterval {
            try encodeContainer.encode(retainInterval, forKey: .retainInterval)
        }
        if let schedules = schedules {
            var schedulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schedules)
            for schedule0 in schedules {
                try schedulesContainer.encode(schedule0)
            }
        }
        if let targetTags = targetTags {
            var targetTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTags)
            for tag0 in targetTags {
                try targetTagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTypeDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([DLMClientTypes.ResourceTypeValues?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[DLMClientTypes.ResourceTypeValues]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [DLMClientTypes.ResourceTypeValues]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let resourceLocationsContainer = try containerValues.decodeIfPresent([DLMClientTypes.ResourceLocationValues?].self, forKey: .resourceLocations)
        var resourceLocationsDecoded0:[DLMClientTypes.ResourceLocationValues]? = nil
        if let resourceLocationsContainer = resourceLocationsContainer {
            resourceLocationsDecoded0 = [DLMClientTypes.ResourceLocationValues]()
            for enum0 in resourceLocationsContainer {
                if let enum0 = enum0 {
                    resourceLocationsDecoded0?.append(enum0)
                }
            }
        }
        resourceLocations = resourceLocationsDecoded0
        let targetTagsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Tag?].self, forKey: .targetTags)
        var targetTagsDecoded0:[DLMClientTypes.Tag]? = nil
        if let targetTagsContainer = targetTagsContainer {
            targetTagsDecoded0 = [DLMClientTypes.Tag]()
            for structure0 in targetTagsContainer {
                if let structure0 = structure0 {
                    targetTagsDecoded0?.append(structure0)
                }
            }
        }
        targetTags = targetTagsDecoded0
        let schedulesContainer = try containerValues.decodeIfPresent([DLMClientTypes.Schedule?].self, forKey: .schedules)
        var schedulesDecoded0:[DLMClientTypes.Schedule]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [DLMClientTypes.Schedule]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(DLMClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(DLMClientTypes.EventSource.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[DLMClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DLMClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let policyLanguageDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyLanguageValues.self, forKey: .policyLanguage)
        policyLanguage = policyLanguageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DLMClientTypes.ResourceTypeValues.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createInterval)
        createInterval = createIntervalDecoded
        let retainIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retainInterval)
        retainInterval = retainIntervalDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let crossRegionCopyTargetsContainer = try containerValues.decodeIfPresent([DLMClientTypes.CrossRegionCopyTarget?].self, forKey: .crossRegionCopyTargets)
        var crossRegionCopyTargetsDecoded0:[DLMClientTypes.CrossRegionCopyTarget]? = nil
        if let crossRegionCopyTargetsContainer = crossRegionCopyTargetsContainer {
            crossRegionCopyTargetsDecoded0 = [DLMClientTypes.CrossRegionCopyTarget]()
            for structure0 in crossRegionCopyTargetsContainer {
                if let structure0 = structure0 {
                    crossRegionCopyTargetsDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyTargets = crossRegionCopyTargetsDecoded0
        let extendDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extendDeletion)
        extendDeletion = extendDeletionDecoded
        let exclusionsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.Exclusions.self, forKey: .exclusions)
        exclusions = exclusionsDecoded
    }
}

extension DLMClientTypes {
    /// Specifies the configuration of a lifecycle policy.
    public struct PolicyDetails: Swift.Equatable {
        /// [Event-based policies only] The actions to be performed when the event-based policy is activated. You can specify only one action per policy.
        public var actions: [DLMClientTypes.Action]?
        /// [Default policies only] Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. If you do not specify a value, the default is false. Default: false
        public var copyTags: Swift.Bool?
        /// [Default policies only] Specifies how often the policy should run and create snapshots or AMIs. The creation frequency can range from 1 to 7 days. If you do not specify a value, the default is 1. Default: 1
        public var createInterval: Swift.Int?
        /// [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify up to 3 destination Regions. If you do not want to create cross-Region copies, omit this parameter.
        public var crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]?
        /// [Event-based policies only] The event that activates the event-based policy.
        public var eventSource: DLMClientTypes.EventSource?
        /// [Default policies only] Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs for target resources that match any of the specified exclusion parameters.
        public var exclusions: DLMClientTypes.Exclusions?
        /// [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the source volume or instance is deleted, or if the policy enters the error, disabled, or deleted state. By default (ExtendDeletion=false):
        ///
        /// * If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously created snapshots or AMIs, up to but not including the last one, based on the specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs, including the last one, specify true.
        ///
        /// * If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs, including the last one, if the policy enters one of these states, specify true.
        ///
        ///
        /// If you enable extended deletion (ExtendDeletion=true), you override both default behaviors simultaneously. If you do not specify a value, the default is false. Default: false
        public var extendDeletion: Swift.Bool?
        /// [Custom snapshot and AMI policies only] A set of optional parameters for snapshot and AMI lifecycle policies. If you are modifying a policy that was created or previously modified using the Amazon Data Lifecycle Manager console, then you must include this parameter and specify either the default values or the new values that you require. You can't omit this parameter or set its values to null.
        public var parameters: DLMClientTypes.Parameters?
        /// The type of policy to create. Specify one of the following:
        ///
        /// * SIMPLIFIED To create a default policy.
        ///
        /// * STANDARD To create a custom policy.
        public var policyLanguage: DLMClientTypes.PolicyLanguageValues?
        /// [Custom policies only] The valid target resource types and actions a policy can manage. Specify EBS_SNAPSHOT_MANAGEMENT to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY  to create an event-based policy that performs specific actions when a defined event occurs in your Amazon Web Services account. The default is EBS_SNAPSHOT_MANAGEMENT.
        public var policyType: DLMClientTypes.PolicyTypeValues?
        /// [Custom snapshot and AMI policies only] The location of the resources to backup. If the source resources are located in an Amazon Web Services Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If you specify OUTPOST, Amazon Data Lifecycle Manager backs up all resources of the specified type with matching target tags across all of the Outposts in your account.
        public var resourceLocations: [DLMClientTypes.ResourceLocationValues]?
        /// [Default policies only] Specify the type of default policy to create.
        ///
        /// * To create a default policy for EBS snapshots, that creates snapshots of all volumes in the Region that do not have recent backups, specify VOLUME.
        ///
        /// * To create a default policy for EBS-backed AMIs, that creates EBS-backed AMIs from all instances in the Region that do not have recent backups, specify INSTANCE.
        public var resourceType: DLMClientTypes.ResourceTypeValues?
        /// [Custom snapshot policies only] The target resource type for snapshot and AMI lifecycle policies. Use VOLUME to create snapshots of individual volumes or use INSTANCE to create multi-volume snapshots from the volumes for an instance.
        public var resourceTypes: [DLMClientTypes.ResourceTypeValues]?
        /// [Default policies only] Specifies how long the policy should retain snapshots or AMIs before deleting them. The retention period can range from 2 to 14 days, but it must be greater than the creation frequency to ensure that the policy retains at least 1 snapshot or AMI at any given time. If you do not specify a value, the default is 7. Default: 7
        public var retainInterval: Swift.Int?
        /// [Custom snapshot and AMI policies only] The schedules of policy-defined actions for snapshot and AMI lifecycle policies. A policy can have up to four schedulesone mandatory schedule and up to three optional schedules.
        public var schedules: [DLMClientTypes.Schedule]?
        /// [Custom snapshot and AMI policies only] The single tag that identifies targeted resources for this policy.
        public var targetTags: [DLMClientTypes.Tag]?

        public init(
            actions: [DLMClientTypes.Action]? = nil,
            copyTags: Swift.Bool? = nil,
            createInterval: Swift.Int? = nil,
            crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]? = nil,
            eventSource: DLMClientTypes.EventSource? = nil,
            exclusions: DLMClientTypes.Exclusions? = nil,
            extendDeletion: Swift.Bool? = nil,
            parameters: DLMClientTypes.Parameters? = nil,
            policyLanguage: DLMClientTypes.PolicyLanguageValues? = nil,
            policyType: DLMClientTypes.PolicyTypeValues? = nil,
            resourceLocations: [DLMClientTypes.ResourceLocationValues]? = nil,
            resourceType: DLMClientTypes.ResourceTypeValues? = nil,
            resourceTypes: [DLMClientTypes.ResourceTypeValues]? = nil,
            retainInterval: Swift.Int? = nil,
            schedules: [DLMClientTypes.Schedule]? = nil,
            targetTags: [DLMClientTypes.Tag]? = nil
        )
        {
            self.actions = actions
            self.copyTags = copyTags
            self.createInterval = createInterval
            self.crossRegionCopyTargets = crossRegionCopyTargets
            self.eventSource = eventSource
            self.exclusions = exclusions
            self.extendDeletion = extendDeletion
            self.parameters = parameters
            self.policyLanguage = policyLanguage
            self.policyType = policyType
            self.resourceLocations = resourceLocations
            self.resourceType = resourceType
            self.resourceTypes = resourceTypes
            self.retainInterval = retainInterval
            self.schedules = schedules
            self.targetTags = targetTags
        }
    }

}

extension DLMClientTypes {
    public enum PolicyLanguageValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case simplified
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyLanguageValues] {
            return [
                .simplified,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .simplified: return "SIMPLIFIED"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyLanguageValues(rawValue: rawValue) ?? PolicyLanguageValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes {
    public enum PolicyTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsSnapshotManagement
        case eventBasedPolicy
        case imageManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyTypeValues] {
            return [
                .ebsSnapshotManagement,
                .eventBasedPolicy,
                .imageManagement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsSnapshotManagement: return "EBS_SNAPSHOT_MANAGEMENT"
            case .eventBasedPolicy: return "EVENT_BASED_POLICY"
            case .imageManagement: return "IMAGE_MANAGEMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyTypeValues(rawValue: rawValue) ?? PolicyTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes {
    public enum ResourceLocationValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case outpost
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceLocationValues] {
            return [
                .cloud,
                .outpost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .outpost: return "OUTPOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceLocationValues(rawValue: rawValue) ?? ResourceLocationValues.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.resourceIds = output.resourceIds
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.resourceIds = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Value is a list of resource IDs that were not found.
        public internal(set) var resourceIds: [Swift.String]? = nil
        /// Value is the type of resource that was not found.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceIds = resourceIds
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceType: Swift.String?
    let resourceIds: [Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DLMClientTypes {
    public enum ResourceTypeValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeValues] {
            return [
                .instance,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeValues(rawValue: rawValue) ?? ResourceTypeValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.RetainRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot and AMI policies only] Specifies a retention rule for snapshots created by snapshot policies, or for AMIs created by AMI policies. For snapshot policies that have an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html), this retention rule applies to standard tier retention. When the retention threshold is met, snapshots are moved from the standard to the archive tier. For snapshot policies that do not have an ArchiveRule, snapshots are permanently deleted when this retention threshold is met. You can retain snapshots based on either a count or a time interval.
    ///
    /// * Count-based retention You must specify Count. If you specify an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html) for the schedule, then you can specify a retention count of 0 to archive snapshots immediately after creation. If you specify a [FastRestoreRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_FastRestoreRule.html), [ShareRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ShareRule.html), or a [CrossRegionCopyRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_CrossRegionCopyRule.html), then you must specify a retention count of 1 or more.
    ///
    /// * Age-based retention You must specify Interval and IntervalUnit. If you specify an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html) for the schedule, then you can specify a retention interval of 0 days to archive snapshots immediately after creation. If you specify a [FastRestoreRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_FastRestoreRule.html), [ShareRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ShareRule.html), or a [CrossRegionCopyRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_CrossRegionCopyRule.html), then you must specify a retention interval of 1 day or more.
    public struct RetainRule: Swift.Equatable {
        /// The number of snapshots to retain for each volume, up to a maximum of 1000. For example if you want to retain a maximum of three snapshots, specify 3. When the fourth snapshot is created, the oldest retained snapshot is deleted, or it is moved to the archive tier if you have specified an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html).
        public var count: Swift.Int?
        /// The amount of time to retain each snapshot. The maximum is 100 years. This is equivalent to 1200 months, 5200 weeks, or 36500 days.
        public var interval: Swift.Int?
        /// The unit of time for time-based retention. For example, to retain snapshots for 3 months, specify Interval=3 and IntervalUnit=MONTHS. Once the snapshot has been retained for 3 months, it is deleted, or it is moved to the archive tier if you have specified an [ArchiveRule](https://docs.aws.amazon.com/dlm/latest/APIReference/API_ArchiveRule.html).
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            count: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DLMClientTypes.RetentionArchiveTier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = self.intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies only] Describes the retention rule for archived snapshots. Once the archive retention threshold is met, the snapshots are permanently deleted from the archive tier. The archive retention rule must retain snapshots in the archive tier for a minimum of 90 days. For count-based schedules, you must specify Count. For age-based schedules, you must specify Interval and IntervalUnit. For more information about using snapshot archiving, see [Considerations for snapshot lifecycle policies](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshot-ami-policy.html#dlm-archive).
    public struct RetentionArchiveTier: Swift.Equatable {
        /// The maximum number of snapshots to retain in the archive storage tier for each volume. The count must ensure that each snapshot remains in the archive tier for at least 90 days. For example, if the schedule creates snapshots every 30 days, you must specify a count of 3 or more to ensure that each snapshot is archived for at least 90 days.
        public var count: Swift.Int?
        /// Specifies the period of time to retain snapshots in the archive tier. After this period expires, the snapshot is permanently deleted.
        public var interval: Swift.Int?
        /// The unit of time in which to measure the Interval. For example, to retain a snapshots in the archive tier for 6 months, specify Interval=6 and IntervalUnit=MONTHS.
        public var intervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            count: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            intervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.count = count
            self.interval = interval
            self.intervalUnit = intervalUnit
        }
    }

}

extension DLMClientTypes {
    public enum RetentionIntervalUnitValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case months
        case weeks
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionIntervalUnitValues] {
            return [
                .days,
                .months,
                .weeks,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .weeks: return "WEEKS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionIntervalUnitValues(rawValue: rawValue) ?? RetentionIntervalUnitValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.Schedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveRule = "ArchiveRule"
        case copyTags = "CopyTags"
        case createRule = "CreateRule"
        case crossRegionCopyRules = "CrossRegionCopyRules"
        case deprecateRule = "DeprecateRule"
        case fastRestoreRule = "FastRestoreRule"
        case name = "Name"
        case retainRule = "RetainRule"
        case shareRules = "ShareRules"
        case tagsToAdd = "TagsToAdd"
        case variableTags = "VariableTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveRule = self.archiveRule {
            try encodeContainer.encode(archiveRule, forKey: .archiveRule)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createRule = self.createRule {
            try encodeContainer.encode(createRule, forKey: .createRule)
        }
        if let crossRegionCopyRules = crossRegionCopyRules {
            var crossRegionCopyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyRules)
            for crossregioncopyrule0 in crossRegionCopyRules {
                try crossRegionCopyRulesContainer.encode(crossregioncopyrule0)
            }
        }
        if let deprecateRule = self.deprecateRule {
            try encodeContainer.encode(deprecateRule, forKey: .deprecateRule)
        }
        if let fastRestoreRule = self.fastRestoreRule {
            try encodeContainer.encode(fastRestoreRule, forKey: .fastRestoreRule)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retainRule = self.retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let shareRules = shareRules {
            var shareRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareRules)
            for sharerule0 in shareRules {
                try shareRulesContainer.encode(sharerule0)
            }
        }
        if let tagsToAdd = tagsToAdd {
            var tagsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToAdd)
            for tag0 in tagsToAdd {
                try tagsToAddContainer.encode(tag0)
            }
        }
        if let variableTags = variableTags {
            var variableTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableTags)
            for tag0 in variableTags {
                try variableTagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let tagsToAddContainer = try containerValues.decodeIfPresent([DLMClientTypes.Tag?].self, forKey: .tagsToAdd)
        var tagsToAddDecoded0:[DLMClientTypes.Tag]? = nil
        if let tagsToAddContainer = tagsToAddContainer {
            tagsToAddDecoded0 = [DLMClientTypes.Tag]()
            for structure0 in tagsToAddContainer {
                if let structure0 = structure0 {
                    tagsToAddDecoded0?.append(structure0)
                }
            }
        }
        tagsToAdd = tagsToAddDecoded0
        let variableTagsContainer = try containerValues.decodeIfPresent([DLMClientTypes.Tag?].self, forKey: .variableTags)
        var variableTagsDecoded0:[DLMClientTypes.Tag]? = nil
        if let variableTagsContainer = variableTagsContainer {
            variableTagsDecoded0 = [DLMClientTypes.Tag]()
            for structure0 in variableTagsContainer {
                if let structure0 = structure0 {
                    variableTagsDecoded0?.append(structure0)
                }
            }
        }
        variableTags = variableTagsDecoded0
        let createRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.CreateRule.self, forKey: .createRule)
        createRule = createRuleDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
        let fastRestoreRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.FastRestoreRule.self, forKey: .fastRestoreRule)
        fastRestoreRule = fastRestoreRuleDecoded
        let crossRegionCopyRulesContainer = try containerValues.decodeIfPresent([DLMClientTypes.CrossRegionCopyRule?].self, forKey: .crossRegionCopyRules)
        var crossRegionCopyRulesDecoded0:[DLMClientTypes.CrossRegionCopyRule]? = nil
        if let crossRegionCopyRulesContainer = crossRegionCopyRulesContainer {
            crossRegionCopyRulesDecoded0 = [DLMClientTypes.CrossRegionCopyRule]()
            for structure0 in crossRegionCopyRulesContainer {
                if let structure0 = structure0 {
                    crossRegionCopyRulesDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyRules = crossRegionCopyRulesDecoded0
        let shareRulesContainer = try containerValues.decodeIfPresent([DLMClientTypes.ShareRule?].self, forKey: .shareRules)
        var shareRulesDecoded0:[DLMClientTypes.ShareRule]? = nil
        if let shareRulesContainer = shareRulesContainer {
            shareRulesDecoded0 = [DLMClientTypes.ShareRule]()
            for structure0 in shareRulesContainer {
                if let structure0 = structure0 {
                    shareRulesDecoded0?.append(structure0)
                }
            }
        }
        shareRules = shareRulesDecoded0
        let deprecateRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.DeprecateRule.self, forKey: .deprecateRule)
        deprecateRule = deprecateRuleDecoded
        let archiveRuleDecoded = try containerValues.decodeIfPresent(DLMClientTypes.ArchiveRule.self, forKey: .archiveRule)
        archiveRule = archiveRuleDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot and AMI policies only] Specifies a schedule for a snapshot or AMI lifecycle policy.
    public struct Schedule: Swift.Equatable {
        /// [Custom snapshot policies that target volumes only] The snapshot archiving rule for the schedule. When you specify an archiving rule, snapshots are automatically moved from the standard tier to the archive tier once the schedule's retention threshold is met. Snapshots are then retained in the archive tier for the archive retention period that you specify. For more information about using snapshot archiving, see [Considerations for snapshot lifecycle policies](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshot-ami-policy.html#dlm-archive).
        public var archiveRule: DLMClientTypes.ArchiveRule?
        /// Copy all user-defined tags on a source volume to snapshots of the volume created by this policy.
        public var copyTags: Swift.Bool?
        /// The creation rule.
        public var createRule: DLMClientTypes.CreateRule?
        /// Specifies a rule for copying snapshots or AMIs across regions. You can't specify cross-Region copy rules for policies that create snapshots on an Outpost. If the policy creates snapshots in a Region, then snapshots can be copied to up to three Regions or Outposts.
        public var crossRegionCopyRules: [DLMClientTypes.CrossRegionCopyRule]?
        /// [Custom AMI policies only] The AMI deprecation rule for the schedule.
        public var deprecateRule: DLMClientTypes.DeprecateRule?
        /// [Custom snapshot policies only] The rule for enabling fast snapshot restore.
        public var fastRestoreRule: DLMClientTypes.FastRestoreRule?
        /// The name of the schedule.
        public var name: Swift.String?
        /// The retention rule for snapshots or AMIs created by the policy.
        public var retainRule: DLMClientTypes.RetainRule?
        /// [Custom snapshot policies only] The rule for sharing snapshots with other Amazon Web Services accounts.
        public var shareRules: [DLMClientTypes.ShareRule]?
        /// The tags to apply to policy-created resources. These user-defined tags are in addition to the Amazon Web Services-added lifecycle tags.
        public var tagsToAdd: [DLMClientTypes.Tag]?
        /// [AMI policies and snapshot policies that target instances only] A collection of key/value pairs with values determined dynamically when the policy is executed. Keys may be any valid Amazon EC2 tag key. Values must be in one of the two following formats: $(instance-id) or $(timestamp). Variable tags are only valid for EBS Snapshot Management  Instance policies.
        public var variableTags: [DLMClientTypes.Tag]?

        public init(
            archiveRule: DLMClientTypes.ArchiveRule? = nil,
            copyTags: Swift.Bool? = nil,
            createRule: DLMClientTypes.CreateRule? = nil,
            crossRegionCopyRules: [DLMClientTypes.CrossRegionCopyRule]? = nil,
            deprecateRule: DLMClientTypes.DeprecateRule? = nil,
            fastRestoreRule: DLMClientTypes.FastRestoreRule? = nil,
            name: Swift.String? = nil,
            retainRule: DLMClientTypes.RetainRule? = nil,
            shareRules: [DLMClientTypes.ShareRule]? = nil,
            tagsToAdd: [DLMClientTypes.Tag]? = nil,
            variableTags: [DLMClientTypes.Tag]? = nil
        )
        {
            self.archiveRule = archiveRule
            self.copyTags = copyTags
            self.createRule = createRule
            self.crossRegionCopyRules = crossRegionCopyRules
            self.deprecateRule = deprecateRule
            self.fastRestoreRule = fastRestoreRule
            self.name = name
            self.retainRule = retainRule
            self.shareRules = shareRules
            self.tagsToAdd = tagsToAdd
            self.variableTags = variableTags
        }
    }

}

extension DLMClientTypes.Script: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executeOperationOnScriptFailure = "ExecuteOperationOnScriptFailure"
        case executionHandler = "ExecutionHandler"
        case executionHandlerService = "ExecutionHandlerService"
        case executionTimeout = "ExecutionTimeout"
        case maximumRetryCount = "MaximumRetryCount"
        case stages = "Stages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executeOperationOnScriptFailure = self.executeOperationOnScriptFailure {
            try encodeContainer.encode(executeOperationOnScriptFailure, forKey: .executeOperationOnScriptFailure)
        }
        if let executionHandler = self.executionHandler {
            try encodeContainer.encode(executionHandler, forKey: .executionHandler)
        }
        if let executionHandlerService = self.executionHandlerService {
            try encodeContainer.encode(executionHandlerService.rawValue, forKey: .executionHandlerService)
        }
        if let executionTimeout = self.executionTimeout {
            try encodeContainer.encode(executionTimeout, forKey: .executionTimeout)
        }
        if let maximumRetryCount = self.maximumRetryCount {
            try encodeContainer.encode(maximumRetryCount, forKey: .maximumRetryCount)
        }
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for stagevalues0 in stages {
                try stagesContainer.encode(stagevalues0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([DLMClientTypes.StageValues?].self, forKey: .stages)
        var stagesDecoded0:[DLMClientTypes.StageValues]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [DLMClientTypes.StageValues]()
            for enum0 in stagesContainer {
                if let enum0 = enum0 {
                    stagesDecoded0?.append(enum0)
                }
            }
        }
        stages = stagesDecoded0
        let executionHandlerServiceDecoded = try containerValues.decodeIfPresent(DLMClientTypes.ExecutionHandlerServiceValues.self, forKey: .executionHandlerService)
        executionHandlerService = executionHandlerServiceDecoded
        let executionHandlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionHandler)
        executionHandler = executionHandlerDecoded
        let executeOperationOnScriptFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .executeOperationOnScriptFailure)
        executeOperationOnScriptFailure = executeOperationOnScriptFailureDecoded
        let executionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeout)
        executionTimeout = executionTimeoutDecoded
        let maximumRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryCount)
        maximumRetryCount = maximumRetryCountDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies that target instances only] Information about pre and/or post scripts for a snapshot lifecycle policy that targets instances. For more information, see [ Automating application-consistent snapshots with pre and post scripts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/automate-app-consistent-backups.html).
    public struct Script: Swift.Equatable {
        /// Indicates whether Amazon Data Lifecycle Manager should default to crash-consistent snapshots if the pre script fails.
        ///
        /// * To default to crash consistent snapshot if the pre script fails, specify true.
        ///
        /// * To skip the instance for snapshot creation if the pre script fails, specify false.
        ///
        ///
        /// This parameter is supported only if you run a pre script. If you run a post script only, omit this parameter. Default: true
        public var executeOperationOnScriptFailure: Swift.Bool?
        /// The SSM document that includes the pre and/or post scripts to run.
        ///
        /// * If you are automating VSS backups, specify AWS_VSS_BACKUP. In this case, Amazon Data Lifecycle Manager automatically uses the AWSEC2-CreateVssSnapshot SSM document.
        ///
        /// * If you are automating application-consistent snapshots for SAP HANA workloads, specify AWSSystemsManagerSAP-CreateDLMSnapshotForSAPHANA.
        ///
        /// * If you are using a custom SSM document that you own, specify either the name or ARN of the SSM document. If you are using a custom SSM document that is shared with you, specify the ARN of the SSM document.
        /// This member is required.
        public var executionHandler: Swift.String?
        /// Indicates the service used to execute the pre and/or post scripts.
        ///
        /// * If you are using custom SSM documents or automating application-consistent snapshots of SAP HANA workloads, specify AWS_SYSTEMS_MANAGER.
        ///
        /// * If you are automating VSS Backups, omit this parameter.
        ///
        ///
        /// Default: AWS_SYSTEMS_MANAGER
        public var executionHandlerService: DLMClientTypes.ExecutionHandlerServiceValues?
        /// Specifies a timeout period, in seconds, after which Amazon Data Lifecycle Manager fails the script run attempt if it has not completed. If a script does not complete within its timeout period, Amazon Data Lifecycle Manager fails the attempt. The timeout period applies to the pre and post scripts individually. If you are automating VSS Backups, omit this parameter. Default: 10
        public var executionTimeout: Swift.Int?
        /// Specifies the number of times Amazon Data Lifecycle Manager should retry scripts that fail.
        ///
        /// * If the pre script fails, Amazon Data Lifecycle Manager retries the entire snapshot creation process, including running the pre and post scripts.
        ///
        /// * If the post script fails, Amazon Data Lifecycle Manager retries the post script only; in this case, the pre script will have completed and the snapshot might have been created.
        ///
        ///
        /// If you do not want Amazon Data Lifecycle Manager to retry failed scripts, specify 0. Default: 0
        public var maximumRetryCount: Swift.Int?
        /// Indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager initiates snapshot creation.
        ///
        /// * To run a pre script only, specify PRE. In this case, Amazon Data Lifecycle Manager calls the SSM document with the pre-script parameter before initiating snapshot creation.
        ///
        /// * To run a post script only, specify POST. In this case, Amazon Data Lifecycle Manager calls the SSM document with the post-script parameter after initiating snapshot creation.
        ///
        /// * To run both pre and post scripts, specify both PRE and POST. In this case, Amazon Data Lifecycle Manager calls the SSM document with the pre-script parameter before initiating snapshot creation, and then it calls the SSM document again with the post-script parameter after initiating snapshot creation.
        ///
        ///
        /// If you are automating VSS Backups, omit this parameter. Default: PRE and POST
        public var stages: [DLMClientTypes.StageValues]?

        public init(
            executeOperationOnScriptFailure: Swift.Bool? = nil,
            executionHandler: Swift.String? = nil,
            executionHandlerService: DLMClientTypes.ExecutionHandlerServiceValues? = nil,
            executionTimeout: Swift.Int? = nil,
            maximumRetryCount: Swift.Int? = nil,
            stages: [DLMClientTypes.StageValues]? = nil
        )
        {
            self.executeOperationOnScriptFailure = executeOperationOnScriptFailure
            self.executionHandler = executionHandler
            self.executionHandlerService = executionHandlerService
            self.executionTimeout = executionTimeout
            self.maximumRetryCount = maximumRetryCount
            self.stages = stages
        }
    }

}

extension DLMClientTypes {
    public enum SettablePolicyStateValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SettablePolicyStateValues] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SettablePolicyStateValues(rawValue: rawValue) ?? SettablePolicyStateValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.ShareRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAccounts = "TargetAccounts"
        case unshareInterval = "UnshareInterval"
        case unshareIntervalUnit = "UnshareIntervalUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAccounts = targetAccounts {
            var targetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccounts)
            for awsaccountid0 in targetAccounts {
                try targetAccountsContainer.encode(awsaccountid0)
            }
        }
        if let unshareInterval = self.unshareInterval {
            try encodeContainer.encode(unshareInterval, forKey: .unshareInterval)
        }
        if let unshareIntervalUnit = self.unshareIntervalUnit {
            try encodeContainer.encode(unshareIntervalUnit.rawValue, forKey: .unshareIntervalUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetAccounts)
        var targetAccountsDecoded0:[Swift.String]? = nil
        if let targetAccountsContainer = targetAccountsContainer {
            targetAccountsDecoded0 = [Swift.String]()
            for string0 in targetAccountsContainer {
                if let string0 = string0 {
                    targetAccountsDecoded0?.append(string0)
                }
            }
        }
        targetAccounts = targetAccountsDecoded0
        let unshareIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unshareInterval)
        unshareInterval = unshareIntervalDecoded
        let unshareIntervalUnitDecoded = try containerValues.decodeIfPresent(DLMClientTypes.RetentionIntervalUnitValues.self, forKey: .unshareIntervalUnit)
        unshareIntervalUnit = unshareIntervalUnitDecoded
    }
}

extension DLMClientTypes {
    /// [Custom snapshot policies only] Specifies a rule for sharing snapshots across Amazon Web Services accounts.
    public struct ShareRule: Swift.Equatable {
        /// The IDs of the Amazon Web Services accounts with which to share the snapshots.
        /// This member is required.
        public var targetAccounts: [Swift.String]?
        /// The period after which snapshots that are shared with other Amazon Web Services accounts are automatically unshared.
        public var unshareInterval: Swift.Int?
        /// The unit of time for the automatic unsharing interval.
        public var unshareIntervalUnit: DLMClientTypes.RetentionIntervalUnitValues?

        public init(
            targetAccounts: [Swift.String]? = nil,
            unshareInterval: Swift.Int? = nil,
            unshareIntervalUnit: DLMClientTypes.RetentionIntervalUnitValues? = nil
        )
        {
            self.targetAccounts = targetAccounts
            self.unshareInterval = unshareInterval
            self.unshareIntervalUnit = unshareIntervalUnit
        }
    }

}

extension DLMClientTypes {
    public enum StageValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case post
        case pre
        case sdkUnknown(Swift.String)

        public static var allCases: [StageValues] {
            return [
                .post,
                .pre,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .post: return "POST"
            case .pre: return "PRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageValues(rawValue: rawValue) ?? StageValues.sdkUnknown(rawValue)
        }
    }
}

extension DLMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DLMClientTypes {
    /// Specifies a tag for a resource.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case createInterval = "CreateInterval"
        case crossRegionCopyTargets = "CrossRegionCopyTargets"
        case description = "Description"
        case exclusions = "Exclusions"
        case executionRoleArn = "ExecutionRoleArn"
        case extendDeletion = "ExtendDeletion"
        case policyDetails = "PolicyDetails"
        case retainInterval = "RetainInterval"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createInterval = self.createInterval {
            try encodeContainer.encode(createInterval, forKey: .createInterval)
        }
        if let crossRegionCopyTargets = crossRegionCopyTargets {
            var crossRegionCopyTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyTargets)
            for crossregioncopytarget0 in crossRegionCopyTargets {
                try crossRegionCopyTargetsContainer.encode(crossregioncopytarget0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let exclusions = self.exclusions {
            try encodeContainer.encode(exclusions, forKey: .exclusions)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let extendDeletion = self.extendDeletion {
            try encodeContainer.encode(extendDeletion, forKey: .extendDeletion)
        }
        if let policyDetails = self.policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let retainInterval = self.retainInterval {
            try encodeContainer.encode(retainInterval, forKey: .retainInterval)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateLifecyclePolicyInput {

    static func urlPathProvider(_ value: UpdateLifecyclePolicyInput) -> Swift.String? {
        guard let policyId = value.policyId else {
            return nil
        }
        return "/policies/\(policyId.urlPercentEncoding())"
    }
}

public struct UpdateLifecyclePolicyInput: Swift.Equatable {
    /// [Default policies only] Indicates whether the policy should copy tags from the source resource to the snapshot or AMI.
    public var copyTags: Swift.Bool?
    /// [Default policies only] Specifies how often the policy should run and create snapshots or AMIs. The creation frequency can range from 1 to 7 days.
    public var createInterval: Swift.Int?
    /// [Default policies only] Specifies destination Regions for snapshot or AMI copies. You can specify up to 3 destination Regions. If you do not want to create cross-Region copies, omit this parameter.
    public var crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]?
    /// A description of the lifecycle policy.
    public var description: Swift.String?
    /// [Default policies only] Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs. The policy will not create snapshots or AMIs for target resources that match any of the specified exclusion parameters.
    public var exclusions: DLMClientTypes.Exclusions?
    /// The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by the lifecycle policy.
    public var executionRoleArn: Swift.String?
    /// [Default policies only] Defines the snapshot or AMI retention behavior for the policy if the source volume or instance is deleted, or if the policy enters the error, disabled, or deleted state. By default (ExtendDeletion=false):
    ///
    /// * If a source resource is deleted, Amazon Data Lifecycle Manager will continue to delete previously created snapshots or AMIs, up to but not including the last one, based on the specified retention period. If you want Amazon Data Lifecycle Manager to delete all snapshots or AMIs, including the last one, specify true.
    ///
    /// * If a policy enters the error, disabled, or deleted state, Amazon Data Lifecycle Manager stops deleting snapshots and AMIs. If you want Amazon Data Lifecycle Manager to continue deleting snapshots or AMIs, including the last one, if the policy enters one of these states, specify true.
    ///
    ///
    /// If you enable extended deletion (ExtendDeletion=true), you override both default behaviors simultaneously. Default: false
    public var extendDeletion: Swift.Bool?
    /// The configuration of the lifecycle policy. You cannot update the policy type or the resource type.
    public var policyDetails: DLMClientTypes.PolicyDetails?
    /// The identifier of the lifecycle policy.
    /// This member is required.
    public var policyId: Swift.String?
    /// [Default policies only] Specifies how long the policy should retain snapshots or AMIs before deleting them. The retention period can range from 2 to 14 days, but it must be greater than the creation frequency to ensure that the policy retains at least 1 snapshot or AMI at any given time.
    public var retainInterval: Swift.Int?
    /// The desired activation state of the lifecycle policy after creation.
    public var state: DLMClientTypes.SettablePolicyStateValues?

    public init(
        copyTags: Swift.Bool? = nil,
        createInterval: Swift.Int? = nil,
        crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]? = nil,
        description: Swift.String? = nil,
        exclusions: DLMClientTypes.Exclusions? = nil,
        executionRoleArn: Swift.String? = nil,
        extendDeletion: Swift.Bool? = nil,
        policyDetails: DLMClientTypes.PolicyDetails? = nil,
        policyId: Swift.String? = nil,
        retainInterval: Swift.Int? = nil,
        state: DLMClientTypes.SettablePolicyStateValues? = nil
    )
    {
        self.copyTags = copyTags
        self.createInterval = createInterval
        self.crossRegionCopyTargets = crossRegionCopyTargets
        self.description = description
        self.exclusions = exclusions
        self.executionRoleArn = executionRoleArn
        self.extendDeletion = extendDeletion
        self.policyDetails = policyDetails
        self.policyId = policyId
        self.retainInterval = retainInterval
        self.state = state
    }
}

struct UpdateLifecyclePolicyInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let state: DLMClientTypes.SettablePolicyStateValues?
    let description: Swift.String?
    let policyDetails: DLMClientTypes.PolicyDetails?
    let createInterval: Swift.Int?
    let retainInterval: Swift.Int?
    let copyTags: Swift.Bool?
    let extendDeletion: Swift.Bool?
    let crossRegionCopyTargets: [DLMClientTypes.CrossRegionCopyTarget]?
    let exclusions: DLMClientTypes.Exclusions?
}

extension UpdateLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyTags = "CopyTags"
        case createInterval = "CreateInterval"
        case crossRegionCopyTargets = "CrossRegionCopyTargets"
        case description = "Description"
        case exclusions = "Exclusions"
        case executionRoleArn = "ExecutionRoleArn"
        case extendDeletion = "ExtendDeletion"
        case policyDetails = "PolicyDetails"
        case retainInterval = "RetainInterval"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DLMClientTypes.SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let createIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createInterval)
        createInterval = createIntervalDecoded
        let retainIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retainInterval)
        retainInterval = retainIntervalDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let extendDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extendDeletion)
        extendDeletion = extendDeletionDecoded
        let crossRegionCopyTargetsContainer = try containerValues.decodeIfPresent([DLMClientTypes.CrossRegionCopyTarget?].self, forKey: .crossRegionCopyTargets)
        var crossRegionCopyTargetsDecoded0:[DLMClientTypes.CrossRegionCopyTarget]? = nil
        if let crossRegionCopyTargetsContainer = crossRegionCopyTargetsContainer {
            crossRegionCopyTargetsDecoded0 = [DLMClientTypes.CrossRegionCopyTarget]()
            for structure0 in crossRegionCopyTargetsContainer {
                if let structure0 = structure0 {
                    crossRegionCopyTargetsDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyTargets = crossRegionCopyTargetsDecoded0
        let exclusionsDecoded = try containerValues.decodeIfPresent(DLMClientTypes.Exclusions.self, forKey: .exclusions)
        exclusions = exclusionsDecoded
    }
}

extension UpdateLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLifecyclePolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
