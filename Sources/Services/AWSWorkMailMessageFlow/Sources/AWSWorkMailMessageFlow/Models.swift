//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// The requested email message is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetRawMessageContentInput: Swift.Sendable {
    /// The identifier of the email message to retrieve.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

public struct GetRawMessageContentOutput: Swift.Sendable {
    /// The raw content of the email message, in MIME format.
    /// This member is required.
    public var messageContent: Smithy.ByteStream?

    public init(
        messageContent: Smithy.ByteStream? = nil
    )
    {
        self.messageContent = messageContent
    }
}

/// WorkMail could not access the updated email content. Possible reasons:
///
/// * You made the request in a region other than your S3 bucket region.
///
/// * The [S3 bucket owner](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-owner-condition.html) is not the same as the calling AWS account.
///
/// * You have an incomplete or missing S3 bucket policy. For more information about policies, see [ Updating message content with AWS Lambda ](https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html) in the WorkMail Administrator Guide.
public struct InvalidContentLocation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidContentLocation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested email is not eligible for update. This is usually the case for a redirected email.
public struct MessageFrozen: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MessageFrozen" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested email could not be updated due to an error in the MIME content. Check the error message for more information about what caused the error.
public struct MessageRejected: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MessageRejected" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailMessageFlowClientTypes {

    /// Amazon S3 object representing the updated message content, in MIME format. The region for the S3 bucket containing the S3 object must match the region used for WorkMail operations. Also, for WorkMail to process an S3 object, it must have permission to access that object. For more information, see [ Updating message content with AWS Lambda](https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html).
    public struct S3Reference: Swift.Sendable {
        /// The S3 bucket name.
        /// This member is required.
        public var bucket: Swift.String?
        /// The S3 key object name.
        /// This member is required.
        public var key: Swift.String?
        /// If you enable versioning for the bucket, you can specify the object version.
        public var objectVersion: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.objectVersion = objectVersion
        }
    }
}

extension WorkMailMessageFlowClientTypes {

    /// Provides the MIME content of the updated email message as an S3 object. All MIME content must meet the following criteria:
    ///
    /// * Each part of a multipart MIME message must be formatted properly.
    ///
    /// * Attachments must be of a content type that Amazon SES supports. For more information, see [Unsupported Attachment Types](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mime-types-appendix.html).
    ///
    /// * If any of the MIME parts in a message contain content that is outside of the 7-bit ASCII character range, we recommend encoding that content.
    ///
    /// * Per [RFC 5321](https://tools.ietf.org/html/rfc5321#section-4.5.3.1.6), the maximum length of each line of text, including the , must not exceed 1,000 characters.
    ///
    /// * The message must contain all the required header fields. Check the returned error message for more information.
    ///
    /// * The value of immutable headers must remain unchanged. Check the returned error message for more information.
    ///
    /// * Certain unique headers can only appear once. Check the returned error message for more information.
    public struct RawMessageContent: Swift.Sendable {
        /// The S3 reference of an email message.
        /// This member is required.
        public var s3Reference: WorkMailMessageFlowClientTypes.S3Reference?

        public init(
            s3Reference: WorkMailMessageFlowClientTypes.S3Reference? = nil
        )
        {
            self.s3Reference = s3Reference
        }
    }
}

public struct PutRawMessageContentInput: Swift.Sendable {
    /// Describes the raw message content of the updated email message.
    /// This member is required.
    public var content: WorkMailMessageFlowClientTypes.RawMessageContent?
    /// The identifier of the email message being updated.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        content: WorkMailMessageFlowClientTypes.RawMessageContent? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.content = content
        self.messageId = messageId
    }
}

public struct PutRawMessageContentOutput: Swift.Sendable {

    public init() { }
}

extension GetRawMessageContentInput {

    static func urlPathProvider(_ value: GetRawMessageContentInput) -> Swift.String? {
        guard let messageId = value.messageId else {
            return nil
        }
        return "/messages/\(messageId.urlPercentEncoding())"
    }
}

extension PutRawMessageContentInput {

    static func urlPathProvider(_ value: PutRawMessageContentInput) -> Swift.String? {
        guard let messageId = value.messageId else {
            return nil
        }
        return "/messages/\(messageId.urlPercentEncoding())"
    }
}

extension PutRawMessageContentInput {

    static func write(value: PutRawMessageContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: WorkMailMessageFlowClientTypes.RawMessageContent.write(value:to:))
    }
}

extension GetRawMessageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRawMessageContentOutput {
        var value = GetRawMessageContentOutput()
        switch httpResponse.body {
        case .data(let data):
            value.messageContent = .data(data)
        case .stream(let stream):
            value.messageContent = .stream(stream)
        case .noStream:
            value.messageContent = nil
        }
        return value
    }
}

extension PutRawMessageContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRawMessageContentOutput {
        return PutRawMessageContentOutput()
    }
}

enum GetRawMessageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRawMessageContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidContentLocation": return try InvalidContentLocation.makeError(baseError: baseError)
            case "MessageFrozen": return try MessageFrozen.makeError(baseError: baseError)
            case "MessageRejected": return try MessageRejected.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MessageRejected {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MessageRejected {
        let reader = baseError.errorBodyReader
        var value = MessageRejected()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MessageFrozen {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MessageFrozen {
        let reader = baseError.errorBodyReader
        var value = MessageFrozen()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidContentLocation {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidContentLocation {
        let reader = baseError.errorBodyReader
        var value = InvalidContentLocation()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkMailMessageFlowClientTypes.RawMessageContent {

    static func write(value: WorkMailMessageFlowClientTypes.RawMessageContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Reference"].write(value.s3Reference, with: WorkMailMessageFlowClientTypes.S3Reference.write(value:to:))
    }
}

extension WorkMailMessageFlowClientTypes.S3Reference {

    static func write(value: WorkMailMessageFlowClientTypes.S3Reference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
        try writer["objectVersion"].write(value.objectVersion)
    }
}

public enum WorkMailMessageFlowClientTypes {}
