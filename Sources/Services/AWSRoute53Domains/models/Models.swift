// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptDomainTransferFromAnotherAwsAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The AcceptDomainTransferFromAnotherAwsAccount request includes the following elements.
public struct AcceptDomainTransferFromAnotherAwsAccountInput: Swift.Equatable {
    /// The name of the domain that was specified when another Amazon Web Services account submitted a [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var domainName: Swift.String?
    /// The password that was returned by the [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var password: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.password = password
    }
}

struct AcceptDomainTransferFromAnotherAwsAccountInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let password: Swift.String?
}

extension AcceptDomainTransferFromAnotherAwsAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptDomainTransferFromAnotherAwsAccountOutputError: Swift.Error, Swift.Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The AcceptDomainTransferFromAnotherAwsAccount response includes the following element.
public struct AcceptDomainTransferFromAnotherAwsAccountOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension AcceptDomainTransferFromAnotherAwsAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AssociateDelegationSignerToDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case signingAttributes = "SigningAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let signingAttributes = self.signingAttributes {
            try encodeContainer.encode(signingAttributes, forKey: .signingAttributes)
        }
    }
}

extension AssociateDelegationSignerToDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDelegationSignerToDomainInput: Swift.Equatable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The information about a key, including the algorithm, public key-value, and flags.
    /// This member is required.
    public var signingAttributes: Route53DomainsClientTypes.DnssecSigningAttributes?

    public init (
        domainName: Swift.String? = nil,
        signingAttributes: Route53DomainsClientTypes.DnssecSigningAttributes? = nil
    )
    {
        self.domainName = domainName
        self.signingAttributes = signingAttributes
    }
}

struct AssociateDelegationSignerToDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let signingAttributes: Route53DomainsClientTypes.DnssecSigningAttributes?
}

extension AssociateDelegationSignerToDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case signingAttributes = "SigningAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let signingAttributesDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.DnssecSigningAttributes.self, forKey: .signingAttributes)
        signingAttributes = signingAttributesDecoded
    }
}

extension AssociateDelegationSignerToDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDelegationSignerToDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DnssecLimitExceeded" : self = .dnssecLimitExceeded(try DnssecLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateDelegationSignerToDomainOutputError: Swift.Error, Swift.Equatable {
    case dnssecLimitExceeded(DnssecLimitExceeded)
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDelegationSignerToDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateDelegationSignerToDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct AssociateDelegationSignerToDomainOutputResponse: Swift.Equatable {
    /// The identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct AssociateDelegationSignerToDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension AssociateDelegationSignerToDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension Route53DomainsClientTypes.BillingRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billDate = "BillDate"
        case domainName = "DomainName"
        case invoiceId = "InvoiceId"
        case operation = "Operation"
        case price = "Price"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billDate = self.billDate {
            try encodeContainer.encodeTimestamp(billDate, format: .epochSeconds, forKey: .billDate)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let invoiceId = self.invoiceId {
            try encodeContainer.encode(invoiceId, forKey: .invoiceId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if price != 0.0 {
            try encodeContainer.encode(price, forKey: .price)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.OperationType.self, forKey: .operation)
        operation = operationDecoded
        let invoiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invoiceId)
        invoiceId = invoiceIdDecoded
        let billDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .billDate)
        billDate = billDateDecoded
        let priceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .price) ?? 0.0
        price = priceDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information for one billing record.
    public struct BillingRecord: Swift.Equatable {
        /// The date that the operation was billed, in Unix format.
        public var billDate: ClientRuntime.Date?
        /// The name of the domain that the billing record applies to. If the domain name contains characters other than a-z, 0-9, and - (hyphen), such as an internationalized domain name, then this value is in Punycode. For more information, see [DNS Domain Name Format](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html) in the Amazon Route 53 Developer Guide.
        public var domainName: Swift.String?
        /// The ID of the invoice that is associated with the billing record.
        public var invoiceId: Swift.String?
        /// The operation that you were charged for.
        public var operation: Route53DomainsClientTypes.OperationType?
        /// The price that you were charged for the operation, in US dollars. Example value: 12.0
        public var price: Swift.Double

        public init (
            billDate: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            invoiceId: Swift.String? = nil,
            operation: Route53DomainsClientTypes.OperationType? = nil,
            price: Swift.Double = 0.0
        )
        {
            self.billDate = billDate
            self.domainName = domainName
            self.invoiceId = invoiceId
            self.operation = operation
            self.price = price
        }
    }

}

extension CancelDomainTransferToAnotherAwsAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension CancelDomainTransferToAnotherAwsAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The CancelDomainTransferToAnotherAwsAccount request includes the following element.
public struct CancelDomainTransferToAnotherAwsAccountInput: Swift.Equatable {
    /// The name of the domain for which you want to cancel the transfer to another Amazon Web Services account.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct CancelDomainTransferToAnotherAwsAccountInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension CancelDomainTransferToAnotherAwsAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension CancelDomainTransferToAnotherAwsAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDomainTransferToAnotherAwsAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelDomainTransferToAnotherAwsAccountOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDomainTransferToAnotherAwsAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelDomainTransferToAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The CancelDomainTransferToAnotherAwsAccount response includes the following element.
public struct CancelDomainTransferToAnotherAwsAccountOutputResponse: Swift.Equatable {
    /// The identifier that TransferDomainToAnotherAwsAccount returned to track the progress of the request. Because the transfer request was canceled, the value is no longer valid, and you can't use GetOperationDetail to query the operation status.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CancelDomainTransferToAnotherAwsAccountOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension CancelDomainTransferToAnotherAwsAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CheckDomainAvailabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case idnLangCode = "IdnLangCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let idnLangCode = self.idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
    }
}

extension CheckDomainAvailabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The CheckDomainAvailability request contains the following elements.
public struct CheckDomainAvailabilityInput: Swift.Equatable {
    /// The name of the domain that you want to get availability for. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html). For more information, see [Formatting Internationalized Domain Names](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns).
    /// This member is required.
    public var domainName: Swift.String?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        idnLangCode: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.idnLangCode = idnLangCode
    }
}

struct CheckDomainAvailabilityInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let idnLangCode: Swift.String?
}

extension CheckDomainAvailabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case idnLangCode = "IdnLangCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
    }
}

extension CheckDomainAvailabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckDomainAvailabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CheckDomainAvailabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckDomainAvailabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CheckDomainAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availability = output.availability
        } else {
            self.availability = nil
        }
    }
}

/// The CheckDomainAvailability response includes the following elements.
public struct CheckDomainAvailabilityOutputResponse: Swift.Equatable {
    /// Whether the domain name is available for registering. You can register only domains designated as AVAILABLE. Valid values: AVAILABLE The domain name is available. AVAILABLE_RESERVED The domain name is reserved under specific conditions. AVAILABLE_PREORDER The domain name is available and can be preordered. DONT_KNOW The TLD registry didn't reply with a definitive answer about whether the domain name is available. Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance. Try again later. PENDING The TLD registry didn't return a response in the expected amount of time. When the response is delayed, it usually takes just a few extra seconds. You can resubmit the request immediately. RESERVED The domain name has been reserved for another person or organization. UNAVAILABLE The domain name is not available. UNAVAILABLE_PREMIUM The domain name is not available. UNAVAILABLE_RESTRICTED The domain name is forbidden.
    public var availability: Route53DomainsClientTypes.DomainAvailability?

    public init (
        availability: Route53DomainsClientTypes.DomainAvailability? = nil
    )
    {
        self.availability = availability
    }
}

struct CheckDomainAvailabilityOutputResponseBody: Swift.Equatable {
    let availability: Route53DomainsClientTypes.DomainAvailability?
}

extension CheckDomainAvailabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availability = "Availability"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.DomainAvailability.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension CheckDomainTransferabilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckDomainTransferabilityInput(domainName: \(Swift.String(describing: domainName)), authCode: \"CONTENT_REDACTED\")"}
}

extension CheckDomainTransferabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode = "AuthCode"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = self.authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension CheckDomainTransferabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The CheckDomainTransferability request contains the following elements.
public struct CheckDomainTransferabilityInput: Swift.Equatable {
    /// If the registrar for the top-level domain (TLD) requires an authorization code to transfer the domain, the code that you got from the current registrar for the domain.
    public var authCode: Swift.String?
    /// The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        authCode: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.authCode = authCode
        self.domainName = domainName
    }
}

struct CheckDomainTransferabilityInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let authCode: Swift.String?
}

extension CheckDomainTransferabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode = "AuthCode"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
    }
}

extension CheckDomainTransferabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckDomainTransferabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CheckDomainTransferabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckDomainTransferabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CheckDomainTransferabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transferability = output.transferability
        } else {
            self.transferability = nil
        }
    }
}

/// The CheckDomainTransferability response includes the following elements.
public struct CheckDomainTransferabilityOutputResponse: Swift.Equatable {
    /// A complex type that contains information about whether the specified domain can be transferred to Route 53.
    public var transferability: Route53DomainsClientTypes.DomainTransferability?

    public init (
        transferability: Route53DomainsClientTypes.DomainTransferability? = nil
    )
    {
        self.transferability = transferability
    }
}

struct CheckDomainTransferabilityOutputResponseBody: Swift.Equatable {
    let transferability: Route53DomainsClientTypes.DomainTransferability?
}

extension CheckDomainTransferabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferability = "Transferability"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferabilityDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.DomainTransferability.self, forKey: .transferability)
        transferability = transferabilityDecoded
    }
}

extension Route53DomainsClientTypes.Consent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency = "Currency"
        case maxPrice = "MaxPrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if maxPrice != 0.0 {
            try encodeContainer.encode(maxPrice, forKey: .maxPrice)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxPriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxPrice) ?? 0.0
        maxPrice = maxPriceDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Customer's consent for the owner change request.
    public struct Consent: Swift.Equatable {
        /// Currency for the MaxPrice.
        /// This member is required.
        public var currency: Swift.String?
        /// Maximum amount the customer agreed to accept.
        /// This member is required.
        public var maxPrice: Swift.Double

        public init (
            currency: Swift.String? = nil,
            maxPrice: Swift.Double = 0.0
        )
        {
            self.currency = currency
            self.maxPrice = maxPrice
        }
    }

}

extension Route53DomainsClientTypes.ContactDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressLine1 = "AddressLine1"
        case addressLine2 = "AddressLine2"
        case city = "City"
        case contactType = "ContactType"
        case countryCode = "CountryCode"
        case email = "Email"
        case extraParams = "ExtraParams"
        case fax = "Fax"
        case firstName = "FirstName"
        case lastName = "LastName"
        case organizationName = "OrganizationName"
        case phoneNumber = "PhoneNumber"
        case state = "State"
        case zipCode = "ZipCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressLine1 = self.addressLine1 {
            try encodeContainer.encode(addressLine1, forKey: .addressLine1)
        }
        if let addressLine2 = self.addressLine2 {
            try encodeContainer.encode(addressLine2, forKey: .addressLine2)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let contactType = self.contactType {
            try encodeContainer.encode(contactType.rawValue, forKey: .contactType)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode.rawValue, forKey: .countryCode)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let extraParams = extraParams {
            var extraParamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extraParams)
            for extraparam0 in extraParams {
                try extraParamsContainer.encode(extraparam0)
            }
        }
        if let fax = self.fax {
            try encodeContainer.encode(fax, forKey: .fax)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let organizationName = self.organizationName {
            try encodeContainer.encode(organizationName, forKey: .organizationName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let zipCode = self.zipCode {
            try encodeContainer.encode(zipCode, forKey: .zipCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let contactTypeDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactType.self, forKey: .contactType)
        contactType = contactTypeDecoded
        let organizationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let addressLine1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine1)
        addressLine1 = addressLine1Decoded
        let addressLine2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine2)
        addressLine2 = addressLine2Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.CountryCode.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let zipCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zipCode)
        zipCode = zipCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let faxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fax)
        fax = faxDecoded
        let extraParamsContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.ExtraParam?].self, forKey: .extraParams)
        var extraParamsDecoded0:[Route53DomainsClientTypes.ExtraParam]? = nil
        if let extraParamsContainer = extraParamsContainer {
            extraParamsDecoded0 = [Route53DomainsClientTypes.ExtraParam]()
            for structure0 in extraParamsContainer {
                if let structure0 = structure0 {
                    extraParamsDecoded0?.append(structure0)
                }
            }
        }
        extraParams = extraParamsDecoded0
    }
}

extension Route53DomainsClientTypes.ContactDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension Route53DomainsClientTypes {
    /// ContactDetail includes the following elements.
    public struct ContactDetail: Swift.Equatable {
        /// First line of the contact's address.
        public var addressLine1: Swift.String?
        /// Second line of contact's address, if any.
        public var addressLine2: Swift.String?
        /// The city of the contact's address.
        public var city: Swift.String?
        /// Indicates whether the contact is a person, company, association, or public organization. Note the following:
        ///
        /// * If you specify a value other than PERSON, you must also specify a value for OrganizationName.
        ///
        /// * For some TLDs, the privacy protection available depends on the value that you specify for Contact Type. For the privacy protection settings for your TLD, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide
        ///
        /// * For .es domains, the value of ContactType must be PERSON for all three contacts.
        public var contactType: Route53DomainsClientTypes.ContactType?
        /// Code for the country of the contact's address.
        public var countryCode: Route53DomainsClientTypes.CountryCode?
        /// Email address of the contact.
        public var email: Swift.String?
        /// A list of name-value pairs for parameters required by certain top-level domains.
        public var extraParams: [Route53DomainsClientTypes.ExtraParam]?
        /// Fax number of the contact. Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code]". For example, a US phone number might appear as "+1.1234567890".
        public var fax: Swift.String?
        /// First name of contact.
        public var firstName: Swift.String?
        /// Last name of contact.
        public var lastName: Swift.String?
        /// Name of the organization for contact types other than PERSON.
        public var organizationName: Swift.String?
        /// The phone number of the contact. Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code>]". For example, a US phone number might appear as "+1.1234567890".
        public var phoneNumber: Swift.String?
        /// The state or province of the contact's city.
        public var state: Swift.String?
        /// The zip or postal code of the contact's address.
        public var zipCode: Swift.String?

        public init (
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            city: Swift.String? = nil,
            contactType: Route53DomainsClientTypes.ContactType? = nil,
            countryCode: Route53DomainsClientTypes.CountryCode? = nil,
            email: Swift.String? = nil,
            extraParams: [Route53DomainsClientTypes.ExtraParam]? = nil,
            fax: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            organizationName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            state: Swift.String? = nil,
            zipCode: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.city = city
            self.contactType = contactType
            self.countryCode = countryCode
            self.email = email
            self.extraParams = extraParams
            self.fax = fax
            self.firstName = firstName
            self.lastName = lastName
            self.organizationName = organizationName
            self.phoneNumber = phoneNumber
            self.state = state
            self.zipCode = zipCode
        }
    }

}

extension Route53DomainsClientTypes {
    public enum ContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case association
        case company
        case person
        case publicBody
        case reseller
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .association,
                .company,
                .person,
                .publicBody,
                .reseller,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .association: return "ASSOCIATION"
            case .company: return "COMPANY"
            case .person: return "PERSON"
            case .publicBody: return "PUBLIC_BODY"
            case .reseller: return "RESELLER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes {
    public enum CountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ac
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case ax
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case bq
        case br
        case bs
        case bt
        case bv
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gf
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gp
        case gq
        case gr
        case gs
        case gt
        case gu
        case gw
        case gy
        case hk
        case hm
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kp
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mq
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case nf
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case ps
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case ss
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tf
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tp
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [CountryCode] {
            return [
                .ac,
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .ax,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .bq,
                .br,
                .bs,
                .bt,
                .bv,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gf,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gp,
                .gq,
                .gr,
                .gs,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hm,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kp,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mq,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .nf,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .ps,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .ss,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tf,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tp,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ac: return "AC"
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .ax: return "AX"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .bq: return "BQ"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bv: return "BV"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gf: return "GF"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gp: return "GP"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gs: return "GS"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hm: return "HM"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kp: return "KP"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mq: return "MQ"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .nf: return "NF"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .ps: return "PS"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .ss: return "SS"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tf: return "TF"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tp: return "TP"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CountryCode(rawValue: rawValue) ?? CountryCode.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// Name of the domain to be deleted.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension DeleteDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DeleteTagsForDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case tagsToDelete = "TagsToDelete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let tagsToDelete = tagsToDelete {
            var tagsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToDelete)
            for tagkey0 in tagsToDelete {
                try tagsToDeleteContainer.encode(tagkey0)
            }
        }
    }
}

extension DeleteTagsForDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The DeleteTagsForDomainRequest includes the following elements.
public struct DeleteTagsForDomainInput: Swift.Equatable {
    /// The domain for which you want to delete one or more tags.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of tag keys to delete.
    /// This member is required.
    public var tagsToDelete: [Swift.String]?

    public init (
        domainName: Swift.String? = nil,
        tagsToDelete: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToDelete = tagsToDelete
    }
}

struct DeleteTagsForDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let tagsToDelete: [Swift.String]?
}

extension DeleteTagsForDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case tagsToDelete = "TagsToDelete"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let tagsToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagsToDelete)
        var tagsToDeleteDecoded0:[Swift.String]? = nil
        if let tagsToDeleteContainer = tagsToDeleteContainer {
            tagsToDeleteDecoded0 = [Swift.String]()
            for string0 in tagsToDeleteContainer {
                if let string0 = string0 {
                    tagsToDeleteDecoded0?.append(string0)
                }
            }
        }
        tagsToDelete = tagsToDeleteDecoded0
    }
}

extension DeleteTagsForDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsForDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTagsForDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsForDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsForDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisableDomainAutoRenewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension DisableDomainAutoRenewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableDomainAutoRenewInput: Swift.Equatable {
    /// The name of the domain that you want to disable automatic renewal for.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisableDomainAutoRenewInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension DisableDomainAutoRenewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisableDomainAutoRenewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDomainAutoRenewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableDomainAutoRenewOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDomainAutoRenewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableDomainAutoRenewOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisableDomainTransferLockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension DisableDomainTransferLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The DisableDomainTransferLock request includes the following element.
public struct DisableDomainTransferLockInput: Swift.Equatable {
    /// The name of the domain that you want to remove the transfer lock for.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DisableDomainTransferLockInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension DisableDomainTransferLockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisableDomainTransferLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDomainTransferLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableDomainTransferLockOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDomainTransferLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableDomainTransferLockOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The DisableDomainTransferLock response includes the following element.
public struct DisableDomainTransferLockOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DisableDomainTransferLockOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension DisableDomainTransferLockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DisassociateDelegationSignerFromDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DisassociateDelegationSignerFromDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDelegationSignerFromDomainInput: Swift.Equatable {
    /// Name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// An internal identification number assigned to each DS record after it’s created. You can retrieve it as part of DNSSEC information returned by [GetDomainDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetDomainDetail.html).
    /// This member is required.
    public var id: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.id = id
    }
}

struct DisassociateDelegationSignerFromDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let id: Swift.String?
}

extension DisassociateDelegationSignerFromDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DisassociateDelegationSignerFromDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDelegationSignerFromDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateDelegationSignerFromDomainOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDelegationSignerFromDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateDelegationSignerFromDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DisassociateDelegationSignerFromDomainOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DisassociateDelegationSignerFromDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension DisassociateDelegationSignerFromDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension Route53DomainsClientTypes.DnssecKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "Algorithm"
        case digest = "Digest"
        case digestType = "DigestType"
        case flags = "Flags"
        case id = "Id"
        case keyTag = "KeyTag"
        case publicKey = "PublicKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = self.algorithm {
            try encodeContainer.encode(algorithm, forKey: .algorithm)
        }
        if let digest = self.digest {
            try encodeContainer.encode(digest, forKey: .digest)
        }
        if let digestType = self.digestType {
            try encodeContainer.encode(digestType, forKey: .digestType)
        }
        if let flags = self.flags {
            try encodeContainer.encode(flags, forKey: .flags)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let keyTag = self.keyTag {
            try encodeContainer.encode(keyTag, forKey: .keyTag)
        }
        if let publicKey = self.publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let flagsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .flags)
        flags = flagsDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let digestTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .digestType)
        digestType = digestTypeDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let keyTagDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyTag)
        keyTag = keyTagDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information about the DNSSEC key. You get this from your DNS provider and then give it to Route 53 (by using [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html)) to pass it to the registry to establish the chain of trust.
    public struct DnssecKey: Swift.Equatable {
        /// The number of the public key’s cryptographic algorithm according to an [IANA](https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml) assignment. If Route 53 is your DNS service, set this to 13. For more information about enabling DNSSEC signing, see [Enabling DNSSEC signing and establishing a chain of trust](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html).
        public var algorithm: Swift.Int?
        /// The delegation signer digest. Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records.
        public var digest: Swift.String?
        /// The number of the DS digest algorithm according to an IANA assignment. For more information, see [IANA](https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml) for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms.
        public var digestType: Swift.Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.
        public var flags: Swift.Int?
        /// An ID assigned to each DS record created by [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html).
        public var id: Swift.String?
        /// A numeric identification of the DNSKEY record referred to by this DS record.
        public var keyTag: Swift.Int?
        /// The base64-encoded public key part of the key pair that is passed to the registry .
        public var publicKey: Swift.String?

        public init (
            algorithm: Swift.Int? = nil,
            digest: Swift.String? = nil,
            digestType: Swift.Int? = nil,
            flags: Swift.Int? = nil,
            id: Swift.String? = nil,
            keyTag: Swift.Int? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.digest = digest
            self.digestType = digestType
            self.flags = flags
            self.id = id
            self.keyTag = keyTag
            self.publicKey = publicKey
        }
    }

}

extension DnssecLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DnssecLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error is returned if you call AssociateDelegationSignerToDomain when the specified domain has reached the maximum number of DS records. You can't add any additional DS records unless you delete an existing one first.
public struct DnssecLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DnssecLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension DnssecLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53DomainsClientTypes.DnssecSigningAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "Algorithm"
        case flags = "Flags"
        case publicKey = "PublicKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = self.algorithm {
            try encodeContainer.encode(algorithm, forKey: .algorithm)
        }
        if let flags = self.flags {
            try encodeContainer.encode(flags, forKey: .flags)
        }
        if let publicKey = self.publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let flagsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .flags)
        flags = flagsDecoded
        let publicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information about a delegation signer (DS) record that was created in the registry by [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html).
    public struct DnssecSigningAttributes: Swift.Equatable {
        /// Algorithm which was used to generate the digest from the public key.
        public var algorithm: Swift.Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.
        public var flags: Swift.Int?
        /// The base64-encoded public key part of the key pair that is passed to the registry.
        public var publicKey: Swift.String?

        public init (
            algorithm: Swift.Int? = nil,
            flags: Swift.Int? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.flags = flags
            self.publicKey = publicKey
        }
    }

}

extension Route53DomainsClientTypes {
    public enum DomainAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case availablePreorder
        case availableReserved
        case dontKnow
        case reserved
        case unavailable
        case unavailablePremium
        case unavailableRestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainAvailability] {
            return [
                .available,
                .availablePreorder,
                .availableReserved,
                .dontKnow,
                .reserved,
                .unavailable,
                .unavailablePremium,
                .unavailableRestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .availablePreorder: return "AVAILABLE_PREORDER"
            case .availableReserved: return "AVAILABLE_RESERVED"
            case .dontKnow: return "DONT_KNOW"
            case .reserved: return "RESERVED"
            case .unavailable: return "UNAVAILABLE"
            case .unavailablePremium: return "UNAVAILABLE_PREMIUM"
            case .unavailableRestricted: return "UNAVAILABLE_RESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainAvailability(rawValue: rawValue) ?? DomainAvailability.sdkUnknown(rawValue)
        }
    }
}

extension DomainLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DomainLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of domains has exceeded the allowed threshold for the account.
public struct DomainLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The number of domains has exceeded the allowed threshold for the account.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DomainLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension DomainLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53DomainsClientTypes.DomainPrice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeOwnershipPrice = "ChangeOwnershipPrice"
        case name = "Name"
        case registrationPrice = "RegistrationPrice"
        case renewalPrice = "RenewalPrice"
        case restorationPrice = "RestorationPrice"
        case transferPrice = "TransferPrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeOwnershipPrice = self.changeOwnershipPrice {
            try encodeContainer.encode(changeOwnershipPrice, forKey: .changeOwnershipPrice)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let registrationPrice = self.registrationPrice {
            try encodeContainer.encode(registrationPrice, forKey: .registrationPrice)
        }
        if let renewalPrice = self.renewalPrice {
            try encodeContainer.encode(renewalPrice, forKey: .renewalPrice)
        }
        if let restorationPrice = self.restorationPrice {
            try encodeContainer.encode(restorationPrice, forKey: .restorationPrice)
        }
        if let transferPrice = self.transferPrice {
            try encodeContainer.encode(transferPrice, forKey: .transferPrice)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let registrationPriceDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.PriceWithCurrency.self, forKey: .registrationPrice)
        registrationPrice = registrationPriceDecoded
        let transferPriceDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.PriceWithCurrency.self, forKey: .transferPrice)
        transferPrice = transferPriceDecoded
        let renewalPriceDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.PriceWithCurrency.self, forKey: .renewalPrice)
        renewalPrice = renewalPriceDecoded
        let changeOwnershipPriceDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.PriceWithCurrency.self, forKey: .changeOwnershipPrice)
        changeOwnershipPrice = changeOwnershipPriceDecoded
        let restorationPriceDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.PriceWithCurrency.self, forKey: .restorationPrice)
        restorationPrice = restorationPriceDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information about the domain price associated with a TLD.
    public struct DomainPrice: Swift.Equatable {
        /// The price for changing domain ownership.
        public var changeOwnershipPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The name of the TLD for which the prices apply.
        public var name: Swift.String?
        /// The price for domain registration with Route 53.
        public var registrationPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for renewing domain registration with Route 53.
        public var renewalPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for restoring the domain with Route 53.
        public var restorationPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for transferring the domain registration to Route 53.
        public var transferPrice: Route53DomainsClientTypes.PriceWithCurrency?

        public init (
            changeOwnershipPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            name: Swift.String? = nil,
            registrationPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            renewalPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            restorationPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            transferPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil
        )
        {
            self.changeOwnershipPrice = changeOwnershipPrice
            self.name = name
            self.registrationPrice = registrationPrice
            self.renewalPrice = renewalPrice
            self.restorationPrice = restorationPrice
            self.transferPrice = transferPrice
        }
    }

}

extension Route53DomainsClientTypes.DomainSuggestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availability = "Availability"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availability = self.availability {
            try encodeContainer.encode(availability, forKey: .availability)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let availabilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information about one suggested domain name.
    public struct DomainSuggestion: Swift.Equatable {
        /// Whether the domain name is available for registering. You can register only the domains that are designated as AVAILABLE. Valid values: AVAILABLE The domain name is available. AVAILABLE_RESERVED The domain name is reserved under specific conditions. AVAILABLE_PREORDER The domain name is available and can be preordered. DONT_KNOW The TLD registry didn't reply with a definitive answer about whether the domain name is available. Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance. Try again later. PENDING The TLD registry didn't return a response in the expected amount of time. When the response is delayed, it usually takes just a few extra seconds. You can resubmit the request immediately. RESERVED The domain name has been reserved for another person or organization. UNAVAILABLE The domain name is not available. UNAVAILABLE_PREMIUM The domain name is not available. UNAVAILABLE_RESTRICTED The domain name is forbidden.
        public var availability: Swift.String?
        /// A suggested domain name.
        public var domainName: Swift.String?

        public init (
            availability: Swift.String? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.availability = availability
            self.domainName = domainName
        }
    }

}

extension Route53DomainsClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case expiry = "Expiry"
        case transferLock = "TransferLock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = self.autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let expiry = self.expiry {
            try encodeContainer.encodeTimestamp(expiry, format: .epochSeconds, forKey: .expiry)
        }
        if let transferLock = self.transferLock {
            try encodeContainer.encode(transferLock, forKey: .transferLock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let transferLockDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transferLock)
        transferLock = transferLockDecoded
        let expiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Summary information about one domain.
    public struct DomainSummary: Swift.Equatable {
        /// Indicates whether the domain is automatically renewed upon expiration.
        public var autoRenew: Swift.Bool?
        /// The name of the domain that the summary information applies to.
        public var domainName: Swift.String?
        /// Expiration date of the domain in Unix time format and Coordinated Universal Time (UTC).
        public var expiry: ClientRuntime.Date?
        /// Indicates whether a domain is locked from unauthorized transfer to another party.
        public var transferLock: Swift.Bool?

        public init (
            autoRenew: Swift.Bool? = nil,
            domainName: Swift.String? = nil,
            expiry: ClientRuntime.Date? = nil,
            transferLock: Swift.Bool? = nil
        )
        {
            self.autoRenew = autoRenew
            self.domainName = domainName
            self.expiry = expiry
            self.transferLock = transferLock
        }
    }

}

extension Route53DomainsClientTypes.DomainTransferability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferable = "Transferable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transferable = self.transferable {
            try encodeContainer.encode(transferable.rawValue, forKey: .transferable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferableDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.Transferable.self, forKey: .transferable)
        transferable = transferableDecoded
    }
}

extension Route53DomainsClientTypes {
    /// A complex type that contains information about whether the specified domain can be transferred to Route 53.
    public struct DomainTransferability: Swift.Equatable {
        /// Whether the domain name can be transferred to Route 53. You can transfer only domains that have a value of TRANSFERABLE or Transferable. Valid values: TRANSFERABLE The domain name can be transferred to Route 53. UNTRANSFERRABLE The domain name can't be transferred to Route 53. DONT_KNOW Reserved for future use. DOMAIN_IN_OWN_ACCOUNT The domain already exists in the current Amazon Web Services account. DOMAIN_IN_ANOTHER_ACCOUNT the domain exists in another Amazon Web Services account. PREMIUM_DOMAIN Premium domain transfer is not supported.
        public var transferable: Route53DomainsClientTypes.Transferable?

        public init (
            transferable: Route53DomainsClientTypes.Transferable? = nil
        )
        {
            self.transferable = transferable
        }
    }

}

extension DuplicateRequest {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is already in progress for the domain.
public struct DuplicateRequest: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The request is already in progress for the domain.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableDomainAutoRenewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension EnableDomainAutoRenewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableDomainAutoRenewInput: Swift.Equatable {
    /// The name of the domain that you want to enable automatic renewal for.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct EnableDomainAutoRenewInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension EnableDomainAutoRenewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension EnableDomainAutoRenewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDomainAutoRenewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableDomainAutoRenewOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDomainAutoRenewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableDomainAutoRenewOutputResponse: Swift.Equatable {

    public init () { }
}

extension EnableDomainTransferLockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension EnableDomainTransferLockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A request to set the transfer lock for the specified domain.
public struct EnableDomainTransferLockInput: Swift.Equatable {
    /// The name of the domain that you want to set the transfer lock for.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct EnableDomainTransferLockInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension EnableDomainTransferLockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension EnableDomainTransferLockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDomainTransferLockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableDomainTransferLockOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDomainTransferLockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableDomainTransferLockOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The EnableDomainTransferLock response includes the following elements.
public struct EnableDomainTransferLockOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct EnableDomainTransferLockOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension EnableDomainTransferLockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension Route53DomainsClientTypes.ExtraParam: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ExtraParamName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Route53DomainsClientTypes.ExtraParam: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExtraParam(name: \(Swift.String(describing: name)), value: \"CONTENT_REDACTED\")"}
}

extension Route53DomainsClientTypes {
    /// ExtraParam includes the following elements.
    public struct ExtraParam: Swift.Equatable {
        /// The name of an additional parameter that is required by a top-level domain. Here are the top-level domains that require additional parameters and the names of the parameters that they require: .com.au and .net.au
        ///
        /// * AU_ID_NUMBER
        ///
        /// * AU_ID_TYPE Valid values include the following:
        ///
        /// * ABN (Australian business number)
        ///
        /// * ACN (Australian company number)
        ///
        /// * TM (Trademark number)
        ///
        ///
        ///
        ///
        ///
        /// .ca
        ///
        /// * BRAND_NUMBER
        ///
        /// * CA_BUSINESS_ENTITY_TYPE Valid values include the following:
        ///
        /// * BANK (Bank)
        ///
        /// * COMMERCIAL_COMPANY (Commercial company)
        ///
        /// * COMPANY (Company)
        ///
        /// * COOPERATION (Cooperation)
        ///
        /// * COOPERATIVE (Cooperative)
        ///
        /// * COOPRIX (Cooprix)
        ///
        /// * CORP (Corporation)
        ///
        /// * CREDIT_UNION (Credit union)
        ///
        /// * FOMIA (Federation of mutual insurance associations)
        ///
        /// * INC (Incorporated)
        ///
        /// * LTD (Limited)
        ///
        /// * LTEE (Limitée)
        ///
        /// * LLC (Limited liability corporation)
        ///
        /// * LLP (Limited liability partnership)
        ///
        /// * LTE (Lte.)
        ///
        /// * MBA (Mutual benefit association)
        ///
        /// * MIC (Mutual insurance company)
        ///
        /// * NFP (Not-for-profit corporation)
        ///
        /// * SA (S.A.)
        ///
        /// * SAVINGS_COMPANY (Savings company)
        ///
        /// * SAVINGS_UNION (Savings union)
        ///
        /// * SARL (Société à responsabilité limitée)
        ///
        /// * TRUST (Trust)
        ///
        /// * ULC (Unlimited liability corporation)
        ///
        ///
        ///
        ///
        /// * CA_LEGAL_TYPE When ContactType is PERSON, valid values include the following:
        ///
        /// * ABO (Aboriginal Peoples indigenous to Canada)
        ///
        /// * CCT (Canadian citizen)
        ///
        /// * LGR (Legal Representative of a Canadian Citizen or Permanent Resident)
        ///
        /// * RES (Permanent resident of Canada)
        ///
        ///
        /// When ContactType is a value other than PERSON, valid values include the following:
        ///
        /// * ASS (Canadian unincorporated association)
        ///
        /// * CCO (Canadian corporation)
        ///
        /// * EDU (Canadian educational institution)
        ///
        /// * GOV (Government or government entity in Canada)
        ///
        /// * HOP (Canadian Hospital)
        ///
        /// * INB (Indian Band recognized by the Indian Act of Canada)
        ///
        /// * LAM (Canadian Library, Archive, or Museum)
        ///
        /// * MAJ (Her/His Majesty the Queen/King)
        ///
        /// * OMK (Official mark registered in Canada)
        ///
        /// * PLT (Canadian Political Party)
        ///
        /// * PRT (Partnership Registered in Canada)
        ///
        /// * TDM (Trademark registered in Canada)
        ///
        /// * TRD (Canadian Trade Union)
        ///
        /// * TRS (Trust established in Canada)
        ///
        ///
        ///
        ///
        ///
        /// .es
        ///
        /// * ES_IDENTIFICATION The value of ES_IDENTIFICATION depends on the following values:
        ///
        /// * The value of ES_LEGAL_FORM
        ///
        /// * The value of ES_IDENTIFICATION_TYPE
        ///
        ///
        /// If ES_LEGAL_FORM is any value other than INDIVIDUAL:
        ///
        /// * Specify 1 letter + 8 numbers (CIF [Certificado de Identificación Fiscal])
        ///
        /// * Example: B12345678
        ///
        ///
        /// If ES_LEGAL_FORM is INDIVIDUAL, the value that you specify for ES_IDENTIFICATION depends on the value of ES_IDENTIFICATION_TYPE:
        ///
        /// * If ES_IDENTIFICATION_TYPE is DNI_AND_NIF (for Spanish contacts):
        ///
        /// * Specify 8 numbers + 1 letter (DNI [Documento Nacional de Identidad], NIF [Número de Identificación Fiscal])
        ///
        /// * Example: 12345678M
        ///
        ///
        ///
        ///
        /// * If ES_IDENTIFICATION_TYPE is NIE (for foreigners with legal residence):
        ///
        /// * Specify 1 letter + 7 numbers + 1 letter ( NIE [Número de Identidad de Extranjero])
        ///
        /// * Example: Y1234567X
        ///
        ///
        ///
        ///
        /// * If ES_IDENTIFICATION_TYPE is OTHER (for contacts outside of Spain):
        ///
        /// * Specify a passport number, drivers license number, or national identity card number
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * ES_IDENTIFICATION_TYPE Valid values include the following:
        ///
        /// * DNI_AND_NIF (For Spanish contacts)
        ///
        /// * NIE (For foreigners with legal residence)
        ///
        /// * OTHER (For contacts outside of Spain)
        ///
        ///
        ///
        ///
        /// * ES_LEGAL_FORM Valid values include the following:
        ///
        /// * ASSOCIATION
        ///
        /// * CENTRAL_GOVERNMENT_BODY
        ///
        /// * CIVIL_SOCIETY
        ///
        /// * COMMUNITY_OF_OWNERS
        ///
        /// * COMMUNITY_PROPERTY
        ///
        /// * CONSULATE
        ///
        /// * COOPERATIVE
        ///
        /// * DESIGNATION_OF_ORIGIN_SUPERVISORY_COUNCIL
        ///
        /// * ECONOMIC_INTEREST_GROUP
        ///
        /// * EMBASSY
        ///
        /// * ENTITY_MANAGING_NATURAL_AREAS
        ///
        /// * FARM_PARTNERSHIP
        ///
        /// * FOUNDATION
        ///
        /// * GENERAL_AND_LIMITED_PARTNERSHIP
        ///
        /// * GENERAL_PARTNERSHIP
        ///
        /// * INDIVIDUAL
        ///
        /// * LIMITED_COMPANY
        ///
        /// * LOCAL_AUTHORITY
        ///
        /// * LOCAL_PUBLIC_ENTITY
        ///
        /// * MUTUAL_INSURANCE_COMPANY
        ///
        /// * NATIONAL_PUBLIC_ENTITY
        ///
        /// * ORDER_OR_RELIGIOUS_INSTITUTION
        ///
        /// * OTHERS (Only for contacts outside of Spain)
        ///
        /// * POLITICAL_PARTY
        ///
        /// * PROFESSIONAL_ASSOCIATION
        ///
        /// * PUBLIC_LAW_ASSOCIATION
        ///
        /// * PUBLIC_LIMITED_COMPANY
        ///
        /// * REGIONAL_GOVERNMENT_BODY
        ///
        /// * REGIONAL_PUBLIC_ENTITY
        ///
        /// * SAVINGS_BANK
        ///
        /// * SPANISH_OFFICE
        ///
        /// * SPORTS_ASSOCIATION
        ///
        /// * SPORTS_FEDERATION
        ///
        /// * SPORTS_LIMITED_COMPANY
        ///
        /// * TEMPORARY_ALLIANCE_OF_ENTERPRISES
        ///
        /// * TRADE_UNION
        ///
        /// * WORKER_OWNED_COMPANY
        ///
        /// * WORKER_OWNED_LIMITED_COMPANY
        ///
        ///
        ///
        ///
        ///
        /// .eu
        ///
        /// * EU_COUNTRY_OF_CITIZENSHIP
        ///
        ///
        /// .fi
        ///
        /// * BIRTH_DATE_IN_YYYY_MM_DD
        ///
        /// * FI_BUSINESS_NUMBER
        ///
        /// * FI_ID_NUMBER
        ///
        /// * FI_NATIONALITY Valid values include the following:
        ///
        /// * FINNISH
        ///
        /// * NOT_FINNISH
        ///
        ///
        ///
        ///
        /// * FI_ORGANIZATION_TYPE Valid values include the following:
        ///
        /// * COMPANY
        ///
        /// * CORPORATION
        ///
        /// * GOVERNMENT
        ///
        /// * INSTITUTION
        ///
        /// * POLITICAL_PARTY
        ///
        /// * PUBLIC_COMMUNITY
        ///
        /// * TOWNSHIP
        ///
        ///
        ///
        ///
        ///
        /// .fr
        ///
        /// * BIRTH_CITY
        ///
        /// * BIRTH_COUNTRY
        ///
        /// * BIRTH_DATE_IN_YYYY_MM_DD
        ///
        /// * BIRTH_DEPARTMENT: Specify the INSEE code that corresponds with the department where the contact was born. If the contact was born somewhere other than France or its overseas departments, specify 99. For more information, including a list of departments and the corresponding INSEE numbers, see the Wikipedia entry [Departments of France](https://en.wikipedia.org/wiki/Departments_of_France).
        ///
        /// * BRAND_NUMBER
        ///
        ///
        /// .it
        ///
        /// * IT_NATIONALITY
        ///
        /// * IT_PIN
        ///
        /// * IT_REGISTRANT_ENTITY_TYPE Valid values include the following:
        ///
        /// * FOREIGNERS
        ///
        /// * FREELANCE_WORKERS (Freelance workers and professionals)
        ///
        /// * ITALIAN_COMPANIES (Italian companies and one-person companies)
        ///
        /// * NON_PROFIT_ORGANIZATIONS
        ///
        /// * OTHER_SUBJECTS
        ///
        /// * PUBLIC_ORGANIZATIONS
        ///
        ///
        ///
        ///
        ///
        /// .ru
        ///
        /// * BIRTH_DATE_IN_YYYY_MM_DD
        ///
        /// * RU_PASSPORT_DATA
        ///
        ///
        /// .se
        ///
        /// * BIRTH_COUNTRY
        ///
        /// * SE_ID_NUMBER
        ///
        ///
        /// .sg
        ///
        /// * SG_ID_NUMBER
        ///
        ///
        /// .uk, .co.uk, .me.uk, and .org.uk
        ///
        /// * UK_CONTACT_TYPE Valid values include the following:
        ///
        /// * CRC (UK Corporation by Royal Charter)
        ///
        /// * FCORP (Non-UK Corporation)
        ///
        /// * FIND (Non-UK Individual, representing self)
        ///
        /// * FOTHER (Non-UK Entity that does not fit into any other category)
        ///
        /// * GOV (UK Government Body)
        ///
        /// * IND (UK Individual (representing self))
        ///
        /// * IP (UK Industrial/Provident Registered Company)
        ///
        /// * LLP (UK Limited Liability Partnership)
        ///
        /// * LTD (UK Limited Company)
        ///
        /// * OTHER (UK Entity that does not fit into any other category)
        ///
        /// * PLC (UK Public Limited Company)
        ///
        /// * PTNR (UK Partnership)
        ///
        /// * RCHAR (UK Registered Charity)
        ///
        /// * SCH (UK School)
        ///
        /// * STAT (UK Statutory Body)
        ///
        /// * STRA (UK Sole Trader)
        ///
        ///
        ///
        ///
        /// * UK_COMPANY_NUMBER
        ///
        ///
        /// In addition, many TLDs require a VAT_NUMBER.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ExtraParamName?
        /// The value that corresponds with the name of an extra parameter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Route53DomainsClientTypes.ExtraParamName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension Route53DomainsClientTypes {
    public enum ExtraParamName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auIdNumber
        case auIdType
        case auPriorityToken
        case birthCity
        case birthCountry
        case birthDateInYyyyMmDd
        case birthDepartment
        case brandNumber
        case caBusinessEntityType
        case caLegalRepresentative
        case caLegalRepresentativeCapacity
        case caLegalType
        case documentNumber
        case dunsNumber
        case esIdentification
        case esIdentificationType
        case esLegalForm
        case euCountryOfCitizenship
        case fiBusinessNumber
        case fiNationality
        case fiOrganizationType
        case itNationality
        case itPin
        case itRegistrantEntityType
        case onwerFiIdNumber
        case ruPassportData
        case seIdNumber
        case sgIdNumber
        case ukCompanyNumber
        case ukContactType
        case vatNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ExtraParamName] {
            return [
                .auIdNumber,
                .auIdType,
                .auPriorityToken,
                .birthCity,
                .birthCountry,
                .birthDateInYyyyMmDd,
                .birthDepartment,
                .brandNumber,
                .caBusinessEntityType,
                .caLegalRepresentative,
                .caLegalRepresentativeCapacity,
                .caLegalType,
                .documentNumber,
                .dunsNumber,
                .esIdentification,
                .esIdentificationType,
                .esLegalForm,
                .euCountryOfCitizenship,
                .fiBusinessNumber,
                .fiNationality,
                .fiOrganizationType,
                .itNationality,
                .itPin,
                .itRegistrantEntityType,
                .onwerFiIdNumber,
                .ruPassportData,
                .seIdNumber,
                .sgIdNumber,
                .ukCompanyNumber,
                .ukContactType,
                .vatNumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auIdNumber: return "AU_ID_NUMBER"
            case .auIdType: return "AU_ID_TYPE"
            case .auPriorityToken: return "AU_PRIORITY_TOKEN"
            case .birthCity: return "BIRTH_CITY"
            case .birthCountry: return "BIRTH_COUNTRY"
            case .birthDateInYyyyMmDd: return "BIRTH_DATE_IN_YYYY_MM_DD"
            case .birthDepartment: return "BIRTH_DEPARTMENT"
            case .brandNumber: return "BRAND_NUMBER"
            case .caBusinessEntityType: return "CA_BUSINESS_ENTITY_TYPE"
            case .caLegalRepresentative: return "CA_LEGAL_REPRESENTATIVE"
            case .caLegalRepresentativeCapacity: return "CA_LEGAL_REPRESENTATIVE_CAPACITY"
            case .caLegalType: return "CA_LEGAL_TYPE"
            case .documentNumber: return "DOCUMENT_NUMBER"
            case .dunsNumber: return "DUNS_NUMBER"
            case .esIdentification: return "ES_IDENTIFICATION"
            case .esIdentificationType: return "ES_IDENTIFICATION_TYPE"
            case .esLegalForm: return "ES_LEGAL_FORM"
            case .euCountryOfCitizenship: return "EU_COUNTRY_OF_CITIZENSHIP"
            case .fiBusinessNumber: return "FI_BUSINESS_NUMBER"
            case .fiNationality: return "FI_NATIONALITY"
            case .fiOrganizationType: return "FI_ORGANIZATION_TYPE"
            case .itNationality: return "IT_NATIONALITY"
            case .itPin: return "IT_PIN"
            case .itRegistrantEntityType: return "IT_REGISTRANT_ENTITY_TYPE"
            case .onwerFiIdNumber: return "FI_ID_NUMBER"
            case .ruPassportData: return "RU_PASSPORT_DATA"
            case .seIdNumber: return "SE_ID_NUMBER"
            case .sgIdNumber: return "SG_ID_NUMBER"
            case .ukCompanyNumber: return "UK_COMPANY_NUMBER"
            case .ukContactType: return "UK_CONTACT_TYPE"
            case .vatNumber: return "VAT_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExtraParamName(rawValue: rawValue) ?? ExtraParamName.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes.FilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ListDomainsAttributeName.self, forKey: .name)
        name = nameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Route53DomainsClientTypes {
    /// Information for the filtering of a list of domains returned by [ListDomains](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains__ListDomains.html).
    public struct FilterCondition: Swift.Equatable {
        /// Name of the field which should be used for filtering the list of domains.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ListDomainsAttributeName?
        /// The operator values for filtering domain names. The values can be:
        ///
        /// * LE: Less than, or equal to
        ///
        /// * GE: Greater than, or equal to
        ///
        /// * BEGINS_WITH: Begins with
        /// This member is required.
        public var `operator`: Route53DomainsClientTypes.Operator?
        /// An array of strings presenting values to compare. Only 1 item in the list is currently supported.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Route53DomainsClientTypes.ListDomainsAttributeName? = nil,
            `operator`: Route53DomainsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension GetContactReachabilityStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension GetContactReachabilityStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactReachabilityStatusInput: Swift.Equatable {
    /// The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetContactReachabilityStatusInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension GetContactReachabilityStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetContactReachabilityStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactReachabilityStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContactReachabilityStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactReachabilityStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContactReachabilityStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainName = output.domainName
            self.status = output.status
        } else {
            self.domainName = nil
            self.status = nil
        }
    }
}

public struct GetContactReachabilityStatusOutputResponse: Swift.Equatable {
    /// The domain name for which you requested the reachability status.
    public var domainName: Swift.String?
    /// Whether the registrant contact has responded. Values include the following: PENDING We sent the confirmation email and haven't received a response yet. DONE We sent the email and got confirmation from the registrant contact. EXPIRED The time limit expired before the registrant contact responded.
    public var status: Route53DomainsClientTypes.ReachabilityStatus?

    public init (
        domainName: Swift.String? = nil,
        status: Route53DomainsClientTypes.ReachabilityStatus? = nil
    )
    {
        self.domainName = domainName
        self.status = status
    }
}

struct GetContactReachabilityStatusOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let status: Route53DomainsClientTypes.ReachabilityStatus?
}

extension GetContactReachabilityStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ReachabilityStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetDomainDetailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension GetDomainDetailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The GetDomainDetail request includes the following element.
public struct GetDomainDetailInput: Swift.Equatable {
    /// The name of the domain that you want to get detailed information about.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainDetailInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension GetDomainDetailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GetDomainDetailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainDetailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDomainDetailOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainDetailOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainDetailOutputResponse(abuseContactEmail: \(Swift.String(describing: abuseContactEmail)), abuseContactPhone: \(Swift.String(describing: abuseContactPhone)), adminPrivacy: \(Swift.String(describing: adminPrivacy)), autoRenew: \(Swift.String(describing: autoRenew)), creationDate: \(Swift.String(describing: creationDate)), dnsSec: \(Swift.String(describing: dnsSec)), dnssecKeys: \(Swift.String(describing: dnssecKeys)), domainName: \(Swift.String(describing: domainName)), expirationDate: \(Swift.String(describing: expirationDate)), nameservers: \(Swift.String(describing: nameservers)), registrantPrivacy: \(Swift.String(describing: registrantPrivacy)), registrarName: \(Swift.String(describing: registrarName)), registrarUrl: \(Swift.String(describing: registrarUrl)), registryDomainId: \(Swift.String(describing: registryDomainId)), reseller: \(Swift.String(describing: reseller)), statusList: \(Swift.String(describing: statusList)), techPrivacy: \(Swift.String(describing: techPrivacy)), updatedDate: \(Swift.String(describing: updatedDate)), whoIsServer: \(Swift.String(describing: whoIsServer)), adminContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

extension GetDomainDetailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDomainDetailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.abuseContactEmail = output.abuseContactEmail
            self.abuseContactPhone = output.abuseContactPhone
            self.adminContact = output.adminContact
            self.adminPrivacy = output.adminPrivacy
            self.autoRenew = output.autoRenew
            self.creationDate = output.creationDate
            self.dnsSec = output.dnsSec
            self.dnssecKeys = output.dnssecKeys
            self.domainName = output.domainName
            self.expirationDate = output.expirationDate
            self.nameservers = output.nameservers
            self.registrantContact = output.registrantContact
            self.registrantPrivacy = output.registrantPrivacy
            self.registrarName = output.registrarName
            self.registrarUrl = output.registrarUrl
            self.registryDomainId = output.registryDomainId
            self.reseller = output.reseller
            self.statusList = output.statusList
            self.techContact = output.techContact
            self.techPrivacy = output.techPrivacy
            self.updatedDate = output.updatedDate
            self.whoIsServer = output.whoIsServer
        } else {
            self.abuseContactEmail = nil
            self.abuseContactPhone = nil
            self.adminContact = nil
            self.adminPrivacy = nil
            self.autoRenew = nil
            self.creationDate = nil
            self.dnsSec = nil
            self.dnssecKeys = nil
            self.domainName = nil
            self.expirationDate = nil
            self.nameservers = nil
            self.registrantContact = nil
            self.registrantPrivacy = nil
            self.registrarName = nil
            self.registrarUrl = nil
            self.registryDomainId = nil
            self.reseller = nil
            self.statusList = nil
            self.techContact = nil
            self.techPrivacy = nil
            self.updatedDate = nil
            self.whoIsServer = nil
        }
    }
}

/// The GetDomainDetail response includes the following elements.
public struct GetDomainDetailOutputResponse: Swift.Equatable {
    /// Email address to contact to report incorrect contact information for a domain, to report that the domain is being used to send spam, to report that someone is cybersquatting on a domain name, or report some other type of abuse.
    public var abuseContactEmail: Swift.String?
    /// Phone number for reporting abuse.
    public var abuseContactPhone: Swift.String?
    /// Provides details about the domain administrative contact.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If the value is false, WHOIS queries return the information that you entered for the admin contact.
    public var adminPrivacy: Swift.Bool?
    /// Specifies whether the domain registration is set to renew automatically.
    public var autoRenew: Swift.Bool?
    /// The date when the domain was created as found in the response to a WHOIS query. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var creationDate: ClientRuntime.Date?
    /// Deprecated.
    public var dnsSec: Swift.String?
    /// A complex type that contains information about the DNSSEC configuration.
    public var dnssecKeys: [Route53DomainsClientTypes.DnssecKey]?
    /// The name of a domain.
    public var domainName: Swift.String?
    /// The date when the registration for the domain is set to expire. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var expirationDate: ClientRuntime.Date?
    /// The name servers of the domain.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?
    /// Provides details about the domain registrant.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If the value is false, WHOIS queries return the information that you entered for the registrant contact (domain owner).
    public var registrantPrivacy: Swift.Bool?
    /// Name of the registrar of the domain as identified in the registry. Domains with a .com, .net, or .org TLD are registered by Amazon Registrar. All other domains are registered by our registrar associate, Gandi. The value for domains that are registered by Gandi is "GANDI SAS".
    public var registrarName: Swift.String?
    /// Web address of the registrar.
    public var registrarUrl: Swift.String?
    /// Reserved for future use.
    public var registryDomainId: Swift.String?
    /// Reseller of the domain. Domains registered or transferred using Route 53 domains will have "Amazon" as the reseller.
    public var reseller: Swift.String?
    /// An array of domain name status codes, also known as Extensible Provisioning Protocol (EPP) status codes. ICANN, the organization that maintains a central database of domain names, has developed a set of domain name status codes that tell you the status of a variety of operations on a domain name, for example, registering a domain name, transferring a domain name to another registrar, renewing the registration for a domain name, and so on. All registrars use this same set of status codes. For a current list of domain name status codes and an explanation of what each code means, go to the [ICANN website](https://www.icann.org/) and search for epp status codes. (Search on the ICANN website; web searches sometimes return an old version of the document.)
    public var statusList: [Swift.String]?
    /// Provides details about the domain technical contact.
    public var techContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If the value is false, WHOIS queries return the information that you entered for the technical contact.
    public var techPrivacy: Swift.Bool?
    /// The last updated date of the domain as found in the response to a WHOIS query. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var updatedDate: ClientRuntime.Date?
    /// The fully qualified name of the WHOIS server that can answer the WHOIS query for the domain.
    public var whoIsServer: Swift.String?

    public init (
        abuseContactEmail: Swift.String? = nil,
        abuseContactPhone: Swift.String? = nil,
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        adminPrivacy: Swift.Bool? = nil,
        autoRenew: Swift.Bool? = nil,
        creationDate: ClientRuntime.Date? = nil,
        dnsSec: Swift.String? = nil,
        dnssecKeys: [Route53DomainsClientTypes.DnssecKey]? = nil,
        domainName: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        registrantPrivacy: Swift.Bool? = nil,
        registrarName: Swift.String? = nil,
        registrarUrl: Swift.String? = nil,
        registryDomainId: Swift.String? = nil,
        reseller: Swift.String? = nil,
        statusList: [Swift.String]? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techPrivacy: Swift.Bool? = nil,
        updatedDate: ClientRuntime.Date? = nil,
        whoIsServer: Swift.String? = nil
    )
    {
        self.abuseContactEmail = abuseContactEmail
        self.abuseContactPhone = abuseContactPhone
        self.adminContact = adminContact
        self.adminPrivacy = adminPrivacy
        self.autoRenew = autoRenew
        self.creationDate = creationDate
        self.dnsSec = dnsSec
        self.dnssecKeys = dnssecKeys
        self.domainName = domainName
        self.expirationDate = expirationDate
        self.nameservers = nameservers
        self.registrantContact = registrantContact
        self.registrantPrivacy = registrantPrivacy
        self.registrarName = registrarName
        self.registrarUrl = registrarUrl
        self.registryDomainId = registryDomainId
        self.reseller = reseller
        self.statusList = statusList
        self.techContact = techContact
        self.techPrivacy = techPrivacy
        self.updatedDate = updatedDate
        self.whoIsServer = whoIsServer
    }
}

struct GetDomainDetailOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let nameservers: [Route53DomainsClientTypes.Nameserver]?
    let autoRenew: Swift.Bool?
    let adminContact: Route53DomainsClientTypes.ContactDetail?
    let registrantContact: Route53DomainsClientTypes.ContactDetail?
    let techContact: Route53DomainsClientTypes.ContactDetail?
    let adminPrivacy: Swift.Bool?
    let registrantPrivacy: Swift.Bool?
    let techPrivacy: Swift.Bool?
    let registrarName: Swift.String?
    let whoIsServer: Swift.String?
    let registrarUrl: Swift.String?
    let abuseContactEmail: Swift.String?
    let abuseContactPhone: Swift.String?
    let registryDomainId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let updatedDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let reseller: Swift.String?
    let dnsSec: Swift.String?
    let statusList: [Swift.String]?
    let dnssecKeys: [Route53DomainsClientTypes.DnssecKey]?
}

extension GetDomainDetailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abuseContactEmail = "AbuseContactEmail"
        case abuseContactPhone = "AbuseContactPhone"
        case adminContact = "AdminContact"
        case adminPrivacy = "AdminPrivacy"
        case autoRenew = "AutoRenew"
        case creationDate = "CreationDate"
        case dnsSec = "DnsSec"
        case dnssecKeys = "DnssecKeys"
        case domainName = "DomainName"
        case expirationDate = "ExpirationDate"
        case nameservers = "Nameservers"
        case registrantContact = "RegistrantContact"
        case registrantPrivacy = "RegistrantPrivacy"
        case registrarName = "RegistrarName"
        case registrarUrl = "RegistrarUrl"
        case registryDomainId = "RegistryDomainId"
        case reseller = "Reseller"
        case statusList = "StatusList"
        case techContact = "TechContact"
        case techPrivacy = "TechPrivacy"
        case updatedDate = "UpdatedDate"
        case whoIsServer = "WhoIsServer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Route53DomainsClientTypes.Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Route53DomainsClientTypes.Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
        let autoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let adminPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .adminPrivacy)
        adminPrivacy = adminPrivacyDecoded
        let registrantPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registrantPrivacy)
        registrantPrivacy = registrantPrivacyDecoded
        let techPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .techPrivacy)
        techPrivacy = techPrivacyDecoded
        let registrarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrarName)
        registrarName = registrarNameDecoded
        let whoIsServerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whoIsServer)
        whoIsServer = whoIsServerDecoded
        let registrarUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrarUrl)
        registrarUrl = registrarUrlDecoded
        let abuseContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .abuseContactEmail)
        abuseContactEmail = abuseContactEmailDecoded
        let abuseContactPhoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .abuseContactPhone)
        abuseContactPhone = abuseContactPhoneDecoded
        let registryDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryDomainId)
        registryDomainId = registryDomainIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let updatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedDate)
        updatedDate = updatedDateDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let resellerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reseller)
        reseller = resellerDecoded
        let dnsSecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsSec)
        dnsSec = dnsSecDecoded
        let statusListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statusList)
        var statusListDecoded0:[Swift.String]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [Swift.String]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let dnssecKeysContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.DnssecKey?].self, forKey: .dnssecKeys)
        var dnssecKeysDecoded0:[Route53DomainsClientTypes.DnssecKey]? = nil
        if let dnssecKeysContainer = dnssecKeysContainer {
            dnssecKeysDecoded0 = [Route53DomainsClientTypes.DnssecKey]()
            for structure0 in dnssecKeysContainer {
                if let structure0 = structure0 {
                    dnssecKeysDecoded0?.append(structure0)
                }
            }
        }
        dnssecKeys = dnssecKeysDecoded0
    }
}

extension GetDomainSuggestionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case onlyAvailable = "OnlyAvailable"
        case suggestionCount = "SuggestionCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let onlyAvailable = self.onlyAvailable {
            try encodeContainer.encode(onlyAvailable, forKey: .onlyAvailable)
        }
        if suggestionCount != 0 {
            try encodeContainer.encode(suggestionCount, forKey: .suggestionCount)
        }
    }
}

extension GetDomainSuggestionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDomainSuggestionsInput: Swift.Equatable {
    /// A domain name that you want to use as the basis for a list of possible domain names. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html).
    /// This member is required.
    public var domainName: Swift.String?
    /// If OnlyAvailable is true, Route 53 returns only domain names that are available. If OnlyAvailable is false, Route 53 returns domain names without checking whether they're available to be registered. To determine whether the domain is available, you can call checkDomainAvailability for each suggestion.
    /// This member is required.
    public var onlyAvailable: Swift.Bool?
    /// The number of suggested domain names that you want Route 53 to return. Specify a value between 1 and 50.
    /// This member is required.
    public var suggestionCount: Swift.Int

    public init (
        domainName: Swift.String? = nil,
        onlyAvailable: Swift.Bool? = nil,
        suggestionCount: Swift.Int = 0
    )
    {
        self.domainName = domainName
        self.onlyAvailable = onlyAvailable
        self.suggestionCount = suggestionCount
    }
}

struct GetDomainSuggestionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let suggestionCount: Swift.Int
    let onlyAvailable: Swift.Bool?
}

extension GetDomainSuggestionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case onlyAvailable = "OnlyAvailable"
        case suggestionCount = "SuggestionCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let suggestionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suggestionCount) ?? 0
        suggestionCount = suggestionCountDecoded
        let onlyAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyAvailable)
        onlyAvailable = onlyAvailableDecoded
    }
}

extension GetDomainSuggestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainSuggestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDomainSuggestionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainSuggestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDomainSuggestionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggestionsList = output.suggestionsList
        } else {
            self.suggestionsList = nil
        }
    }
}

public struct GetDomainSuggestionsOutputResponse: Swift.Equatable {
    /// A list of possible domain names. If you specified true for OnlyAvailable in the request, the list contains only domains that are available for registration.
    public var suggestionsList: [Route53DomainsClientTypes.DomainSuggestion]?

    public init (
        suggestionsList: [Route53DomainsClientTypes.DomainSuggestion]? = nil
    )
    {
        self.suggestionsList = suggestionsList
    }
}

struct GetDomainSuggestionsOutputResponseBody: Swift.Equatable {
    let suggestionsList: [Route53DomainsClientTypes.DomainSuggestion]?
}

extension GetDomainSuggestionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggestionsList = "SuggestionsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suggestionsListContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.DomainSuggestion?].self, forKey: .suggestionsList)
        var suggestionsListDecoded0:[Route53DomainsClientTypes.DomainSuggestion]? = nil
        if let suggestionsListContainer = suggestionsListContainer {
            suggestionsListDecoded0 = [Route53DomainsClientTypes.DomainSuggestion]()
            for structure0 in suggestionsListContainer {
                if let structure0 = structure0 {
                    suggestionsListDecoded0?.append(structure0)
                }
            }
        }
        suggestionsList = suggestionsListDecoded0
    }
}

extension GetOperationDetailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = self.operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

extension GetOperationDetailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html) request includes the following element.
public struct GetOperationDetailInput: Swift.Equatable {
    /// The identifier for the operation for which you want to get the status. Route 53 returned the identifier in the response to the original request.
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationDetailInputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension GetOperationDetailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationDetailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationDetailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOperationDetailOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationDetailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOperationDetailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainName = output.domainName
            self.lastUpdatedDate = output.lastUpdatedDate
            self.message = output.message
            self.operationId = output.operationId
            self.status = output.status
            self.statusFlag = output.statusFlag
            self.submittedDate = output.submittedDate
            self.type = output.type
        } else {
            self.domainName = nil
            self.lastUpdatedDate = nil
            self.message = nil
            self.operationId = nil
            self.status = nil
            self.statusFlag = nil
            self.submittedDate = nil
            self.type = nil
        }
    }
}

/// The GetOperationDetail response includes the following elements.
public struct GetOperationDetailOutputResponse: Swift.Equatable {
    /// The name of a domain.
    public var domainName: Swift.String?
    /// The date when the operation was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Detailed information on the status including possible errors.
    public var message: Swift.String?
    /// The identifier for the operation.
    public var operationId: Swift.String?
    /// The current status of the requested operation in the system.
    public var status: Route53DomainsClientTypes.OperationStatus?
    /// Lists any outstanding operations that require customer action. Valid values are:
    ///
    /// * PENDING_ACCEPTANCE: The operation is waiting for acceptance from the account that is receiving the domain.
    ///
    /// * PENDING_CUSTOMER_ACTION: The operation is waiting for customer action, for example, returning an email.
    ///
    /// * PENDING_AUTHORIZATION: The operation is waiting for the form of authorization. For more information, see [ResendOperationAuthorization](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ResendOperationAuthorization.html).
    ///
    /// * PENDING_PAYMENT_VERIFICATION: The operation is waiting for the payment method to validate.
    ///
    /// * PENDING_SUPPORT_CASE: The operation includes a support case and is waiting for its resolution.
    public var statusFlag: Route53DomainsClientTypes.StatusFlag?
    /// The date when the request was submitted.
    public var submittedDate: ClientRuntime.Date?
    /// The type of operation that was requested.
    public var type: Route53DomainsClientTypes.OperationType?

    public init (
        domainName: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        operationId: Swift.String? = nil,
        status: Route53DomainsClientTypes.OperationStatus? = nil,
        statusFlag: Route53DomainsClientTypes.StatusFlag? = nil,
        submittedDate: ClientRuntime.Date? = nil,
        type: Route53DomainsClientTypes.OperationType? = nil
    )
    {
        self.domainName = domainName
        self.lastUpdatedDate = lastUpdatedDate
        self.message = message
        self.operationId = operationId
        self.status = status
        self.statusFlag = statusFlag
        self.submittedDate = submittedDate
        self.type = type
    }
}

struct GetOperationDetailOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
    let status: Route53DomainsClientTypes.OperationStatus?
    let message: Swift.String?
    let domainName: Swift.String?
    let type: Route53DomainsClientTypes.OperationType?
    let submittedDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let statusFlag: Route53DomainsClientTypes.StatusFlag?
}

extension GetOperationDetailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case lastUpdatedDate = "LastUpdatedDate"
        case message = "Message"
        case operationId = "OperationId"
        case status = "Status"
        case statusFlag = "StatusFlag"
        case submittedDate = "SubmittedDate"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let submittedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedDate)
        submittedDate = submittedDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let statusFlagDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.StatusFlag.self, forKey: .statusFlag)
        statusFlag = statusFlagDecoded
    }
}

extension InvalidInput {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested item is not acceptable. For example, for APIs that accept a domain name, the request might specify a domain name that doesn't belong to the account that submitted the request. For AcceptDomainTransferFromAnotherAwsAccount, the password might be invalid.
public struct InvalidInput: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The requested item is not acceptable. For example, for an OperationId it might refer to the ID of an operation that is already completed. For a domain name, it might not be a valid domain name or belong to the requester account.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53DomainsClientTypes {
    public enum ListDomainsAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainname
        case expiry
        case sdkUnknown(Swift.String)

        public static var allCases: [ListDomainsAttributeName] {
            return [
                .domainname,
                .expiry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainname: return "DomainName"
            case .expiry: return "Expiry"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListDomainsAttributeName(rawValue: rawValue) ?? ListDomainsAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterConditions = "FilterConditions"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortCondition = "SortCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterConditions = filterConditions {
            var filterConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterConditions)
            for filtercondition0 in filterConditions {
                try filterConditionsContainer.encode(filtercondition0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = self.maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let sortCondition = self.sortCondition {
            try encodeContainer.encode(sortCondition, forKey: .sortCondition)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The ListDomains request includes the following elements.
public struct ListDomainsInput: Swift.Equatable {
    /// A complex type that contains information about the filters applied during the ListDomains request. The filter conditions can include domain name and domain expiration.
    public var filterConditions: [Route53DomainsClientTypes.FilterCondition]?
    /// For an initial request for a list of domains, omit this element. If the number of domains that are associated with the current Amazon Web Services account is greater than the value that you specified for MaxItems, you can use Marker to return additional domains. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Constraints: The marker must match the value specified in the previous request.
    public var marker: Swift.String?
    /// Number of domains to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// A complex type that contains information about the requested ordering of domains in the returned list.
    public var sortCondition: Route53DomainsClientTypes.SortCondition?

    public init (
        filterConditions: [Route53DomainsClientTypes.FilterCondition]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortCondition: Route53DomainsClientTypes.SortCondition? = nil
    )
    {
        self.filterConditions = filterConditions
        self.marker = marker
        self.maxItems = maxItems
        self.sortCondition = sortCondition
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let filterConditions: [Route53DomainsClientTypes.FilterCondition]?
    let sortCondition: Route53DomainsClientTypes.SortCondition?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterConditions = "FilterConditions"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortCondition = "SortCondition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterConditionsContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.FilterCondition?].self, forKey: .filterConditions)
        var filterConditionsDecoded0:[Route53DomainsClientTypes.FilterCondition]? = nil
        if let filterConditionsContainer = filterConditionsContainer {
            filterConditionsDecoded0 = [Route53DomainsClientTypes.FilterCondition]()
            for structure0 in filterConditionsContainer {
                if let structure0 = structure0 {
                    filterConditionsDecoded0?.append(structure0)
                }
            }
        }
        filterConditions = filterConditionsDecoded0
        let sortConditionDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.SortCondition.self, forKey: .sortCondition)
        sortCondition = sortConditionDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextPageMarker = output.nextPageMarker
        } else {
            self.domains = nil
            self.nextPageMarker = nil
        }
    }
}

/// The ListDomains response includes the following elements.
public struct ListDomainsOutputResponse: Swift.Equatable {
    /// A list of domains.
    public var domains: [Route53DomainsClientTypes.DomainSummary]?
    /// If there are more domains than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?

    public init (
        domains: [Route53DomainsClientTypes.DomainSummary]? = nil,
        nextPageMarker: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextPageMarker = nextPageMarker
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domains: [Route53DomainsClientTypes.DomainSummary]?
    let nextPageMarker: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextPageMarker = "NextPageMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[Route53DomainsClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Route53DomainsClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
    }
}

extension ListOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case status = "Status"
        case submittedSince = "SubmittedSince"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = self.maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let status = status {
            var statusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .status)
            for operationstatus0 in status {
                try statusContainer.encode(operationstatus0.rawValue)
            }
        }
        if let submittedSince = self.submittedSince {
            try encodeContainer.encodeTimestamp(submittedSince, format: .epochSeconds, forKey: .submittedSince)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for operationtype0 in type {
                try typeContainer.encode(operationtype0.rawValue)
            }
        }
    }
}

extension ListOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The ListOperations request includes the following elements.
public struct ListOperationsInput: Swift.Equatable {
    /// For an initial request for a list of operations, omit this element. If the number of operations that are not yet complete is greater than the value that you specified for MaxItems, you can use Marker to return additional operations. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element.
    public var marker: Swift.String?
    /// Number of domains to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// The sort type for returned values.
    public var sortBy: Route53DomainsClientTypes.ListOperationsSortAttributeName?
    /// The sort order ofr returned values, either ascending or descending.
    public var sortOrder: Route53DomainsClientTypes.SortOrder?
    /// The status of the operations.
    public var status: [Route53DomainsClientTypes.OperationStatus]?
    /// An optional parameter that lets you get information about all the operations that you submitted after a specified date and time. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var submittedSince: ClientRuntime.Date?
    /// An arrays of the domains operation types.
    public var type: [Route53DomainsClientTypes.OperationType]?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortBy: Route53DomainsClientTypes.ListOperationsSortAttributeName? = nil,
        sortOrder: Route53DomainsClientTypes.SortOrder? = nil,
        status: [Route53DomainsClientTypes.OperationStatus]? = nil,
        submittedSince: ClientRuntime.Date? = nil,
        type: [Route53DomainsClientTypes.OperationType]? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.submittedSince = submittedSince
        self.type = type
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    let submittedSince: ClientRuntime.Date?
    let marker: Swift.String?
    let maxItems: Swift.Int?
    let status: [Route53DomainsClientTypes.OperationStatus]?
    let type: [Route53DomainsClientTypes.OperationType]?
    let sortBy: Route53DomainsClientTypes.ListOperationsSortAttributeName?
    let sortOrder: Route53DomainsClientTypes.SortOrder?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
        case status = "Status"
        case submittedSince = "SubmittedSince"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submittedSinceDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedSince)
        submittedSince = submittedSinceDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let statusContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.OperationStatus?].self, forKey: .status)
        var statusDecoded0:[Route53DomainsClientTypes.OperationStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [Route53DomainsClientTypes.OperationStatus]()
            for enum0 in statusContainer {
                if let enum0 = enum0 {
                    statusDecoded0?.append(enum0)
                }
            }
        }
        status = statusDecoded0
        let typeContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.OperationType?].self, forKey: .type)
        var typeDecoded0:[Route53DomainsClientTypes.OperationType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [Route53DomainsClientTypes.OperationType]()
            for enum0 in typeContainer {
                if let enum0 = enum0 {
                    typeDecoded0?.append(enum0)
                }
            }
        }
        type = typeDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ListOperationsSortAttributeName.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageMarker = output.nextPageMarker
            self.operations = output.operations
        } else {
            self.nextPageMarker = nil
            self.operations = nil
        }
    }
}

/// The ListOperations response includes the following elements.
public struct ListOperationsOutputResponse: Swift.Equatable {
    /// If there are more operations than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?
    /// Lists summaries of the operations.
    public var operations: [Route53DomainsClientTypes.OperationSummary]?

    public init (
        nextPageMarker: Swift.String? = nil,
        operations: [Route53DomainsClientTypes.OperationSummary]? = nil
    )
    {
        self.nextPageMarker = nextPageMarker
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    let operations: [Route53DomainsClientTypes.OperationSummary]?
    let nextPageMarker: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageMarker = "NextPageMarker"
        case operations = "Operations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[Route53DomainsClientTypes.OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [Route53DomainsClientTypes.OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
    }
}

extension Route53DomainsClientTypes {
    public enum ListOperationsSortAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case submitteddate
        case sdkUnknown(Swift.String)

        public static var allCases: [ListOperationsSortAttributeName] {
            return [
                .submitteddate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .submitteddate: return "SubmittedDate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListOperationsSortAttributeName(rawValue: rawValue) ?? ListOperationsSortAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension ListPricesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case tld = "Tld"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = self.maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let tld = self.tld {
            try encodeContainer.encode(tld, forKey: .tld)
        }
    }
}

extension ListPricesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPricesInput: Swift.Equatable {
    /// For an initial request for a list of prices, omit this element. If the number of prices that are not yet complete is greater than the value that you specified for MaxItems, you can use Marker to return additional prices. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Used only for all TLDs. If you specify a TLD, don't specify a Marker.
    public var marker: Swift.String?
    /// Number of Prices to be returned. Used only for all TLDs. If you specify a TLD, don't specify a MaxItems.
    public var maxItems: Swift.Int?
    /// The TLD for which you want to receive the pricing information. For example. .net. If a Tld value is not provided, a list of prices for all TLDs supported by Route 53 is returned.
    public var tld: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        tld: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.tld = tld
    }
}

struct ListPricesInputBody: Swift.Equatable {
    let tld: Swift.String?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ListPricesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case tld = "Tld"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tld)
        tld = tldDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ListPricesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPricesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPricesOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPricesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPricesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageMarker = output.nextPageMarker
            self.prices = output.prices
        } else {
            self.nextPageMarker = nil
            self.prices = nil
        }
    }
}

public struct ListPricesOutputResponse: Swift.Equatable {
    /// If there are more prices than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker. Used only for all TLDs. If you specify a TLD, don't specify a NextPageMarker.
    public var nextPageMarker: Swift.String?
    /// A complex type that includes all the pricing information. If you specify a TLD, this array contains only the pricing for that TLD.
    public var prices: [Route53DomainsClientTypes.DomainPrice]?

    public init (
        nextPageMarker: Swift.String? = nil,
        prices: [Route53DomainsClientTypes.DomainPrice]? = nil
    )
    {
        self.nextPageMarker = nextPageMarker
        self.prices = prices
    }
}

struct ListPricesOutputResponseBody: Swift.Equatable {
    let prices: [Route53DomainsClientTypes.DomainPrice]?
    let nextPageMarker: Swift.String?
}

extension ListPricesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageMarker = "NextPageMarker"
        case prices = "Prices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricesContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.DomainPrice?].self, forKey: .prices)
        var pricesDecoded0:[Route53DomainsClientTypes.DomainPrice]? = nil
        if let pricesContainer = pricesContainer {
            pricesDecoded0 = [Route53DomainsClientTypes.DomainPrice]()
            for structure0 in pricesContainer {
                if let structure0 = structure0 {
                    pricesDecoded0?.append(structure0)
                }
            }
        }
        prices = pricesDecoded0
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
    }
}

extension ListTagsForDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension ListTagsForDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The ListTagsForDomainRequest includes the following elements.
public struct ListTagsForDomainInput: Swift.Equatable {
    /// The domain for which you want to get a list of tags.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct ListTagsForDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension ListTagsForDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension ListTagsForDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// The ListTagsForDomain response includes the following elements.
public struct ListTagsForDomainOutputResponse: Swift.Equatable {
    /// A list of the tags that are associated with the specified domain.
    public var tagList: [Route53DomainsClientTypes.Tag]?

    public init (
        tagList: [Route53DomainsClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForDomainOutputResponseBody: Swift.Equatable {
    let tagList: [Route53DomainsClientTypes.Tag]?
}

extension ListTagsForDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Route53DomainsClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Route53DomainsClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension Route53DomainsClientTypes.Nameserver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueIps = "GlueIps"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueIps = glueIps {
            var glueIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .glueIps)
            for glueip0 in glueIps {
                try glueIpsContainer.encode(glueip0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let glueIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .glueIps)
        var glueIpsDecoded0:[Swift.String]? = nil
        if let glueIpsContainer = glueIpsContainer {
            glueIpsDecoded0 = [Swift.String]()
            for string0 in glueIpsContainer {
                if let string0 = string0 {
                    glueIpsDecoded0?.append(string0)
                }
            }
        }
        glueIps = glueIpsDecoded0
    }
}

extension Route53DomainsClientTypes {
    /// Name server includes the following elements.
    public struct Nameserver: Swift.Equatable {
        /// Glue IP address of a name server entry. Glue IP addresses are required only when the name of the name server is a subdomain of the domain. For example, if your domain is example.com and the name server for the domain is ns.example.com, you need to specify the IP address for ns.example.com. Constraints: The list can contain only one IPv4 and one IPv6 address.
        public var glueIps: [Swift.String]?
        /// The fully qualified host name of the name server. Constraint: Maximum 255 characters
        /// This member is required.
        public var name: Swift.String?

        public init (
            glueIps: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.glueIps = glueIps
            self.name = name
        }
    }

}

extension OperationLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of operations or jobs running exceeded the allowed threshold for the account.
public struct OperationLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The number of operations or jobs running exceeded the allowed threshold for the account.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53DomainsClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case failed
        case inProgress
        case submitted
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .error,
                .failed,
                .inProgress,
                .submitted,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes.OperationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case lastUpdatedDate = "LastUpdatedDate"
        case message = "Message"
        case operationId = "OperationId"
        case status = "Status"
        case statusFlag = "StatusFlag"
        case submittedDate = "SubmittedDate"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .epochSeconds, forKey: .lastUpdatedDate)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let operationId = self.operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusFlag = self.statusFlag {
            try encodeContainer.encode(statusFlag.rawValue, forKey: .statusFlag)
        }
        if let submittedDate = self.submittedDate {
            try encodeContainer.encodeTimestamp(submittedDate, format: .epochSeconds, forKey: .submittedDate)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let submittedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedDate)
        submittedDate = submittedDateDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusFlagDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.StatusFlag.self, forKey: .statusFlag)
        statusFlag = statusFlagDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension Route53DomainsClientTypes {
    /// OperationSummary includes the following elements.
    public struct OperationSummary: Swift.Equatable {
        /// Name of the domain.
        public var domainName: Swift.String?
        /// The date when the last change was made in Unix time format and Coordinated Universal Time (UTC).
        public var lastUpdatedDate: ClientRuntime.Date?
        /// Message about the operation.
        public var message: Swift.String?
        /// Identifier returned to track the requested action.
        public var operationId: Swift.String?
        /// The current status of the requested operation in the system.
        public var status: Route53DomainsClientTypes.OperationStatus?
        /// Automatically checks whether there are no outstanding operations on domains that need customer attention. Valid values are:
        ///
        /// * PENDING_ACCEPTANCE: The operation is waiting for acceptance from the account that is receiving the domain.
        ///
        /// * PENDING_CUSTOMER_ACTION: The operation is waiting for customer action, for example, returning an email.
        ///
        /// * PENDING_AUTHORIZATION: The operation is waiting for the form of authorization. For more information, see [ResendOperationAuthorization](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ResendOperationAuthorization.html).
        ///
        /// * PENDING_PAYMENT_VERIFICATION: The operation is waiting for the payment method to validate.
        ///
        /// * PENDING_SUPPORT_CASE: The operation includes a support case and is waiting for its resolution.
        public var statusFlag: Route53DomainsClientTypes.StatusFlag?
        /// The date when the request was submitted.
        public var submittedDate: ClientRuntime.Date?
        /// Type of the action requested.
        public var type: Route53DomainsClientTypes.OperationType?

        public init (
            domainName: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            operationId: Swift.String? = nil,
            status: Route53DomainsClientTypes.OperationStatus? = nil,
            statusFlag: Route53DomainsClientTypes.StatusFlag? = nil,
            submittedDate: ClientRuntime.Date? = nil,
            type: Route53DomainsClientTypes.OperationType? = nil
        )
        {
            self.domainName = domainName
            self.lastUpdatedDate = lastUpdatedDate
            self.message = message
            self.operationId = operationId
            self.status = status
            self.statusFlag = statusFlag
            self.submittedDate = submittedDate
            self.type = type
        }
    }

}

extension Route53DomainsClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addDnssec
        case changeDomainOwner
        case changePrivacyProtection
        case deleteDomain
        case disableAutorenew
        case domainLock
        case enableAutorenew
        case expireDomain
        case internalTransferInDomain
        case internalTransferOutDomain
        case pushDomain
        case registerDomain
        case removeDnssec
        case renewDomain
        case transferInDomain
        case transferOutDomain
        case updateDomainContact
        case updateNameserver
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .addDnssec,
                .changeDomainOwner,
                .changePrivacyProtection,
                .deleteDomain,
                .disableAutorenew,
                .domainLock,
                .enableAutorenew,
                .expireDomain,
                .internalTransferInDomain,
                .internalTransferOutDomain,
                .pushDomain,
                .registerDomain,
                .removeDnssec,
                .renewDomain,
                .transferInDomain,
                .transferOutDomain,
                .updateDomainContact,
                .updateNameserver,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addDnssec: return "ADD_DNSSEC"
            case .changeDomainOwner: return "CHANGE_DOMAIN_OWNER"
            case .changePrivacyProtection: return "CHANGE_PRIVACY_PROTECTION"
            case .deleteDomain: return "DELETE_DOMAIN"
            case .disableAutorenew: return "DISABLE_AUTORENEW"
            case .domainLock: return "DOMAIN_LOCK"
            case .enableAutorenew: return "ENABLE_AUTORENEW"
            case .expireDomain: return "EXPIRE_DOMAIN"
            case .internalTransferInDomain: return "INTERNAL_TRANSFER_IN_DOMAIN"
            case .internalTransferOutDomain: return "INTERNAL_TRANSFER_OUT_DOMAIN"
            case .pushDomain: return "PUSH_DOMAIN"
            case .registerDomain: return "REGISTER_DOMAIN"
            case .removeDnssec: return "REMOVE_DNSSEC"
            case .renewDomain: return "RENEW_DOMAIN"
            case .transferInDomain: return "TRANSFER_IN_DOMAIN"
            case .transferOutDomain: return "TRANSFER_OUT_DOMAIN"
            case .updateDomainContact: return "UPDATE_DOMAIN_CONTACT"
            case .updateNameserver: return "UPDATE_NAMESERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case ge
        case le
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .beginsWith,
                .ge,
                .le,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .ge: return "GE"
            case .le: return "LE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes.PriceWithCurrency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency = "Currency"
        case price = "Price"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if price != 0.0 {
            try encodeContainer.encode(price, forKey: .price)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .price) ?? 0.0
        price = priceDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Currency-specific price information.
    public struct PriceWithCurrency: Swift.Equatable {
        /// The currency specifier.
        /// This member is required.
        public var currency: Swift.String?
        /// The price of a domain, in a specific currency.
        /// This member is required.
        public var price: Swift.Double

        public init (
            currency: Swift.String? = nil,
            price: Swift.Double = 0.0
        )
        {
            self.currency = currency
            self.price = price
        }
    }

}

extension PushDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension PushDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PushDomainInput: Swift.Equatable {
    /// Name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// New IPS tag for the domain.
    /// This member is required.
    public var target: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.target = target
    }
}

struct PushDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let target: Swift.String?
}

extension PushDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension PushDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PushDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PushDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension PushDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PushDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension Route53DomainsClientTypes {
    public enum ReachabilityStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case done
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReachabilityStatus] {
            return [
                .done,
                .expired,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .done: return "DONE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReachabilityStatus(rawValue: rawValue) ?? ReachabilityStatus.sdkUnknown(rawValue)
        }
    }
}

extension RegisterDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDomainInput(autoRenew: \(Swift.String(describing: autoRenew)), domainName: \(Swift.String(describing: domainName)), durationInYears: \(Swift.String(describing: durationInYears)), idnLangCode: \(Swift.String(describing: idnLangCode)), privacyProtectAdminContact: \(Swift.String(describing: privacyProtectAdminContact)), privacyProtectRegistrantContact: \(Swift.String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(Swift.String(describing: privacyProtectTechContact)), adminContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

extension RegisterDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = self.adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let autoRenew = self.autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = self.durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
        if let idnLangCode = self.idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
        if let privacyProtectAdminContact = self.privacyProtectAdminContact {
            try encodeContainer.encode(privacyProtectAdminContact, forKey: .privacyProtectAdminContact)
        }
        if let privacyProtectRegistrantContact = self.privacyProtectRegistrantContact {
            try encodeContainer.encode(privacyProtectRegistrantContact, forKey: .privacyProtectRegistrantContact)
        }
        if let privacyProtectTechContact = self.privacyProtectTechContact {
            try encodeContainer.encode(privacyProtectTechContact, forKey: .privacyProtectTechContact)
        }
        if let registrantContact = self.registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = self.techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

extension RegisterDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The RegisterDomain request includes the following elements.
public struct RegisterDomainInput: Swift.Equatable {
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Indicates whether the domain will be automatically renewed (true) or not (false). Auto renewal only takes effect after the account is charged. Default: true
    public var autoRenew: Swift.Bool?
    /// The domain name that you want to register. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html). For more information, see [Formatting Internationalized Domain Names](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns).
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to register the domain for. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. For the range of valid values for your domain, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. Default: 1
    /// This member is required.
    public var durationInYears: Swift.Int?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the admin contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectAdminContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the registrant contact (the domain owner). You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectRegistrantContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectTechContact: Swift.Bool?
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init (
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        autoRenew: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil,
        idnLangCode: Swift.String? = nil,
        privacyProtectAdminContact: Swift.Bool? = nil,
        privacyProtectRegistrantContact: Swift.Bool? = nil,
        privacyProtectTechContact: Swift.Bool? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.autoRenew = autoRenew
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct RegisterDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let idnLangCode: Swift.String?
    let durationInYears: Swift.Int?
    let autoRenew: Swift.Bool?
    let adminContact: Route53DomainsClientTypes.ContactDetail?
    let registrantContact: Route53DomainsClientTypes.ContactDetail?
    let techContact: Route53DomainsClientTypes.ContactDetail?
    let privacyProtectAdminContact: Swift.Bool?
    let privacyProtectRegistrantContact: Swift.Bool?
    let privacyProtectTechContact: Swift.Bool?
}

extension RegisterDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let privacyProtectAdminContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectAdminContact)
        privacyProtectAdminContact = privacyProtectAdminContactDecoded
        let privacyProtectRegistrantContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectRegistrantContact)
        privacyProtectRegistrantContact = privacyProtectRegistrantContactDecoded
        let privacyProtectTechContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectTechContact)
        privacyProtectTechContact = privacyProtectTechContactDecoded
    }
}

extension RegisterDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterDomainOutputError: Swift.Error, Swift.Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The RegisterDomain response includes the following element.
public struct RegisterDomainOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension RegisterDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RejectDomainTransferFromAnotherAwsAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension RejectDomainTransferFromAnotherAwsAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The RejectDomainTransferFromAnotherAwsAccount request includes the following element.
public struct RejectDomainTransferFromAnotherAwsAccountInput: Swift.Equatable {
    /// The name of the domain that was specified when another Amazon Web Services account submitted a [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct RejectDomainTransferFromAnotherAwsAccountInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension RejectDomainTransferFromAnotherAwsAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RejectDomainTransferFromAnotherAwsAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectDomainTransferFromAnotherAwsAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RejectDomainTransferFromAnotherAwsAccountOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectDomainTransferFromAnotherAwsAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RejectDomainTransferFromAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The RejectDomainTransferFromAnotherAwsAccount response includes the following element.
public struct RejectDomainTransferFromAnotherAwsAccountOutputResponse: Swift.Equatable {
    /// The identifier that TransferDomainToAnotherAwsAccount returned to track the progress of the request. Because the transfer request was rejected, the value is no longer valid, and you can't use GetOperationDetail to query the operation status.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RejectDomainTransferFromAnotherAwsAccountOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension RejectDomainTransferFromAnotherAwsAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RenewDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentExpiryYear = "CurrentExpiryYear"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentExpiryYear != 0 {
            try encodeContainer.encode(currentExpiryYear, forKey: .currentExpiryYear)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = self.durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
    }
}

extension RenewDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A RenewDomain request includes the number of years that you want to renew for and the current expiration year.
public struct RenewDomainInput: Swift.Equatable {
    /// The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain.
    /// This member is required.
    public var currentExpiryYear: Swift.Int
    /// The name of the domain that you want to renew.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain. For the range of valid values for your domain, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. Default: 1
    public var durationInYears: Swift.Int?

    public init (
        currentExpiryYear: Swift.Int = 0,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil
    )
    {
        self.currentExpiryYear = currentExpiryYear
        self.domainName = domainName
        self.durationInYears = durationInYears
    }
}

struct RenewDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let durationInYears: Swift.Int?
    let currentExpiryYear: Swift.Int
}

extension RenewDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentExpiryYear = "CurrentExpiryYear"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let currentExpiryYearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentExpiryYear) ?? 0
        currentExpiryYear = currentExpiryYearDecoded
    }
}

extension RenewDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RenewDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RenewDomainOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RenewDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RenewDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RenewDomainOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RenewDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension RenewDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension ResendContactReachabilityEmailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension ResendContactReachabilityEmailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResendContactReachabilityEmailInput: Swift.Equatable {
    /// The name of the domain for which you want Route 53 to resend a confirmation email to the registrant contact.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct ResendContactReachabilityEmailInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension ResendContactReachabilityEmailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension ResendContactReachabilityEmailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResendContactReachabilityEmailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResendContactReachabilityEmailOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResendContactReachabilityEmailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResendContactReachabilityEmailOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainName = output.domainName
            self.emailAddress = output.emailAddress
            self.isAlreadyVerified = output.isAlreadyVerified
        } else {
            self.domainName = nil
            self.emailAddress = nil
            self.isAlreadyVerified = nil
        }
    }
}

public struct ResendContactReachabilityEmailOutputResponse: Swift.Equatable {
    /// The domain name for which you requested a confirmation email.
    public var domainName: Swift.String?
    /// The email address for the registrant contact at the time that we sent the verification email.
    public var emailAddress: Swift.String?
    /// True if the email address for the registrant contact has already been verified, and false otherwise. If the email address has already been verified, we don't send another confirmation email.
    public var isAlreadyVerified: Swift.Bool?

    public init (
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        isAlreadyVerified: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.isAlreadyVerified = isAlreadyVerified
    }
}

struct ResendContactReachabilityEmailOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let emailAddress: Swift.String?
    let isAlreadyVerified: Swift.Bool?
}

extension ResendContactReachabilityEmailOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case emailAddress
        case isAlreadyVerified
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let isAlreadyVerifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAlreadyVerified)
        isAlreadyVerified = isAlreadyVerifiedDecoded
    }
}

extension ResendOperationAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = self.operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

extension ResendOperationAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResendOperationAuthorizationInput: Swift.Equatable {
    /// Operation ID.
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct ResendOperationAuthorizationInputBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension ResendOperationAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension ResendOperationAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResendOperationAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResendOperationAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResendOperationAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResendOperationAuthorizationOutputResponse: Swift.Equatable {

    public init () { }
}

extension RetrieveDomainAuthCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension RetrieveDomainAuthCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// A request for the authorization code for the specified domain. To transfer a domain to another registrar, you provide this value to the new registrar.
public struct RetrieveDomainAuthCodeInput: Swift.Equatable {
    /// The name of the domain that you want to get an authorization code for.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct RetrieveDomainAuthCodeInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension RetrieveDomainAuthCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RetrieveDomainAuthCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveDomainAuthCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetrieveDomainAuthCodeOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveDomainAuthCodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveDomainAuthCodeOutputResponse(authCode: \"CONTENT_REDACTED\")"}
}

extension RetrieveDomainAuthCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetrieveDomainAuthCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authCode = output.authCode
        } else {
            self.authCode = nil
        }
    }
}

/// The RetrieveDomainAuthCode response includes the following element.
public struct RetrieveDomainAuthCodeOutputResponse: Swift.Equatable {
    /// The authorization code for the domain.
    public var authCode: Swift.String?

    public init (
        authCode: Swift.String? = nil
    )
    {
        self.authCode = authCode
    }
}

struct RetrieveDomainAuthCodeOutputResponseBody: Swift.Equatable {
    let authCode: Swift.String?
}

extension RetrieveDomainAuthCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode = "AuthCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
    }
}

extension Route53DomainsClientTypes.SortCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ListDomainsAttributeName.self, forKey: .name)
        name = nameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Information for sorting a list of domains.
    public struct SortCondition: Swift.Equatable {
        /// Field to be used for sorting the list of domains. It can be either the name or the expiration for a domain. Note that if filterCondition is used in the same [ListDomains](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains__ListDomains.html) call, the field used for sorting has to be the same as the field used for filtering.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ListDomainsAttributeName?
        /// The sort order for a list of domains. Either ascending (ASC) or descending (DES).
        /// This member is required.
        public var sortOrder: Route53DomainsClientTypes.SortOrder?

        public init (
            name: Route53DomainsClientTypes.ListDomainsAttributeName? = nil,
            sortOrder: Route53DomainsClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }

}

extension Route53DomainsClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension Route53DomainsClientTypes {
    public enum StatusFlag: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pendingAcceptance
        case pendingAuthorization
        case pendingCustomerAction
        case pendingPaymentVerification
        case pendingSupportCase
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusFlag] {
            return [
                .pendingAcceptance,
                .pendingAuthorization,
                .pendingCustomerAction,
                .pendingPaymentVerification,
                .pendingSupportCase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .pendingAuthorization: return "PENDING_AUTHORIZATION"
            case .pendingCustomerAction: return "PENDING_CUSTOMER_ACTION"
            case .pendingPaymentVerification: return "PENDING_PAYMENT_VERIFICATION"
            case .pendingSupportCase: return "PENDING_SUPPORT_CASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusFlag(rawValue: rawValue) ?? StatusFlag.sdkUnknown(rawValue)
        }
    }
}

extension TLDRulesViolation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TLDRulesViolationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The top-level domain does not support this operation.
public struct TLDRulesViolation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The top-level domain does not support this operation.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TLDRulesViolationBody: Swift.Equatable {
    let message: Swift.String?
}

extension TLDRulesViolationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53DomainsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Each tag includes the following elements.
    public struct Tag: Swift.Equatable {
        /// The key (name) of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each key can be 1-128 characters long.
        public var key: Swift.String?
        /// The value of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each value can be 0-256 characters long.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TransferDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransferDomainInput(autoRenew: \(Swift.String(describing: autoRenew)), domainName: \(Swift.String(describing: domainName)), durationInYears: \(Swift.String(describing: durationInYears)), idnLangCode: \(Swift.String(describing: idnLangCode)), nameservers: \(Swift.String(describing: nameservers)), privacyProtectAdminContact: \(Swift.String(describing: privacyProtectAdminContact)), privacyProtectRegistrantContact: \(Swift.String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(Swift.String(describing: privacyProtectTechContact)), adminContact: \"CONTENT_REDACTED\", authCode: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

extension TransferDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case authCode = "AuthCode"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case nameservers = "Nameservers"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = self.adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let authCode = self.authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let autoRenew = self.autoRenew {
            try encodeContainer.encode(autoRenew, forKey: .autoRenew)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let durationInYears = self.durationInYears {
            try encodeContainer.encode(durationInYears, forKey: .durationInYears)
        }
        if let idnLangCode = self.idnLangCode {
            try encodeContainer.encode(idnLangCode, forKey: .idnLangCode)
        }
        if let nameservers = nameservers {
            var nameserversContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nameservers)
            for nameserver0 in nameservers {
                try nameserversContainer.encode(nameserver0)
            }
        }
        if let privacyProtectAdminContact = self.privacyProtectAdminContact {
            try encodeContainer.encode(privacyProtectAdminContact, forKey: .privacyProtectAdminContact)
        }
        if let privacyProtectRegistrantContact = self.privacyProtectRegistrantContact {
            try encodeContainer.encode(privacyProtectRegistrantContact, forKey: .privacyProtectRegistrantContact)
        }
        if let privacyProtectTechContact = self.privacyProtectTechContact {
            try encodeContainer.encode(privacyProtectTechContact, forKey: .privacyProtectTechContact)
        }
        if let registrantContact = self.registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = self.techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

extension TransferDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The TransferDomain request includes the following elements.
public struct TransferDomainInput: Swift.Equatable {
    /// Provides detailed contact information.
    /// This member is required.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// The authorization code for the domain. You get this value from the current registrar.
    public var authCode: Swift.String?
    /// Indicates whether the domain will be automatically renewed (true) or not (false). Auto renewal only takes effect after the account is charged. Default: true
    public var autoRenew: Swift.Bool?
    /// The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to register the domain for. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. Default: 1
    /// This member is required.
    public var durationInYears: Swift.Int?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?
    /// Contains details for the host and glue IP addresses.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the admin contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectAdminContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the registrant contact (domain owner). You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectRegistrantContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts. Default: true
    public var privacyProtectTechContact: Swift.Bool?
    /// Provides detailed contact information.
    /// This member is required.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information.
    /// This member is required.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init (
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        authCode: Swift.String? = nil,
        autoRenew: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil,
        idnLangCode: Swift.String? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil,
        privacyProtectAdminContact: Swift.Bool? = nil,
        privacyProtectRegistrantContact: Swift.Bool? = nil,
        privacyProtectTechContact: Swift.Bool? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.authCode = authCode
        self.autoRenew = autoRenew
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.nameservers = nameservers
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct TransferDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let idnLangCode: Swift.String?
    let durationInYears: Swift.Int?
    let nameservers: [Route53DomainsClientTypes.Nameserver]?
    let authCode: Swift.String?
    let autoRenew: Swift.Bool?
    let adminContact: Route53DomainsClientTypes.ContactDetail?
    let registrantContact: Route53DomainsClientTypes.ContactDetail?
    let techContact: Route53DomainsClientTypes.ContactDetail?
    let privacyProtectAdminContact: Swift.Bool?
    let privacyProtectRegistrantContact: Swift.Bool?
    let privacyProtectTechContact: Swift.Bool?
}

extension TransferDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case authCode = "AuthCode"
        case autoRenew = "AutoRenew"
        case domainName = "DomainName"
        case durationInYears = "DurationInYears"
        case idnLangCode = "IdnLangCode"
        case nameservers = "Nameservers"
        case privacyProtectAdminContact = "PrivacyProtectAdminContact"
        case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
        case privacyProtectTechContact = "PrivacyProtectTechContact"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idnLangCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idnLangCode)
        idnLangCode = idnLangCodeDecoded
        let durationInYearsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInYears)
        durationInYears = durationInYearsDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Route53DomainsClientTypes.Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Route53DomainsClientTypes.Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let privacyProtectAdminContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectAdminContact)
        privacyProtectAdminContact = privacyProtectAdminContactDecoded
        let privacyProtectRegistrantContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectRegistrantContact)
        privacyProtectRegistrantContact = privacyProtectRegistrantContactDecoded
        let privacyProtectTechContactDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privacyProtectTechContact)
        privacyProtectTechContact = privacyProtectTechContactDecoded
    }
}

extension TransferDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TransferDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DomainLimitExceeded" : self = .domainLimitExceeded(try DomainLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TransferDomainOutputError: Swift.Error, Swift.Equatable {
    case domainLimitExceeded(DomainLimitExceeded)
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension TransferDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TransferDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The TransferDomain response includes the following element.
public struct TransferDomainOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct TransferDomainOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension TransferDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension TransferDomainToAnotherAwsAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension TransferDomainToAnotherAwsAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The TransferDomainToAnotherAwsAccount request includes the following elements.
public struct TransferDomainToAnotherAwsAccountInput: Swift.Equatable {
    /// The account ID of the Amazon Web Services account that you want to transfer the domain to, for example, 111122223333.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the domain that you want to transfer from the current Amazon Web Services account to another account.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.domainName = domainName
    }
}

struct TransferDomainToAnotherAwsAccountInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let accountId: Swift.String?
}

extension TransferDomainToAnotherAwsAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension TransferDomainToAnotherAwsAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TransferDomainToAnotherAwsAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TransferDomainToAnotherAwsAccountOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension TransferDomainToAnotherAwsAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TransferDomainToAnotherAwsAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.password = output.password
        } else {
            self.operationId = nil
            self.password = nil
        }
    }
}

/// The TransferDomainToAnotherAwsAccount response includes the following elements.
public struct TransferDomainToAnotherAwsAccountOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?
    /// To finish transferring a domain to another Amazon Web Services account, the account that the domain is being transferred to must submit an [AcceptDomainTransferFromAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AcceptDomainTransferFromAnotherAwsAccount.html) request. The request must include the value of the Password element that was returned in the TransferDomainToAnotherAwsAccount response.
    public var password: Swift.String?

    public init (
        operationId: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.operationId = operationId
        self.password = password
    }
}

struct TransferDomainToAnotherAwsAccountOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
    let password: Swift.String?
}

extension TransferDomainToAnotherAwsAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension Route53DomainsClientTypes {
    /// Whether the domain name can be transferred to Route 53. You can transfer only domains that have a value of TRANSFERABLE or Transferable. Valid values: TRANSFERABLE The domain name can be transferred to Route 53. UNTRANSFERRABLE The domain name can't be transferred to Route 53. DONT_KNOW Reserved for future use. DOMAIN_IN_OWN_ACCOUNT The domain already exists in the current Amazon Web Services account. DOMAIN_IN_ANOTHER_ACCOUNT the domain exists in another Amazon Web Services account. PREMIUM_DOMAIN Premium domain transfer is not supported.
    public enum Transferable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainInAnotherAccount
        case domainInOwnAccount
        case dontKnow
        case premiumDomain
        case transferable
        case untransferable
        case sdkUnknown(Swift.String)

        public static var allCases: [Transferable] {
            return [
                .domainInAnotherAccount,
                .domainInOwnAccount,
                .dontKnow,
                .premiumDomain,
                .transferable,
                .untransferable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainInAnotherAccount: return "DOMAIN_IN_ANOTHER_ACCOUNT"
            case .domainInOwnAccount: return "DOMAIN_IN_OWN_ACCOUNT"
            case .dontKnow: return "DONT_KNOW"
            case .premiumDomain: return "PREMIUM_DOMAIN"
            case .transferable: return "TRANSFERABLE"
            case .untransferable: return "UNTRANSFERABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Transferable(rawValue: rawValue) ?? Transferable.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedTLD {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedTLDBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Route 53 does not support this top-level domain (TLD).
public struct UnsupportedTLD: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Amazon Route 53 does not support this top-level domain (TLD).
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedTLDBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedTLDBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDomainContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainContactInput(consent: \(Swift.String(describing: consent)), domainName: \(Swift.String(describing: domainName)), adminContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

extension UpdateDomainContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case consent = "Consent"
        case domainName = "DomainName"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminContact = self.adminContact {
            try encodeContainer.encode(adminContact, forKey: .adminContact)
        }
        if let consent = self.consent {
            try encodeContainer.encode(consent, forKey: .consent)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let registrantContact = self.registrantContact {
            try encodeContainer.encode(registrantContact, forKey: .registrantContact)
        }
        if let techContact = self.techContact {
            try encodeContainer.encode(techContact, forKey: .techContact)
        }
    }
}

extension UpdateDomainContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The UpdateDomainContact request includes the following elements.
public struct UpdateDomainContactInput: Swift.Equatable {
    /// Provides detailed contact information.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Customer's consent for the owner change request.
    public var consent: Route53DomainsClientTypes.Consent?
    /// The name of the domain that you want to update contact information for.
    /// This member is required.
    public var domainName: Swift.String?
    /// Provides detailed contact information.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init (
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        consent: Route53DomainsClientTypes.Consent? = nil,
        domainName: Swift.String? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.consent = consent
        self.domainName = domainName
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

struct UpdateDomainContactInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let adminContact: Route53DomainsClientTypes.ContactDetail?
    let registrantContact: Route53DomainsClientTypes.ContactDetail?
    let techContact: Route53DomainsClientTypes.ContactDetail?
    let consent: Route53DomainsClientTypes.Consent?
}

extension UpdateDomainContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminContact = "AdminContact"
        case consent = "Consent"
        case domainName = "DomainName"
        case registrantContact = "RegistrantContact"
        case techContact = "TechContact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let adminContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .adminContact)
        adminContact = adminContactDecoded
        let registrantContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .registrantContact)
        registrantContact = registrantContactDecoded
        let techContactDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.ContactDetail.self, forKey: .techContact)
        techContact = techContactDecoded
        let consentDecoded = try containerValues.decodeIfPresent(Route53DomainsClientTypes.Consent.self, forKey: .consent)
        consent = consentDecoded
    }
}

extension UpdateDomainContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainContactOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDomainContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The UpdateDomainContact response includes the following element.
public struct UpdateDomainContactOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainContactOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdateDomainContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateDomainContactPrivacyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPrivacy = "AdminPrivacy"
        case domainName = "DomainName"
        case registrantPrivacy = "RegistrantPrivacy"
        case techPrivacy = "TechPrivacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminPrivacy = self.adminPrivacy {
            try encodeContainer.encode(adminPrivacy, forKey: .adminPrivacy)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let registrantPrivacy = self.registrantPrivacy {
            try encodeContainer.encode(registrantPrivacy, forKey: .registrantPrivacy)
        }
        if let techPrivacy = self.techPrivacy {
            try encodeContainer.encode(techPrivacy, forKey: .techPrivacy)
        }
    }
}

extension UpdateDomainContactPrivacyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The UpdateDomainContactPrivacy request includes the following elements.
public struct UpdateDomainContactPrivacyInput: Swift.Equatable {
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the admin contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts.
    public var adminPrivacy: Swift.Bool?
    /// The name of the domain that you want to update the privacy setting for.
    /// This member is required.
    public var domainName: Swift.String?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the registrant contact (domain owner). You must specify the same privacy setting for the administrative, registrant, and technical contacts.
    public var registrantPrivacy: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar (for .com, .net, and .org domains) or for our registrar associate, Gandi (for all other TLDs). If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, registrant, and technical contacts.
    public var techPrivacy: Swift.Bool?

    public init (
        adminPrivacy: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        registrantPrivacy: Swift.Bool? = nil,
        techPrivacy: Swift.Bool? = nil
    )
    {
        self.adminPrivacy = adminPrivacy
        self.domainName = domainName
        self.registrantPrivacy = registrantPrivacy
        self.techPrivacy = techPrivacy
    }
}

struct UpdateDomainContactPrivacyInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let adminPrivacy: Swift.Bool?
    let registrantPrivacy: Swift.Bool?
    let techPrivacy: Swift.Bool?
}

extension UpdateDomainContactPrivacyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminPrivacy = "AdminPrivacy"
        case domainName = "DomainName"
        case registrantPrivacy = "RegistrantPrivacy"
        case techPrivacy = "TechPrivacy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let adminPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .adminPrivacy)
        adminPrivacy = adminPrivacyDecoded
        let registrantPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registrantPrivacy)
        registrantPrivacy = registrantPrivacyDecoded
        let techPrivacyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .techPrivacy)
        techPrivacy = techPrivacyDecoded
    }
}

extension UpdateDomainContactPrivacyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainContactPrivacyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainContactPrivacyOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainContactPrivacyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDomainContactPrivacyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The UpdateDomainContactPrivacy response includes the following element.
public struct UpdateDomainContactPrivacyOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainContactPrivacyOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdateDomainContactPrivacyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateDomainNameserversInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainNameserversInput(domainName: \(Swift.String(describing: domainName)), nameservers: \(Swift.String(describing: nameservers)), fiAuthKey: \"CONTENT_REDACTED\")"}
}

extension UpdateDomainNameserversInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fiAuthKey = "FIAuthKey"
        case nameservers = "Nameservers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fiAuthKey = self.fiAuthKey {
            try encodeContainer.encode(fiAuthKey, forKey: .fiAuthKey)
        }
        if let nameservers = nameservers {
            var nameserversContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nameservers)
            for nameserver0 in nameservers {
                try nameserversContainer.encode(nameserver0)
            }
        }
    }
}

extension UpdateDomainNameserversInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Replaces the current set of name servers for the domain with the specified set of name servers. If you use Amazon Route 53 as your DNS service, specify the four name servers in the delegation set for the hosted zone for the domain. If successful, this operation returns an operation ID that you can use to track the progress and completion of the action. If the request is not completed successfully, the domain registrant will be notified by email.
public struct UpdateDomainNameserversInput: Swift.Equatable {
    /// The name of the domain that you want to change name servers for.
    /// This member is required.
    public var domainName: Swift.String?
    /// The authorization key for .fi domains
    @available(*, deprecated)
    public var fiAuthKey: Swift.String?
    /// A list of new name servers for the domain.
    /// This member is required.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?

    public init (
        domainName: Swift.String? = nil,
        fiAuthKey: Swift.String? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil
    )
    {
        self.domainName = domainName
        self.fiAuthKey = fiAuthKey
        self.nameservers = nameservers
    }
}

struct UpdateDomainNameserversInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let fiAuthKey: Swift.String?
    let nameservers: [Route53DomainsClientTypes.Nameserver]?
}

extension UpdateDomainNameserversInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case fiAuthKey = "FIAuthKey"
        case nameservers = "Nameservers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let fiAuthKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fiAuthKey)
        fiAuthKey = fiAuthKeyDecoded
        let nameserversContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.Nameserver?].self, forKey: .nameservers)
        var nameserversDecoded0:[Route53DomainsClientTypes.Nameserver]? = nil
        if let nameserversContainer = nameserversContainer {
            nameserversDecoded0 = [Route53DomainsClientTypes.Nameserver]()
            for structure0 in nameserversContainer {
                if let structure0 = structure0 {
                    nameserversDecoded0?.append(structure0)
                }
            }
        }
        nameservers = nameserversDecoded0
    }
}

extension UpdateDomainNameserversOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameserversOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TLDRulesViolation" : self = .tLDRulesViolation(try TLDRulesViolation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainNameserversOutputError: Swift.Error, Swift.Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case tLDRulesViolation(TLDRulesViolation)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameserversOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDomainNameserversOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

/// The UpdateDomainNameservers response includes the following element.
public struct UpdateDomainNameserversOutputResponse: Swift.Equatable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateDomainNameserversOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension UpdateDomainNameserversOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateTagsForDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case tagsToUpdate = "TagsToUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let tagsToUpdate = tagsToUpdate {
            var tagsToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToUpdate)
            for tag0 in tagsToUpdate {
                try tagsToUpdateContainer.encode(tag0)
            }
        }
    }
}

extension UpdateTagsForDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The UpdateTagsForDomainRequest includes the following elements.
public struct UpdateTagsForDomainInput: Swift.Equatable {
    /// The domain for which you want to add or update tags.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the tag keys and values that you want to add or update. If you specify a key that already exists, the corresponding value will be replaced.
    public var tagsToUpdate: [Route53DomainsClientTypes.Tag]?

    public init (
        domainName: Swift.String? = nil,
        tagsToUpdate: [Route53DomainsClientTypes.Tag]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToUpdate = tagsToUpdate
    }
}

struct UpdateTagsForDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let tagsToUpdate: [Route53DomainsClientTypes.Tag]?
}

extension UpdateTagsForDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case tagsToUpdate = "TagsToUpdate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let tagsToUpdateContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.Tag?].self, forKey: .tagsToUpdate)
        var tagsToUpdateDecoded0:[Route53DomainsClientTypes.Tag]? = nil
        if let tagsToUpdateContainer = tagsToUpdateContainer {
            tagsToUpdateDecoded0 = [Route53DomainsClientTypes.Tag]()
            for structure0 in tagsToUpdateContainer {
                if let structure0 = structure0 {
                    tagsToUpdateDecoded0?.append(structure0)
                }
            }
        }
        tagsToUpdate = tagsToUpdateDecoded0
    }
}

extension UpdateTagsForDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTagsForDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationLimitExceeded" : self = .operationLimitExceeded(try OperationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedTLD" : self = .unsupportedTLD(try UnsupportedTLD(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTagsForDomainOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case operationLimitExceeded(OperationLimitExceeded)
    case unsupportedTLD(UnsupportedTLD)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTagsForDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTagsForDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension ViewBillingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encodeTimestamp(end, format: .epochSeconds, forKey: .end)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxItems = self.maxItems {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .epochSeconds, forKey: .start)
        }
    }
}

extension ViewBillingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The ViewBilling request includes the following elements.
public struct ViewBillingInput: Swift.Equatable {
    /// The end date and time for the time period for which you want a list of billing records. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var end: ClientRuntime.Date?
    /// For an initial request for a list of billing records, omit this element. If the number of billing records that are associated with the current Amazon Web Services account during the specified period is greater than the value that you specified for MaxItems, you can use Marker to return additional billing records. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Constraints: The marker must match the value of NextPageMarker that was returned in the previous response.
    public var marker: Swift.String?
    /// The number of billing records to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// The beginning date and time for the time period for which you want a list of billing records. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var start: ClientRuntime.Date?

    public init (
        end: ClientRuntime.Date? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        start: ClientRuntime.Date? = nil
    )
    {
        self.end = end
        self.marker = marker
        self.maxItems = maxItems
        self.start = start
    }
}

struct ViewBillingInputBody: Swift.Equatable {
    let start: ClientRuntime.Date?
    let end: ClientRuntime.Date?
    let marker: Swift.String?
    let maxItems: Swift.Int?
}

extension ViewBillingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case start = "Start"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .end)
        end = endDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension ViewBillingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ViewBillingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ViewBillingOutputError: Swift.Error, Swift.Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ViewBillingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ViewBillingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingRecords = output.billingRecords
            self.nextPageMarker = output.nextPageMarker
        } else {
            self.billingRecords = nil
            self.nextPageMarker = nil
        }
    }
}

/// The ViewBilling response includes the following elements.
public struct ViewBillingOutputResponse: Swift.Equatable {
    /// A summary of billing records.
    public var billingRecords: [Route53DomainsClientTypes.BillingRecord]?
    /// If there are more billing records than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?

    public init (
        billingRecords: [Route53DomainsClientTypes.BillingRecord]? = nil,
        nextPageMarker: Swift.String? = nil
    )
    {
        self.billingRecords = billingRecords
        self.nextPageMarker = nextPageMarker
    }
}

struct ViewBillingOutputResponseBody: Swift.Equatable {
    let nextPageMarker: Swift.String?
    let billingRecords: [Route53DomainsClientTypes.BillingRecord]?
}

extension ViewBillingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingRecords = "BillingRecords"
        case nextPageMarker = "NextPageMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageMarker)
        nextPageMarker = nextPageMarkerDecoded
        let billingRecordsContainer = try containerValues.decodeIfPresent([Route53DomainsClientTypes.BillingRecord?].self, forKey: .billingRecords)
        var billingRecordsDecoded0:[Route53DomainsClientTypes.BillingRecord]? = nil
        if let billingRecordsContainer = billingRecordsContainer {
            billingRecordsDecoded0 = [Route53DomainsClientTypes.BillingRecord]()
            for structure0 in billingRecordsContainer {
                if let structure0 = structure0 {
                    billingRecordsDecoded0?.append(structure0)
                }
            }
        }
        billingRecords = billingRecordsDecoded0
    }
}
