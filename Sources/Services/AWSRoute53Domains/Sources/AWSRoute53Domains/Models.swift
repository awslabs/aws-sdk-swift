//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct PushDomainOutput: Swift.Sendable {

    public init() { }
}

public struct ResendOperationAuthorizationOutput: Swift.Sendable {

    public init() { }
}

/// The number of domains has exceeded the allowed threshold for the account.
public struct DomainLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The number of domains has exceeded the allowed threshold for the account.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DomainLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested item is not acceptable. For example, for APIs that accept a domain name, the request might specify a domain name that doesn't belong to the account that submitted the request. For AcceptDomainTransferFromAnotherAwsAccount, the password might be invalid.
public struct InvalidInput: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The requested item is not acceptable. For example, for an OperationId it might refer to the ID of an operation that is already completed. For a domain name, it might not be a valid domain name or belong to the requester account.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInput" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of operations or jobs running exceeded the allowed threshold for the account.
public struct OperationLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The number of operations or jobs running exceeded the allowed threshold for the account.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Amazon Route 53 does not support this top-level domain (TLD).
public struct UnsupportedTLD: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Amazon Route 53 does not support this top-level domain (TLD).
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedTLD" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The AcceptDomainTransferFromAnotherAwsAccount request includes the following elements.
public struct AcceptDomainTransferFromAnotherAwsAccountInput: Swift.Sendable {
    /// The name of the domain that was specified when another Amazon Web Services account submitted a [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var domainName: Swift.String?
    /// The password that was returned by the [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var password: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.password = password
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptDomainTransferFromAnotherAwsAccountInput(domainName: \(Swift.String(describing: domainName)), password: \"CONTENT_REDACTED\")"}
}

/// The AcceptDomainTransferFromAnotherAwsAccount response includes the following element.
public struct AcceptDomainTransferFromAnotherAwsAccountOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// This error is returned if you call AssociateDelegationSignerToDomain when the specified domain has reached the maximum number of DS records. You can't add any additional DS records unless you delete an existing one first.
public struct DnssecLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DnssecLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is already in progress for the domain.
public struct DuplicateRequest: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request is already in progress for the domain.
        public internal(set) var message: Swift.String? = nil
        /// ID of the request operation.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The top-level domain does not support this operation.
public struct TLDRulesViolation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The top-level domain does not support this operation.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TLDRulesViolation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53DomainsClientTypes {

    /// Information about a delegation signer (DS) record that was created in the registry by [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html).
    public struct DnssecSigningAttributes: Swift.Sendable {
        /// Algorithm which was used to generate the digest from the public key.
        public var algorithm: Swift.Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.
        public var flags: Swift.Int?
        /// The base64-encoded public key part of the key pair that is passed to the registry.
        public var publicKey: Swift.String?

        public init(
            algorithm: Swift.Int? = nil,
            flags: Swift.Int? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.flags = flags
            self.publicKey = publicKey
        }
    }
}

public struct AssociateDelegationSignerToDomainInput: Swift.Sendable {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The information about a key, including the algorithm, public key-value, and flags.
    /// This member is required.
    public var signingAttributes: Route53DomainsClientTypes.DnssecSigningAttributes?

    public init(
        domainName: Swift.String? = nil,
        signingAttributes: Route53DomainsClientTypes.DnssecSigningAttributes? = nil
    )
    {
        self.domainName = domainName
        self.signingAttributes = signingAttributes
    }
}

public struct AssociateDelegationSignerToDomainOutput: Swift.Sendable {
    /// The identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension Route53DomainsClientTypes {

    public enum OperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addDnssec
        case changeDomainOwner
        case changePrivacyProtection
        case deleteDomain
        case disableAutorenew
        case domainLock
        case enableAutorenew
        case expireDomain
        case internalTransferInDomain
        case internalTransferOutDomain
        case pushDomain
        case registerDomain
        case releaseToGandi
        case removeDnssec
        case renewDomain
        case transferInDomain
        case transferOnRenew
        case transferOutDomain
        case updateDomainContact
        case updateNameserver
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .addDnssec,
                .changeDomainOwner,
                .changePrivacyProtection,
                .deleteDomain,
                .disableAutorenew,
                .domainLock,
                .enableAutorenew,
                .expireDomain,
                .internalTransferInDomain,
                .internalTransferOutDomain,
                .pushDomain,
                .registerDomain,
                .releaseToGandi,
                .removeDnssec,
                .renewDomain,
                .transferInDomain,
                .transferOnRenew,
                .transferOutDomain,
                .updateDomainContact,
                .updateNameserver
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addDnssec: return "ADD_DNSSEC"
            case .changeDomainOwner: return "CHANGE_DOMAIN_OWNER"
            case .changePrivacyProtection: return "CHANGE_PRIVACY_PROTECTION"
            case .deleteDomain: return "DELETE_DOMAIN"
            case .disableAutorenew: return "DISABLE_AUTORENEW"
            case .domainLock: return "DOMAIN_LOCK"
            case .enableAutorenew: return "ENABLE_AUTORENEW"
            case .expireDomain: return "EXPIRE_DOMAIN"
            case .internalTransferInDomain: return "INTERNAL_TRANSFER_IN_DOMAIN"
            case .internalTransferOutDomain: return "INTERNAL_TRANSFER_OUT_DOMAIN"
            case .pushDomain: return "PUSH_DOMAIN"
            case .registerDomain: return "REGISTER_DOMAIN"
            case .releaseToGandi: return "RELEASE_TO_GANDI"
            case .removeDnssec: return "REMOVE_DNSSEC"
            case .renewDomain: return "RENEW_DOMAIN"
            case .transferInDomain: return "TRANSFER_IN_DOMAIN"
            case .transferOnRenew: return "TRANSFER_ON_RENEW"
            case .transferOutDomain: return "TRANSFER_OUT_DOMAIN"
            case .updateDomainContact: return "UPDATE_DOMAIN_CONTACT"
            case .updateNameserver: return "UPDATE_NAMESERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    /// Information for one billing record.
    public struct BillingRecord: Swift.Sendable {
        /// The date that the operation was billed, in Unix format.
        public var billDate: Foundation.Date?
        /// The name of the domain that the billing record applies to. If the domain name contains characters other than a-z, 0-9, and - (hyphen), such as an internationalized domain name, then this value is in Punycode. For more information, see [DNS Domain Name Format](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html) in the Amazon Route 53 Developer Guide.
        public var domainName: Swift.String?
        /// The ID of the invoice that is associated with the billing record.
        public var invoiceId: Swift.String?
        /// The operation that you were charged for.
        public var operation: Route53DomainsClientTypes.OperationType?
        /// The price that you were charged for the operation, in US dollars. Example value: 12.0
        public var price: Swift.Double

        public init(
            billDate: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            invoiceId: Swift.String? = nil,
            operation: Route53DomainsClientTypes.OperationType? = nil,
            price: Swift.Double = 0.0
        )
        {
            self.billDate = billDate
            self.domainName = domainName
            self.invoiceId = invoiceId
            self.operation = operation
            self.price = price
        }
    }
}

/// The CancelDomainTransferToAnotherAwsAccount request includes the following element.
public struct CancelDomainTransferToAnotherAwsAccountInput: Swift.Sendable {
    /// The name of the domain for which you want to cancel the transfer to another Amazon Web Services account.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The CancelDomainTransferToAnotherAwsAccount response includes the following element.
public struct CancelDomainTransferToAnotherAwsAccountOutput: Swift.Sendable {
    /// The identifier that TransferDomainToAnotherAwsAccount returned to track the progress of the request. Because the transfer request was canceled, the value is no longer valid, and you can't use GetOperationDetail to query the operation status.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The CheckDomainAvailability request contains the following elements.
public struct CheckDomainAvailabilityInput: Swift.Sendable {
    /// The name of the domain that you want to get availability for. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html). For more information, see [Formatting Internationalized Domain Names](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns).
    /// This member is required.
    public var domainName: Swift.String?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        idnLangCode: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.idnLangCode = idnLangCode
    }
}

extension Route53DomainsClientTypes {

    public enum DomainAvailability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case availablePreorder
        case availableReserved
        case dontKnow
        case invalidNameForTld
        case pending
        case reserved
        case unavailable
        case unavailablePremium
        case unavailableRestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainAvailability] {
            return [
                .available,
                .availablePreorder,
                .availableReserved,
                .dontKnow,
                .invalidNameForTld,
                .pending,
                .reserved,
                .unavailable,
                .unavailablePremium,
                .unavailableRestricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .availablePreorder: return "AVAILABLE_PREORDER"
            case .availableReserved: return "AVAILABLE_RESERVED"
            case .dontKnow: return "DONT_KNOW"
            case .invalidNameForTld: return "INVALID_NAME_FOR_TLD"
            case .pending: return "PENDING"
            case .reserved: return "RESERVED"
            case .unavailable: return "UNAVAILABLE"
            case .unavailablePremium: return "UNAVAILABLE_PREMIUM"
            case .unavailableRestricted: return "UNAVAILABLE_RESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The CheckDomainAvailability response includes the following elements.
public struct CheckDomainAvailabilityOutput: Swift.Sendable {
    /// Whether the domain name is available for registering. You can register only domains designated as AVAILABLE. Valid values: AVAILABLE The domain name is available. AVAILABLE_RESERVED The domain name is reserved under specific conditions. AVAILABLE_PREORDER The domain name is available and can be preordered. DONT_KNOW The TLD registry didn't reply with a definitive answer about whether the domain name is available. Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance. Try again later. INVALID_NAME_FOR_TLD The TLD isn't valid. For example, it can contain characters that aren't allowed. PENDING The TLD registry didn't return a response in the expected amount of time. When the response is delayed, it usually takes just a few extra seconds. You can resubmit the request immediately. RESERVED The domain name has been reserved for another person or organization. UNAVAILABLE The domain name is not available. UNAVAILABLE_PREMIUM The domain name is not available. UNAVAILABLE_RESTRICTED The domain name is forbidden.
    public var availability: Route53DomainsClientTypes.DomainAvailability?

    public init(
        availability: Route53DomainsClientTypes.DomainAvailability? = nil
    )
    {
        self.availability = availability
    }
}

/// The CheckDomainTransferability request contains the following elements.
public struct CheckDomainTransferabilityInput: Swift.Sendable {
    /// If the registrar for the top-level domain (TLD) requires an authorization code to transfer the domain, the code that you got from the current registrar for the domain.
    public var authCode: Swift.String?
    /// The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        authCode: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.authCode = authCode
        self.domainName = domainName
    }
}

extension CheckDomainTransferabilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckDomainTransferabilityInput(domainName: \(Swift.String(describing: domainName)), authCode: \"CONTENT_REDACTED\")"}
}

extension Route53DomainsClientTypes {

    /// Whether the domain name can be transferred to Route 53. You can transfer only domains that have a value of TRANSFERABLE or Transferable. Valid values: TRANSFERABLE The domain name can be transferred to Route 53. UNTRANSFERRABLE The domain name can't be transferred to Route 53. DONT_KNOW Reserved for future use. DOMAIN_IN_OWN_ACCOUNT The domain already exists in the current Amazon Web Services account. DOMAIN_IN_ANOTHER_ACCOUNT The domain exists in another Amazon Web Services account. PREMIUM_DOMAIN Premium domain transfer is not supported.
    public enum Transferable: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainInAnotherAccount
        case domainInOwnAccount
        case dontKnow
        case premiumDomain
        case transferable
        case untransferable
        case sdkUnknown(Swift.String)

        public static var allCases: [Transferable] {
            return [
                .domainInAnotherAccount,
                .domainInOwnAccount,
                .dontKnow,
                .premiumDomain,
                .transferable,
                .untransferable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainInAnotherAccount: return "DOMAIN_IN_ANOTHER_ACCOUNT"
            case .domainInOwnAccount: return "DOMAIN_IN_OWN_ACCOUNT"
            case .dontKnow: return "DONT_KNOW"
            case .premiumDomain: return "PREMIUM_DOMAIN"
            case .transferable: return "TRANSFERABLE"
            case .untransferable: return "UNTRANSFERABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    /// A complex type that contains information about whether the specified domain can be transferred to Route 53.
    public struct DomainTransferability: Swift.Sendable {
        /// Whether the domain name can be transferred to Route 53. You can transfer only domains that have a value of TRANSFERABLE or Transferable. Valid values: TRANSFERABLE The domain name can be transferred to Route 53. UNTRANSFERRABLE The domain name can't be transferred to Route 53. DONT_KNOW Reserved for future use. DOMAIN_IN_OWN_ACCOUNT The domain already exists in the current Amazon Web Services account. DOMAIN_IN_ANOTHER_ACCOUNT The domain exists in another Amazon Web Services account. PREMIUM_DOMAIN Premium domain transfer is not supported.
        public var transferable: Route53DomainsClientTypes.Transferable?

        public init(
            transferable: Route53DomainsClientTypes.Transferable? = nil
        )
        {
            self.transferable = transferable
        }
    }
}

/// The CheckDomainTransferability response includes the following elements.
public struct CheckDomainTransferabilityOutput: Swift.Sendable {
    /// Provides an explanation for when a domain can't be transferred.
    public var message: Swift.String?
    /// A complex type that contains information about whether the specified domain can be transferred to Route 53.
    public var transferability: Route53DomainsClientTypes.DomainTransferability?

    public init(
        message: Swift.String? = nil,
        transferability: Route53DomainsClientTypes.DomainTransferability? = nil
    )
    {
        self.message = message
        self.transferability = transferability
    }
}

extension Route53DomainsClientTypes {

    /// Customer's consent for the owner change request.
    public struct Consent: Swift.Sendable {
        /// Currency for the MaxPrice.
        /// This member is required.
        public var currency: Swift.String?
        /// Maximum amount the customer agreed to accept.
        /// This member is required.
        public var maxPrice: Swift.Double

        public init(
            currency: Swift.String? = nil,
            maxPrice: Swift.Double = 0.0
        )
        {
            self.currency = currency
            self.maxPrice = maxPrice
        }
    }
}

extension Route53DomainsClientTypes {

    public enum ContactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case association
        case company
        case person
        case publicBody
        case reseller
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .association,
                .company,
                .person,
                .publicBody,
                .reseller
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .association: return "ASSOCIATION"
            case .company: return "COMPANY"
            case .person: return "PERSON"
            case .publicBody: return "PUBLIC_BODY"
            case .reseller: return "RESELLER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    public enum CountryCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ac
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case ax
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case bq
        case br
        case bs
        case bt
        case bv
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gf
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gp
        case gq
        case gr
        case gs
        case gt
        case gu
        case gw
        case gy
        case hk
        case hm
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kp
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mq
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case nf
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case ps
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case ss
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tf
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tp
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [CountryCode] {
            return [
                .ac,
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .ax,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .bq,
                .br,
                .bs,
                .bt,
                .bv,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gf,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gp,
                .gq,
                .gr,
                .gs,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hm,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kp,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mq,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .nf,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .ps,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .ss,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tf,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tp,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ac: return "AC"
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .ax: return "AX"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .bq: return "BQ"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bv: return "BV"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gf: return "GF"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gp: return "GP"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gs: return "GS"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hm: return "HM"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kp: return "KP"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mq: return "MQ"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .nf: return "NF"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .ps: return "PS"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .ss: return "SS"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tf: return "TF"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tp: return "TP"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    public enum ExtraParamName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auIdNumber
        case auIdType
        case auPriorityToken
        case birthCity
        case birthCountry
        case birthDateInYyyyMmDd
        case birthDepartment
        case brandNumber
        case caBusinessEntityType
        case caLegalRepresentative
        case caLegalRepresentativeCapacity
        case caLegalType
        case documentNumber
        case dunsNumber
        case esIdentification
        case esIdentificationType
        case esLegalForm
        case euCountryOfCitizenship
        case fiBusinessNumber
        case fiNationality
        case fiOrganizationType
        case itNationality
        case itPin
        case itRegistrantEntityType
        case onwerFiIdNumber
        case ruPassportData
        case seIdNumber
        case sgIdNumber
        case ukCompanyNumber
        case ukContactType
        case vatNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ExtraParamName] {
            return [
                .auIdNumber,
                .auIdType,
                .auPriorityToken,
                .birthCity,
                .birthCountry,
                .birthDateInYyyyMmDd,
                .birthDepartment,
                .brandNumber,
                .caBusinessEntityType,
                .caLegalRepresentative,
                .caLegalRepresentativeCapacity,
                .caLegalType,
                .documentNumber,
                .dunsNumber,
                .esIdentification,
                .esIdentificationType,
                .esLegalForm,
                .euCountryOfCitizenship,
                .fiBusinessNumber,
                .fiNationality,
                .fiOrganizationType,
                .itNationality,
                .itPin,
                .itRegistrantEntityType,
                .onwerFiIdNumber,
                .ruPassportData,
                .seIdNumber,
                .sgIdNumber,
                .ukCompanyNumber,
                .ukContactType,
                .vatNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auIdNumber: return "AU_ID_NUMBER"
            case .auIdType: return "AU_ID_TYPE"
            case .auPriorityToken: return "AU_PRIORITY_TOKEN"
            case .birthCity: return "BIRTH_CITY"
            case .birthCountry: return "BIRTH_COUNTRY"
            case .birthDateInYyyyMmDd: return "BIRTH_DATE_IN_YYYY_MM_DD"
            case .birthDepartment: return "BIRTH_DEPARTMENT"
            case .brandNumber: return "BRAND_NUMBER"
            case .caBusinessEntityType: return "CA_BUSINESS_ENTITY_TYPE"
            case .caLegalRepresentative: return "CA_LEGAL_REPRESENTATIVE"
            case .caLegalRepresentativeCapacity: return "CA_LEGAL_REPRESENTATIVE_CAPACITY"
            case .caLegalType: return "CA_LEGAL_TYPE"
            case .documentNumber: return "DOCUMENT_NUMBER"
            case .dunsNumber: return "DUNS_NUMBER"
            case .esIdentification: return "ES_IDENTIFICATION"
            case .esIdentificationType: return "ES_IDENTIFICATION_TYPE"
            case .esLegalForm: return "ES_LEGAL_FORM"
            case .euCountryOfCitizenship: return "EU_COUNTRY_OF_CITIZENSHIP"
            case .fiBusinessNumber: return "FI_BUSINESS_NUMBER"
            case .fiNationality: return "FI_NATIONALITY"
            case .fiOrganizationType: return "FI_ORGANIZATION_TYPE"
            case .itNationality: return "IT_NATIONALITY"
            case .itPin: return "IT_PIN"
            case .itRegistrantEntityType: return "IT_REGISTRANT_ENTITY_TYPE"
            case .onwerFiIdNumber: return "FI_ID_NUMBER"
            case .ruPassportData: return "RU_PASSPORT_DATA"
            case .seIdNumber: return "SE_ID_NUMBER"
            case .sgIdNumber: return "SG_ID_NUMBER"
            case .ukCompanyNumber: return "UK_COMPANY_NUMBER"
            case .ukContactType: return "UK_CONTACT_TYPE"
            case .vatNumber: return "VAT_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    /// ExtraParam includes the following elements.
    public struct ExtraParam: Swift.Sendable {
        /// The name of an additional parameter that is required by a top-level domain. Here are the top-level domains that require additional parameters and the names of the parameters that they require: .com.au and .net.au
        ///
        /// * AU_ID_NUMBER
        ///
        /// * AU_ID_TYPE Valid values include the following:
        ///
        /// * ABN (Australian business number)
        ///
        /// * ACN (Australian company number)
        ///
        /// * TM (Trademark number)
        ///
        ///
        ///
        ///
        ///
        /// .ca
        ///
        /// * BRAND_NUMBER
        ///
        /// * CA_BUSINESS_ENTITY_TYPE Valid values include the following:
        ///
        /// * BANK (Bank)
        ///
        /// * COMMERCIAL_COMPANY (Commercial company)
        ///
        /// * COMPANY (Company)
        ///
        /// * COOPERATION (Cooperation)
        ///
        /// * COOPERATIVE (Cooperative)
        ///
        /// * COOPRIX (Cooprix)
        ///
        /// * CORP (Corporation)
        ///
        /// * CREDIT_UNION (Credit union)
        ///
        /// * FOMIA (Federation of mutual insurance associations)
        ///
        /// * INC (Incorporated)
        ///
        /// * LTD (Limited)
        ///
        /// * LTEE (Limitée)
        ///
        /// * LLC (Limited liability corporation)
        ///
        /// * LLP (Limited liability partnership)
        ///
        /// * LTE (Lte.)
        ///
        /// * MBA (Mutual benefit association)
        ///
        /// * MIC (Mutual insurance company)
        ///
        /// * NFP (Not-for-profit corporation)
        ///
        /// * SA (S.A.)
        ///
        /// * SAVINGS_COMPANY (Savings company)
        ///
        /// * SAVINGS_UNION (Savings union)
        ///
        /// * SARL (Société à responsabilité limitée)
        ///
        /// * TRUST (Trust)
        ///
        /// * ULC (Unlimited liability corporation)
        ///
        ///
        ///
        ///
        /// * CA_LEGAL_TYPE When ContactType is PERSON, valid values include the following:
        ///
        /// * ABO (Aboriginal Peoples indigenous to Canada)
        ///
        /// * CCT (Canadian citizen)
        ///
        /// * LGR (Legal Representative of a Canadian Citizen or Permanent Resident)
        ///
        /// * RES (Permanent resident of Canada)
        ///
        ///
        /// When ContactType is a value other than PERSON, valid values include the following:
        ///
        /// * ASS (Canadian unincorporated association)
        ///
        /// * CCO (Canadian corporation)
        ///
        /// * EDU (Canadian educational institution)
        ///
        /// * GOV (Government or government entity in Canada)
        ///
        /// * HOP (Canadian Hospital)
        ///
        /// * INB (Indian Band recognized by the Indian Act of Canada)
        ///
        /// * LAM (Canadian Library, Archive, or Museum)
        ///
        /// * MAJ (Her/His Majesty the Queen/King)
        ///
        /// * OMK (Official mark registered in Canada)
        ///
        /// * PLT (Canadian Political Party)
        ///
        /// * PRT (Partnership Registered in Canada)
        ///
        /// * TDM (Trademark registered in Canada)
        ///
        /// * TRD (Canadian Trade Union)
        ///
        /// * TRS (Trust established in Canada)
        ///
        ///
        ///
        ///
        ///
        /// .es
        ///
        /// * ES_IDENTIFICATION The value of ES_IDENTIFICATION depends on the following values:
        ///
        /// * The value of ES_LEGAL_FORM
        ///
        /// * The value of ES_IDENTIFICATION_TYPE
        ///
        ///
        /// If ES_LEGAL_FORM is any value other than INDIVIDUAL:
        ///
        /// * Specify 1 letter + 8 numbers (CIF [Certificado de Identificación Fiscal])
        ///
        /// * Example: B12345678
        ///
        ///
        /// If ES_LEGAL_FORM is INDIVIDUAL, the value that you specify for ES_IDENTIFICATION depends on the value of ES_IDENTIFICATION_TYPE:
        ///
        /// * If ES_IDENTIFICATION_TYPE is DNI_AND_NIF (for Spanish contacts):
        ///
        /// * Specify 8 numbers + 1 letter (DNI [Documento Nacional de Identidad], NIF [Número de Identificación Fiscal])
        ///
        /// * Example: 12345678M
        ///
        ///
        ///
        ///
        /// * If ES_IDENTIFICATION_TYPE is NIE (for foreigners with legal residence):
        ///
        /// * Specify 1 letter + 7 numbers + 1 letter ( NIE [Número de Identidad de Extranjero])
        ///
        /// * Example: Y1234567X
        ///
        ///
        ///
        ///
        /// * If ES_IDENTIFICATION_TYPE is OTHER (for contacts outside of Spain):
        ///
        /// * Specify a passport number, drivers license number, or national identity card number
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * ES_IDENTIFICATION_TYPE Valid values include the following:
        ///
        /// * DNI_AND_NIF (For Spanish contacts)
        ///
        /// * NIE (For foreigners with legal residence)
        ///
        /// * OTHER (For contacts outside of Spain)
        ///
        ///
        ///
        ///
        /// * ES_LEGAL_FORM Valid values include the following:
        ///
        /// * ASSOCIATION
        ///
        /// * CENTRAL_GOVERNMENT_BODY
        ///
        /// * CIVIL_SOCIETY
        ///
        /// * COMMUNITY_OF_OWNERS
        ///
        /// * COMMUNITY_PROPERTY
        ///
        /// * CONSULATE
        ///
        /// * COOPERATIVE
        ///
        /// * DESIGNATION_OF_ORIGIN_SUPERVISORY_COUNCIL
        ///
        /// * ECONOMIC_INTEREST_GROUP
        ///
        /// * EMBASSY
        ///
        /// * ENTITY_MANAGING_NATURAL_AREAS
        ///
        /// * FARM_PARTNERSHIP
        ///
        /// * FOUNDATION
        ///
        /// * GENERAL_AND_LIMITED_PARTNERSHIP
        ///
        /// * GENERAL_PARTNERSHIP
        ///
        /// * INDIVIDUAL
        ///
        /// * LIMITED_COMPANY
        ///
        /// * LOCAL_AUTHORITY
        ///
        /// * LOCAL_PUBLIC_ENTITY
        ///
        /// * MUTUAL_INSURANCE_COMPANY
        ///
        /// * NATIONAL_PUBLIC_ENTITY
        ///
        /// * ORDER_OR_RELIGIOUS_INSTITUTION
        ///
        /// * OTHERS (Only for contacts outside of Spain)
        ///
        /// * POLITICAL_PARTY
        ///
        /// * PROFESSIONAL_ASSOCIATION
        ///
        /// * PUBLIC_LAW_ASSOCIATION
        ///
        /// * PUBLIC_LIMITED_COMPANY
        ///
        /// * REGIONAL_GOVERNMENT_BODY
        ///
        /// * REGIONAL_PUBLIC_ENTITY
        ///
        /// * SAVINGS_BANK
        ///
        /// * SPANISH_OFFICE
        ///
        /// * SPORTS_ASSOCIATION
        ///
        /// * SPORTS_FEDERATION
        ///
        /// * SPORTS_LIMITED_COMPANY
        ///
        /// * TEMPORARY_ALLIANCE_OF_ENTERPRISES
        ///
        /// * TRADE_UNION
        ///
        /// * WORKER_OWNED_COMPANY
        ///
        /// * WORKER_OWNED_LIMITED_COMPANY
        ///
        ///
        ///
        ///
        ///
        /// .eu
        ///
        /// * EU_COUNTRY_OF_CITIZENSHIP
        ///
        ///
        /// .fi
        ///
        /// * BIRTH_DATE_IN_YYYY_MM_DD
        ///
        /// * FI_BUSINESS_NUMBER
        ///
        /// * FI_ID_NUMBER
        ///
        /// * FI_NATIONALITY Valid values include the following:
        ///
        /// * FINNISH
        ///
        /// * NOT_FINNISH
        ///
        ///
        ///
        ///
        /// * FI_ORGANIZATION_TYPE Valid values include the following:
        ///
        /// * COMPANY
        ///
        /// * CORPORATION
        ///
        /// * GOVERNMENT
        ///
        /// * INSTITUTION
        ///
        /// * POLITICAL_PARTY
        ///
        /// * PUBLIC_COMMUNITY
        ///
        /// * TOWNSHIP
        ///
        ///
        ///
        ///
        ///
        /// .it
        ///
        /// * IT_NATIONALITY
        ///
        /// * IT_PIN
        ///
        /// * IT_REGISTRANT_ENTITY_TYPE Valid values include the following:
        ///
        /// * FOREIGNERS
        ///
        /// * FREELANCE_WORKERS (Freelance workers and professionals)
        ///
        /// * ITALIAN_COMPANIES (Italian companies and one-person companies)
        ///
        /// * NON_PROFIT_ORGANIZATIONS
        ///
        /// * OTHER_SUBJECTS
        ///
        /// * PUBLIC_ORGANIZATIONS
        ///
        ///
        ///
        ///
        ///
        /// .ru
        ///
        /// * BIRTH_DATE_IN_YYYY_MM_DD
        ///
        /// * RU_PASSPORT_DATA
        ///
        ///
        /// .se
        ///
        /// * BIRTH_COUNTRY
        ///
        /// * SE_ID_NUMBER
        ///
        ///
        /// .sg
        ///
        /// * SG_ID_NUMBER
        ///
        ///
        /// .uk, .co.uk, .me.uk, and .org.uk
        ///
        /// * UK_CONTACT_TYPE Valid values include the following:
        ///
        /// * CRC (UK Corporation by Royal Charter)
        ///
        /// * FCORP (Non-UK Corporation)
        ///
        /// * FIND (Non-UK Individual, representing self)
        ///
        /// * FOTHER (Non-UK Entity that does not fit into any other category)
        ///
        /// * GOV (UK Government Body)
        ///
        /// * IND (UK Individual (representing self))
        ///
        /// * IP (UK Industrial/Provident Registered Company)
        ///
        /// * LLP (UK Limited Liability Partnership)
        ///
        /// * LTD (UK Limited Company)
        ///
        /// * OTHER (UK Entity that does not fit into any other category)
        ///
        /// * PLC (UK Public Limited Company)
        ///
        /// * PTNR (UK Partnership)
        ///
        /// * RCHAR (UK Registered Charity)
        ///
        /// * SCH (UK School)
        ///
        /// * STAT (UK Statutory Body)
        ///
        /// * STRA (UK Sole Trader)
        ///
        ///
        ///
        ///
        /// * UK_COMPANY_NUMBER
        ///
        ///
        /// In addition, many TLDs require a VAT_NUMBER.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ExtraParamName?
        /// The value that corresponds with the name of an extra parameter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Route53DomainsClientTypes.ExtraParamName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension Route53DomainsClientTypes.ExtraParam: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExtraParam(name: \(Swift.String(describing: name)), value: \"CONTENT_REDACTED\")"}
}

extension Route53DomainsClientTypes {

    /// ContactDetail includes the following elements.
    public struct ContactDetail: Swift.Sendable {
        /// First line of the contact's address.
        public var addressLine1: Swift.String?
        /// Second line of contact's address, if any.
        public var addressLine2: Swift.String?
        /// The city of the contact's address.
        public var city: Swift.String?
        /// Indicates whether the contact is a person, company, association, or public organization. Note the following:
        ///
        /// * If you specify a value other than PERSON, you must also specify a value for OrganizationName.
        ///
        /// * For some TLDs, the privacy protection available depends on the value that you specify for Contact Type. For the privacy protection settings for your TLD, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide
        ///
        /// * For .es domains, the value of ContactType must be PERSON for all three contacts.
        public var contactType: Route53DomainsClientTypes.ContactType?
        /// Code for the country of the contact's address.
        public var countryCode: Route53DomainsClientTypes.CountryCode?
        /// Email address of the contact.
        public var email: Swift.String?
        /// A list of name-value pairs for parameters required by certain top-level domains.
        public var extraParams: [Route53DomainsClientTypes.ExtraParam]?
        /// Fax number of the contact. Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code]". For example, a US phone number might appear as "+1.1234567890".
        public var fax: Swift.String?
        /// First name of contact.
        public var firstName: Swift.String?
        /// Last name of contact.
        public var lastName: Swift.String?
        /// Name of the organization for contact types other than PERSON.
        public var organizationName: Swift.String?
        /// The phone number of the contact. Constraints: Phone number must be specified in the format "+[country dialing code].[number including any area code>]". For example, a US phone number might appear as "+1.1234567890".
        public var phoneNumber: Swift.String?
        /// The state or province of the contact's city.
        public var state: Swift.String?
        /// The zip or postal code of the contact's address.
        public var zipCode: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            city: Swift.String? = nil,
            contactType: Route53DomainsClientTypes.ContactType? = nil,
            countryCode: Route53DomainsClientTypes.CountryCode? = nil,
            email: Swift.String? = nil,
            extraParams: [Route53DomainsClientTypes.ExtraParam]? = nil,
            fax: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            organizationName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            state: Swift.String? = nil,
            zipCode: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.city = city
            self.contactType = contactType
            self.countryCode = countryCode
            self.email = email
            self.extraParams = extraParams
            self.fax = fax
            self.firstName = firstName
            self.lastName = lastName
            self.organizationName = organizationName
            self.phoneNumber = phoneNumber
            self.state = state
            self.zipCode = zipCode
        }
    }
}

extension Route53DomainsClientTypes.ContactDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// Name of the domain to be deleted.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DeleteDomainOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The DeleteTagsForDomainRequest includes the following elements.
public struct DeleteTagsForDomainInput: Swift.Sendable {
    /// The domain for which you want to delete one or more tags.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of tag keys to delete.
    /// This member is required.
    public var tagsToDelete: [Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        tagsToDelete: [Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToDelete = tagsToDelete
    }
}

public struct DeleteTagsForDomainOutput: Swift.Sendable {

    public init() { }
}

public struct DisableDomainAutoRenewInput: Swift.Sendable {
    /// The name of the domain that you want to disable automatic renewal for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DisableDomainAutoRenewOutput: Swift.Sendable {

    public init() { }
}

/// The DisableDomainTransferLock request includes the following element.
public struct DisableDomainTransferLockInput: Swift.Sendable {
    /// The name of the domain that you want to remove the transfer lock for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The DisableDomainTransferLock response includes the following element.
public struct DisableDomainTransferLockOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct DisassociateDelegationSignerFromDomainInput: Swift.Sendable {
    /// Name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// An internal identification number assigned to each DS record after it’s created. You can retrieve it as part of DNSSEC information returned by [GetDomainDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetDomainDetail.html).
    /// This member is required.
    public var id: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.id = id
    }
}

public struct DisassociateDelegationSignerFromDomainOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension Route53DomainsClientTypes {

    /// Information about the DNSSEC key. You get this from your DNS provider and then give it to Route 53 (by using [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html)) to pass it to the registry to establish the chain of trust.
    public struct DnssecKey: Swift.Sendable {
        /// The number of the public key’s cryptographic algorithm according to an [IANA](https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xml) assignment. If Route 53 is your DNS service, set this to 13. For more information about enabling DNSSEC signing, see [Enabling DNSSEC signing and establishing a chain of trust](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-configuring-dnssec-enable-signing.html).
        public var algorithm: Swift.Int?
        /// The delegation signer digest. Digest is calculated from the public key provided using specified digest algorithm and this digest is the actual value returned from the registry nameservers as the value of DS records.
        public var digest: Swift.String?
        /// The number of the DS digest algorithm according to an IANA assignment. For more information, see [IANA](https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml) for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms.
        public var digestType: Swift.Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK (zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS) record. If you have ZSK keys only – use ZSK to create a DS record.
        public var flags: Swift.Int?
        /// An ID assigned to each DS record created by [AssociateDelegationSignerToDomain](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AssociateDelegationSignerToDomain.html).
        public var id: Swift.String?
        /// A numeric identification of the DNSKEY record referred to by this DS record.
        public var keyTag: Swift.Int?
        /// The base64-encoded public key part of the key pair that is passed to the registry .
        public var publicKey: Swift.String?

        public init(
            algorithm: Swift.Int? = nil,
            digest: Swift.String? = nil,
            digestType: Swift.Int? = nil,
            flags: Swift.Int? = nil,
            id: Swift.String? = nil,
            keyTag: Swift.Int? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.digest = digest
            self.digestType = digestType
            self.flags = flags
            self.id = id
            self.keyTag = keyTag
            self.publicKey = publicKey
        }
    }
}

extension Route53DomainsClientTypes {

    /// Currency-specific price information.
    public struct PriceWithCurrency: Swift.Sendable {
        /// The currency specifier.
        /// This member is required.
        public var currency: Swift.String?
        /// The price of a domain, in a specific currency.
        /// This member is required.
        public var price: Swift.Double

        public init(
            currency: Swift.String? = nil,
            price: Swift.Double = 0.0
        )
        {
            self.currency = currency
            self.price = price
        }
    }
}

extension Route53DomainsClientTypes {

    /// Information about the domain price associated with a TLD.
    public struct DomainPrice: Swift.Sendable {
        /// The price for changing domain ownership.
        public var changeOwnershipPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The name of the TLD for which the prices apply.
        public var name: Swift.String?
        /// The price for domain registration with Route 53.
        public var registrationPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for renewing domain registration with Route 53.
        public var renewalPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for restoring the domain with Route 53.
        public var restorationPrice: Route53DomainsClientTypes.PriceWithCurrency?
        /// The price for transferring the domain registration to Route 53.
        public var transferPrice: Route53DomainsClientTypes.PriceWithCurrency?

        public init(
            changeOwnershipPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            name: Swift.String? = nil,
            registrationPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            renewalPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            restorationPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil,
            transferPrice: Route53DomainsClientTypes.PriceWithCurrency? = nil
        )
        {
            self.changeOwnershipPrice = changeOwnershipPrice
            self.name = name
            self.registrationPrice = registrationPrice
            self.renewalPrice = renewalPrice
            self.restorationPrice = restorationPrice
            self.transferPrice = transferPrice
        }
    }
}

extension Route53DomainsClientTypes {

    /// Information about one suggested domain name.
    public struct DomainSuggestion: Swift.Sendable {
        /// Whether the domain name is available for registering. You can register only the domains that are designated as AVAILABLE. Valid values: AVAILABLE The domain name is available. AVAILABLE_RESERVED The domain name is reserved under specific conditions. AVAILABLE_PREORDER The domain name is available and can be preordered. DONT_KNOW The TLD registry didn't reply with a definitive answer about whether the domain name is available. Route 53 can return this response for a variety of reasons, for example, the registry is performing maintenance. Try again later. PENDING The TLD registry didn't return a response in the expected amount of time. When the response is delayed, it usually takes just a few extra seconds. You can resubmit the request immediately. RESERVED The domain name has been reserved for another person or organization. UNAVAILABLE The domain name is not available. UNAVAILABLE_PREMIUM The domain name is not available. UNAVAILABLE_RESTRICTED The domain name is forbidden.
        public var availability: Swift.String?
        /// A suggested domain name.
        public var domainName: Swift.String?

        public init(
            availability: Swift.String? = nil,
            domainName: Swift.String? = nil
        )
        {
            self.availability = availability
            self.domainName = domainName
        }
    }
}

extension Route53DomainsClientTypes {

    /// Summary information about one domain.
    public struct DomainSummary: Swift.Sendable {
        /// Indicates whether the domain is automatically renewed upon expiration.
        public var autoRenew: Swift.Bool?
        /// The name of the domain that the summary information applies to.
        public var domainName: Swift.String?
        /// Expiration date of the domain in Unix time format and Coordinated Universal Time (UTC).
        public var expiry: Foundation.Date?
        /// Indicates whether a domain is locked from unauthorized transfer to another party.
        public var transferLock: Swift.Bool?

        public init(
            autoRenew: Swift.Bool? = nil,
            domainName: Swift.String? = nil,
            expiry: Foundation.Date? = nil,
            transferLock: Swift.Bool? = nil
        )
        {
            self.autoRenew = autoRenew
            self.domainName = domainName
            self.expiry = expiry
            self.transferLock = transferLock
        }
    }
}

public struct EnableDomainAutoRenewInput: Swift.Sendable {
    /// The name of the domain that you want to enable automatic renewal for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct EnableDomainAutoRenewOutput: Swift.Sendable {

    public init() { }
}

/// A request to set the transfer lock for the specified domain.
public struct EnableDomainTransferLockInput: Swift.Sendable {
    /// The name of the domain that you want to set the transfer lock for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The EnableDomainTransferLock response includes the following elements.
public struct EnableDomainTransferLockOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension Route53DomainsClientTypes {

    public enum ListDomainsAttributeName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domainname
        case expiry
        case sdkUnknown(Swift.String)

        public static var allCases: [ListDomainsAttributeName] {
            return [
                .domainname,
                .expiry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domainname: return "DomainName"
            case .expiry: return "Expiry"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case ge
        case le
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .beginsWith,
                .ge,
                .le
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .ge: return "GE"
            case .le: return "LE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    /// Information for the filtering of a list of domains returned by [ListDomains](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains__ListDomains.html).
    public struct FilterCondition: Swift.Sendable {
        /// Name of the field which should be used for filtering the list of domains.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ListDomainsAttributeName?
        /// The operator values for filtering domain names. The values can be:
        ///
        /// * LE: Less than, or equal to
        ///
        /// * GE: Greater than, or equal to
        ///
        /// * BEGINS_WITH: Begins with
        /// This member is required.
        public var `operator`: Route53DomainsClientTypes.Operator?
        /// An array of strings presenting values to compare. Only 1 item in the list is currently supported.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Route53DomainsClientTypes.ListDomainsAttributeName? = nil,
            `operator`: Route53DomainsClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct GetContactReachabilityStatusInput: Swift.Sendable {
    /// The name of the domain for which you want to know whether the registrant contact has confirmed that the email address is valid.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension Route53DomainsClientTypes {

    public enum ReachabilityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case done
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReachabilityStatus] {
            return [
                .done,
                .expired,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .done: return "DONE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetContactReachabilityStatusOutput: Swift.Sendable {
    /// The domain name for which you requested the reachability status.
    public var domainName: Swift.String?
    /// Whether the registrant contact has responded. Values include the following: PENDING We sent the confirmation email and haven't received a response yet. DONE We sent the email and got confirmation from the registrant contact. EXPIRED The time limit expired before the registrant contact responded.
    public var status: Route53DomainsClientTypes.ReachabilityStatus?

    public init(
        domainName: Swift.String? = nil,
        status: Route53DomainsClientTypes.ReachabilityStatus? = nil
    )
    {
        self.domainName = domainName
        self.status = status
    }
}

/// The GetDomainDetail request includes the following element.
public struct GetDomainDetailInput: Swift.Sendable {
    /// The name of the domain that you want to get detailed information about.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension Route53DomainsClientTypes {

    /// Name server includes the following elements.
    public struct Nameserver: Swift.Sendable {
        /// Glue IP address of a name server entry. Glue IP addresses are required only when the name of the name server is a subdomain of the domain. For example, if your domain is example.com and the name server for the domain is ns.example.com, you need to specify the IP address for ns.example.com. Constraints: The list can contain only one IPv4 and one IPv6 address.
        public var glueIps: [Swift.String]?
        /// The fully qualified host name of the name server. Constraint: Maximum 255 characters
        /// This member is required.
        public var name: Swift.String?

        public init(
            glueIps: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.glueIps = glueIps
            self.name = name
        }
    }
}

/// The GetDomainDetail response includes the following elements.
public struct GetDomainDetailOutput: Swift.Sendable {
    /// Email address to contact to report incorrect contact information for a domain, to report that the domain is being used to send spam, to report that someone is cybersquatting on a domain name, or report some other type of abuse.
    public var abuseContactEmail: Swift.String?
    /// Phone number for reporting abuse.
    public var abuseContactPhone: Swift.String?
    /// Provides details about the domain administrative contact.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If the value is false, WHOIS queries return the information that you entered for the admin contact.
    public var adminPrivacy: Swift.Bool?
    /// Specifies whether the domain registration is set to renew automatically.
    public var autoRenew: Swift.Bool?
    /// Provides details about the domain billing contact.
    public var billingContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If the value is false, WHOIS queries return the information that you entered for the billing contact.
    public var billingPrivacy: Swift.Bool?
    /// The date when the domain was created as found in the response to a WHOIS query. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var creationDate: Foundation.Date?
    /// Deprecated.
    public var dnsSec: Swift.String?
    /// A complex type that contains information about the DNSSEC configuration.
    public var dnssecKeys: [Route53DomainsClientTypes.DnssecKey]?
    /// The name of a domain.
    public var domainName: Swift.String?
    /// The date when the registration for the domain is set to expire. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var expirationDate: Foundation.Date?
    /// The name servers of the domain.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?
    /// Provides details about the domain registrant.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If the value is false, WHOIS queries return the information that you entered for the registrant contact (domain owner).
    public var registrantPrivacy: Swift.Bool?
    /// Name of the registrar of the domain as identified in the registry.
    public var registrarName: Swift.String?
    /// Web address of the registrar.
    public var registrarUrl: Swift.String?
    /// Reserved for future use.
    public var registryDomainId: Swift.String?
    /// Reseller of the domain. Domains registered or transferred using Route 53 domains will have "Amazon" as the reseller.
    public var reseller: Swift.String?
    /// An array of domain name status codes, also known as Extensible Provisioning Protocol (EPP) status codes. ICANN, the organization that maintains a central database of domain names, has developed a set of domain name status codes that tell you the status of a variety of operations on a domain name, for example, registering a domain name, transferring a domain name to another registrar, renewing the registration for a domain name, and so on. All registrars use this same set of status codes. For a current list of domain name status codes and an explanation of what each code means, go to the [ICANN website](https://www.icann.org/) and search for epp status codes. (Search on the ICANN website; web searches sometimes return an old version of the document.)
    public var statusList: [Swift.String]?
    /// Provides details about the domain technical contact.
    public var techContact: Route53DomainsClientTypes.ContactDetail?
    /// Specifies whether contact information is concealed from WHOIS queries. If the value is true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If the value is false, WHOIS queries return the information that you entered for the technical contact.
    public var techPrivacy: Swift.Bool?
    /// The last updated date of the domain as found in the response to a WHOIS query. The date and time is in Unix time format and Coordinated Universal time (UTC).
    public var updatedDate: Foundation.Date?
    /// The fully qualified name of the WHOIS server that can answer the WHOIS query for the domain.
    public var whoIsServer: Swift.String?

    public init(
        abuseContactEmail: Swift.String? = nil,
        abuseContactPhone: Swift.String? = nil,
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        adminPrivacy: Swift.Bool? = nil,
        autoRenew: Swift.Bool? = nil,
        billingContact: Route53DomainsClientTypes.ContactDetail? = nil,
        billingPrivacy: Swift.Bool? = nil,
        creationDate: Foundation.Date? = nil,
        dnsSec: Swift.String? = nil,
        dnssecKeys: [Route53DomainsClientTypes.DnssecKey]? = nil,
        domainName: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        registrantPrivacy: Swift.Bool? = nil,
        registrarName: Swift.String? = nil,
        registrarUrl: Swift.String? = nil,
        registryDomainId: Swift.String? = nil,
        reseller: Swift.String? = nil,
        statusList: [Swift.String]? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techPrivacy: Swift.Bool? = nil,
        updatedDate: Foundation.Date? = nil,
        whoIsServer: Swift.String? = nil
    )
    {
        self.abuseContactEmail = abuseContactEmail
        self.abuseContactPhone = abuseContactPhone
        self.adminContact = adminContact
        self.adminPrivacy = adminPrivacy
        self.autoRenew = autoRenew
        self.billingContact = billingContact
        self.billingPrivacy = billingPrivacy
        self.creationDate = creationDate
        self.dnsSec = dnsSec
        self.dnssecKeys = dnssecKeys
        self.domainName = domainName
        self.expirationDate = expirationDate
        self.nameservers = nameservers
        self.registrantContact = registrantContact
        self.registrantPrivacy = registrantPrivacy
        self.registrarName = registrarName
        self.registrarUrl = registrarUrl
        self.registryDomainId = registryDomainId
        self.reseller = reseller
        self.statusList = statusList
        self.techContact = techContact
        self.techPrivacy = techPrivacy
        self.updatedDate = updatedDate
        self.whoIsServer = whoIsServer
    }
}

extension GetDomainDetailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainDetailOutput(adminPrivacy: \(Swift.String(describing: adminPrivacy)), autoRenew: \(Swift.String(describing: autoRenew)), billingPrivacy: \(Swift.String(describing: billingPrivacy)), creationDate: \(Swift.String(describing: creationDate)), dnsSec: \(Swift.String(describing: dnsSec)), dnssecKeys: \(Swift.String(describing: dnssecKeys)), domainName: \(Swift.String(describing: domainName)), expirationDate: \(Swift.String(describing: expirationDate)), nameservers: \(Swift.String(describing: nameservers)), registrantPrivacy: \(Swift.String(describing: registrantPrivacy)), registrarName: \(Swift.String(describing: registrarName)), registrarUrl: \(Swift.String(describing: registrarUrl)), registryDomainId: \(Swift.String(describing: registryDomainId)), reseller: \(Swift.String(describing: reseller)), statusList: \(Swift.String(describing: statusList)), techPrivacy: \(Swift.String(describing: techPrivacy)), updatedDate: \(Swift.String(describing: updatedDate)), whoIsServer: \(Swift.String(describing: whoIsServer)), abuseContactEmail: \"CONTENT_REDACTED\", abuseContactPhone: \"CONTENT_REDACTED\", adminContact: \"CONTENT_REDACTED\", billingContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

public struct GetDomainSuggestionsInput: Swift.Sendable {
    /// A domain name that you want to use as the basis for a list of possible domain names. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html).
    /// This member is required.
    public var domainName: Swift.String?
    /// If OnlyAvailable is true, Route 53 returns only domain names that are available. If OnlyAvailable is false, Route 53 returns domain names without checking whether they're available to be registered. To determine whether the domain is available, you can call checkDomainAvailability for each suggestion.
    /// This member is required.
    public var onlyAvailable: Swift.Bool?
    /// The number of suggested domain names that you want Route 53 to return. Specify a value between 1 and 50.
    /// This member is required.
    public var suggestionCount: Swift.Int?

    public init(
        domainName: Swift.String? = nil,
        onlyAvailable: Swift.Bool? = nil,
        suggestionCount: Swift.Int? = 0
    )
    {
        self.domainName = domainName
        self.onlyAvailable = onlyAvailable
        self.suggestionCount = suggestionCount
    }
}

public struct GetDomainSuggestionsOutput: Swift.Sendable {
    /// A list of possible domain names. If you specified true for OnlyAvailable in the request, the list contains only domains that are available for registration.
    public var suggestionsList: [Route53DomainsClientTypes.DomainSuggestion]?

    public init(
        suggestionsList: [Route53DomainsClientTypes.DomainSuggestion]? = nil
    )
    {
        self.suggestionsList = suggestionsList
    }
}

/// The [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html) request includes the following element.
public struct GetOperationDetailInput: Swift.Sendable {
    /// The identifier for the operation for which you want to get the status. Route 53 returned the identifier in the response to the original request.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension Route53DomainsClientTypes {

    public enum OperationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case failed
        case inProgress
        case submitted
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .error,
                .failed,
                .inProgress,
                .submitted,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    public enum StatusFlag: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pendingAcceptance
        case pendingAuthorization
        case pendingCustomerAction
        case pendingPaymentVerification
        case pendingSupportCase
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusFlag] {
            return [
                .pendingAcceptance,
                .pendingAuthorization,
                .pendingCustomerAction,
                .pendingPaymentVerification,
                .pendingSupportCase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .pendingAuthorization: return "PENDING_AUTHORIZATION"
            case .pendingCustomerAction: return "PENDING_CUSTOMER_ACTION"
            case .pendingPaymentVerification: return "PENDING_PAYMENT_VERIFICATION"
            case .pendingSupportCase: return "PENDING_SUPPORT_CASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The GetOperationDetail response includes the following elements.
public struct GetOperationDetailOutput: Swift.Sendable {
    /// The name of a domain.
    public var domainName: Swift.String?
    /// The date when the operation was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Detailed information on the status including possible errors.
    public var message: Swift.String?
    /// The identifier for the operation.
    public var operationId: Swift.String?
    /// The current status of the requested operation in the system.
    public var status: Route53DomainsClientTypes.OperationStatus?
    /// Lists any outstanding operations that require customer action. Valid values are:
    ///
    /// * PENDING_ACCEPTANCE: The operation is waiting for acceptance from the account that is receiving the domain.
    ///
    /// * PENDING_CUSTOMER_ACTION: The operation is waiting for customer action, for example, returning an email.
    ///
    /// * PENDING_AUTHORIZATION: The operation is waiting for the form of authorization. For more information, see [ResendOperationAuthorization](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ResendOperationAuthorization.html).
    ///
    /// * PENDING_PAYMENT_VERIFICATION: The operation is waiting for the payment method to validate.
    ///
    /// * PENDING_SUPPORT_CASE: The operation includes a support case and is waiting for its resolution.
    public var statusFlag: Route53DomainsClientTypes.StatusFlag?
    /// The date when the request was submitted.
    public var submittedDate: Foundation.Date?
    /// The type of operation that was requested.
    public var type: Route53DomainsClientTypes.OperationType?

    public init(
        domainName: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        message: Swift.String? = nil,
        operationId: Swift.String? = nil,
        status: Route53DomainsClientTypes.OperationStatus? = nil,
        statusFlag: Route53DomainsClientTypes.StatusFlag? = nil,
        submittedDate: Foundation.Date? = nil,
        type: Route53DomainsClientTypes.OperationType? = nil
    )
    {
        self.domainName = domainName
        self.lastUpdatedDate = lastUpdatedDate
        self.message = message
        self.operationId = operationId
        self.status = status
        self.statusFlag = statusFlag
        self.submittedDate = submittedDate
        self.type = type
    }
}

extension Route53DomainsClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53DomainsClientTypes {

    /// Information for sorting a list of domains.
    public struct SortCondition: Swift.Sendable {
        /// Field to be used for sorting the list of domains. It can be either the name or the expiration for a domain. Note that if filterCondition is used in the same [ListDomains](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains__ListDomains.html) call, the field used for sorting has to be the same as the field used for filtering.
        /// This member is required.
        public var name: Route53DomainsClientTypes.ListDomainsAttributeName?
        /// The sort order for a list of domains. Either ascending (ASC) or descending (DES).
        /// This member is required.
        public var sortOrder: Route53DomainsClientTypes.SortOrder?

        public init(
            name: Route53DomainsClientTypes.ListDomainsAttributeName? = nil,
            sortOrder: Route53DomainsClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }
}

/// The ListDomains request includes the following elements.
public struct ListDomainsInput: Swift.Sendable {
    /// A complex type that contains information about the filters applied during the ListDomains request. The filter conditions can include domain name and domain expiration.
    public var filterConditions: [Route53DomainsClientTypes.FilterCondition]?
    /// For an initial request for a list of domains, omit this element. If the number of domains that are associated with the current Amazon Web Services account is greater than the value that you specified for MaxItems, you can use Marker to return additional domains. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Constraints: The marker must match the value specified in the previous request.
    public var marker: Swift.String?
    /// Number of domains to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// A complex type that contains information about the requested ordering of domains in the returned list.
    public var sortCondition: Route53DomainsClientTypes.SortCondition?

    public init(
        filterConditions: [Route53DomainsClientTypes.FilterCondition]? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortCondition: Route53DomainsClientTypes.SortCondition? = nil
    )
    {
        self.filterConditions = filterConditions
        self.marker = marker
        self.maxItems = maxItems
        self.sortCondition = sortCondition
    }
}

/// The ListDomains response includes the following elements.
public struct ListDomainsOutput: Swift.Sendable {
    /// A list of domains.
    public var domains: [Route53DomainsClientTypes.DomainSummary]?
    /// If there are more domains than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?

    public init(
        domains: [Route53DomainsClientTypes.DomainSummary]? = nil,
        nextPageMarker: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextPageMarker = nextPageMarker
    }
}

extension Route53DomainsClientTypes {

    public enum ListOperationsSortAttributeName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case submitteddate
        case sdkUnknown(Swift.String)

        public static var allCases: [ListOperationsSortAttributeName] {
            return [
                .submitteddate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .submitteddate: return "SubmittedDate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The ListOperations request includes the following elements.
public struct ListOperationsInput: Swift.Sendable {
    /// For an initial request for a list of operations, omit this element. If the number of operations that are not yet complete is greater than the value that you specified for MaxItems, you can use Marker to return additional operations. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element.
    public var marker: Swift.String?
    /// Number of domains to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// The sort type for returned values.
    public var sortBy: Route53DomainsClientTypes.ListOperationsSortAttributeName?
    /// The sort order for returned values, either ascending or descending.
    public var sortOrder: Route53DomainsClientTypes.SortOrder?
    /// The status of the operations.
    public var status: [Route53DomainsClientTypes.OperationStatus]?
    /// An optional parameter that lets you get information about all the operations that you submitted after a specified date and time. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var submittedSince: Foundation.Date?
    /// An arrays of the domains operation types.
    public var type: [Route53DomainsClientTypes.OperationType]?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        sortBy: Route53DomainsClientTypes.ListOperationsSortAttributeName? = nil,
        sortOrder: Route53DomainsClientTypes.SortOrder? = nil,
        status: [Route53DomainsClientTypes.OperationStatus]? = nil,
        submittedSince: Foundation.Date? = nil,
        type: [Route53DomainsClientTypes.OperationType]? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.status = status
        self.submittedSince = submittedSince
        self.type = type
    }
}

extension Route53DomainsClientTypes {

    /// OperationSummary includes the following elements.
    public struct OperationSummary: Swift.Sendable {
        /// Name of the domain.
        public var domainName: Swift.String?
        /// The date when the last change was made in Unix time format and Coordinated Universal Time (UTC).
        public var lastUpdatedDate: Foundation.Date?
        /// Message about the operation.
        public var message: Swift.String?
        /// Identifier returned to track the requested action.
        public var operationId: Swift.String?
        /// The current status of the requested operation in the system.
        public var status: Route53DomainsClientTypes.OperationStatus?
        /// Automatically checks whether there are no outstanding operations on domains that need customer attention. Valid values are:
        ///
        /// * PENDING_ACCEPTANCE: The operation is waiting for acceptance from the account that is receiving the domain.
        ///
        /// * PENDING_CUSTOMER_ACTION: The operation is waiting for customer action, for example, returning an email.
        ///
        /// * PENDING_AUTHORIZATION: The operation is waiting for the form of authorization. For more information, see [ResendOperationAuthorization](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ResendOperationAuthorization.html).
        ///
        /// * PENDING_PAYMENT_VERIFICATION: The operation is waiting for the payment method to validate.
        ///
        /// * PENDING_SUPPORT_CASE: The operation includes a support case and is waiting for its resolution.
        public var statusFlag: Route53DomainsClientTypes.StatusFlag?
        /// The date when the request was submitted.
        public var submittedDate: Foundation.Date?
        /// Type of the action requested.
        public var type: Route53DomainsClientTypes.OperationType?

        public init(
            domainName: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            message: Swift.String? = nil,
            operationId: Swift.String? = nil,
            status: Route53DomainsClientTypes.OperationStatus? = nil,
            statusFlag: Route53DomainsClientTypes.StatusFlag? = nil,
            submittedDate: Foundation.Date? = nil,
            type: Route53DomainsClientTypes.OperationType? = nil
        )
        {
            self.domainName = domainName
            self.lastUpdatedDate = lastUpdatedDate
            self.message = message
            self.operationId = operationId
            self.status = status
            self.statusFlag = statusFlag
            self.submittedDate = submittedDate
            self.type = type
        }
    }
}

/// The ListOperations response includes the following elements.
public struct ListOperationsOutput: Swift.Sendable {
    /// If there are more operations than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?
    /// Lists summaries of the operations.
    public var operations: [Route53DomainsClientTypes.OperationSummary]?

    public init(
        nextPageMarker: Swift.String? = nil,
        operations: [Route53DomainsClientTypes.OperationSummary]? = nil
    )
    {
        self.nextPageMarker = nextPageMarker
        self.operations = operations
    }
}

public struct ListPricesInput: Swift.Sendable {
    /// For an initial request for a list of prices, omit this element. If the number of prices that are not yet complete is greater than the value that you specified for MaxItems, you can use Marker to return additional prices. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Used only for all TLDs. If you specify a TLD, don't specify a Marker.
    public var marker: Swift.String?
    /// Number of Prices to be returned. Used only for all TLDs. If you specify a TLD, don't specify a MaxItems.
    public var maxItems: Swift.Int?
    /// The TLD for which you want to receive the pricing information. For example. .net. If a Tld value is not provided, a list of prices for all TLDs supported by Route 53 is returned.
    public var tld: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        tld: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.tld = tld
    }
}

public struct ListPricesOutput: Swift.Sendable {
    /// If there are more prices than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker. Used only for all TLDs. If you specify a TLD, don't specify a NextPageMarker.
    public var nextPageMarker: Swift.String?
    /// A complex type that includes all the pricing information. If you specify a TLD, this array contains only the pricing for that TLD.
    public var prices: [Route53DomainsClientTypes.DomainPrice]?

    public init(
        nextPageMarker: Swift.String? = nil,
        prices: [Route53DomainsClientTypes.DomainPrice]? = nil
    )
    {
        self.nextPageMarker = nextPageMarker
        self.prices = prices
    }
}

/// The ListTagsForDomainRequest includes the following elements.
public struct ListTagsForDomainInput: Swift.Sendable {
    /// The domain for which you want to get a list of tags.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension Route53DomainsClientTypes {

    /// Each tag includes the following elements.
    public struct Tag: Swift.Sendable {
        /// The key (name) of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each key can be 1-128 characters long.
        public var key: Swift.String?
        /// The value of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each value can be 0-256 characters long.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// The ListTagsForDomain response includes the following elements.
public struct ListTagsForDomainOutput: Swift.Sendable {
    /// A list of the tags that are associated with the specified domain.
    public var tagList: [Route53DomainsClientTypes.Tag]?

    public init(
        tagList: [Route53DomainsClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct PushDomainInput: Swift.Sendable {
    /// Name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// New IPS tag for the domain.
    /// This member is required.
    public var target: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.target = target
    }
}

/// The RegisterDomain request includes the following elements.
public struct RegisterDomainInput: Swift.Sendable {
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Indicates whether the domain will be automatically renewed (true) or not (false). Auto renewal only takes effect after the account is charged. Default: true
    public var autoRenew: Swift.Bool?
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    public var billingContact: Route53DomainsClientTypes.ContactDetail?
    /// The domain name that you want to register. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    ///
    ///
    /// Internationalized domain names are not supported for some top-level domains. To determine whether the TLD that you want to use supports internationalized domain names, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html). For more information, see [Formatting Internationalized Domain Names](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html#domain-name-format-idns).
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to register the domain for. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. For the range of valid values for your domain, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. Default: 1
    /// This member is required.
    public var durationInYears: Swift.Int?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the admin contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts. Default: true
    public var privacyProtectAdminContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the billing contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var privacyProtectBillingContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the registrant contact (the domain owner). You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts. Default: true
    public var privacyProtectRegistrantContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts. Default: true
    public var privacyProtectTechContact: Swift.Bool?
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information. For information about the values that you specify for each element, see [ContactDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_ContactDetail.html).
    /// This member is required.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init(
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        autoRenew: Swift.Bool? = nil,
        billingContact: Route53DomainsClientTypes.ContactDetail? = nil,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil,
        idnLangCode: Swift.String? = nil,
        privacyProtectAdminContact: Swift.Bool? = nil,
        privacyProtectBillingContact: Swift.Bool? = nil,
        privacyProtectRegistrantContact: Swift.Bool? = nil,
        privacyProtectTechContact: Swift.Bool? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.autoRenew = autoRenew
        self.billingContact = billingContact
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectBillingContact = privacyProtectBillingContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

extension RegisterDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDomainInput(autoRenew: \(Swift.String(describing: autoRenew)), domainName: \(Swift.String(describing: domainName)), durationInYears: \(Swift.String(describing: durationInYears)), idnLangCode: \(Swift.String(describing: idnLangCode)), privacyProtectAdminContact: \(Swift.String(describing: privacyProtectAdminContact)), privacyProtectBillingContact: \(Swift.String(describing: privacyProtectBillingContact)), privacyProtectRegistrantContact: \(Swift.String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(Swift.String(describing: privacyProtectTechContact)), adminContact: \"CONTENT_REDACTED\", billingContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

/// The RegisterDomain response includes the following element.
public struct RegisterDomainOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The RejectDomainTransferFromAnotherAwsAccount request includes the following element.
public struct RejectDomainTransferFromAnotherAwsAccountInput: Swift.Sendable {
    /// The name of the domain that was specified when another Amazon Web Services account submitted a [TransferDomainToAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_TransferDomainToAnotherAwsAccount.html) request.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The RejectDomainTransferFromAnotherAwsAccount response includes the following element.
public struct RejectDomainTransferFromAnotherAwsAccountOutput: Swift.Sendable {
    /// The identifier that TransferDomainToAnotherAwsAccount returned to track the progress of the request. Because the transfer request was rejected, the value is no longer valid, and you can't use GetOperationDetail to query the operation status.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// A RenewDomain request includes the number of years that you want to renew for and the current expiration year.
public struct RenewDomainInput: Swift.Sendable {
    /// The year when the registration for the domain is set to expire. This value must match the current expiration date for the domain.
    /// This member is required.
    public var currentExpiryYear: Swift.Int?
    /// The name of the domain that you want to renew.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to renew the domain for. The maximum number of years depends on the top-level domain. For the range of valid values for your domain, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. Default: 1
    public var durationInYears: Swift.Int?

    public init(
        currentExpiryYear: Swift.Int? = 0,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil
    )
    {
        self.currentExpiryYear = currentExpiryYear
        self.domainName = domainName
        self.durationInYears = durationInYears
    }
}

public struct RenewDomainOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct ResendContactReachabilityEmailInput: Swift.Sendable {
    /// The name of the domain for which you want Route 53 to resend a confirmation email to the registrant contact.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct ResendContactReachabilityEmailOutput: Swift.Sendable {
    /// The domain name for which you requested a confirmation email.
    public var domainName: Swift.String?
    /// The email address for the registrant contact at the time that we sent the verification email.
    public var emailAddress: Swift.String?
    /// True if the email address for the registrant contact has already been verified, and false otherwise. If the email address has already been verified, we don't send another confirmation email.
    public var isAlreadyVerified: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        isAlreadyVerified: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.emailAddress = emailAddress
        self.isAlreadyVerified = isAlreadyVerified
    }
}

extension ResendContactReachabilityEmailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResendContactReachabilityEmailOutput(domainName: \(Swift.String(describing: domainName)), isAlreadyVerified: \(Swift.String(describing: isAlreadyVerified)), emailAddress: \"CONTENT_REDACTED\")"}
}

public struct ResendOperationAuthorizationInput: Swift.Sendable {
    /// Operation ID.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// A request for the authorization code for the specified domain. To transfer a domain to another registrar, you provide this value to the new registrar.
public struct RetrieveDomainAuthCodeInput: Swift.Sendable {
    /// The name of the domain that you want to get an authorization code for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The RetrieveDomainAuthCode response includes the following element.
public struct RetrieveDomainAuthCodeOutput: Swift.Sendable {
    /// The authorization code for the domain.
    public var authCode: Swift.String?

    public init(
        authCode: Swift.String? = nil
    )
    {
        self.authCode = authCode
    }
}

extension RetrieveDomainAuthCodeOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveDomainAuthCodeOutput(authCode: \"CONTENT_REDACTED\")"}
}

/// The TransferDomain request includes the following elements.
public struct TransferDomainInput: Swift.Sendable {
    /// Provides detailed contact information.
    /// This member is required.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// The authorization code for the domain. You get this value from the current registrar.
    public var authCode: Swift.String?
    /// Indicates whether the domain will be automatically renewed (true) or not (false). Auto renewal only takes effect after the account is charged. Default: true
    public var autoRenew: Swift.Bool?
    /// Provides detailed contact information.
    public var billingContact: Route53DomainsClientTypes.ContactDetail?
    /// The name of the domain that you want to transfer to Route 53. The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs, see [Domains that You Can Register with Amazon Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html) in the Amazon Route 53 Developer Guide. The domain name can contain only the following characters:
    ///
    /// * Letters a through z. Domain names are not case sensitive.
    ///
    /// * Numbers 0 through 9.
    ///
    /// * Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
    ///
    /// * Period (.) to separate the labels in the name, such as the . in example.com.
    /// This member is required.
    public var domainName: Swift.String?
    /// The number of years that you want to register the domain for. Domains are registered for a minimum of one year. The maximum period depends on the top-level domain. Default: 1
    /// This member is required.
    public var durationInYears: Swift.Int?
    /// Reserved for future use.
    public var idnLangCode: Swift.String?
    /// Contains details for the host and glue IP addresses.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information for the registrar, the phrase "REDACTED FOR PRIVACY", or "On behalf of owner.". While some domains may allow different privacy settings per contact, we recommend specifying the same privacy setting for all contacts. Default: true
    public var privacyProtectAdminContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the billing contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var privacyProtectBillingContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the registrant contact (domain owner). You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts. Default: true
    public var privacyProtectRegistrantContact: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts. Default: true
    public var privacyProtectTechContact: Swift.Bool?
    /// Provides detailed contact information.
    /// This member is required.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information.
    /// This member is required.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init(
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        authCode: Swift.String? = nil,
        autoRenew: Swift.Bool? = nil,
        billingContact: Route53DomainsClientTypes.ContactDetail? = nil,
        domainName: Swift.String? = nil,
        durationInYears: Swift.Int? = nil,
        idnLangCode: Swift.String? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil,
        privacyProtectAdminContact: Swift.Bool? = nil,
        privacyProtectBillingContact: Swift.Bool? = nil,
        privacyProtectRegistrantContact: Swift.Bool? = nil,
        privacyProtectTechContact: Swift.Bool? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.authCode = authCode
        self.autoRenew = autoRenew
        self.billingContact = billingContact
        self.domainName = domainName
        self.durationInYears = durationInYears
        self.idnLangCode = idnLangCode
        self.nameservers = nameservers
        self.privacyProtectAdminContact = privacyProtectAdminContact
        self.privacyProtectBillingContact = privacyProtectBillingContact
        self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
        self.privacyProtectTechContact = privacyProtectTechContact
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

extension TransferDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransferDomainInput(autoRenew: \(Swift.String(describing: autoRenew)), domainName: \(Swift.String(describing: domainName)), durationInYears: \(Swift.String(describing: durationInYears)), idnLangCode: \(Swift.String(describing: idnLangCode)), nameservers: \(Swift.String(describing: nameservers)), privacyProtectAdminContact: \(Swift.String(describing: privacyProtectAdminContact)), privacyProtectBillingContact: \(Swift.String(describing: privacyProtectBillingContact)), privacyProtectRegistrantContact: \(Swift.String(describing: privacyProtectRegistrantContact)), privacyProtectTechContact: \(Swift.String(describing: privacyProtectTechContact)), adminContact: \"CONTENT_REDACTED\", authCode: \"CONTENT_REDACTED\", billingContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

/// The TransferDomain response includes the following element.
public struct TransferDomainOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The TransferDomainToAnotherAwsAccount request includes the following elements.
public struct TransferDomainToAnotherAwsAccountInput: Swift.Sendable {
    /// The account ID of the Amazon Web Services account that you want to transfer the domain to, for example, 111122223333.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the domain that you want to transfer from the current Amazon Web Services account to another account.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.domainName = domainName
    }
}

/// The TransferDomainToAnotherAwsAccount response includes the following elements.
public struct TransferDomainToAnotherAwsAccountOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?
    /// To finish transferring a domain to another Amazon Web Services account, the account that the domain is being transferred to must submit an [AcceptDomainTransferFromAnotherAwsAccount](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_AcceptDomainTransferFromAnotherAwsAccount.html) request. The request must include the value of the Password element that was returned in the TransferDomainToAnotherAwsAccount response.
    public var password: Swift.String?

    public init(
        operationId: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.operationId = operationId
        self.password = password
    }
}

extension TransferDomainToAnotherAwsAccountOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransferDomainToAnotherAwsAccountOutput(operationId: \(Swift.String(describing: operationId)), password: \"CONTENT_REDACTED\")"}
}

/// The UpdateDomainContact request includes the following elements.
public struct UpdateDomainContactInput: Swift.Sendable {
    /// Provides detailed contact information.
    public var adminContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information.
    public var billingContact: Route53DomainsClientTypes.ContactDetail?
    /// Customer's consent for the owner change request. Required if the domain is not free (consent price is more than $0.00).
    public var consent: Route53DomainsClientTypes.Consent?
    /// The name of the domain that you want to update contact information for.
    /// This member is required.
    public var domainName: Swift.String?
    /// Provides detailed contact information.
    public var registrantContact: Route53DomainsClientTypes.ContactDetail?
    /// Provides detailed contact information.
    public var techContact: Route53DomainsClientTypes.ContactDetail?

    public init(
        adminContact: Route53DomainsClientTypes.ContactDetail? = nil,
        billingContact: Route53DomainsClientTypes.ContactDetail? = nil,
        consent: Route53DomainsClientTypes.Consent? = nil,
        domainName: Swift.String? = nil,
        registrantContact: Route53DomainsClientTypes.ContactDetail? = nil,
        techContact: Route53DomainsClientTypes.ContactDetail? = nil
    )
    {
        self.adminContact = adminContact
        self.billingContact = billingContact
        self.consent = consent
        self.domainName = domainName
        self.registrantContact = registrantContact
        self.techContact = techContact
    }
}

extension UpdateDomainContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainContactInput(consent: \(Swift.String(describing: consent)), domainName: \(Swift.String(describing: domainName)), adminContact: \"CONTENT_REDACTED\", billingContact: \"CONTENT_REDACTED\", registrantContact: \"CONTENT_REDACTED\", techContact: \"CONTENT_REDACTED\")"}
}

/// The UpdateDomainContact response includes the following element.
public struct UpdateDomainContactOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The UpdateDomainContactPrivacy request includes the following elements.
public struct UpdateDomainContactPrivacyInput: Swift.Sendable {
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the admin contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var adminPrivacy: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the billing contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var billingPrivacy: Swift.Bool?
    /// The name of the domain that you want to update the privacy setting for.
    /// This member is required.
    public var domainName: Swift.String?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the registrant contact (domain owner). You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var registrantPrivacy: Swift.Bool?
    /// Whether you want to conceal contact information from WHOIS queries. If you specify true, WHOIS ("who is") queries return contact information either for Amazon Registrar or for our registrar associate, Gandi. If you specify false, WHOIS queries return the information that you entered for the technical contact. You must specify the same privacy setting for the administrative, billing, registrant, and technical contacts.
    public var techPrivacy: Swift.Bool?

    public init(
        adminPrivacy: Swift.Bool? = nil,
        billingPrivacy: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        registrantPrivacy: Swift.Bool? = nil,
        techPrivacy: Swift.Bool? = nil
    )
    {
        self.adminPrivacy = adminPrivacy
        self.billingPrivacy = billingPrivacy
        self.domainName = domainName
        self.registrantPrivacy = registrantPrivacy
        self.techPrivacy = techPrivacy
    }
}

/// The UpdateDomainContactPrivacy response includes the following element.
public struct UpdateDomainContactPrivacyOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To use this ID to query the operation status, use GetOperationDetail.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// Replaces the current set of name servers for the domain with the specified set of name servers. If you use Amazon Route 53 as your DNS service, specify the four name servers in the delegation set for the hosted zone for the domain. If successful, this operation returns an operation ID that you can use to track the progress and completion of the action. If the request is not completed successfully, the domain registrant will be notified by email.
public struct UpdateDomainNameserversInput: Swift.Sendable {
    /// The name of the domain that you want to change name servers for.
    /// This member is required.
    public var domainName: Swift.String?
    /// The authorization key for .fi domains
    @available(*, deprecated)
    public var fiAuthKey: Swift.String?
    /// A list of new name servers for the domain.
    /// This member is required.
    public var nameservers: [Route53DomainsClientTypes.Nameserver]?

    public init(
        domainName: Swift.String? = nil,
        fiAuthKey: Swift.String? = nil,
        nameservers: [Route53DomainsClientTypes.Nameserver]? = nil
    )
    {
        self.domainName = domainName
        self.fiAuthKey = fiAuthKey
        self.nameservers = nameservers
    }
}

extension UpdateDomainNameserversInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainNameserversInput(domainName: \(Swift.String(describing: domainName)), nameservers: \(Swift.String(describing: nameservers)), fiAuthKey: \"CONTENT_REDACTED\")"}
}

/// The UpdateDomainNameservers response includes the following element.
public struct UpdateDomainNameserversOutput: Swift.Sendable {
    /// Identifier for tracking the progress of the request. To query the operation status, use [GetOperationDetail](https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_GetOperationDetail.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The UpdateTagsForDomainRequest includes the following elements.
public struct UpdateTagsForDomainInput: Swift.Sendable {
    /// The domain for which you want to add or update tags.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the tag keys and values that you want to add or update. If you specify a key that already exists, the corresponding value will be replaced.
    public var tagsToUpdate: [Route53DomainsClientTypes.Tag]?

    public init(
        domainName: Swift.String? = nil,
        tagsToUpdate: [Route53DomainsClientTypes.Tag]? = nil
    )
    {
        self.domainName = domainName
        self.tagsToUpdate = tagsToUpdate
    }
}

public struct UpdateTagsForDomainOutput: Swift.Sendable {

    public init() { }
}

/// The ViewBilling request includes the following elements.
public struct ViewBillingInput: Swift.Sendable {
    /// The end date and time for the time period for which you want a list of billing records. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var end: Foundation.Date?
    /// For an initial request for a list of billing records, omit this element. If the number of billing records that are associated with the current Amazon Web Services account during the specified period is greater than the value that you specified for MaxItems, you can use Marker to return additional billing records. Get the value of NextPageMarker from the previous response, and submit another request that includes the value of NextPageMarker in the Marker element. Constraints: The marker must match the value of NextPageMarker that was returned in the previous response.
    public var marker: Swift.String?
    /// The number of billing records to be returned. Default: 20
    public var maxItems: Swift.Int?
    /// The beginning date and time for the time period for which you want a list of billing records. Specify the date and time in Unix time format and Coordinated Universal time (UTC).
    public var start: Foundation.Date?

    public init(
        end: Foundation.Date? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        start: Foundation.Date? = nil
    )
    {
        self.end = end
        self.marker = marker
        self.maxItems = maxItems
        self.start = start
    }
}

/// The ViewBilling response includes the following elements.
public struct ViewBillingOutput: Swift.Sendable {
    /// A summary of billing records.
    public var billingRecords: [Route53DomainsClientTypes.BillingRecord]?
    /// If there are more billing records than you specified for MaxItems in the request, submit another request and include the value of NextPageMarker in the value of Marker.
    public var nextPageMarker: Swift.String?

    public init(
        billingRecords: [Route53DomainsClientTypes.BillingRecord]? = nil,
        nextPageMarker: Swift.String? = nil
    )
    {
        self.billingRecords = billingRecords
        self.nextPageMarker = nextPageMarker
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountInput {

    static func urlPathProvider(_ value: AcceptDomainTransferFromAnotherAwsAccountInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDelegationSignerToDomainInput {

    static func urlPathProvider(_ value: AssociateDelegationSignerToDomainInput) -> Swift.String? {
        return "/"
    }
}

extension CancelDomainTransferToAnotherAwsAccountInput {

    static func urlPathProvider(_ value: CancelDomainTransferToAnotherAwsAccountInput) -> Swift.String? {
        return "/"
    }
}

extension CheckDomainAvailabilityInput {

    static func urlPathProvider(_ value: CheckDomainAvailabilityInput) -> Swift.String? {
        return "/"
    }
}

extension CheckDomainTransferabilityInput {

    static func urlPathProvider(_ value: CheckDomainTransferabilityInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTagsForDomainInput {

    static func urlPathProvider(_ value: DeleteTagsForDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DisableDomainAutoRenewInput {

    static func urlPathProvider(_ value: DisableDomainAutoRenewInput) -> Swift.String? {
        return "/"
    }
}

extension DisableDomainTransferLockInput {

    static func urlPathProvider(_ value: DisableDomainTransferLockInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateDelegationSignerFromDomainInput {

    static func urlPathProvider(_ value: DisassociateDelegationSignerFromDomainInput) -> Swift.String? {
        return "/"
    }
}

extension EnableDomainAutoRenewInput {

    static func urlPathProvider(_ value: EnableDomainAutoRenewInput) -> Swift.String? {
        return "/"
    }
}

extension EnableDomainTransferLockInput {

    static func urlPathProvider(_ value: EnableDomainTransferLockInput) -> Swift.String? {
        return "/"
    }
}

extension GetContactReachabilityStatusInput {

    static func urlPathProvider(_ value: GetContactReachabilityStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetDomainDetailInput {

    static func urlPathProvider(_ value: GetDomainDetailInput) -> Swift.String? {
        return "/"
    }
}

extension GetDomainSuggestionsInput {

    static func urlPathProvider(_ value: GetDomainSuggestionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetOperationDetailInput {

    static func urlPathProvider(_ value: GetOperationDetailInput) -> Swift.String? {
        return "/"
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOperationsInput {

    static func urlPathProvider(_ value: ListOperationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPricesInput {

    static func urlPathProvider(_ value: ListPricesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForDomainInput {

    static func urlPathProvider(_ value: ListTagsForDomainInput) -> Swift.String? {
        return "/"
    }
}

extension PushDomainInput {

    static func urlPathProvider(_ value: PushDomainInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterDomainInput {

    static func urlPathProvider(_ value: RegisterDomainInput) -> Swift.String? {
        return "/"
    }
}

extension RejectDomainTransferFromAnotherAwsAccountInput {

    static func urlPathProvider(_ value: RejectDomainTransferFromAnotherAwsAccountInput) -> Swift.String? {
        return "/"
    }
}

extension RenewDomainInput {

    static func urlPathProvider(_ value: RenewDomainInput) -> Swift.String? {
        return "/"
    }
}

extension ResendContactReachabilityEmailInput {

    static func urlPathProvider(_ value: ResendContactReachabilityEmailInput) -> Swift.String? {
        return "/"
    }
}

extension ResendOperationAuthorizationInput {

    static func urlPathProvider(_ value: ResendOperationAuthorizationInput) -> Swift.String? {
        return "/"
    }
}

extension RetrieveDomainAuthCodeInput {

    static func urlPathProvider(_ value: RetrieveDomainAuthCodeInput) -> Swift.String? {
        return "/"
    }
}

extension TransferDomainInput {

    static func urlPathProvider(_ value: TransferDomainInput) -> Swift.String? {
        return "/"
    }
}

extension TransferDomainToAnotherAwsAccountInput {

    static func urlPathProvider(_ value: TransferDomainToAnotherAwsAccountInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDomainContactInput {

    static func urlPathProvider(_ value: UpdateDomainContactInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDomainContactPrivacyInput {

    static func urlPathProvider(_ value: UpdateDomainContactPrivacyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDomainNameserversInput {

    static func urlPathProvider(_ value: UpdateDomainNameserversInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTagsForDomainInput {

    static func urlPathProvider(_ value: UpdateTagsForDomainInput) -> Swift.String? {
        return "/"
    }
}

extension ViewBillingInput {

    static func urlPathProvider(_ value: ViewBillingInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountInput {

    static func write(value: AcceptDomainTransferFromAnotherAwsAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Password"].write(value.password)
    }
}

extension AssociateDelegationSignerToDomainInput {

    static func write(value: AssociateDelegationSignerToDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["SigningAttributes"].write(value.signingAttributes, with: Route53DomainsClientTypes.DnssecSigningAttributes.write(value:to:))
    }
}

extension CancelDomainTransferToAnotherAwsAccountInput {

    static func write(value: CancelDomainTransferToAnotherAwsAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension CheckDomainAvailabilityInput {

    static func write(value: CheckDomainAvailabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["IdnLangCode"].write(value.idnLangCode)
    }
}

extension CheckDomainTransferabilityInput {

    static func write(value: CheckDomainTransferabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthCode"].write(value.authCode)
        try writer["DomainName"].write(value.domainName)
    }
}

extension DeleteDomainInput {

    static func write(value: DeleteDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension DeleteTagsForDomainInput {

    static func write(value: DeleteTagsForDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["TagsToDelete"].writeList(value.tagsToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisableDomainAutoRenewInput {

    static func write(value: DisableDomainAutoRenewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension DisableDomainTransferLockInput {

    static func write(value: DisableDomainTransferLockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension DisassociateDelegationSignerFromDomainInput {

    static func write(value: DisassociateDelegationSignerFromDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
    }
}

extension EnableDomainAutoRenewInput {

    static func write(value: EnableDomainAutoRenewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension EnableDomainTransferLockInput {

    static func write(value: EnableDomainTransferLockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension GetContactReachabilityStatusInput {

    static func write(value: GetContactReachabilityStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
    }
}

extension GetDomainDetailInput {

    static func write(value: GetDomainDetailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension GetDomainSuggestionsInput {

    static func write(value: GetDomainSuggestionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OnlyAvailable"].write(value.onlyAvailable)
        try writer["SuggestionCount"].write(value.suggestionCount)
    }
}

extension GetOperationDetailInput {

    static func write(value: GetOperationDetailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperationId"].write(value.operationId)
    }
}

extension ListDomainsInput {

    static func write(value: ListDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterConditions"].writeList(value.filterConditions, memberWritingClosure: Route53DomainsClientTypes.FilterCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["SortCondition"].write(value.sortCondition, with: Route53DomainsClientTypes.SortCondition.write(value:to:))
    }
}

extension ListOperationsInput {

    static func write(value: ListOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Route53DomainsClientTypes.OperationStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubmittedSince"].writeTimestamp(value.submittedSince, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Type"].writeList(value.type, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Route53DomainsClientTypes.OperationType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListPricesInput {

    static func write(value: ListPricesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Tld"].write(value.tld)
    }
}

extension ListTagsForDomainInput {

    static func write(value: ListTagsForDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension PushDomainInput {

    static func write(value: PushDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Target"].write(value.target)
    }
}

extension RegisterDomainInput {

    static func write(value: RegisterDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminContact"].write(value.adminContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["AutoRenew"].write(value.autoRenew)
        try writer["BillingContact"].write(value.billingContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["DurationInYears"].write(value.durationInYears)
        try writer["IdnLangCode"].write(value.idnLangCode)
        try writer["PrivacyProtectAdminContact"].write(value.privacyProtectAdminContact)
        try writer["PrivacyProtectBillingContact"].write(value.privacyProtectBillingContact)
        try writer["PrivacyProtectRegistrantContact"].write(value.privacyProtectRegistrantContact)
        try writer["PrivacyProtectTechContact"].write(value.privacyProtectTechContact)
        try writer["RegistrantContact"].write(value.registrantContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["TechContact"].write(value.techContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
    }
}

extension RejectDomainTransferFromAnotherAwsAccountInput {

    static func write(value: RejectDomainTransferFromAnotherAwsAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension RenewDomainInput {

    static func write(value: RenewDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentExpiryYear"].write(value.currentExpiryYear)
        try writer["DomainName"].write(value.domainName)
        try writer["DurationInYears"].write(value.durationInYears)
    }
}

extension ResendContactReachabilityEmailInput {

    static func write(value: ResendContactReachabilityEmailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
    }
}

extension ResendOperationAuthorizationInput {

    static func write(value: ResendOperationAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperationId"].write(value.operationId)
    }
}

extension RetrieveDomainAuthCodeInput {

    static func write(value: RetrieveDomainAuthCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension TransferDomainInput {

    static func write(value: TransferDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminContact"].write(value.adminContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["AuthCode"].write(value.authCode)
        try writer["AutoRenew"].write(value.autoRenew)
        try writer["BillingContact"].write(value.billingContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["DurationInYears"].write(value.durationInYears)
        try writer["IdnLangCode"].write(value.idnLangCode)
        try writer["Nameservers"].writeList(value.nameservers, memberWritingClosure: Route53DomainsClientTypes.Nameserver.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PrivacyProtectAdminContact"].write(value.privacyProtectAdminContact)
        try writer["PrivacyProtectBillingContact"].write(value.privacyProtectBillingContact)
        try writer["PrivacyProtectRegistrantContact"].write(value.privacyProtectRegistrantContact)
        try writer["PrivacyProtectTechContact"].write(value.privacyProtectTechContact)
        try writer["RegistrantContact"].write(value.registrantContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["TechContact"].write(value.techContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
    }
}

extension TransferDomainToAnotherAwsAccountInput {

    static func write(value: TransferDomainToAnotherAwsAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["DomainName"].write(value.domainName)
    }
}

extension UpdateDomainContactInput {

    static func write(value: UpdateDomainContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminContact"].write(value.adminContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["BillingContact"].write(value.billingContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["Consent"].write(value.consent, with: Route53DomainsClientTypes.Consent.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["RegistrantContact"].write(value.registrantContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
        try writer["TechContact"].write(value.techContact, with: Route53DomainsClientTypes.ContactDetail.write(value:to:))
    }
}

extension UpdateDomainContactPrivacyInput {

    static func write(value: UpdateDomainContactPrivacyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminPrivacy"].write(value.adminPrivacy)
        try writer["BillingPrivacy"].write(value.billingPrivacy)
        try writer["DomainName"].write(value.domainName)
        try writer["RegistrantPrivacy"].write(value.registrantPrivacy)
        try writer["TechPrivacy"].write(value.techPrivacy)
    }
}

extension UpdateDomainNameserversInput {

    static func write(value: UpdateDomainNameserversInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["FIAuthKey"].write(value.fiAuthKey)
        try writer["Nameservers"].writeList(value.nameservers, memberWritingClosure: Route53DomainsClientTypes.Nameserver.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTagsForDomainInput {

    static func write(value: UpdateTagsForDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["TagsToUpdate"].writeList(value.tagsToUpdate, memberWritingClosure: Route53DomainsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ViewBillingInput {

    static func write(value: ViewBillingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].writeTimestamp(value.end, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["Start"].writeTimestamp(value.start, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension AcceptDomainTransferFromAnotherAwsAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptDomainTransferFromAnotherAwsAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptDomainTransferFromAnotherAwsAccountOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension AssociateDelegationSignerToDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDelegationSignerToDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateDelegationSignerToDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension CancelDomainTransferToAnotherAwsAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDomainTransferToAnotherAwsAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelDomainTransferToAnotherAwsAccountOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension CheckDomainAvailabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckDomainAvailabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckDomainAvailabilityOutput()
        value.availability = try reader["Availability"].readIfPresent()
        return value
    }
}

extension CheckDomainTransferabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckDomainTransferabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckDomainTransferabilityOutput()
        value.message = try reader["Message"].readIfPresent()
        value.transferability = try reader["Transferability"].readIfPresent(with: Route53DomainsClientTypes.DomainTransferability.read(from:))
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DeleteTagsForDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTagsForDomainOutput {
        return DeleteTagsForDomainOutput()
    }
}

extension DisableDomainAutoRenewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableDomainAutoRenewOutput {
        return DisableDomainAutoRenewOutput()
    }
}

extension DisableDomainTransferLockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableDomainTransferLockOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableDomainTransferLockOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DisassociateDelegationSignerFromDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDelegationSignerFromDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateDelegationSignerFromDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension EnableDomainAutoRenewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableDomainAutoRenewOutput {
        return EnableDomainAutoRenewOutput()
    }
}

extension EnableDomainTransferLockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableDomainTransferLockOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableDomainTransferLockOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension GetContactReachabilityStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContactReachabilityStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactReachabilityStatusOutput()
        value.domainName = try reader["domainName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetDomainDetailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainDetailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainDetailOutput()
        value.abuseContactEmail = try reader["AbuseContactEmail"].readIfPresent()
        value.abuseContactPhone = try reader["AbuseContactPhone"].readIfPresent()
        value.adminContact = try reader["AdminContact"].readIfPresent(with: Route53DomainsClientTypes.ContactDetail.read(from:))
        value.adminPrivacy = try reader["AdminPrivacy"].readIfPresent()
        value.autoRenew = try reader["AutoRenew"].readIfPresent()
        value.billingContact = try reader["BillingContact"].readIfPresent(with: Route53DomainsClientTypes.ContactDetail.read(from:))
        value.billingPrivacy = try reader["BillingPrivacy"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dnsSec = try reader["DnsSec"].readIfPresent()
        value.dnssecKeys = try reader["DnssecKeys"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.DnssecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.domainName = try reader["DomainName"].readIfPresent()
        value.expirationDate = try reader["ExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nameservers = try reader["Nameservers"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.Nameserver.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.registrantContact = try reader["RegistrantContact"].readIfPresent(with: Route53DomainsClientTypes.ContactDetail.read(from:))
        value.registrantPrivacy = try reader["RegistrantPrivacy"].readIfPresent()
        value.registrarName = try reader["RegistrarName"].readIfPresent()
        value.registrarUrl = try reader["RegistrarUrl"].readIfPresent()
        value.registryDomainId = try reader["RegistryDomainId"].readIfPresent()
        value.reseller = try reader["Reseller"].readIfPresent()
        value.statusList = try reader["StatusList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.techContact = try reader["TechContact"].readIfPresent(with: Route53DomainsClientTypes.ContactDetail.read(from:))
        value.techPrivacy = try reader["TechPrivacy"].readIfPresent()
        value.updatedDate = try reader["UpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.whoIsServer = try reader["WhoIsServer"].readIfPresent()
        return value
    }
}

extension GetDomainSuggestionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainSuggestionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainSuggestionsOutput()
        value.suggestionsList = try reader["SuggestionsList"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.DomainSuggestion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetOperationDetailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOperationDetailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOperationDetailOutput()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["Message"].readIfPresent()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusFlag = try reader["StatusFlag"].readIfPresent()
        value.submittedDate = try reader["SubmittedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageMarker = try reader["NextPageMarker"].readIfPresent()
        return value
    }
}

extension ListOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOperationsOutput()
        value.nextPageMarker = try reader["NextPageMarker"].readIfPresent()
        value.operations = try reader["Operations"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.OperationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPricesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPricesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPricesOutput()
        value.nextPageMarker = try reader["NextPageMarker"].readIfPresent()
        value.prices = try reader["Prices"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.DomainPrice.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForDomainOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PushDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PushDomainOutput {
        return PushDomainOutput()
    }
}

extension RegisterDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension RejectDomainTransferFromAnotherAwsAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectDomainTransferFromAnotherAwsAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectDomainTransferFromAnotherAwsAccountOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension RenewDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RenewDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RenewDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension ResendContactReachabilityEmailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResendContactReachabilityEmailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResendContactReachabilityEmailOutput()
        value.domainName = try reader["domainName"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.isAlreadyVerified = try reader["isAlreadyVerified"].readIfPresent()
        return value
    }
}

extension ResendOperationAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResendOperationAuthorizationOutput {
        return ResendOperationAuthorizationOutput()
    }
}

extension RetrieveDomainAuthCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveDomainAuthCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveDomainAuthCodeOutput()
        value.authCode = try reader["AuthCode"].readIfPresent()
        return value
    }
}

extension TransferDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TransferDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TransferDomainOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension TransferDomainToAnotherAwsAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TransferDomainToAnotherAwsAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TransferDomainToAnotherAwsAccountOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        return value
    }
}

extension UpdateDomainContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainContactOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateDomainContactPrivacyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainContactPrivacyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainContactPrivacyOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateDomainNameserversOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainNameserversOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainNameserversOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateTagsForDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTagsForDomainOutput {
        return UpdateTagsForDomainOutput()
    }
}

extension ViewBillingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ViewBillingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ViewBillingOutput()
        value.billingRecords = try reader["BillingRecords"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.BillingRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageMarker = try reader["NextPageMarker"].readIfPresent()
        return value
    }
}

enum AcceptDomainTransferFromAnotherAwsAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DomainLimitExceeded": return try DomainLimitExceeded.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateDelegationSignerToDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DnssecLimitExceeded": return try DnssecLimitExceeded.makeError(baseError: baseError)
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDomainTransferToAnotherAwsAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckDomainAvailabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckDomainTransferabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTagsForDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableDomainAutoRenewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableDomainTransferLockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDelegationSignerFromDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableDomainAutoRenewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableDomainTransferLockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContactReachabilityStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainDetailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainSuggestionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOperationDetailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPricesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PushDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DomainLimitExceeded": return try DomainLimitExceeded.makeError(baseError: baseError)
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectDomainTransferFromAnotherAwsAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RenewDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResendContactReachabilityEmailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResendOperationAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveDomainAuthCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TransferDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DomainLimitExceeded": return try DomainLimitExceeded.makeError(baseError: baseError)
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TransferDomainToAnotherAwsAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainContactPrivacyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainNameserversOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "TLDRulesViolation": return try TLDRulesViolation.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTagsForDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationLimitExceeded": return try OperationLimitExceeded.makeError(baseError: baseError)
            case "UnsupportedTLD": return try UnsupportedTLD.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ViewBillingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DomainLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DomainLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = DomainLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInput {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInput {
        let reader = baseError.errorBodyReader
        var value = InvalidInput()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedTLD {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedTLD {
        let reader = baseError.errorBodyReader
        var value = UnsupportedTLD()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = OperationLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DnssecLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DnssecLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = DnssecLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateRequest {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateRequest {
        let reader = baseError.errorBodyReader
        var value = DuplicateRequest()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.requestId = try reader["requestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TLDRulesViolation {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TLDRulesViolation {
        let reader = baseError.errorBodyReader
        var value = TLDRulesViolation()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension Route53DomainsClientTypes.DomainTransferability {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.DomainTransferability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.DomainTransferability()
        value.transferable = try reader["Transferable"].readIfPresent()
        return value
    }
}

extension Route53DomainsClientTypes.Nameserver {

    static func write(value: Route53DomainsClientTypes.Nameserver?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlueIps"].writeList(value.glueIps, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.Nameserver {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.Nameserver()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.glueIps = try reader["GlueIps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Route53DomainsClientTypes.ContactDetail {

    static func write(value: Route53DomainsClientTypes.ContactDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressLine1"].write(value.addressLine1)
        try writer["AddressLine2"].write(value.addressLine2)
        try writer["City"].write(value.city)
        try writer["ContactType"].write(value.contactType)
        try writer["CountryCode"].write(value.countryCode)
        try writer["Email"].write(value.email)
        try writer["ExtraParams"].writeList(value.extraParams, memberWritingClosure: Route53DomainsClientTypes.ExtraParam.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fax"].write(value.fax)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["OrganizationName"].write(value.organizationName)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["State"].write(value.state)
        try writer["ZipCode"].write(value.zipCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.ContactDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.ContactDetail()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.contactType = try reader["ContactType"].readIfPresent()
        value.organizationName = try reader["OrganizationName"].readIfPresent()
        value.addressLine1 = try reader["AddressLine1"].readIfPresent()
        value.addressLine2 = try reader["AddressLine2"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.zipCode = try reader["ZipCode"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.fax = try reader["Fax"].readIfPresent()
        value.extraParams = try reader["ExtraParams"].readListIfPresent(memberReadingClosure: Route53DomainsClientTypes.ExtraParam.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Route53DomainsClientTypes.ExtraParam {

    static func write(value: Route53DomainsClientTypes.ExtraParam?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.ExtraParam {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.ExtraParam()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension Route53DomainsClientTypes.DnssecKey {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.DnssecKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.DnssecKey()
        value.algorithm = try reader["Algorithm"].readIfPresent()
        value.flags = try reader["Flags"].readIfPresent()
        value.publicKey = try reader["PublicKey"].readIfPresent()
        value.digestType = try reader["DigestType"].readIfPresent()
        value.digest = try reader["Digest"].readIfPresent()
        value.keyTag = try reader["KeyTag"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension Route53DomainsClientTypes.DomainSuggestion {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.DomainSuggestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.DomainSuggestion()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.availability = try reader["Availability"].readIfPresent()
        return value
    }
}

extension Route53DomainsClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.DomainSummary()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.autoRenew = try reader["AutoRenew"].readIfPresent()
        value.transferLock = try reader["TransferLock"].readIfPresent()
        value.expiry = try reader["Expiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Route53DomainsClientTypes.OperationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.OperationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.OperationSummary()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.submittedDate = try reader["SubmittedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domainName = try reader["DomainName"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.statusFlag = try reader["StatusFlag"].readIfPresent()
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension Route53DomainsClientTypes.DomainPrice {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.DomainPrice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.DomainPrice()
        value.name = try reader["Name"].readIfPresent()
        value.registrationPrice = try reader["RegistrationPrice"].readIfPresent(with: Route53DomainsClientTypes.PriceWithCurrency.read(from:))
        value.transferPrice = try reader["TransferPrice"].readIfPresent(with: Route53DomainsClientTypes.PriceWithCurrency.read(from:))
        value.renewalPrice = try reader["RenewalPrice"].readIfPresent(with: Route53DomainsClientTypes.PriceWithCurrency.read(from:))
        value.changeOwnershipPrice = try reader["ChangeOwnershipPrice"].readIfPresent(with: Route53DomainsClientTypes.PriceWithCurrency.read(from:))
        value.restorationPrice = try reader["RestorationPrice"].readIfPresent(with: Route53DomainsClientTypes.PriceWithCurrency.read(from:))
        return value
    }
}

extension Route53DomainsClientTypes.PriceWithCurrency {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.PriceWithCurrency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.PriceWithCurrency()
        value.price = try reader["Price"].readIfPresent() ?? 0
        value.currency = try reader["Currency"].readIfPresent() ?? ""
        return value
    }
}

extension Route53DomainsClientTypes.Tag {

    static func write(value: Route53DomainsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension Route53DomainsClientTypes.BillingRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53DomainsClientTypes.BillingRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53DomainsClientTypes.BillingRecord()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.operation = try reader["Operation"].readIfPresent()
        value.invoiceId = try reader["InvoiceId"].readIfPresent()
        value.billDate = try reader["BillDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.price = try reader["Price"].readIfPresent() ?? 0
        return value
    }
}

extension Route53DomainsClientTypes.DnssecSigningAttributes {

    static func write(value: Route53DomainsClientTypes.DnssecSigningAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Algorithm"].write(value.algorithm)
        try writer["Flags"].write(value.flags)
        try writer["PublicKey"].write(value.publicKey)
    }
}

extension Route53DomainsClientTypes.FilterCondition {

    static func write(value: Route53DomainsClientTypes.FilterCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Route53DomainsClientTypes.SortCondition {

    static func write(value: Route53DomainsClientTypes.SortCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension Route53DomainsClientTypes.Consent {

    static func write(value: Route53DomainsClientTypes.Consent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Currency"].write(value.currency)
        try writer["MaxPrice"].write(value.maxPrice)
    }
}

public enum Route53DomainsClientTypes {}
