// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to the specified resource was denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataBrewClientTypes.AllowedStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics = "Statistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statistics = statistics {
            var statisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statistics)
            for statistic0 in statistics {
                try statisticsContainer.encode(statistic0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statistics)
        var statisticsDecoded0:[Swift.String]? = nil
        if let statisticsContainer = statisticsContainer {
            statisticsDecoded0 = [Swift.String]()
            for string0 in statisticsContainer {
                if let string0 = string0 {
                    statisticsDecoded0?.append(string0)
                }
            }
        }
        statistics = statisticsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Configuration of statistics that are allowed to be run on columns that contain detected entities. When undefined, no statistics will be computed on columns that contain detected entities.
    public struct AllowedStatistics: Swift.Equatable {
        /// One or more column statistics to allow for columns that contain detected entities.
        /// This member is required.
        public var statistics: [Swift.String]?

        public init(
            statistics: [Swift.String]? = nil
        )
        {
            self.statistics = statistics
        }
    }

}

extension DataBrewClientTypes {
    public enum AnalyticsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsMode] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyticsMode(rawValue: rawValue) ?? AnalyticsMode.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteRecipeVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeVersions = "RecipeVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeVersions = recipeVersions {
            var recipeVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeVersions)
            for recipeversion0 in recipeVersions {
                try recipeVersionsContainer.encode(recipeversion0)
            }
        }
    }
}

extension BatchDeleteRecipeVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/recipes/\(name.urlPercentEncoding())/batchDeleteRecipeVersion"
    }
}

public struct BatchDeleteRecipeVersionInput: Swift.Equatable {
    /// The name of the recipe whose versions are to be deleted.
    /// This member is required.
    public var name: Swift.String?
    /// An array of version identifiers, for the recipe versions to be deleted. You can specify numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
    /// This member is required.
    public var recipeVersions: [Swift.String]?

    public init(
        name: Swift.String? = nil,
        recipeVersions: [Swift.String]? = nil
    )
    {
        self.name = name
        self.recipeVersions = recipeVersions
    }
}

struct BatchDeleteRecipeVersionInputBody: Swift.Equatable {
    let recipeVersions: [Swift.String]?
}

extension BatchDeleteRecipeVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeVersions = "RecipeVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recipeVersions)
        var recipeVersionsDecoded0:[Swift.String]? = nil
        if let recipeVersionsContainer = recipeVersionsContainer {
            recipeVersionsDecoded0 = [Swift.String]()
            for string0 in recipeVersionsContainer {
                if let string0 = string0 {
                    recipeVersionsDecoded0?.append(string0)
                }
            }
        }
        recipeVersions = recipeVersionsDecoded0
    }
}

extension BatchDeleteRecipeVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteRecipeVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.name = output.name
        } else {
            self.errors = nil
            self.name = nil
        }
    }
}

public struct BatchDeleteRecipeVersionOutput: Swift.Equatable {
    /// Errors, if any, that occurred while attempting to delete the recipe versions.
    public var errors: [DataBrewClientTypes.RecipeVersionErrorDetail]?
    /// The name of the recipe that was modified.
    /// This member is required.
    public var name: Swift.String?

    public init(
        errors: [DataBrewClientTypes.RecipeVersionErrorDetail]? = nil,
        name: Swift.String? = nil
    )
    {
        self.errors = errors
        self.name = name
    }
}

struct BatchDeleteRecipeVersionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let errors: [DataBrewClientTypes.RecipeVersionErrorDetail]?
}

extension BatchDeleteRecipeVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RecipeVersionErrorDetail?].self, forKey: .errors)
        var errorsDecoded0:[DataBrewClientTypes.RecipeVersionErrorDetail]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataBrewClientTypes.RecipeVersionErrorDetail]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteRecipeVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.ColumnSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case regex = "Regex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DataBrewClientTypes {
    /// Selector of a column from a dataset for profile job configuration. One selector includes either a column name or a regular expression.
    public struct ColumnSelector: Swift.Equatable {
        /// The name of a column from a dataset.
        public var name: Swift.String?
        /// A regular expression for selecting a column from a dataset.
        public var regex: Swift.String?

        public init(
            name: Swift.String? = nil,
            regex: Swift.String? = nil
        )
        {
            self.name = name
            self.regex = regex
        }
    }

}

extension DataBrewClientTypes.ColumnStatisticsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectors = "Selectors"
        case statistics = "Statistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectors = selectors {
            var selectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectors)
            for columnselector0 in selectors {
                try selectorsContainer.encode(columnselector0)
            }
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ColumnSelector?].self, forKey: .selectors)
        var selectorsDecoded0:[DataBrewClientTypes.ColumnSelector]? = nil
        if let selectorsContainer = selectorsContainer {
            selectorsDecoded0 = [DataBrewClientTypes.ColumnSelector]()
            for structure0 in selectorsContainer {
                if let structure0 = structure0 {
                    selectorsDecoded0?.append(structure0)
                }
            }
        }
        selectors = selectorsDecoded0
        let statisticsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.StatisticsConfiguration.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension DataBrewClientTypes {
    /// Configuration for column evaluations for a profile job. ColumnStatisticsConfiguration can be used to select evaluations and override parameters of evaluations for particular columns.
    public struct ColumnStatisticsConfiguration: Swift.Equatable {
        /// List of column selectors. Selectors can be used to select columns from the dataset. When selectors are undefined, configuration will be applied to all supported columns.
        public var selectors: [DataBrewClientTypes.ColumnSelector]?
        /// Configuration for evaluations. Statistics can be used to select evaluations and override parameters of evaluations.
        /// This member is required.
        public var statistics: DataBrewClientTypes.StatisticsConfiguration?

        public init(
            selectors: [DataBrewClientTypes.ColumnSelector]? = nil,
            statistics: DataBrewClientTypes.StatisticsConfiguration? = nil
        )
        {
            self.selectors = selectors
            self.statistics = statistics
        }
    }

}

extension DataBrewClientTypes {
    public enum CompressionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case brotli
        case bzip2
        case deflate
        case gzip
        case lz4
        case lzo
        case snappy
        case zlib
        case zstd
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionFormat] {
            return [
                .brotli,
                .bzip2,
                .deflate,
                .gzip,
                .lz4,
                .lzo,
                .snappy,
                .zlib,
                .zstd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .brotli: return "BROTLI"
            case .bzip2: return "BZIP2"
            case .deflate: return "DEFLATE"
            case .gzip: return "GZIP"
            case .lz4: return "LZ4"
            case .lzo: return "LZO"
            case .snappy: return "SNAPPY"
            case .zlib: return "ZLIB"
            case .zstd: return "ZSTD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionFormat(rawValue: rawValue) ?? CompressionFormat.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.ConditionExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case targetColumn = "TargetColumn"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let targetColumn = self.targetColumn {
            try encodeContainer.encode(targetColumn, forKey: .targetColumn)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let targetColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetColumn)
        targetColumn = targetColumnDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents an individual condition that evaluates to true or false. Conditions are used with recipe actions. The action is only performed for column values where the condition evaluates to true. If a recipe requires more than one condition, then the recipe must specify multiple ConditionExpression elements. Each condition is applied to the rows in a dataset first, before the recipe action is performed.
    public struct ConditionExpression: Swift.Equatable {
        /// A specific condition to apply to a recipe action. For more information, see [Recipe structure](https://docs.aws.amazon.com/databrew/latest/dg/recipes.html#recipes.structure) in the Glue DataBrew Developer Guide.
        /// This member is required.
        public var condition: Swift.String?
        /// A column to apply this condition to.
        /// This member is required.
        public var targetColumn: Swift.String?
        /// A value that the condition must evaluate to for the condition to succeed.
        public var value: Swift.String?

        public init(
            condition: Swift.String? = nil,
            targetColumn: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.targetColumn = targetColumn
            self.value = value
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case name = "Name"
        case pathOptions = "PathOptions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pathOptions = self.pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasets"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The file format of a dataset that is created from an Amazon S3 file or folder.
    public var format: DataBrewClientTypes.InputFormat?
    /// Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.
    public var formatOptions: DataBrewClientTypes.FormatOptions?
    /// Represents information on how DataBrew can find data, in either the Glue Data Catalog or Amazon S3.
    /// This member is required.
    public var input: DataBrewClientTypes.Input?
    /// The name of the dataset to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
    public var pathOptions: DataBrewClientTypes.PathOptions?
    /// Metadata tags to apply to this dataset.
    public var tags: [Swift.String:Swift.String]?

    public init(
        format: DataBrewClientTypes.InputFormat? = nil,
        formatOptions: DataBrewClientTypes.FormatOptions? = nil,
        input: DataBrewClientTypes.Input? = nil,
        name: Swift.String? = nil,
        pathOptions: DataBrewClientTypes.PathOptions? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.name = name
        self.pathOptions = pathOptions
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: DataBrewClientTypes.InputFormat?
    let formatOptions: DataBrewClientTypes.FormatOptions?
    let input: DataBrewClientTypes.Input?
    let pathOptions: DataBrewClientTypes.PathOptions?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case name = "Name"
        case pathOptions = "PathOptions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Input.self, forKey: .input)
        input = inputDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateDatasetOutput: Swift.Equatable {
    /// The name of the dataset that you created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateDatasetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case validationConfigurations = "ValidationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = self.jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let validationConfigurations = validationConfigurations {
            var validationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationConfigurations)
            for validationconfiguration0 in validationConfigurations {
                try validationConfigurationsContainer.encode(validationconfiguration0)
            }
        }
    }
}

extension CreateProfileJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profileJobs"
    }
}

public struct CreateProfileJobInput: Swift.Equatable {
    /// Configuration for profile jobs. Used to select columns, do evaluations, and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    public var configuration: DataBrewClientTypes.ProfileConfiguration?
    /// The name of the dataset that this job is to act upon.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    public var encryptionKeyArn: Swift.String?
    /// The encryption mode for the job, which can be one of the following:
    ///
    /// * SSE-KMS - SSE-KMS - Server-side encryption with KMS-managed keys.
    ///
    /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    public var encryptionMode: DataBrewClientTypes.EncryptionMode?
    /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
    public var jobSample: DataBrewClientTypes.JobSample?
    /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// The maximum number of nodes that DataBrew can use when the job processes data.
    public var maxCapacity: Swift.Int?
    /// The maximum number of times to retry the job after a job run fails.
    public var maxRetries: Swift.Int?
    /// The name of the job to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// Represents an Amazon S3 location (bucket name, bucket owner, and object key) where DataBrew can read input data, or write output from a job.
    /// This member is required.
    public var outputLocation: DataBrewClientTypes.S3Location?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata tags to apply to this job.
    public var tags: [Swift.String:Swift.String]?
    /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    public var timeout: Swift.Int?
    /// List of validation configurations that are applied to the profile job.
    public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

    public init(
        configuration: DataBrewClientTypes.ProfileConfiguration? = nil,
        datasetName: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
        jobSample: DataBrewClientTypes.JobSample? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        maxCapacity: Swift.Int? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputLocation: DataBrewClientTypes.S3Location? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int? = nil,
        validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
    )
    {
        self.configuration = configuration
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputLocation = outputLocation
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
        self.validationConfigurations = validationConfigurations
    }
}

struct CreateProfileJobInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let encryptionKeyArn: Swift.String?
    let encryptionMode: DataBrewClientTypes.EncryptionMode?
    let name: Swift.String?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let maxCapacity: Swift.Int?
    let maxRetries: Swift.Int?
    let outputLocation: DataBrewClientTypes.S3Location?
    let configuration: DataBrewClientTypes.ProfileConfiguration?
    let validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let timeout: Swift.Int?
    let jobSample: DataBrewClientTypes.JobSample?
}

extension CreateProfileJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case validationConfigurations = "ValidationConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ProfileConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension CreateProfileJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateProfileJobOutput: Swift.Equatable {
    /// The name of the job that was created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateProfileJobOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateProfileJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateProfileJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetName = "DatasetName"
        case name = "Name"
        case recipeName = "RecipeName"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeName = self.recipeName {
            try encodeContainer.encode(recipeName, forKey: .recipeName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = self.sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// The name of an existing dataset to associate this project with.
    /// This member is required.
    public var datasetName: Swift.String?
    /// A unique name for the new project. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of an existing recipe to associate with the project.
    /// This member is required.
    public var recipeName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed for this request.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Represents the sample size and sampling type for DataBrew to use for interactive data analysis.
    public var sample: DataBrewClientTypes.Sample?
    /// Metadata tags to apply to this project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        datasetName: Swift.String? = nil,
        name: Swift.String? = nil,
        recipeName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sample: DataBrewClientTypes.Sample? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.datasetName = datasetName
        self.name = name
        self.recipeName = recipeName
        self.roleArn = roleArn
        self.sample = sample
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let name: Swift.String?
    let recipeName: Swift.String?
    let sample: DataBrewClientTypes.Sample?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetName = "DatasetName"
        case name = "Name"
        case recipeName = "RecipeName"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// The name of the project that you created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipestep0 in steps {
                try stepsContainer.encode(recipestep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recipes"
    }
}

public struct CreateRecipeInput: Swift.Equatable {
    /// A description for the recipe.
    public var description: Swift.String?
    /// A unique name for the recipe. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// An array containing the steps to be performed by the recipe. Each recipe step consists of one recipe action and (optionally) an array of condition expressions.
    /// This member is required.
    public var steps: [DataBrewClientTypes.RecipeStep]?
    /// Metadata tags to apply to this recipe.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        steps: [DataBrewClientTypes.RecipeStep]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.steps = steps
        self.tags = tags
    }
}

struct CreateRecipeInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
    let steps: [DataBrewClientTypes.RecipeStep]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[DataBrewClientTypes.RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DataBrewClientTypes.RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecipeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCatalogOutputs = dataCatalogOutputs {
            var dataCatalogOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataCatalogOutputs)
            for datacatalogoutput0 in dataCatalogOutputs {
                try dataCatalogOutputsContainer.encode(datacatalogoutput0)
            }
        }
        if let databaseOutputs = databaseOutputs {
            var databaseOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseOutputs)
            for databaseoutput0 in databaseOutputs {
                try databaseOutputsContainer.encode(databaseoutput0)
            }
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let recipeReference = self.recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

extension CreateRecipeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recipeJobs"
    }
}

public struct CreateRecipeJobInput: Swift.Equatable {
    /// One or more artifacts that represent the Glue Data Catalog output from running the job.
    public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write to.
    public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    /// The name of the dataset that this job processes.
    public var datasetName: Swift.String?
    /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    public var encryptionKeyArn: Swift.String?
    /// The encryption mode for the job, which can be one of the following:
    ///
    /// * SSE-KMS - Server-side encryption with keys managed by KMS.
    ///
    /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    public var encryptionMode: DataBrewClientTypes.EncryptionMode?
    /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// The maximum number of nodes that DataBrew can consume when the job processes data.
    public var maxCapacity: Swift.Int?
    /// The maximum number of times to retry the job after a job run fails.
    public var maxRetries: Swift.Int?
    /// A unique name for the job. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// One or more artifacts that represent the output from running the job.
    public var outputs: [DataBrewClientTypes.Output]?
    /// Either the name of an existing project, or a combination of a recipe and a dataset to associate with the recipe.
    public var projectName: Swift.String?
    /// Represents the name and version of a DataBrew recipe.
    public var recipeReference: DataBrewClientTypes.RecipeReference?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata tags to apply to this job.
    public var tags: [Swift.String:Swift.String]?
    /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    public var timeout: Swift.Int?

    public init(
        dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
        databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
        datasetName: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        maxCapacity: Swift.Int? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputs: [DataBrewClientTypes.Output]? = nil,
        projectName: Swift.String? = nil,
        recipeReference: DataBrewClientTypes.RecipeReference? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.dataCatalogOutputs = dataCatalogOutputs
        self.databaseOutputs = databaseOutputs
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.projectName = projectName
        self.recipeReference = recipeReference
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
    }
}

struct CreateRecipeJobInputBody: Swift.Equatable {
    let datasetName: Swift.String?
    let encryptionKeyArn: Swift.String?
    let encryptionMode: DataBrewClientTypes.EncryptionMode?
    let name: Swift.String?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let maxCapacity: Swift.Int?
    let maxRetries: Swift.Int?
    let outputs: [DataBrewClientTypes.Output]?
    let dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    let databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    let projectName: Swift.String?
    let recipeReference: DataBrewClientTypes.RecipeReference?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let timeout: Swift.Int?
}

extension CreateRecipeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension CreateRecipeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecipeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateRecipeJobOutput: Swift.Equatable {
    /// The name of the job that you created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateRecipeJobOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateRecipeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateRecipeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateRecipeOutput: Swift.Equatable {
    /// The name of the recipe that you created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateRecipeOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRulesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension CreateRulesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rulesets"
    }
}

public struct CreateRulesetInput: Swift.Equatable {
    /// The description of the ruleset.
    public var description: Swift.String?
    /// The name of the ruleset to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// A list of rules that are defined with the ruleset. A rule includes one or more checks to be validated on a DataBrew dataset.
    /// This member is required.
    public var rules: [DataBrewClientTypes.Rule]?
    /// Metadata tags to apply to the ruleset.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset is associated with.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        rules: [DataBrewClientTypes.Rule]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.rules = rules
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateRulesetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let targetArn: Swift.String?
    let rules: [DataBrewClientTypes.Rule]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRulesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DataBrewClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DataBrewClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRulesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRulesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateRulesetOutput: Swift.Equatable {
    /// The unique name of the created ruleset.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateRulesetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateRulesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateRulesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = self.cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobname0 in jobNames {
                try jobNamesContainer.encode(jobname0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schedules"
    }
}

public struct CreateScheduleInput: Swift.Equatable {
    /// The date or dates and time or times when the jobs are to be run. For more information, see [Cron expressions](https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html) in the Glue DataBrew Developer Guide.
    /// This member is required.
    public var cronExpression: Swift.String?
    /// The name or names of one or more jobs to be run.
    public var jobNames: [Swift.String]?
    /// A unique name for the schedule. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata tags to apply to this schedule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        cronExpression: Swift.String? = nil,
        jobNames: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.name = name
        self.tags = tags
    }
}

struct CreateScheduleInputBody: Swift.Equatable {
    let jobNames: [Swift.String]?
    let cronExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let name: Swift.String?
}

extension CreateScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[Swift.String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [Swift.String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateScheduleOutput: Swift.Equatable {
    /// The name of the schedule that was created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateScheduleOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.CsvOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
        case headerRow = "HeaderRow"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let headerRow = self.headerRow {
            try encodeContainer.encode(headerRow, forKey: .headerRow)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerRowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .headerRow)
        headerRow = headerRowDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define how DataBrew will read a comma-separated value (CSV) file when creating a dataset from that file.
    public struct CsvOptions: Swift.Equatable {
        /// A single character that specifies the delimiter being used in the CSV file.
        public var delimiter: Swift.String?
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public var headerRow: Swift.Bool?

        public init(
            delimiter: Swift.String? = nil,
            headerRow: Swift.Bool? = nil
        )
        {
            self.delimiter = delimiter
            self.headerRow = headerRow
        }
    }

}

extension DataBrewClientTypes.CsvOutputOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define how DataBrew will write a comma-separated value (CSV) file.
    public struct CsvOutputOptions: Swift.Equatable {
        /// A single character that specifies the delimiter used to create CSV job output.
        public var delimiter: Swift.String?

        public init(
            delimiter: Swift.String? = nil
        )
        {
            self.delimiter = delimiter
        }
    }

}

extension DataBrewClientTypes.DataCatalogInputDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case tempDirectory = "TempDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tempDirectory = self.tempDirectory {
            try encodeContainer.encode(tempDirectory, forKey: .tempDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tempDirectoryDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .tempDirectory)
        tempDirectory = tempDirectoryDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents how metadata stored in the Glue Data Catalog is defined in a DataBrew dataset.
    public struct DataCatalogInputDefinition: Swift.Equatable {
        /// The unique identifier of the Amazon Web Services account that holds the Data Catalog that stores the data.
        public var catalogId: Swift.String?
        /// The name of a database in the Data Catalog.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of a database table in the Data Catalog. This table corresponds to a DataBrew dataset.
        /// This member is required.
        public var tableName: Swift.String?
        /// Represents an Amazon location where DataBrew can store intermediate results.
        public var tempDirectory: DataBrewClientTypes.S3Location?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tempDirectory: DataBrewClientTypes.S3Location? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }
    }

}

extension DataBrewClientTypes.DataCatalogOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case databaseOptions = "DatabaseOptions"
        case overwrite = "Overwrite"
        case s3Options = "S3Options"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databaseOptions = self.databaseOptions {
            try encodeContainer.encode(databaseOptions, forKey: .databaseOptions)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let s3Options = self.s3Options {
            try encodeContainer.encode(s3Options, forKey: .s3Options)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3OptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3TableOutputOptions.self, forKey: .s3Options)
        s3Options = s3OptionsDecoded
        let databaseOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DatabaseTableOutputOptions.self, forKey: .databaseOptions)
        databaseOptions = databaseOptionsDecoded
        let overwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overwrite) ?? false
        overwrite = overwriteDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents options that specify how and where in the Glue Data Catalog DataBrew writes the output generated by recipe jobs.
    public struct DataCatalogOutput: Swift.Equatable {
        /// The unique identifier of the Amazon Web Services account that holds the Data Catalog that stores the data.
        public var catalogId: Swift.String?
        /// The name of a database in the Data Catalog.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        public var databaseOptions: DataBrewClientTypes.DatabaseTableOutputOptions?
        /// A value that, if true, means that any data in the location specified for output is overwritten with new output. Not supported with DatabaseOptions.
        public var overwrite: Swift.Bool
        /// Represents options that specify how and where DataBrew writes the Amazon S3 output generated by recipe jobs.
        public var s3Options: DataBrewClientTypes.S3TableOutputOptions?
        /// The name of a table in the Data Catalog.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseOptions: DataBrewClientTypes.DatabaseTableOutputOptions? = nil,
            overwrite: Swift.Bool = false,
            s3Options: DataBrewClientTypes.S3TableOutputOptions? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.databaseOptions = databaseOptions
            self.overwrite = overwrite
            self.s3Options = s3Options
            self.tableName = tableName
        }
    }

}

extension DataBrewClientTypes.DatabaseInputDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseTableName = "DatabaseTableName"
        case glueConnectionName = "GlueConnectionName"
        case queryString = "QueryString"
        case tempDirectory = "TempDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseTableName = self.databaseTableName {
            try encodeContainer.encode(databaseTableName, forKey: .databaseTableName)
        }
        if let glueConnectionName = self.glueConnectionName {
            try encodeContainer.encode(glueConnectionName, forKey: .glueConnectionName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let tempDirectory = self.tempDirectory {
            try encodeContainer.encode(tempDirectory, forKey: .tempDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueConnectionName)
        glueConnectionName = glueConnectionNameDecoded
        let databaseTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseTableName)
        databaseTableName = databaseTableNameDecoded
        let tempDirectoryDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .tempDirectory)
        tempDirectory = tempDirectoryDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension DataBrewClientTypes {
    /// Connection information for dataset input files stored in a database.
    public struct DatabaseInputDefinition: Swift.Equatable {
        /// The table within the target database.
        public var databaseTableName: Swift.String?
        /// The Glue Connection that stores the connection information for the target database.
        /// This member is required.
        public var glueConnectionName: Swift.String?
        /// Custom SQL to run against the provided Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
        public var queryString: Swift.String?
        /// Represents an Amazon S3 location (bucket name, bucket owner, and object key) where DataBrew can read input data, or write output from a job.
        public var tempDirectory: DataBrewClientTypes.S3Location?

        public init(
            databaseTableName: Swift.String? = nil,
            glueConnectionName: Swift.String? = nil,
            queryString: Swift.String? = nil,
            tempDirectory: DataBrewClientTypes.S3Location? = nil
        )
        {
            self.databaseTableName = databaseTableName
            self.glueConnectionName = glueConnectionName
            self.queryString = queryString
            self.tempDirectory = tempDirectory
        }
    }

}

extension DataBrewClientTypes.DatabaseOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseOptions = "DatabaseOptions"
        case databaseOutputMode = "DatabaseOutputMode"
        case glueConnectionName = "GlueConnectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseOptions = self.databaseOptions {
            try encodeContainer.encode(databaseOptions, forKey: .databaseOptions)
        }
        if let databaseOutputMode = self.databaseOutputMode {
            try encodeContainer.encode(databaseOutputMode.rawValue, forKey: .databaseOutputMode)
        }
        if let glueConnectionName = self.glueConnectionName {
            try encodeContainer.encode(glueConnectionName, forKey: .glueConnectionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueConnectionName)
        glueConnectionName = glueConnectionNameDecoded
        let databaseOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DatabaseTableOutputOptions.self, forKey: .databaseOptions)
        databaseOptions = databaseOptionsDecoded
        let databaseOutputModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DatabaseOutputMode.self, forKey: .databaseOutputMode)
        databaseOutputMode = databaseOutputModeDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a JDBC database output object which defines the output destination for a DataBrew recipe job to write into.
    public struct DatabaseOutput: Swift.Equatable {
        /// Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
        /// This member is required.
        public var databaseOptions: DataBrewClientTypes.DatabaseTableOutputOptions?
        /// The output mode to write into the database. Currently supported option: NEW_TABLE.
        public var databaseOutputMode: DataBrewClientTypes.DatabaseOutputMode?
        /// The Glue connection that stores the connection information for the target database.
        /// This member is required.
        public var glueConnectionName: Swift.String?

        public init(
            databaseOptions: DataBrewClientTypes.DatabaseTableOutputOptions? = nil,
            databaseOutputMode: DataBrewClientTypes.DatabaseOutputMode? = nil,
            glueConnectionName: Swift.String? = nil
        )
        {
            self.databaseOptions = databaseOptions
            self.databaseOutputMode = databaseOutputMode
            self.glueConnectionName = glueConnectionName
        }
    }

}

extension DataBrewClientTypes {
    public enum DatabaseOutputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case newTable
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseOutputMode] {
            return [
                .newTable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .newTable: return "NEW_TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseOutputMode(rawValue: rawValue) ?? DatabaseOutputMode.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.DatabaseTableOutputOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableName = "TableName"
        case tempDirectory = "TempDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tempDirectory = self.tempDirectory {
            try encodeContainer.encode(tempDirectory, forKey: .tempDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tempDirectoryDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .tempDirectory)
        tempDirectory = tempDirectoryDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents options that specify how and where DataBrew writes the database output generated by recipe jobs.
    public struct DatabaseTableOutputOptions: Swift.Equatable {
        /// A prefix for the name of a table DataBrew will create in the database.
        /// This member is required.
        public var tableName: Swift.String?
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can store intermediate results.
        public var tempDirectory: DataBrewClientTypes.S3Location?

        public init(
            tableName: Swift.String? = nil,
            tempDirectory: DataBrewClientTypes.S3Location? = nil
        )
        {
            self.tableName = tableName
            self.tempDirectory = tempDirectory
        }
    }

}

extension DataBrewClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case pathOptions = "PathOptions"
        case resourceArn = "ResourceArn"
        case source = "Source"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pathOptions = self.pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Input.self, forKey: .input)
        input = inputDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a dataset that can be processed by DataBrew.
    public struct Dataset: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the dataset.
        public var accountId: Swift.String?
        /// The date and time that the dataset was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who created the dataset.
        public var createdBy: Swift.String?
        /// The file format of a dataset that is created from an Amazon S3 file or folder.
        public var format: DataBrewClientTypes.InputFormat?
        /// A set of options that define how DataBrew interprets the data in the dataset.
        public var formatOptions: DataBrewClientTypes.FormatOptions?
        /// Information on how DataBrew can find the dataset, in either the Glue Data Catalog or Amazon S3.
        /// This member is required.
        public var input: DataBrewClientTypes.Input?
        /// The Amazon Resource Name (ARN) of the user who last modified the dataset.
        public var lastModifiedBy: Swift.String?
        /// The last modification date and time of the dataset.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The unique name of the dataset.
        /// This member is required.
        public var name: Swift.String?
        /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
        public var pathOptions: DataBrewClientTypes.PathOptions?
        /// The unique Amazon Resource Name (ARN) for the dataset.
        public var resourceArn: Swift.String?
        /// The location of the data for the dataset, either Amazon S3 or the Glue Data Catalog.
        public var source: DataBrewClientTypes.Source?
        /// Metadata tags that have been applied to the dataset.
        public var tags: [Swift.String:Swift.String]?

        public init(
            accountId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            format: DataBrewClientTypes.InputFormat? = nil,
            formatOptions: DataBrewClientTypes.FormatOptions? = nil,
            input: DataBrewClientTypes.Input? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            pathOptions: DataBrewClientTypes.PathOptions? = nil,
            resourceArn: Swift.String? = nil,
            source: DataBrewClientTypes.Source? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.format = format
            self.formatOptions = formatOptions
            self.input = input
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.pathOptions = pathOptions
            self.resourceArn = resourceArn
            self.source = source
            self.tags = tags
        }
    }

}

extension DataBrewClientTypes.DatasetParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createColumn = "CreateColumn"
        case datetimeOptions = "DatetimeOptions"
        case filter = "Filter"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createColumn != false {
            try encodeContainer.encode(createColumn, forKey: .createColumn)
        }
        if let datetimeOptions = self.datetimeOptions {
            try encodeContainer.encode(datetimeOptions, forKey: .datetimeOptions)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let datetimeOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DatetimeOptions.self, forKey: .datetimeOptions)
        datetimeOptions = datetimeOptionsDecoded
        let createColumnDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createColumn) ?? false
        createColumn = createColumnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FilterExpression.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a dataset parameter that defines type and conditions for a parameter in the Amazon S3 path of the dataset.
    public struct DatasetParameter: Swift.Equatable {
        /// Optional boolean value that defines whether the captured value of this parameter should be used to create a new column in a dataset.
        public var createColumn: Swift.Bool
        /// Additional parameter options such as a format and a timezone. Required for datetime parameters.
        public var datetimeOptions: DataBrewClientTypes.DatetimeOptions?
        /// The optional filter expression structure to apply additional matching criteria to the parameter.
        public var filter: DataBrewClientTypes.FilterExpression?
        /// The name of the parameter that is used in the dataset's Amazon S3 path.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the dataset parameter, can be one of a 'String', 'Number' or 'Datetime'.
        /// This member is required.
        public var type: DataBrewClientTypes.ParameterType?

        public init(
            createColumn: Swift.Bool = false,
            datetimeOptions: DataBrewClientTypes.DatetimeOptions? = nil,
            filter: DataBrewClientTypes.FilterExpression? = nil,
            name: Swift.String? = nil,
            type: DataBrewClientTypes.ParameterType? = nil
        )
        {
            self.createColumn = createColumn
            self.datetimeOptions = datetimeOptions
            self.filter = filter
            self.name = name
            self.type = type
        }
    }

}

extension DataBrewClientTypes.DatetimeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case localeCode = "LocaleCode"
        case timezoneOffset = "TimezoneOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let localeCode = self.localeCode {
            try encodeContainer.encode(localeCode, forKey: .localeCode)
        }
        if let timezoneOffset = self.timezoneOffset {
            try encodeContainer.encode(timezoneOffset, forKey: .timezoneOffset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let timezoneOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezoneOffset)
        timezoneOffset = timezoneOffsetDecoded
        let localeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeCode)
        localeCode = localeCodeDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents additional options for correct interpretation of datetime parameters used in the Amazon S3 path of a dataset.
    public struct DatetimeOptions: Swift.Equatable {
        /// Required option, that defines the datetime format used for a date parameter in the Amazon S3 path. Should use only supported datetime specifiers and separation characters, all literal a-z or A-Z characters should be escaped with single quotes. E.g. "MM.dd.yyyy-'at'-HH:mm".
        /// This member is required.
        public var format: Swift.String?
        /// Optional value for a non-US locale code, needed for correct interpretation of some date formats.
        public var localeCode: Swift.String?
        /// Optional value for a timezone offset of the datetime parameter value in the Amazon S3 path. Shouldn't be used if Format for this parameter includes timezone fields. If no offset specified, UTC is assumed.
        public var timezoneOffset: Swift.String?

        public init(
            format: Swift.String? = nil,
            localeCode: Swift.String? = nil,
            timezoneOffset: Swift.String? = nil
        )
        {
            self.format = format
            self.localeCode = localeCode
            self.timezoneOffset = timezoneOffset
        }
    }

}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/datasets/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The name of the dataset to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteDatasetOutput: Swift.Equatable {
    /// The name of the dataset that you deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDatasetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// The name of the job to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteJobInputBody: Swift.Equatable {
}

extension DeleteJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteJobOutput: Swift.Equatable {
    /// The name of the job that you deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteJobOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/projects/\(name.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name of the project to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteProjectOutput: Swift.Equatable {
    /// The name of the project that you deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecipeVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let recipeVersion = recipeVersion else {
            return nil
        }
        return "/recipes/\(name.urlPercentEncoding())/recipeVersion/\(recipeVersion.urlPercentEncoding())"
    }
}

public struct DeleteRecipeVersionInput: Swift.Equatable {
    /// The name of the recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The version of the recipe to be deleted. You can specify a numeric versions (X.Y) or LATEST_WORKING. LATEST_PUBLISHED is not supported.
    /// This member is required.
    public var recipeVersion: Swift.String?

    public init(
        name: Swift.String? = nil,
        recipeVersion: Swift.String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DeleteRecipeVersionInputBody: Swift.Equatable {
}

extension DeleteRecipeVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecipeVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRecipeVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.recipeVersion = output.recipeVersion
        } else {
            self.name = nil
            self.recipeVersion = nil
        }
    }
}

public struct DeleteRecipeVersionOutput: Swift.Equatable {
    /// The name of the recipe that was deleted.
    /// This member is required.
    public var name: Swift.String?
    /// The version of the recipe that was deleted.
    /// This member is required.
    public var recipeVersion: Swift.String?

    public init(
        name: Swift.String? = nil,
        recipeVersion: Swift.String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DeleteRecipeVersionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let recipeVersion: Swift.String?
}

extension DeleteRecipeVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case recipeVersion = "RecipeVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

enum DeleteRecipeVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRulesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/rulesets/\(name.urlPercentEncoding())"
    }
}

public struct DeleteRulesetInput: Swift.Equatable {
    /// The name of the ruleset to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteRulesetInputBody: Swift.Equatable {
}

extension DeleteRulesetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRulesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRulesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteRulesetOutput: Swift.Equatable {
    /// The name of the deleted ruleset.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteRulesetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteRulesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteRulesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct DeleteScheduleInput: Swift.Equatable {
    /// The name of the schedule to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteScheduleInputBody: Swift.Equatable {
}

extension DeleteScheduleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteScheduleOutput: Swift.Equatable {
    /// The name of the schedule that was deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteScheduleOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/datasets/\(name.urlPercentEncoding())"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The name of the dataset to be described.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.format = output.format
            self.formatOptions = output.formatOptions
            self.input = output.input
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.pathOptions = output.pathOptions
            self.resourceArn = output.resourceArn
            self.source = output.source
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.format = nil
            self.formatOptions = nil
            self.input = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.pathOptions = nil
            self.resourceArn = nil
            self.source = nil
            self.tags = nil
        }
    }
}

public struct DescribeDatasetOutput: Swift.Equatable {
    /// The date and time that the dataset was created.
    public var createDate: ClientRuntime.Date?
    /// The identifier (user name) of the user who created the dataset.
    public var createdBy: Swift.String?
    /// The file format of a dataset that is created from an Amazon S3 file or folder.
    public var format: DataBrewClientTypes.InputFormat?
    /// Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.
    public var formatOptions: DataBrewClientTypes.FormatOptions?
    /// Represents information on how DataBrew can find data, in either the Glue Data Catalog or Amazon S3.
    /// This member is required.
    public var input: DataBrewClientTypes.Input?
    /// The identifier (user name) of the user who last modified the dataset.
    public var lastModifiedBy: Swift.String?
    /// The date and time that the dataset was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
    public var pathOptions: DataBrewClientTypes.PathOptions?
    /// The Amazon Resource Name (ARN) of the dataset.
    public var resourceArn: Swift.String?
    /// The location of the data for this dataset, Amazon S3 or the Glue Data Catalog.
    public var source: DataBrewClientTypes.Source?
    /// Metadata tags associated with this dataset.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        format: DataBrewClientTypes.InputFormat? = nil,
        formatOptions: DataBrewClientTypes.FormatOptions? = nil,
        input: DataBrewClientTypes.Input? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        pathOptions: DataBrewClientTypes.PathOptions? = nil,
        resourceArn: Swift.String? = nil,
        source: DataBrewClientTypes.Source? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.pathOptions = pathOptions
        self.resourceArn = resourceArn
        self.source = source
        self.tags = tags
    }
}

struct DescribeDatasetOutputBody: Swift.Equatable {
    let createdBy: Swift.String?
    let createDate: ClientRuntime.Date?
    let name: Swift.String?
    let format: DataBrewClientTypes.InputFormat?
    let formatOptions: DataBrewClientTypes.FormatOptions?
    let input: DataBrewClientTypes.Input?
    let lastModifiedDate: ClientRuntime.Date?
    let lastModifiedBy: Swift.String?
    let source: DataBrewClientTypes.Source?
    let pathOptions: DataBrewClientTypes.PathOptions?
    let tags: [Swift.String:Swift.String]?
    let resourceArn: Swift.String?
}

extension DescribeDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case pathOptions = "PathOptions"
        case resourceArn = "ResourceArn"
        case source = "Source"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Input.self, forKey: .input)
        input = inputDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum DescribeDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The name of the job to be described.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeJobInputBody: Swift.Equatable {
}

extension DescribeJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.dataCatalogOutputs = output.dataCatalogOutputs
            self.databaseOutputs = output.databaseOutputs
            self.datasetName = output.datasetName
            self.encryptionKeyArn = output.encryptionKeyArn
            self.encryptionMode = output.encryptionMode
            self.jobSample = output.jobSample
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.logSubscription = output.logSubscription
            self.maxCapacity = output.maxCapacity
            self.maxRetries = output.maxRetries
            self.name = output.name
            self.outputs = output.outputs
            self.profileConfiguration = output.profileConfiguration
            self.projectName = output.projectName
            self.recipeReference = output.recipeReference
            self.resourceArn = output.resourceArn
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.timeout = output.timeout
            self.type = output.type
            self.validationConfigurations = output.validationConfigurations
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.dataCatalogOutputs = nil
            self.databaseOutputs = nil
            self.datasetName = nil
            self.encryptionKeyArn = nil
            self.encryptionMode = nil
            self.jobSample = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.logSubscription = nil
            self.maxCapacity = 0
            self.maxRetries = 0
            self.name = nil
            self.outputs = nil
            self.profileConfiguration = nil
            self.projectName = nil
            self.recipeReference = nil
            self.resourceArn = nil
            self.roleArn = nil
            self.tags = nil
            self.timeout = 0
            self.type = nil
            self.validationConfigurations = nil
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// The date and time that the job was created.
    public var createDate: ClientRuntime.Date?
    /// The identifier (user name) of the user associated with the creation of the job.
    public var createdBy: Swift.String?
    /// One or more artifacts that represent the Glue Data Catalog output from running the job.
    public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write into.
    public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    /// The dataset that the job acts upon.
    public var datasetName: Swift.String?
    /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    public var encryptionKeyArn: Swift.String?
    /// The encryption mode for the job, which can be one of the following:
    ///
    /// * SSE-KMS - Server-side encryption with keys managed by KMS.
    ///
    /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    public var encryptionMode: DataBrewClientTypes.EncryptionMode?
    /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed.
    public var jobSample: DataBrewClientTypes.JobSample?
    /// The identifier (user name) of the user who last modified the job.
    public var lastModifiedBy: Swift.String?
    /// The date and time that the job was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// Indicates whether Amazon CloudWatch logging is enabled for this job.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// The maximum number of compute nodes that DataBrew can consume when the job processes data.
    public var maxCapacity: Swift.Int
    /// The maximum number of times to retry the job after a job run fails.
    public var maxRetries: Swift.Int
    /// The name of the job.
    /// This member is required.
    public var name: Swift.String?
    /// One or more artifacts that represent the output from running the job.
    public var outputs: [DataBrewClientTypes.Output]?
    /// Configuration for profile jobs. Used to select columns, do evaluations, and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    public var profileConfiguration: DataBrewClientTypes.ProfileConfiguration?
    /// The DataBrew project associated with this job.
    public var projectName: Swift.String?
    /// Represents the name and version of a DataBrew recipe.
    public var recipeReference: DataBrewClientTypes.RecipeReference?
    /// The Amazon Resource Name (ARN) of the job.
    public var resourceArn: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    public var roleArn: Swift.String?
    /// Metadata tags associated with this job.
    public var tags: [Swift.String:Swift.String]?
    /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    public var timeout: Swift.Int
    /// The job type, which must be one of the following:
    ///
    /// * PROFILE - The job analyzes the dataset to determine its size, data types, data distribution, and more.
    ///
    /// * RECIPE - The job applies one or more transformations to a dataset.
    public var type: DataBrewClientTypes.JobType?
    /// List of validation configurations that are applied to the profile job.
    public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
        databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
        datasetName: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
        jobSample: DataBrewClientTypes.JobSample? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        maxCapacity: Swift.Int = 0,
        maxRetries: Swift.Int = 0,
        name: Swift.String? = nil,
        outputs: [DataBrewClientTypes.Output]? = nil,
        profileConfiguration: DataBrewClientTypes.ProfileConfiguration? = nil,
        projectName: Swift.String? = nil,
        recipeReference: DataBrewClientTypes.RecipeReference? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeout: Swift.Int = 0,
        type: DataBrewClientTypes.JobType? = nil,
        validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.dataCatalogOutputs = dataCatalogOutputs
        self.databaseOutputs = databaseOutputs
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.profileConfiguration = profileConfiguration
        self.projectName = projectName
        self.recipeReference = recipeReference
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
        self.type = type
        self.validationConfigurations = validationConfigurations
    }
}

struct DescribeJobOutputBody: Swift.Equatable {
    let createDate: ClientRuntime.Date?
    let createdBy: Swift.String?
    let datasetName: Swift.String?
    let encryptionKeyArn: Swift.String?
    let encryptionMode: DataBrewClientTypes.EncryptionMode?
    let name: Swift.String?
    let type: DataBrewClientTypes.JobType?
    let lastModifiedBy: Swift.String?
    let lastModifiedDate: ClientRuntime.Date?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let maxCapacity: Swift.Int
    let maxRetries: Swift.Int
    let outputs: [DataBrewClientTypes.Output]?
    let dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    let databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    let projectName: Swift.String?
    let profileConfiguration: DataBrewClientTypes.ProfileConfiguration?
    let validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?
    let recipeReference: DataBrewClientTypes.RecipeReference?
    let resourceArn: Swift.String?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let timeout: Swift.Int
    let jobSample: DataBrewClientTypes.JobSample?
}

extension DescribeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case profileConfiguration = "ProfileConfiguration"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case type = "Type"
        case validationConfigurations = "ValidationConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity) ?? 0
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries) ?? 0
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let profileConfigurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ProfileConfiguration.self, forKey: .profileConfiguration)
        profileConfiguration = profileConfigurationDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

enum DescribeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let runId = runId else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())/jobRun/\(runId.urlPercentEncoding())"
    }
}

public struct DescribeJobRunInput: Swift.Equatable {
    /// The name of the job being processed during this run.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the job run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        name: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct DescribeJobRunInputBody: Swift.Equatable {
}

extension DescribeJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.attempt = output.attempt
            self.completedOn = output.completedOn
            self.dataCatalogOutputs = output.dataCatalogOutputs
            self.databaseOutputs = output.databaseOutputs
            self.datasetName = output.datasetName
            self.errorMessage = output.errorMessage
            self.executionTime = output.executionTime
            self.jobName = output.jobName
            self.jobSample = output.jobSample
            self.logGroupName = output.logGroupName
            self.logSubscription = output.logSubscription
            self.outputs = output.outputs
            self.profileConfiguration = output.profileConfiguration
            self.recipeReference = output.recipeReference
            self.runId = output.runId
            self.startedBy = output.startedBy
            self.startedOn = output.startedOn
            self.state = output.state
            self.validationConfigurations = output.validationConfigurations
        } else {
            self.attempt = 0
            self.completedOn = nil
            self.dataCatalogOutputs = nil
            self.databaseOutputs = nil
            self.datasetName = nil
            self.errorMessage = nil
            self.executionTime = 0
            self.jobName = nil
            self.jobSample = nil
            self.logGroupName = nil
            self.logSubscription = nil
            self.outputs = nil
            self.profileConfiguration = nil
            self.recipeReference = nil
            self.runId = nil
            self.startedBy = nil
            self.startedOn = nil
            self.state = nil
            self.validationConfigurations = nil
        }
    }
}

public struct DescribeJobRunOutput: Swift.Equatable {
    /// The number of times that DataBrew has attempted to run the job.
    public var attempt: Swift.Int
    /// The date and time when the job completed processing.
    public var completedOn: ClientRuntime.Date?
    /// One or more artifacts that represent the Glue Data Catalog output from running the job.
    public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write into.
    public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    /// The name of the dataset for the job to process.
    public var datasetName: Swift.String?
    /// A message indicating an error (if any) that was encountered when the job ran.
    public var errorMessage: Swift.String?
    /// The amount of time, in seconds, during which the job run consumed resources.
    public var executionTime: Swift.Int
    /// The name of the job being processed during this run.
    /// This member is required.
    public var jobName: Swift.String?
    /// Sample configuration for profile jobs only. Determines the number of rows on which the profile job will be executed. If a JobSample value is not provided, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
    public var jobSample: DataBrewClientTypes.JobSample?
    /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
    public var logGroupName: Swift.String?
    /// The current status of Amazon CloudWatch logging for the job run.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// One or more output artifacts from a job run.
    public var outputs: [DataBrewClientTypes.Output]?
    /// Configuration for profile jobs. Used to select columns, do evaluations, and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    public var profileConfiguration: DataBrewClientTypes.ProfileConfiguration?
    /// Represents the name and version of a DataBrew recipe.
    public var recipeReference: DataBrewClientTypes.RecipeReference?
    /// The unique identifier of the job run.
    public var runId: Swift.String?
    /// The Amazon Resource Name (ARN) of the user who started the job run.
    public var startedBy: Swift.String?
    /// The date and time when the job run began.
    public var startedOn: ClientRuntime.Date?
    /// The current state of the job run entity itself.
    public var state: DataBrewClientTypes.JobRunState?
    /// List of validation configurations that are applied to the profile job.
    public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

    public init(
        attempt: Swift.Int = 0,
        completedOn: ClientRuntime.Date? = nil,
        dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
        databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
        datasetName: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        executionTime: Swift.Int = 0,
        jobName: Swift.String? = nil,
        jobSample: DataBrewClientTypes.JobSample? = nil,
        logGroupName: Swift.String? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        outputs: [DataBrewClientTypes.Output]? = nil,
        profileConfiguration: DataBrewClientTypes.ProfileConfiguration? = nil,
        recipeReference: DataBrewClientTypes.RecipeReference? = nil,
        runId: Swift.String? = nil,
        startedBy: Swift.String? = nil,
        startedOn: ClientRuntime.Date? = nil,
        state: DataBrewClientTypes.JobRunState? = nil,
        validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
    )
    {
        self.attempt = attempt
        self.completedOn = completedOn
        self.dataCatalogOutputs = dataCatalogOutputs
        self.databaseOutputs = databaseOutputs
        self.datasetName = datasetName
        self.errorMessage = errorMessage
        self.executionTime = executionTime
        self.jobName = jobName
        self.jobSample = jobSample
        self.logGroupName = logGroupName
        self.logSubscription = logSubscription
        self.outputs = outputs
        self.profileConfiguration = profileConfiguration
        self.recipeReference = recipeReference
        self.runId = runId
        self.startedBy = startedBy
        self.startedOn = startedOn
        self.state = state
        self.validationConfigurations = validationConfigurations
    }
}

struct DescribeJobRunOutputBody: Swift.Equatable {
    let attempt: Swift.Int
    let completedOn: ClientRuntime.Date?
    let datasetName: Swift.String?
    let errorMessage: Swift.String?
    let executionTime: Swift.Int
    let jobName: Swift.String?
    let profileConfiguration: DataBrewClientTypes.ProfileConfiguration?
    let validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?
    let runId: Swift.String?
    let state: DataBrewClientTypes.JobRunState?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let logGroupName: Swift.String?
    let outputs: [DataBrewClientTypes.Output]?
    let dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    let databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    let recipeReference: DataBrewClientTypes.RecipeReference?
    let startedBy: Swift.String?
    let startedOn: ClientRuntime.Date?
    let jobSample: DataBrewClientTypes.JobSample?
}

extension DescribeJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attempt = "Attempt"
        case completedOn = "CompletedOn"
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case errorMessage = "ErrorMessage"
        case executionTime = "ExecutionTime"
        case jobName = "JobName"
        case jobSample = "JobSample"
        case logGroupName = "LogGroupName"
        case logSubscription = "LogSubscription"
        case outputs = "Outputs"
        case profileConfiguration = "ProfileConfiguration"
        case recipeReference = "RecipeReference"
        case runId = "RunId"
        case startedBy = "StartedBy"
        case startedOn = "StartedOn"
        case state = "State"
        case validationConfigurations = "ValidationConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attempt) ?? 0
        attempt = attemptDecoded
        let completedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedOn)
        completedOn = completedOnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTime) ?? 0
        executionTime = executionTimeDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let profileConfigurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ProfileConfiguration.self, forKey: .profileConfiguration)
        profileConfiguration = profileConfigurationDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let startedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedOn)
        startedOn = startedOnDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

enum DescribeJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/projects/\(name.urlPercentEncoding())"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The name of the project to be described.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.datasetName = output.datasetName
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.openDate = output.openDate
            self.openedBy = output.openedBy
            self.recipeName = output.recipeName
            self.resourceArn = output.resourceArn
            self.roleArn = output.roleArn
            self.sample = output.sample
            self.sessionStatus = output.sessionStatus
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.datasetName = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.openDate = nil
            self.openedBy = nil
            self.recipeName = nil
            self.resourceArn = nil
            self.roleArn = nil
            self.sample = nil
            self.sessionStatus = nil
            self.tags = nil
        }
    }
}

public struct DescribeProjectOutput: Swift.Equatable {
    /// The date and time that the project was created.
    public var createDate: ClientRuntime.Date?
    /// The identifier (user name) of the user who created the project.
    public var createdBy: Swift.String?
    /// The dataset associated with the project.
    public var datasetName: Swift.String?
    /// The identifier (user name) of the user who last modified the project.
    public var lastModifiedBy: Swift.String?
    /// The date and time that the project was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The date and time when the project was opened.
    public var openDate: ClientRuntime.Date?
    /// The identifier (user name) of the user that opened the project for use.
    public var openedBy: Swift.String?
    /// The recipe associated with this job.
    public var recipeName: Swift.String?
    /// The Amazon Resource Name (ARN) of the project.
    public var resourceArn: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    public var roleArn: Swift.String?
    /// Represents the sample size and sampling type for DataBrew to use for interactive data analysis.
    public var sample: DataBrewClientTypes.Sample?
    /// Describes the current state of the session:
    ///
    /// * PROVISIONING - allocating resources for the session.
    ///
    /// * INITIALIZING - getting the session ready for first use.
    ///
    /// * ASSIGNED - the session is ready for use.
    public var sessionStatus: DataBrewClientTypes.SessionStatus?
    /// Metadata tags associated with this project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        openDate: ClientRuntime.Date? = nil,
        openedBy: Swift.String? = nil,
        recipeName: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sample: DataBrewClientTypes.Sample? = nil,
        sessionStatus: DataBrewClientTypes.SessionStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.datasetName = datasetName
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.openDate = openDate
        self.openedBy = openedBy
        self.recipeName = recipeName
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.sample = sample
        self.sessionStatus = sessionStatus
        self.tags = tags
    }
}

struct DescribeProjectOutputBody: Swift.Equatable {
    let createDate: ClientRuntime.Date?
    let createdBy: Swift.String?
    let datasetName: Swift.String?
    let lastModifiedDate: ClientRuntime.Date?
    let lastModifiedBy: Swift.String?
    let name: Swift.String?
    let recipeName: Swift.String?
    let resourceArn: Swift.String?
    let sample: DataBrewClientTypes.Sample?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let sessionStatus: DataBrewClientTypes.SessionStatus?
    let openedBy: Swift.String?
    let openDate: ClientRuntime.Date?
}

extension DescribeProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case openDate = "OpenDate"
        case openedBy = "OpenedBy"
        case recipeName = "RecipeName"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case sessionStatus = "SessionStatus"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sessionStatusDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.SessionStatus.self, forKey: .sessionStatus)
        sessionStatus = sessionStatusDecoded
        let openedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openedBy)
        openedBy = openedByDecoded
        let openDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .openDate)
        openDate = openDateDecoded
    }
}

enum DescribeProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let recipeVersion = recipeVersion {
                let recipeVersionQueryItem = ClientRuntime.URLQueryItem(name: "recipeVersion".urlPercentEncoding(), value: Swift.String(recipeVersion).urlPercentEncoding())
                items.append(recipeVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/recipes/\(name.urlPercentEncoding())"
    }
}

public struct DescribeRecipeInput: Swift.Equatable {
    /// The name of the recipe to be described.
    /// This member is required.
    public var name: Swift.String?
    /// The recipe version identifier. If this parameter isn't specified, then the latest published version is returned.
    public var recipeVersion: Swift.String?

    public init(
        name: Swift.String? = nil,
        recipeVersion: Swift.String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DescribeRecipeInputBody: Swift.Equatable {
}

extension DescribeRecipeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.description = output.description
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.projectName = output.projectName
            self.publishedBy = output.publishedBy
            self.publishedDate = output.publishedDate
            self.recipeVersion = output.recipeVersion
            self.resourceArn = output.resourceArn
            self.steps = output.steps
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.description = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.projectName = nil
            self.publishedBy = nil
            self.publishedDate = nil
            self.recipeVersion = nil
            self.resourceArn = nil
            self.steps = nil
            self.tags = nil
        }
    }
}

public struct DescribeRecipeOutput: Swift.Equatable {
    /// The date and time that the recipe was created.
    public var createDate: ClientRuntime.Date?
    /// The identifier (user name) of the user who created the recipe.
    public var createdBy: Swift.String?
    /// The description of the recipe.
    public var description: Swift.String?
    /// The identifier (user name) of the user who last modified the recipe.
    public var lastModifiedBy: Swift.String?
    /// The date and time that the recipe was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project associated with this recipe.
    public var projectName: Swift.String?
    /// The identifier (user name) of the user who last published the recipe.
    public var publishedBy: Swift.String?
    /// The date and time when the recipe was last published.
    public var publishedDate: ClientRuntime.Date?
    /// The recipe version identifier.
    public var recipeVersion: Swift.String?
    /// The ARN of the recipe.
    public var resourceArn: Swift.String?
    /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
    public var steps: [DataBrewClientTypes.RecipeStep]?
    /// Metadata tags associated with this project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        publishedBy: Swift.String? = nil,
        publishedDate: ClientRuntime.Date? = nil,
        recipeVersion: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        steps: [DataBrewClientTypes.RecipeStep]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.description = description
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.projectName = projectName
        self.publishedBy = publishedBy
        self.publishedDate = publishedDate
        self.recipeVersion = recipeVersion
        self.resourceArn = resourceArn
        self.steps = steps
        self.tags = tags
    }
}

struct DescribeRecipeOutputBody: Swift.Equatable {
    let createdBy: Swift.String?
    let createDate: ClientRuntime.Date?
    let lastModifiedBy: Swift.String?
    let lastModifiedDate: ClientRuntime.Date?
    let projectName: Swift.String?
    let publishedBy: Swift.String?
    let publishedDate: ClientRuntime.Date?
    let description: Swift.String?
    let name: Swift.String?
    let steps: [DataBrewClientTypes.RecipeStep]?
    let tags: [Swift.String:Swift.String]?
    let resourceArn: Swift.String?
    let recipeVersion: Swift.String?
}

extension DescribeRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case projectName = "ProjectName"
        case publishedBy = "PublishedBy"
        case publishedDate = "PublishedDate"
        case recipeVersion = "RecipeVersion"
        case resourceArn = "ResourceArn"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let publishedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedBy)
        publishedBy = publishedByDecoded
        let publishedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publishedDate)
        publishedDate = publishedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[DataBrewClientTypes.RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DataBrewClientTypes.RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

enum DescribeRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRulesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/rulesets/\(name.urlPercentEncoding())"
    }
}

public struct DescribeRulesetInput: Swift.Equatable {
    /// The name of the ruleset to be described.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeRulesetInputBody: Swift.Equatable {
}

extension DescribeRulesetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRulesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRulesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.description = output.description
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.resourceArn = output.resourceArn
            self.rules = output.rules
            self.tags = output.tags
            self.targetArn = output.targetArn
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.description = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.resourceArn = nil
            self.rules = nil
            self.tags = nil
            self.targetArn = nil
        }
    }
}

public struct DescribeRulesetOutput: Swift.Equatable {
    /// The date and time that the ruleset was created.
    public var createDate: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the user who created the ruleset.
    public var createdBy: Swift.String?
    /// The description of the ruleset.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the user who last modified the ruleset.
    public var lastModifiedBy: Swift.String?
    /// The modification date and time of the ruleset.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the ruleset.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) for the ruleset.
    public var resourceArn: Swift.String?
    /// A list of rules that are defined with the ruleset. A rule includes one or more checks to be validated on a DataBrew dataset.
    public var rules: [DataBrewClientTypes.Rule]?
    /// Metadata tags that have been applied to the ruleset.
    public var tags: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset is associated with.
    public var targetArn: Swift.String?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        rules: [DataBrewClientTypes.Rule]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.description = description
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.resourceArn = resourceArn
        self.rules = rules
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct DescribeRulesetOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let targetArn: Swift.String?
    let rules: [DataBrewClientTypes.Rule]?
    let createDate: ClientRuntime.Date?
    let createdBy: Swift.String?
    let lastModifiedBy: Swift.String?
    let lastModifiedDate: ClientRuntime.Date?
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeRulesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case rules = "Rules"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DataBrewClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DataBrewClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeRulesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct DescribeScheduleInput: Swift.Equatable {
    /// The name of the schedule to be described.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeScheduleInputBody: Swift.Equatable {
}

extension DescribeScheduleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.cronExpression = output.cronExpression
            self.jobNames = output.jobNames
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.cronExpression = nil
            self.jobNames = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct DescribeScheduleOutput: Swift.Equatable {
    /// The date and time that the schedule was created.
    public var createDate: ClientRuntime.Date?
    /// The identifier (user name) of the user who created the schedule.
    public var createdBy: Swift.String?
    /// The date or dates and time or times when the jobs are to be run for the schedule. For more information, see [Cron expressions](https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html) in the Glue DataBrew Developer Guide.
    public var cronExpression: Swift.String?
    /// The name or names of one or more jobs to be run by using the schedule.
    public var jobNames: [Swift.String]?
    /// The identifier (user name) of the user who last modified the schedule.
    public var lastModifiedBy: Swift.String?
    /// The date and time that the schedule was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the schedule.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the schedule.
    public var resourceArn: Swift.String?
    /// Metadata tags associated with this schedule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createDate: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        cronExpression: Swift.String? = nil,
        jobNames: [Swift.String]? = nil,
        lastModifiedBy: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct DescribeScheduleOutputBody: Swift.Equatable {
    let createDate: ClientRuntime.Date?
    let createdBy: Swift.String?
    let jobNames: [Swift.String]?
    let lastModifiedBy: Swift.String?
    let lastModifiedDate: ClientRuntime.Date?
    let resourceArn: Swift.String?
    let cronExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let name: Swift.String?
}

extension DescribeScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let jobNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[Swift.String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [Swift.String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DescribeScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes {
    public enum EncryptionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssekms
        case sses3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMode] {
            return [
                .ssekms,
                .sses3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssekms: return "SSE-KMS"
            case .sses3: return "SSE-S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionMode(rawValue: rawValue) ?? EncryptionMode.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.EntityDetectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedStatistics = "AllowedStatistics"
        case entityTypes = "EntityTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedStatistics = allowedStatistics {
            var allowedStatisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedStatistics)
            for allowedstatistics0 in allowedStatistics {
                try allowedStatisticsContainer.encode(allowedstatistics0)
            }
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for entitytype0 in entityTypes {
                try entityTypesContainer.encode(entitytype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[Swift.String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [Swift.String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let allowedStatisticsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.AllowedStatistics?].self, forKey: .allowedStatistics)
        var allowedStatisticsDecoded0:[DataBrewClientTypes.AllowedStatistics]? = nil
        if let allowedStatisticsContainer = allowedStatisticsContainer {
            allowedStatisticsDecoded0 = [DataBrewClientTypes.AllowedStatistics]()
            for structure0 in allowedStatisticsContainer {
                if let structure0 = structure0 {
                    allowedStatisticsDecoded0?.append(structure0)
                }
            }
        }
        allowedStatistics = allowedStatisticsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Configuration of entity detection for a profile job. When undefined, entity detection is disabled.
    public struct EntityDetectorConfiguration: Swift.Equatable {
        /// Configuration of statistics that are allowed to be run on columns that contain detected entities. When undefined, no statistics will be computed on columns that contain detected entities.
        public var allowedStatistics: [DataBrewClientTypes.AllowedStatistics]?
        /// Entity types to detect. Can be any of the following:
        ///
        /// * USA_SSN
        ///
        /// * EMAIL
        ///
        /// * USA_ITIN
        ///
        /// * USA_PASSPORT_NUMBER
        ///
        /// * PHONE_NUMBER
        ///
        /// * USA_DRIVING_LICENSE
        ///
        /// * BANK_ACCOUNT
        ///
        /// * CREDIT_CARD
        ///
        /// * IP_ADDRESS
        ///
        /// * MAC_ADDRESS
        ///
        /// * USA_DEA_NUMBER
        ///
        /// * USA_HCPCS_CODE
        ///
        /// * USA_NATIONAL_PROVIDER_IDENTIFIER
        ///
        /// * USA_NATIONAL_DRUG_CODE
        ///
        /// * USA_HEALTH_INSURANCE_CLAIM_NUMBER
        ///
        /// * USA_MEDICARE_BENEFICIARY_IDENTIFIER
        ///
        /// * USA_CPT_CODE
        ///
        /// * PERSON_NAME
        ///
        /// * DATE
        ///
        ///
        /// The Entity type group USA_ALL is also supported, and includes all of the above entity types except PERSON_NAME and DATE.
        /// This member is required.
        public var entityTypes: [Swift.String]?

        public init(
            allowedStatistics: [DataBrewClientTypes.AllowedStatistics]? = nil,
            entityTypes: [Swift.String]? = nil
        )
        {
            self.allowedStatistics = allowedStatistics
            self.entityTypes = entityTypes
        }
    }

}

extension DataBrewClientTypes.ExcelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerRow = "HeaderRow"
        case sheetIndexes = "SheetIndexes"
        case sheetNames = "SheetNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerRow = self.headerRow {
            try encodeContainer.encode(headerRow, forKey: .headerRow)
        }
        if let sheetIndexes = sheetIndexes {
            var sheetIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetIndexes)
            for sheetindex0 in sheetIndexes {
                try sheetIndexesContainer.encode(sheetindex0)
            }
        }
        if let sheetNames = sheetNames {
            var sheetNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetNames)
            for sheetname0 in sheetNames {
                try sheetNamesContainer.encode(sheetname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sheetNames)
        var sheetNamesDecoded0:[Swift.String]? = nil
        if let sheetNamesContainer = sheetNamesContainer {
            sheetNamesDecoded0 = [Swift.String]()
            for string0 in sheetNamesContainer {
                if let string0 = string0 {
                    sheetNamesDecoded0?.append(string0)
                }
            }
        }
        sheetNames = sheetNamesDecoded0
        let sheetIndexesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .sheetIndexes)
        var sheetIndexesDecoded0:[Swift.Int]? = nil
        if let sheetIndexesContainer = sheetIndexesContainer {
            sheetIndexesDecoded0 = [Swift.Int]()
            for integer0 in sheetIndexesContainer {
                if let integer0 = integer0 {
                    sheetIndexesDecoded0?.append(integer0)
                }
            }
        }
        sheetIndexes = sheetIndexesDecoded0
        let headerRowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .headerRow)
        headerRow = headerRowDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define how DataBrew will interpret a Microsoft Excel file when creating a dataset from that file.
    public struct ExcelOptions: Swift.Equatable {
        /// A variable that specifies whether the first row in the file is parsed as the header. If this value is false, column names are auto-generated.
        public var headerRow: Swift.Bool?
        /// One or more sheet numbers in the Excel file that will be included in the dataset.
        public var sheetIndexes: [Swift.Int]?
        /// One or more named sheets in the Excel file that will be included in the dataset.
        public var sheetNames: [Swift.String]?

        public init(
            headerRow: Swift.Bool? = nil,
            sheetIndexes: [Swift.Int]? = nil,
            sheetNames: [Swift.String]? = nil
        )
        {
            self.headerRow = headerRow
            self.sheetIndexes = sheetIndexes
            self.sheetNames = sheetNames
        }
    }

}

extension DataBrewClientTypes.FilesLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxFiles = "MaxFiles"
        case order = "Order"
        case orderedBy = "OrderedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxFiles != 0 {
            try encodeContainer.encode(maxFiles, forKey: .maxFiles)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let orderedBy = self.orderedBy {
            try encodeContainer.encode(orderedBy.rawValue, forKey: .orderedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFiles) ?? 0
        maxFiles = maxFilesDecoded
        let orderedByDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.OrderedBy.self, forKey: .orderedBy)
        orderedBy = orderedByDecoded
        let orderDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a limit imposed on number of Amazon S3 files that should be selected for a dataset from a connected Amazon S3 path.
    public struct FilesLimit: Swift.Equatable {
        /// The number of Amazon S3 files to select.
        /// This member is required.
        public var maxFiles: Swift.Int
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses DESCENDING order, i.e. most recent files are selected first. Another possible value is ASCENDING.
        public var order: DataBrewClientTypes.Order?
        /// A criteria to use for Amazon S3 files sorting before their selection. By default uses LAST_MODIFIED_DATE as a sorting criteria. Currently it's the only allowed value.
        public var orderedBy: DataBrewClientTypes.OrderedBy?

        public init(
            maxFiles: Swift.Int = 0,
            order: DataBrewClientTypes.Order? = nil,
            orderedBy: DataBrewClientTypes.OrderedBy? = nil
        )
        {
            self.maxFiles = maxFiles
            self.order = order
            self.orderedBy = orderedBy
        }
    }

}

extension DataBrewClientTypes.FilterExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case valuesMap = "ValuesMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let valuesMap = valuesMap {
            var valuesMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .valuesMap)
            for (dictKey0, valuesMap0) in valuesMap {
                try valuesMapContainer.encode(valuesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let valuesMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .valuesMap)
        var valuesMapDecoded0: [Swift.String:Swift.String]? = nil
        if let valuesMapContainer = valuesMapContainer {
            valuesMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, conditionvalue0) in valuesMapContainer {
                if let conditionvalue0 = conditionvalue0 {
                    valuesMapDecoded0?[key0] = conditionvalue0
                }
            }
        }
        valuesMap = valuesMapDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents a structure for defining parameter conditions. Supported conditions are described here: [Supported conditions for dynamic datasets](https://docs.aws.amazon.com/databrew/latest/dg/datasets.multiple-files.html#conditions.for.dynamic.datasets) in the Glue DataBrew Developer Guide.
    public struct FilterExpression: Swift.Equatable {
        /// The expression which includes condition names followed by substitution variables, possibly grouped and combined with other conditions. For example, "(starts_with :prefix1 or starts_with :prefix2) and (ends_with :suffix1 or ends_with :suffix2)". Substitution variables should start with ':' symbol.
        /// This member is required.
        public var expression: Swift.String?
        /// The map of substitution variable names to their values used in this filter expression.
        /// This member is required.
        public var valuesMap: [Swift.String:Swift.String]?

        public init(
            expression: Swift.String? = nil,
            valuesMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.expression = expression
            self.valuesMap = valuesMap
        }
    }

}

extension DataBrewClientTypes.FormatOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv = "Csv"
        case excel = "Excel"
        case json = "Json"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
        if let excel = self.excel {
            try encodeContainer.encode(excel, forKey: .excel)
        }
        if let json = self.json {
            try encodeContainer.encode(json, forKey: .json)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JsonOptions.self, forKey: .json)
        json = jsonDecoded
        let excelDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ExcelOptions.self, forKey: .excel)
        excel = excelDecoded
        let csvDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.CsvOptions.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.
    public struct FormatOptions: Swift.Equatable {
        /// Options that define how CSV input is to be interpreted by DataBrew.
        public var csv: DataBrewClientTypes.CsvOptions?
        /// Options that define how Excel input is to be interpreted by DataBrew.
        public var excel: DataBrewClientTypes.ExcelOptions?
        /// Options that define how JSON input is to be interpreted by DataBrew.
        public var json: DataBrewClientTypes.JsonOptions?

        public init(
            csv: DataBrewClientTypes.CsvOptions? = nil,
            excel: DataBrewClientTypes.ExcelOptions? = nil,
            json: DataBrewClientTypes.JsonOptions? = nil
        )
        {
            self.csv = csv
            self.excel = excel
            self.json = json
        }
    }

}

extension DataBrewClientTypes.Input: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogInputDefinition = "DataCatalogInputDefinition"
        case databaseInputDefinition = "DatabaseInputDefinition"
        case metadata = "Metadata"
        case s3InputDefinition = "S3InputDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCatalogInputDefinition = self.dataCatalogInputDefinition {
            try encodeContainer.encode(dataCatalogInputDefinition, forKey: .dataCatalogInputDefinition)
        }
        if let databaseInputDefinition = self.databaseInputDefinition {
            try encodeContainer.encode(databaseInputDefinition, forKey: .databaseInputDefinition)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let s3InputDefinition = self.s3InputDefinition {
            try encodeContainer.encode(s3InputDefinition, forKey: .s3InputDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputDefinitionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .s3InputDefinition)
        s3InputDefinition = s3InputDefinitionDecoded
        let dataCatalogInputDefinitionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DataCatalogInputDefinition.self, forKey: .dataCatalogInputDefinition)
        dataCatalogInputDefinition = dataCatalogInputDefinitionDecoded
        let databaseInputDefinitionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.DatabaseInputDefinition.self, forKey: .databaseInputDefinition)
        databaseInputDefinition = databaseInputDefinitionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Metadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents information on how DataBrew can find data, in either the Glue Data Catalog or Amazon S3.
    public struct Input: Swift.Equatable {
        /// The Glue Data Catalog parameters for the data.
        public var dataCatalogInputDefinition: DataBrewClientTypes.DataCatalogInputDefinition?
        /// Connection information for dataset input files stored in a database.
        public var databaseInputDefinition: DataBrewClientTypes.DatabaseInputDefinition?
        /// Contains additional resource information needed for specific datasets.
        public var metadata: DataBrewClientTypes.Metadata?
        /// The Amazon S3 location where the data is stored.
        public var s3InputDefinition: DataBrewClientTypes.S3Location?

        public init(
            dataCatalogInputDefinition: DataBrewClientTypes.DataCatalogInputDefinition? = nil,
            databaseInputDefinition: DataBrewClientTypes.DatabaseInputDefinition? = nil,
            metadata: DataBrewClientTypes.Metadata? = nil,
            s3InputDefinition: DataBrewClientTypes.S3Location? = nil
        )
        {
            self.dataCatalogInputDefinition = dataCatalogInputDefinition
            self.databaseInputDefinition = databaseInputDefinition
            self.metadata = metadata
            self.s3InputDefinition = s3InputDefinition
        }
    }

}

extension DataBrewClientTypes {
    public enum InputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case excel
        case json
        case orc
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [InputFormat] {
            return [
                .csv,
                .excel,
                .json,
                .orc,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .excel: return "EXCEL"
            case .json: return "JSON"
            case .orc: return "ORC"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputFormat(rawValue: rawValue) ?? InputFormat.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service failure occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataBrewClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case type = "Type"
        case validationConfigurations = "ValidationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let dataCatalogOutputs = dataCatalogOutputs {
            var dataCatalogOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataCatalogOutputs)
            for datacatalogoutput0 in dataCatalogOutputs {
                try dataCatalogOutputsContainer.encode(datacatalogoutput0)
            }
        }
        if let databaseOutputs = databaseOutputs {
            var databaseOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseOutputs)
            for databaseoutput0 in databaseOutputs {
                try databaseOutputsContainer.encode(databaseoutput0)
            }
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = self.jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let recipeReference = self.recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let validationConfigurations = validationConfigurations {
            var validationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationConfigurations)
            for validationconfiguration0 in validationConfigurations {
                try validationConfigurationsContainer.encode(validationconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity) ?? 0
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries) ?? 0
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents all of the attributes of a DataBrew job.
    public struct Job: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the job.
        public var accountId: Swift.String?
        /// The date and time that the job was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who created the job.
        public var createdBy: Swift.String?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
        /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write into.
        public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
        /// A dataset that the job is to process.
        public var datasetName: Swift.String?
        /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job output. For more information, see [Encrypting data written by DataBrew jobs](https://docs.aws.amazon.com/databrew/latest/dg/encryption-security-configuration.html)
        public var encryptionKeyArn: Swift.String?
        /// The encryption mode for the job, which can be one of the following:
        ///
        /// * SSE-KMS - Server-side encryption with keys managed by KMS.
        ///
        /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
        public var encryptionMode: DataBrewClientTypes.EncryptionMode?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default value is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public var jobSample: DataBrewClientTypes.JobSample?
        /// The Amazon Resource Name (ARN) of the user who last modified the job.
        public var lastModifiedBy: Swift.String?
        /// The modification date and time of the job.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The current status of Amazon CloudWatch logging for the job.
        public var logSubscription: DataBrewClientTypes.LogSubscription?
        /// The maximum number of nodes that can be consumed when the job processes data.
        public var maxCapacity: Swift.Int
        /// The maximum number of times to retry the job after a job run fails.
        public var maxRetries: Swift.Int
        /// The unique name of the job.
        /// This member is required.
        public var name: Swift.String?
        /// One or more artifacts that represent output from running the job.
        public var outputs: [DataBrewClientTypes.Output]?
        /// The name of the project that the job is associated with.
        public var projectName: Swift.String?
        /// A set of steps that the job runs.
        public var recipeReference: DataBrewClientTypes.RecipeReference?
        /// The unique Amazon Resource Name (ARN) for the job.
        public var resourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the role to be assumed for this job.
        public var roleArn: Swift.String?
        /// Metadata tags that have been applied to the job.
        public var tags: [Swift.String:Swift.String]?
        /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
        public var timeout: Swift.Int
        /// The job type of the job, which must be one of the following:
        ///
        /// * PROFILE - A job to analyze a dataset, to determine its size, data types, data distribution, and more.
        ///
        /// * RECIPE - A job to apply one or more transformations to a dataset.
        public var type: DataBrewClientTypes.JobType?
        /// List of validation configurations that are applied to the profile job.
        public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

        public init(
            accountId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
            databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
            datasetName: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
            jobSample: DataBrewClientTypes.JobSample? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            logSubscription: DataBrewClientTypes.LogSubscription? = nil,
            maxCapacity: Swift.Int = 0,
            maxRetries: Swift.Int = 0,
            name: Swift.String? = nil,
            outputs: [DataBrewClientTypes.Output]? = nil,
            projectName: Swift.String? = nil,
            recipeReference: DataBrewClientTypes.RecipeReference? = nil,
            resourceArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeout: Swift.Int = 0,
            type: DataBrewClientTypes.JobType? = nil,
            validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
        )
        {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.dataCatalogOutputs = dataCatalogOutputs
            self.databaseOutputs = databaseOutputs
            self.datasetName = datasetName
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionMode = encryptionMode
            self.jobSample = jobSample
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.logSubscription = logSubscription
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.outputs = outputs
            self.projectName = projectName
            self.recipeReference = recipeReference
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.tags = tags
            self.timeout = timeout
            self.type = type
            self.validationConfigurations = validationConfigurations
        }
    }

}

extension DataBrewClientTypes.JobRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attempt = "Attempt"
        case completedOn = "CompletedOn"
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case datasetName = "DatasetName"
        case errorMessage = "ErrorMessage"
        case executionTime = "ExecutionTime"
        case jobName = "JobName"
        case jobSample = "JobSample"
        case logGroupName = "LogGroupName"
        case logSubscription = "LogSubscription"
        case outputs = "Outputs"
        case recipeReference = "RecipeReference"
        case runId = "RunId"
        case startedBy = "StartedBy"
        case startedOn = "StartedOn"
        case state = "State"
        case validationConfigurations = "ValidationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempt != 0 {
            try encodeContainer.encode(attempt, forKey: .attempt)
        }
        if let completedOn = self.completedOn {
            try encodeContainer.encodeTimestamp(completedOn, format: .epochSeconds, forKey: .completedOn)
        }
        if let dataCatalogOutputs = dataCatalogOutputs {
            var dataCatalogOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataCatalogOutputs)
            for datacatalogoutput0 in dataCatalogOutputs {
                try dataCatalogOutputsContainer.encode(datacatalogoutput0)
            }
        }
        if let databaseOutputs = databaseOutputs {
            var databaseOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseOutputs)
            for databaseoutput0 in databaseOutputs {
                try databaseOutputsContainer.encode(databaseoutput0)
            }
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if executionTime != 0 {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobSample = self.jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let recipeReference = self.recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let runId = self.runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let startedOn = self.startedOn {
            try encodeContainer.encodeTimestamp(startedOn, format: .epochSeconds, forKey: .startedOn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let validationConfigurations = validationConfigurations {
            var validationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationConfigurations)
            for validationconfiguration0 in validationConfigurations {
                try validationConfigurationsContainer.encode(validationconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attempt) ?? 0
        attempt = attemptDecoded
        let completedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedOn)
        completedOn = completedOnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTime) ?? 0
        executionTime = executionTimeDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let startedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedOn)
        startedOn = startedOnDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents one run of a DataBrew job.
    public struct JobRun: Swift.Equatable {
        /// The number of times that DataBrew has attempted to run the job.
        public var attempt: Swift.Int
        /// The date and time when the job completed processing.
        public var completedOn: ClientRuntime.Date?
        /// One or more artifacts that represent the Glue Data Catalog output from running the job.
        public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
        /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write into.
        public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
        /// The name of the dataset for the job to process.
        public var datasetName: Swift.String?
        /// A message indicating an error (if any) that was encountered when the job ran.
        public var errorMessage: Swift.String?
        /// The amount of time, in seconds, during which a job run consumed resources.
        public var executionTime: Swift.Int
        /// The name of the job being processed during this run.
        public var jobName: Swift.String?
        /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
        public var jobSample: DataBrewClientTypes.JobSample?
        /// The name of an Amazon CloudWatch log group, where the job writes diagnostic messages when it runs.
        public var logGroupName: Swift.String?
        /// The current status of Amazon CloudWatch logging for the job run.
        public var logSubscription: DataBrewClientTypes.LogSubscription?
        /// One or more output artifacts from a job run.
        public var outputs: [DataBrewClientTypes.Output]?
        /// The set of steps processed by the job.
        public var recipeReference: DataBrewClientTypes.RecipeReference?
        /// The unique identifier of the job run.
        public var runId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who initiated the job run.
        public var startedBy: Swift.String?
        /// The date and time when the job run began.
        public var startedOn: ClientRuntime.Date?
        /// The current state of the job run entity itself.
        public var state: DataBrewClientTypes.JobRunState?
        /// List of validation configurations that are applied to the profile job run.
        public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

        public init(
            attempt: Swift.Int = 0,
            completedOn: ClientRuntime.Date? = nil,
            dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
            databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
            datasetName: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            executionTime: Swift.Int = 0,
            jobName: Swift.String? = nil,
            jobSample: DataBrewClientTypes.JobSample? = nil,
            logGroupName: Swift.String? = nil,
            logSubscription: DataBrewClientTypes.LogSubscription? = nil,
            outputs: [DataBrewClientTypes.Output]? = nil,
            recipeReference: DataBrewClientTypes.RecipeReference? = nil,
            runId: Swift.String? = nil,
            startedBy: Swift.String? = nil,
            startedOn: ClientRuntime.Date? = nil,
            state: DataBrewClientTypes.JobRunState? = nil,
            validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
        )
        {
            self.attempt = attempt
            self.completedOn = completedOn
            self.dataCatalogOutputs = dataCatalogOutputs
            self.databaseOutputs = databaseOutputs
            self.datasetName = datasetName
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.jobName = jobName
            self.jobSample = jobSample
            self.logGroupName = logGroupName
            self.logSubscription = logSubscription
            self.outputs = outputs
            self.recipeReference = recipeReference
            self.runId = runId
            self.startedBy = startedBy
            self.startedOn = startedOn
            self.state = state
            self.validationConfigurations = validationConfigurations
        }
    }

}

extension DataBrewClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case running
        case starting
        case stopped
        case stopping
        case succeeded
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .failed,
                .running,
                .starting,
                .stopped,
                .stopping,
                .succeeded,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.JobSample: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.SampleMode.self, forKey: .mode)
        mode = modeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension DataBrewClientTypes {
    /// A sample configuration for profile jobs only, which determines the number of rows on which the profile job is run. If a JobSample value isn't provided, the default is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the size parameter.
    public struct JobSample: Swift.Equatable {
        /// A value that determines whether the profile job is run on the entire dataset or a specified number of rows. This value must be one of the following:
        ///
        /// * FULL_DATASET - The profile job is run on the entire dataset.
        ///
        /// * CUSTOM_ROWS - The profile job is run on the number of rows specified in the Size parameter.
        public var mode: DataBrewClientTypes.SampleMode?
        /// The Size parameter is only required when the mode is CUSTOM_ROWS. The profile job is run on the specified number of rows. The maximum value for size is Long.MAX_VALUE. Long.MAX_VALUE = 9223372036854775807
        public var size: Swift.Int?

        public init(
            mode: DataBrewClientTypes.SampleMode? = nil,
            size: Swift.Int? = nil
        )
        {
            self.mode = mode
            self.size = size
        }
    }

}

extension DataBrewClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case profile
        case recipe
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .profile,
                .recipe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .profile: return "PROFILE"
            case .recipe: return "RECIPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.JsonOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multiLine = "MultiLine"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if multiLine != false {
            try encodeContainer.encode(multiLine, forKey: .multiLine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multiLineDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiLine) ?? false
        multiLine = multiLineDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents the JSON-specific options that define how input is to be interpreted by Glue DataBrew.
    public struct JsonOptions: Swift.Equatable {
        /// A value that specifies whether JSON input contains embedded new line characters.
        public var multiLine: Swift.Bool

        public init(
            multiLine: Swift.Bool = false
        )
        {
            self.multiLine = multiLine
        }
    }

}

extension ListDatasetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasets"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutput: Swift.Equatable {
    /// A list of datasets that are defined.
    /// This member is required.
    public var datasets: [DataBrewClientTypes.Dataset]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        datasets: [DataBrewClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputBody: Swift.Equatable {
    let datasets: [DataBrewClientTypes.Dataset]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[DataBrewClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [DataBrewClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJobRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())/jobRuns"
    }
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The name of the job.
    /// This member is required.
    public var name: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutput: Swift.Equatable {
    /// A list of job runs that have occurred for the specified job.
    /// This member is required.
    public var jobRuns: [DataBrewClientTypes.JobRun]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobRuns: [DataBrewClientTypes.JobRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputBody: Swift.Equatable {
    let jobRuns: [DataBrewClientTypes.JobRun]?
    let nextToken: Swift.String?
}

extension ListJobRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns = "JobRuns"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[DataBrewClientTypes.JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [DataBrewClientTypes.JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let projectName = projectName {
                let projectNameQueryItem = ClientRuntime.URLQueryItem(name: "projectName".urlPercentEncoding(), value: Swift.String(projectName).urlPercentEncoding())
                items.append(projectNameQueryItem)
            }
            if let datasetName = datasetName {
                let datasetNameQueryItem = ClientRuntime.URLQueryItem(name: "datasetName".urlPercentEncoding(), value: Swift.String(datasetName).urlPercentEncoding())
                items.append(datasetNameQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The name of a dataset. Using this parameter indicates to return only those jobs that act on the specified dataset.
    public var datasetName: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by DataBrew that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the NextToken value from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of a project. Using this parameter indicates to return only those jobs that are associated with the specified project.
    public var projectName: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// A list of jobs that are defined.
    /// This member is required.
    public var jobs: [DataBrewClientTypes.Job]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [DataBrewClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let jobs: [DataBrewClientTypes.Job]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[DataBrewClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DataBrewClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of projects that are defined .
    /// This member is required.
    public var projects: [DataBrewClientTypes.Project]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [DataBrewClientTypes.Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projects: [DataBrewClientTypes.Project]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case projects = "Projects"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Project?].self, forKey: .projects)
        var projectsDecoded0:[DataBrewClientTypes.Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [DataBrewClientTypes.Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecipeVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let name = name else {
                let message = "Creating a URL Query Item failed. name is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
            return items
        }
    }
}

extension ListRecipeVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recipeVersions"
    }
}

public struct ListRecipeVersionsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The name of the recipe for which to return version information.
    /// This member is required.
    public var name: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListRecipeVersionsInputBody: Swift.Equatable {
}

extension ListRecipeVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecipeVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecipeVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipeVersionsOutput: Swift.Equatable {
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of versions for the specified recipe.
    /// This member is required.
    public var recipes: [DataBrewClientTypes.Recipe]?

    public init(
        nextToken: Swift.String? = nil,
        recipes: [DataBrewClientTypes.Recipe]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipeVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recipes: [DataBrewClientTypes.Recipe]?
}

extension ListRecipeVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recipes = "Recipes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recipesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Recipe?].self, forKey: .recipes)
        var recipesDecoded0:[DataBrewClientTypes.Recipe]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [DataBrewClientTypes.Recipe]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
    }
}

enum ListRecipeVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecipesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let recipeVersion = recipeVersion {
                let recipeVersionQueryItem = ClientRuntime.URLQueryItem(name: "recipeVersion".urlPercentEncoding(), value: Swift.String(recipeVersion).urlPercentEncoding())
                items.append(recipeVersionQueryItem)
            }
            return items
        }
    }
}

extension ListRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recipes"
    }
}

public struct ListRecipesInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Return only those recipes with a version identifier of LATEST_WORKING or LATEST_PUBLISHED. If RecipeVersion is omitted, ListRecipes returns all of the LATEST_PUBLISHED recipe versions. Valid values: LATEST_WORKING | LATEST_PUBLISHED
    public var recipeVersion: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recipeVersion: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeVersion = recipeVersion
    }
}

struct ListRecipesInputBody: Swift.Equatable {
}

extension ListRecipesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecipesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecipesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutput: Swift.Equatable {
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of recipes that are defined.
    /// This member is required.
    public var recipes: [DataBrewClientTypes.Recipe]?

    public init(
        nextToken: Swift.String? = nil,
        recipes: [DataBrewClientTypes.Recipe]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputBody: Swift.Equatable {
    let recipes: [DataBrewClientTypes.Recipe]?
    let nextToken: Swift.String?
}

extension ListRecipesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recipes = "Recipes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Recipe?].self, forKey: .recipes)
        var recipesDecoded0:[DataBrewClientTypes.Recipe]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [DataBrewClientTypes.Recipe]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecipesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRulesetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let targetArn = targetArn {
                let targetArnQueryItem = ClientRuntime.URLQueryItem(name: "targetArn".urlPercentEncoding(), value: Swift.String(targetArn).urlPercentEncoding())
                items.append(targetArnQueryItem)
            }
            return items
        }
    }
}

extension ListRulesetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rulesets"
    }
}

public struct ListRulesetsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by DataBrew that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the NextToken value from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of a resource (dataset). Using this parameter indicates to return only those rulesets that are associated with the specified resource.
    public var targetArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListRulesetsInputBody: Swift.Equatable {
}

extension ListRulesetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRulesetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rulesets = output.rulesets
        } else {
            self.nextToken = nil
            self.rulesets = nil
        }
    }
}

public struct ListRulesetsOutput: Swift.Equatable {
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of RulesetItem. RulesetItem contains meta data of a ruleset.
    /// This member is required.
    public var rulesets: [DataBrewClientTypes.RulesetItem]?

    public init(
        nextToken: Swift.String? = nil,
        rulesets: [DataBrewClientTypes.RulesetItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesets = rulesets
    }
}

struct ListRulesetsOutputBody: Swift.Equatable {
    let rulesets: [DataBrewClientTypes.RulesetItem]?
    let nextToken: Swift.String?
}

extension ListRulesetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rulesets = "Rulesets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesetsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RulesetItem?].self, forKey: .rulesets)
        var rulesetsDecoded0:[DataBrewClientTypes.RulesetItem]? = nil
        if let rulesetsContainer = rulesetsContainer {
            rulesetsDecoded0 = [DataBrewClientTypes.RulesetItem]()
            for structure0 in rulesetsContainer {
                if let structure0 = structure0 {
                    rulesetsDecoded0?.append(structure0)
                }
            }
        }
        rulesets = rulesetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRulesetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchedulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let jobName = jobName {
                let jobNameQueryItem = ClientRuntime.URLQueryItem(name: "jobName".urlPercentEncoding(), value: Swift.String(jobName).urlPercentEncoding())
                items.append(jobNameQueryItem)
            }
            return items
        }
    }
}

extension ListSchedulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schedules"
    }
}

public struct ListSchedulesInput: Swift.Equatable {
    /// The name of the job that these schedules apply to.
    public var jobName: Swift.String?
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchedulesInputBody: Swift.Equatable {
}

extension ListSchedulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchedulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchedulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schedules = output.schedules
        } else {
            self.nextToken = nil
            self.schedules = nil
        }
    }
}

public struct ListSchedulesOutput: Swift.Equatable {
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of schedules that are defined.
    /// This member is required.
    public var schedules: [DataBrewClientTypes.Schedule]?

    public init(
        nextToken: Swift.String? = nil,
        schedules: [DataBrewClientTypes.Schedule]? = nil
    )
    {
        self.nextToken = nextToken
        self.schedules = schedules
    }
}

struct ListSchedulesOutputBody: Swift.Equatable {
    let schedules: [DataBrewClientTypes.Schedule]?
    let nextToken: Swift.String?
}

extension ListSchedulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schedules = "Schedules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schedulesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Schedule?].self, forKey: .schedules)
        var schedulesDecoded0:[DataBrewClientTypes.Schedule]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [DataBrewClientTypes.Schedule]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchedulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the DataBrew resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags associated with the DataBrew resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes {
    public enum LogSubscription: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [LogSubscription] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogSubscription(rawValue: rawValue) ?? LogSubscription.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.Metadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceArn = "SourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension DataBrewClientTypes {
    /// Contains additional resource information needed for specific datasets.
    public struct Metadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the dataset. Currently, DataBrew only supports ARNs from Amazon AppFlow.
        public var sourceArn: Swift.String?

        public init(
            sourceArn: Swift.String? = nil
        )
        {
            self.sourceArn = sourceArn
        }
    }

}

extension DataBrewClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes {
    public enum OrderedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastModifiedDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedBy] {
            return [
                .lastModifiedDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastModifiedDate: return "LAST_MODIFIED_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedBy(rawValue: rawValue) ?? OrderedBy.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionFormat = "CompressionFormat"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case location = "Location"
        case maxOutputFiles = "MaxOutputFiles"
        case overwrite = "Overwrite"
        case partitionColumns = "PartitionColumns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFormat = self.compressionFormat {
            try encodeContainer.encode(compressionFormat.rawValue, forKey: .compressionFormat)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let maxOutputFiles = self.maxOutputFiles {
            try encodeContainer.encode(maxOutputFiles, forKey: .maxOutputFiles)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for columnname0 in partitionColumns {
                try partitionColumnsContainer.encode(columnname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFormatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.CompressionFormat.self, forKey: .compressionFormat)
        compressionFormat = compressionFormatDecoded
        let formatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.OutputFormat.self, forKey: .format)
        format = formatDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let locationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .location)
        location = locationDecoded
        let overwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overwrite) ?? false
        overwrite = overwriteDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.OutputFormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let maxOutputFilesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxOutputFiles)
        maxOutputFiles = maxOutputFilesDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents options that specify how and where in Amazon S3 DataBrew writes the output generated by recipe jobs or profile jobs.
    public struct Output: Swift.Equatable {
        /// The compression algorithm used to compress the output text of the job.
        public var compressionFormat: DataBrewClientTypes.CompressionFormat?
        /// The data format of the output of the job.
        public var format: DataBrewClientTypes.OutputFormat?
        /// Represents options that define how DataBrew formats job output files.
        public var formatOptions: DataBrewClientTypes.OutputFormatOptions?
        /// The location in Amazon S3 where the job writes its output.
        /// This member is required.
        public var location: DataBrewClientTypes.S3Location?
        /// Maximum number of files to be generated by the job and written to the output folder. For output partitioned by column(s), the MaxOutputFiles value is the maximum number of files per partition.
        public var maxOutputFiles: Swift.Int?
        /// A value that, if true, means that any data in the location specified for output is overwritten with new output.
        public var overwrite: Swift.Bool
        /// The names of one or more partition columns for the output of the job.
        public var partitionColumns: [Swift.String]?

        public init(
            compressionFormat: DataBrewClientTypes.CompressionFormat? = nil,
            format: DataBrewClientTypes.OutputFormat? = nil,
            formatOptions: DataBrewClientTypes.OutputFormatOptions? = nil,
            location: DataBrewClientTypes.S3Location? = nil,
            maxOutputFiles: Swift.Int? = nil,
            overwrite: Swift.Bool = false,
            partitionColumns: [Swift.String]? = nil
        )
        {
            self.compressionFormat = compressionFormat
            self.format = format
            self.formatOptions = formatOptions
            self.location = location
            self.maxOutputFiles = maxOutputFiles
            self.overwrite = overwrite
            self.partitionColumns = partitionColumns
        }
    }

}

extension DataBrewClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avro
        case csv
        case glueparquet
        case json
        case orc
        case parquet
        case tableauhyper
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .avro,
                .csv,
                .glueparquet,
                .json,
                .orc,
                .parquet,
                .tableauhyper,
                .xml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avro: return "AVRO"
            case .csv: return "CSV"
            case .glueparquet: return "GLUEPARQUET"
            case .json: return "JSON"
            case .orc: return "ORC"
            case .parquet: return "PARQUET"
            case .tableauhyper: return "TABLEAUHYPER"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.OutputFormatOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv = "Csv"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.CsvOutputOptions.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define the structure of comma-separated (CSV) job output.
    public struct OutputFormatOptions: Swift.Equatable {
        /// Represents a set of options that define the structure of comma-separated value (CSV) job output.
        public var csv: DataBrewClientTypes.CsvOutputOptions?

        public init(
            csv: DataBrewClientTypes.CsvOutputOptions? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension DataBrewClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datetime
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .datetime,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datetime: return "Datetime"
            case .number: return "Number"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.PathOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filesLimit = "FilesLimit"
        case lastModifiedDateCondition = "LastModifiedDateCondition"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filesLimit = self.filesLimit {
            try encodeContainer.encode(filesLimit, forKey: .filesLimit)
        }
        if let lastModifiedDateCondition = self.lastModifiedDateCondition {
            try encodeContainer.encode(lastModifiedDateCondition, forKey: .lastModifiedDateCondition)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, pathParametersMap0) in parameters {
                try parametersContainer.encode(pathParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDateConditionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FilterExpression.self, forKey: .lastModifiedDateCondition)
        lastModifiedDateCondition = lastModifiedDateConditionDecoded
        let filesLimitDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FilesLimit.self, forKey: .filesLimit)
        filesLimit = filesLimitDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DataBrewClientTypes.DatasetParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DataBrewClientTypes.DatasetParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DataBrewClientTypes.DatasetParameter]()
            for (key0, datasetparameter0) in parametersContainer {
                if let datasetparameter0 = datasetparameter0 {
                    parametersDecoded0?[key0] = datasetparameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents a set of options that define how DataBrew selects files for a given Amazon S3 path in a dataset.
    public struct PathOptions: Swift.Equatable {
        /// If provided, this structure imposes a limit on a number of files that should be selected.
        public var filesLimit: DataBrewClientTypes.FilesLimit?
        /// If provided, this structure defines a date range for matching Amazon S3 objects based on their LastModifiedDate attribute in Amazon S3.
        public var lastModifiedDateCondition: DataBrewClientTypes.FilterExpression?
        /// A structure that maps names of parameters used in the Amazon S3 path of a dataset to their definitions.
        public var parameters: [Swift.String:DataBrewClientTypes.DatasetParameter]?

        public init(
            filesLimit: DataBrewClientTypes.FilesLimit? = nil,
            lastModifiedDateCondition: DataBrewClientTypes.FilterExpression? = nil,
            parameters: [Swift.String:DataBrewClientTypes.DatasetParameter]? = nil
        )
        {
            self.filesLimit = filesLimit
            self.lastModifiedDateCondition = lastModifiedDateCondition
            self.parameters = parameters
        }
    }

}

extension DataBrewClientTypes.ProfileConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnStatisticsConfigurations = "ColumnStatisticsConfigurations"
        case datasetStatisticsConfiguration = "DatasetStatisticsConfiguration"
        case entityDetectorConfiguration = "EntityDetectorConfiguration"
        case profileColumns = "ProfileColumns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnStatisticsConfigurations = columnStatisticsConfigurations {
            var columnStatisticsConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnStatisticsConfigurations)
            for columnstatisticsconfiguration0 in columnStatisticsConfigurations {
                try columnStatisticsConfigurationsContainer.encode(columnstatisticsconfiguration0)
            }
        }
        if let datasetStatisticsConfiguration = self.datasetStatisticsConfiguration {
            try encodeContainer.encode(datasetStatisticsConfiguration, forKey: .datasetStatisticsConfiguration)
        }
        if let entityDetectorConfiguration = self.entityDetectorConfiguration {
            try encodeContainer.encode(entityDetectorConfiguration, forKey: .entityDetectorConfiguration)
        }
        if let profileColumns = profileColumns {
            var profileColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileColumns)
            for columnselector0 in profileColumns {
                try profileColumnsContainer.encode(columnselector0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetStatisticsConfigurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.StatisticsConfiguration.self, forKey: .datasetStatisticsConfiguration)
        datasetStatisticsConfiguration = datasetStatisticsConfigurationDecoded
        let profileColumnsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ColumnSelector?].self, forKey: .profileColumns)
        var profileColumnsDecoded0:[DataBrewClientTypes.ColumnSelector]? = nil
        if let profileColumnsContainer = profileColumnsContainer {
            profileColumnsDecoded0 = [DataBrewClientTypes.ColumnSelector]()
            for structure0 in profileColumnsContainer {
                if let structure0 = structure0 {
                    profileColumnsDecoded0?.append(structure0)
                }
            }
        }
        profileColumns = profileColumnsDecoded0
        let columnStatisticsConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ColumnStatisticsConfiguration?].self, forKey: .columnStatisticsConfigurations)
        var columnStatisticsConfigurationsDecoded0:[DataBrewClientTypes.ColumnStatisticsConfiguration]? = nil
        if let columnStatisticsConfigurationsContainer = columnStatisticsConfigurationsContainer {
            columnStatisticsConfigurationsDecoded0 = [DataBrewClientTypes.ColumnStatisticsConfiguration]()
            for structure0 in columnStatisticsConfigurationsContainer {
                if let structure0 = structure0 {
                    columnStatisticsConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        columnStatisticsConfigurations = columnStatisticsConfigurationsDecoded0
        let entityDetectorConfigurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EntityDetectorConfiguration.self, forKey: .entityDetectorConfiguration)
        entityDetectorConfiguration = entityDetectorConfigurationDecoded
    }
}

extension DataBrewClientTypes {
    /// Configuration for profile jobs. Configuration can be used to select columns, do evaluations, and override default parameters of evaluations. When configuration is undefined, the profile job will apply default settings to all supported columns.
    public struct ProfileConfiguration: Swift.Equatable {
        /// List of configurations for column evaluations. ColumnStatisticsConfigurations are used to select evaluations and override parameters of evaluations for particular columns. When ColumnStatisticsConfigurations is undefined, the profile job will profile all supported columns and run all supported evaluations.
        public var columnStatisticsConfigurations: [DataBrewClientTypes.ColumnStatisticsConfiguration]?
        /// Configuration for inter-column evaluations. Configuration can be used to select evaluations and override parameters of evaluations. When configuration is undefined, the profile job will run all supported inter-column evaluations.
        public var datasetStatisticsConfiguration: DataBrewClientTypes.StatisticsConfiguration?
        /// Configuration of entity detection for a profile job. When undefined, entity detection is disabled.
        public var entityDetectorConfiguration: DataBrewClientTypes.EntityDetectorConfiguration?
        /// List of column selectors. ProfileColumns can be used to select columns from the dataset. When ProfileColumns is undefined, the profile job will profile all supported columns.
        public var profileColumns: [DataBrewClientTypes.ColumnSelector]?

        public init(
            columnStatisticsConfigurations: [DataBrewClientTypes.ColumnStatisticsConfiguration]? = nil,
            datasetStatisticsConfiguration: DataBrewClientTypes.StatisticsConfiguration? = nil,
            entityDetectorConfiguration: DataBrewClientTypes.EntityDetectorConfiguration? = nil,
            profileColumns: [DataBrewClientTypes.ColumnSelector]? = nil
        )
        {
            self.columnStatisticsConfigurations = columnStatisticsConfigurations
            self.datasetStatisticsConfiguration = datasetStatisticsConfiguration
            self.entityDetectorConfiguration = entityDetectorConfiguration
            self.profileColumns = profileColumns
        }
    }

}

extension DataBrewClientTypes.Project: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case openDate = "OpenDate"
        case openedBy = "OpenedBy"
        case recipeName = "RecipeName"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openDate = self.openDate {
            try encodeContainer.encodeTimestamp(openDate, format: .epochSeconds, forKey: .openDate)
        }
        if let openedBy = self.openedBy {
            try encodeContainer.encode(openedBy, forKey: .openedBy)
        }
        if let recipeName = self.recipeName {
            try encodeContainer.encode(recipeName, forKey: .recipeName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = self.sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Sample.self, forKey: .sample)
        sample = sampleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let openedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openedBy)
        openedBy = openedByDecoded
        let openDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .openDate)
        openDate = openDateDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents all of the attributes of a DataBrew project.
    public struct Project: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the project.
        public var accountId: Swift.String?
        /// The date and time that the project was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who crated the project.
        public var createdBy: Swift.String?
        /// The dataset that the project is to act upon.
        public var datasetName: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last modified the project.
        public var lastModifiedBy: Swift.String?
        /// The last modification date and time for the project.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The unique name of a project.
        /// This member is required.
        public var name: Swift.String?
        /// The date and time when the project was opened.
        public var openDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user that opened the project for use.
        public var openedBy: Swift.String?
        /// The name of a recipe that will be developed during a project session.
        /// This member is required.
        public var recipeName: Swift.String?
        /// The Amazon Resource Name (ARN) for the project.
        public var resourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the role that will be assumed for this project.
        public var roleArn: Swift.String?
        /// The sample size and sampling type to apply to the data. If this parameter isn't specified, then the sample consists of the first 500 rows from the dataset.
        public var sample: DataBrewClientTypes.Sample?
        /// Metadata tags that have been applied to the project.
        public var tags: [Swift.String:Swift.String]?

        public init(
            accountId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            openDate: ClientRuntime.Date? = nil,
            openedBy: Swift.String? = nil,
            recipeName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sample: DataBrewClientTypes.Sample? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.datasetName = datasetName
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.openDate = openDate
            self.openedBy = openedBy
            self.recipeName = recipeName
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.sample = sample
            self.tags = tags
        }
    }

}

extension PublishRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension PublishRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/recipes/\(name.urlPercentEncoding())/publishRecipe"
    }
}

public struct PublishRecipeInput: Swift.Equatable {
    /// A description of the recipe to be published, for this version of the recipe.
    public var description: Swift.String?
    /// The name of the recipe to be published.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct PublishRecipeInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension PublishRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PublishRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct PublishRecipeOutput: Swift.Equatable {
    /// The name of the recipe that you published.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct PublishRecipeOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension PublishRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum PublishRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.Recipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case projectName = "ProjectName"
        case publishedBy = "PublishedBy"
        case publishedDate = "PublishedDate"
        case recipeVersion = "RecipeVersion"
        case resourceArn = "ResourceArn"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let publishedBy = self.publishedBy {
            try encodeContainer.encode(publishedBy, forKey: .publishedBy)
        }
        if let publishedDate = self.publishedDate {
            try encodeContainer.encodeTimestamp(publishedDate, format: .epochSeconds, forKey: .publishedDate)
        }
        if let recipeVersion = self.recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipestep0 in steps {
                try stepsContainer.encode(recipestep0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let publishedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedBy)
        publishedBy = publishedByDecoded
        let publishedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publishedDate)
        publishedDate = publishedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[DataBrewClientTypes.RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DataBrewClientTypes.RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recipeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents one or more actions to be performed on a DataBrew dataset.
    public struct Recipe: Swift.Equatable {
        /// The date and time that the recipe was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who created the recipe.
        public var createdBy: Swift.String?
        /// The description of the recipe.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last modified the recipe.
        public var lastModifiedBy: Swift.String?
        /// The last modification date and time of the recipe.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The unique name for the recipe.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the project that the recipe is associated with.
        public var projectName: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who published the recipe.
        public var publishedBy: Swift.String?
        /// The date and time when the recipe was published.
        public var publishedDate: ClientRuntime.Date?
        /// The identifier for the version for the recipe. Must be one of the following:
        ///
        /// * Numeric version (X.Y) - X and Y stand for major and minor version numbers. The maximum length of each is 6 digits, and neither can be negative values. Both X and Y are required, and "0.0" isn't a valid version.
        ///
        /// * LATEST_WORKING - the most recent valid version being developed in a DataBrew project.
        ///
        /// * LATEST_PUBLISHED - the most recent published version.
        public var recipeVersion: Swift.String?
        /// The Amazon Resource Name (ARN) for the recipe.
        public var resourceArn: Swift.String?
        /// A list of steps that are defined by the recipe.
        public var steps: [DataBrewClientTypes.RecipeStep]?
        /// Metadata tags that have been applied to the recipe.
        public var tags: [Swift.String:Swift.String]?

        public init(
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            projectName: Swift.String? = nil,
            publishedBy: Swift.String? = nil,
            publishedDate: ClientRuntime.Date? = nil,
            recipeVersion: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            steps: [DataBrewClientTypes.RecipeStep]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.projectName = projectName
            self.publishedBy = publishedBy
            self.publishedDate = publishedDate
            self.recipeVersion = recipeVersion
            self.resourceArn = resourceArn
            self.steps = steps
            self.tags = tags
        }
    }

}

extension DataBrewClientTypes.RecipeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "Operation"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in parametersContainer {
                if let parametervalue0 = parametervalue0 {
                    parametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents a transformation and associated parameters that are used to apply a change to a DataBrew dataset. For more information, see [Recipe actions reference](https://docs.aws.amazon.com/databrew/latest/dg/recipe-actions-reference.html).
    public struct RecipeAction: Swift.Equatable {
        /// The name of a valid DataBrew transformation to be performed on the data.
        /// This member is required.
        public var operation: Swift.String?
        /// Contextual parameters for the transformation.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            operation: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.operation = operation
            self.parameters = parameters
        }
    }

}

extension DataBrewClientTypes.RecipeReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case recipeVersion = "RecipeVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeVersion = self.recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents the name and version of a DataBrew recipe.
    public struct RecipeReference: Swift.Equatable {
        /// The name of the recipe.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier for the version for the recipe.
        public var recipeVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            recipeVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.recipeVersion = recipeVersion
        }
    }

}

extension DataBrewClientTypes.RecipeStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case conditionExpressions = "ConditionExpressions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let conditionExpressions = conditionExpressions {
            var conditionExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionExpressions)
            for conditionexpression0 in conditionExpressions {
                try conditionExpressionsContainer.encode(conditionexpression0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeAction.self, forKey: .action)
        action = actionDecoded
        let conditionExpressionsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ConditionExpression?].self, forKey: .conditionExpressions)
        var conditionExpressionsDecoded0:[DataBrewClientTypes.ConditionExpression]? = nil
        if let conditionExpressionsContainer = conditionExpressionsContainer {
            conditionExpressionsDecoded0 = [DataBrewClientTypes.ConditionExpression]()
            for structure0 in conditionExpressionsContainer {
                if let structure0 = structure0 {
                    conditionExpressionsDecoded0?.append(structure0)
                }
            }
        }
        conditionExpressions = conditionExpressionsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents a single step from a DataBrew recipe to be performed.
    public struct RecipeStep: Swift.Equatable {
        /// The particular action to be performed in the recipe step.
        /// This member is required.
        public var action: DataBrewClientTypes.RecipeAction?
        /// One or more conditions that must be met for the recipe step to succeed. All of the conditions in the array must be met. In other words, all of the conditions must be combined using a logical AND operation.
        public var conditionExpressions: [DataBrewClientTypes.ConditionExpression]?

        public init(
            action: DataBrewClientTypes.RecipeAction? = nil,
            conditionExpressions: [DataBrewClientTypes.ConditionExpression]? = nil
        )
        {
            self.action = action
            self.conditionExpressions = conditionExpressions
        }
    }

}

extension DataBrewClientTypes.RecipeVersionErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case recipeVersion = "RecipeVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let recipeVersion = self.recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents any errors encountered when attempting to delete multiple recipe versions.
    public struct RecipeVersionErrorDetail: Swift.Equatable {
        /// The HTTP status code for the error.
        public var errorCode: Swift.String?
        /// The text of the error message.
        public var errorMessage: Swift.String?
        /// The identifier for the recipe version associated with this error.
        public var recipeVersion: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            recipeVersion: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.recipeVersion = recipeVersion
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataBrewClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkExpression = "CheckExpression"
        case columnSelectors = "ColumnSelectors"
        case disabled = "Disabled"
        case name = "Name"
        case substitutionMap = "SubstitutionMap"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkExpression = self.checkExpression {
            try encodeContainer.encode(checkExpression, forKey: .checkExpression)
        }
        if let columnSelectors = columnSelectors {
            var columnSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnSelectors)
            for columnselector0 in columnSelectors {
                try columnSelectorsContainer.encode(columnselector0)
            }
        }
        if disabled != false {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let substitutionMap = substitutionMap {
            var substitutionMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .substitutionMap)
            for (dictKey0, valuesMap0) in substitutionMap {
                try substitutionMapContainer.encode(valuesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled) ?? false
        disabled = disabledDecoded
        let checkExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkExpression)
        checkExpression = checkExpressionDecoded
        let substitutionMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .substitutionMap)
        var substitutionMapDecoded0: [Swift.String:Swift.String]? = nil
        if let substitutionMapContainer = substitutionMapContainer {
            substitutionMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, conditionvalue0) in substitutionMapContainer {
                if let conditionvalue0 = conditionvalue0 {
                    substitutionMapDecoded0?[key0] = conditionvalue0
                }
            }
        }
        substitutionMap = substitutionMapDecoded0
        let thresholdDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Threshold.self, forKey: .threshold)
        threshold = thresholdDecoded
        let columnSelectorsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ColumnSelector?].self, forKey: .columnSelectors)
        var columnSelectorsDecoded0:[DataBrewClientTypes.ColumnSelector]? = nil
        if let columnSelectorsContainer = columnSelectorsContainer {
            columnSelectorsDecoded0 = [DataBrewClientTypes.ColumnSelector]()
            for structure0 in columnSelectorsContainer {
                if let structure0 = structure0 {
                    columnSelectorsDecoded0?.append(structure0)
                }
            }
        }
        columnSelectors = columnSelectorsDecoded0
    }
}

extension DataBrewClientTypes {
    /// Represents a single data quality requirement that should be validated in the scope of this dataset.
    public struct Rule: Swift.Equatable {
        /// The expression which includes column references, condition names followed by variable references, possibly grouped and combined with other conditions. For example, (:col1 starts_with :prefix1 or :col1 starts_with :prefix2) and (:col1 ends_with :suffix1 or :col1 ends_with :suffix2). Column and value references are substitution variables that should start with the ':' symbol. Depending on the context, substitution variables' values can be either an actual value or a column name. These values are defined in the SubstitutionMap. If a CheckExpression starts with a column reference, then ColumnSelectors in the rule should be null. If ColumnSelectors has been defined, then there should be no column reference in the left side of a condition, for example, is_between :val1 and :val2. For more information, see [Available checks](https://docs.aws.amazon.com/databrew/latest/dg/profile.data-quality-available-checks.html)
        /// This member is required.
        public var checkExpression: Swift.String?
        /// List of column selectors. Selectors can be used to select columns using a name or regular expression from the dataset. Rule will be applied to selected columns.
        public var columnSelectors: [DataBrewClientTypes.ColumnSelector]?
        /// A value that specifies whether the rule is disabled. Once a rule is disabled, a profile job will not validate it during a job run. Default value is false.
        public var disabled: Swift.Bool
        /// The name of the rule.
        /// This member is required.
        public var name: Swift.String?
        /// The map of substitution variable names to their values used in a check expression. Variable names should start with a ':' (colon). Variable values can either be actual values or column names. To differentiate between the two, column names should be enclosed in backticks, for example, ":col1": "`Column A`".
        public var substitutionMap: [Swift.String:Swift.String]?
        /// The threshold used with a non-aggregate check expression. Non-aggregate check expressions will be applied to each row in a specific column, and the threshold will be used to determine whether the validation succeeds.
        public var threshold: DataBrewClientTypes.Threshold?

        public init(
            checkExpression: Swift.String? = nil,
            columnSelectors: [DataBrewClientTypes.ColumnSelector]? = nil,
            disabled: Swift.Bool = false,
            name: Swift.String? = nil,
            substitutionMap: [Swift.String:Swift.String]? = nil,
            threshold: DataBrewClientTypes.Threshold? = nil
        )
        {
            self.checkExpression = checkExpression
            self.columnSelectors = columnSelectors
            self.disabled = disabled
            self.name = name
            self.substitutionMap = substitutionMap
            self.threshold = threshold
        }
    }

}

extension DataBrewClientTypes.RulesetItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case ruleCount = "RuleCount"
        case tags = "Tags"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if ruleCount != 0 {
            try encodeContainer.encode(ruleCount, forKey: .ruleCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let ruleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleCount) ?? 0
        ruleCount = ruleCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension DataBrewClientTypes {
    /// Contains metadata about the ruleset.
    public struct RulesetItem: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the ruleset.
        public var accountId: Swift.String?
        /// The date and time that the ruleset was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who created the ruleset.
        public var createdBy: Swift.String?
        /// The description of the ruleset.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last modified the ruleset.
        public var lastModifiedBy: Swift.String?
        /// The modification date and time of the ruleset.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name of the ruleset.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) for the ruleset.
        public var resourceArn: Swift.String?
        /// The number of rules that are defined in the ruleset.
        public var ruleCount: Swift.Int
        /// Metadata tags that have been applied to the ruleset.
        public var tags: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset is associated with.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            ruleCount: Swift.Int = 0,
            tags: [Swift.String:Swift.String]? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.ruleCount = ruleCount
            self.tags = tags
            self.targetArn = targetArn
        }
    }

}

extension DataBrewClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case bucketOwner = "BucketOwner"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let bucketOwner = self.bucketOwner {
            try encodeContainer.encode(bucketOwner, forKey: .bucketOwner)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let bucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketOwner)
        bucketOwner = bucketOwnerDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents an Amazon S3 location (bucket name, bucket owner, and object key) where DataBrew can read input data, or write output from a job.
    public struct S3Location: Swift.Equatable {
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID of the bucket owner.
        public var bucketOwner: Swift.String?
        /// The unique name of the object in the bucket.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            bucketOwner: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.bucketOwner = bucketOwner
            self.key = key
        }
    }

}

extension DataBrewClientTypes.S3TableOutputOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents options that specify how and where DataBrew writes the Amazon S3 output generated by recipe jobs.
    public struct S3TableOutputOptions: Swift.Equatable {
        /// Represents an Amazon S3 location (bucket name and object key) where DataBrew can write output from a job.
        /// This member is required.
        public var location: DataBrewClientTypes.S3Location?

        public init(
            location: DataBrewClientTypes.S3Location? = nil
        )
        {
            self.location = location
        }
    }

}

extension DataBrewClientTypes.Sample: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.SampleType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents the sample size and sampling type for DataBrew to use for interactive data analysis.
    public struct Sample: Swift.Equatable {
        /// The number of rows in the sample.
        public var size: Swift.Int?
        /// The way in which DataBrew obtains rows from a dataset.
        /// This member is required.
        public var type: DataBrewClientTypes.SampleType?

        public init(
            size: Swift.Int? = nil,
            type: DataBrewClientTypes.SampleType? = nil
        )
        {
            self.size = size
            self.type = type
        }
    }

}

extension DataBrewClientTypes {
    public enum SampleMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customRows
        case fullDataset
        case sdkUnknown(Swift.String)

        public static var allCases: [SampleMode] {
            return [
                .customRows,
                .fullDataset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customRows: return "CUSTOM_ROWS"
            case .fullDataset: return "FULL_DATASET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SampleMode(rawValue: rawValue) ?? SampleMode.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes {
    public enum SampleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case firstN
        case lastN
        case random
        case sdkUnknown(Swift.String)

        public static var allCases: [SampleType] {
            return [
                .firstN,
                .lastN,
                .random,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .firstN: return "FIRST_N"
            case .lastN: return "LAST_N"
            case .random: return "RANDOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SampleType(rawValue: rawValue) ?? SampleType.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.Schedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let cronExpression = self.cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobname0 in jobNames {
                try jobNamesContainer.encode(jobname0)
            }
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
        let jobNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[Swift.String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [Swift.String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents one or more dates and times when a job is to run.
    public struct Schedule: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the schedule.
        public var accountId: Swift.String?
        /// The date and time that the schedule was created.
        public var createDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the user who created the schedule.
        public var createdBy: Swift.String?
        /// The dates and times when the job is to run. For more information, see [Cron expressions](https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html) in the Glue DataBrew Developer Guide.
        public var cronExpression: Swift.String?
        /// A list of jobs to be run, according to the schedule.
        public var jobNames: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the user who last modified the schedule.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the schedule was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name of the schedule.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schedule.
        public var resourceArn: Swift.String?
        /// Metadata tags that have been applied to the schedule.
        public var tags: [Swift.String:Swift.String]?

        public init(
            accountId: Swift.String? = nil,
            createDate: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            cronExpression: Swift.String? = nil,
            jobNames: [Swift.String]? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.createDate = createDate
            self.createdBy = createdBy
            self.cronExpression = cronExpression
            self.jobNames = jobNames
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.resourceArn = resourceArn
            self.tags = tags
        }
    }

}

extension SendProjectSessionActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendProjectSessionActionInput(name: \(Swift.String(describing: name)), preview: \(Swift.String(describing: preview)), recipeStep: \(Swift.String(describing: recipeStep)), stepIndex: \(Swift.String(describing: stepIndex)), viewFrame: \(Swift.String(describing: viewFrame)), clientSessionId: \"CONTENT_REDACTED\")"}
}

extension SendProjectSessionActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientSessionId = "ClientSessionId"
        case preview = "Preview"
        case recipeStep = "RecipeStep"
        case stepIndex = "StepIndex"
        case viewFrame = "ViewFrame"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientSessionId = self.clientSessionId {
            try encodeContainer.encode(clientSessionId, forKey: .clientSessionId)
        }
        if let preview = self.preview {
            try encodeContainer.encode(preview, forKey: .preview)
        }
        if let recipeStep = self.recipeStep {
            try encodeContainer.encode(recipeStep, forKey: .recipeStep)
        }
        if let stepIndex = self.stepIndex {
            try encodeContainer.encode(stepIndex, forKey: .stepIndex)
        }
        if let viewFrame = self.viewFrame {
            try encodeContainer.encode(viewFrame, forKey: .viewFrame)
        }
    }
}

extension SendProjectSessionActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/projects/\(name.urlPercentEncoding())/sendProjectSessionAction"
    }
}

public struct SendProjectSessionActionInput: Swift.Equatable {
    /// A unique identifier for an interactive session that's currently open and ready for work. The action will be performed on this session.
    public var clientSessionId: Swift.String?
    /// The name of the project to apply the action to.
    /// This member is required.
    public var name: Swift.String?
    /// If true, the result of the recipe step will be returned, but not applied.
    public var preview: Swift.Bool?
    /// Represents a single step from a DataBrew recipe to be performed.
    public var recipeStep: DataBrewClientTypes.RecipeStep?
    /// The index from which to preview a step. This index is used to preview the result of steps that have already been applied, so that the resulting view frame is from earlier in the view frame stack.
    public var stepIndex: Swift.Int?
    /// Represents the data being transformed during an action.
    public var viewFrame: DataBrewClientTypes.ViewFrame?

    public init(
        clientSessionId: Swift.String? = nil,
        name: Swift.String? = nil,
        preview: Swift.Bool? = nil,
        recipeStep: DataBrewClientTypes.RecipeStep? = nil,
        stepIndex: Swift.Int? = nil,
        viewFrame: DataBrewClientTypes.ViewFrame? = nil
    )
    {
        self.clientSessionId = clientSessionId
        self.name = name
        self.preview = preview
        self.recipeStep = recipeStep
        self.stepIndex = stepIndex
        self.viewFrame = viewFrame
    }
}

struct SendProjectSessionActionInputBody: Swift.Equatable {
    let preview: Swift.Bool?
    let recipeStep: DataBrewClientTypes.RecipeStep?
    let stepIndex: Swift.Int?
    let clientSessionId: Swift.String?
    let viewFrame: DataBrewClientTypes.ViewFrame?
}

extension SendProjectSessionActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientSessionId = "ClientSessionId"
        case preview = "Preview"
        case recipeStep = "RecipeStep"
        case stepIndex = "StepIndex"
        case viewFrame = "ViewFrame"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preview)
        preview = previewDecoded
        let recipeStepDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.RecipeStep.self, forKey: .recipeStep)
        recipeStep = recipeStepDecoded
        let stepIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stepIndex)
        stepIndex = stepIndexDecoded
        let clientSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSessionId)
        clientSessionId = clientSessionIdDecoded
        let viewFrameDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ViewFrame.self, forKey: .viewFrame)
        viewFrame = viewFrameDecoded
    }
}

extension SendProjectSessionActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendProjectSessionActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionId = output.actionId
            self.name = output.name
            self.result = output.result
        } else {
            self.actionId = nil
            self.name = nil
            self.result = nil
        }
    }
}

public struct SendProjectSessionActionOutput: Swift.Equatable {
    /// A unique identifier for the action that was performed.
    public var actionId: Swift.Int?
    /// The name of the project that was affected by the action.
    /// This member is required.
    public var name: Swift.String?
    /// A message indicating the result of performing the action.
    public var result: Swift.String?

    public init(
        actionId: Swift.Int? = nil,
        name: Swift.String? = nil,
        result: Swift.String? = nil
    )
    {
        self.actionId = actionId
        self.name = name
        self.result = result
    }
}

struct SendProjectSessionActionOutputBody: Swift.Equatable {
    let result: Swift.String?
    let name: Swift.String?
    let actionId: Swift.Int?
}

extension SendProjectSessionActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case name = "Name"
        case result = "Result"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

enum SendProjectSessionActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataBrewClientTypes {
    public enum SessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assigned
        case failed
        case initializing
        case provisioning
        case ready
        case recycling
        case rotating
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .assigned,
                .failed,
                .initializing,
                .provisioning,
                .ready,
                .recycling,
                .rotating,
                .terminated,
                .terminating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .provisioning: return "PROVISIONING"
            case .ready: return "READY"
            case .recycling: return "RECYCLING"
            case .rotating: return "ROTATING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionStatus(rawValue: rawValue) ?? SessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes {
    public enum Source: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case database
        case datacatalog
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .database,
                .datacatalog,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .database: return "DATABASE"
            case .datacatalog: return "DATA-CATALOG"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Source(rawValue: rawValue) ?? Source.sdkUnknown(rawValue)
        }
    }
}

extension StartJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())/startJobRun"
    }
}

public struct StartJobRunInput: Swift.Equatable {
    /// The name of the job to be run.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartJobRunInputBody: Swift.Equatable {
}

extension StartJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.runId = output.runId
        } else {
            self.runId = nil
        }
    }
}

public struct StartJobRunOutput: Swift.Equatable {
    /// A system-generated identifier for this particular job run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

struct StartJobRunOutputBody: Swift.Equatable {
    let runId: Swift.String?
}

extension StartJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runId = "RunId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

enum StartJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartProjectSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeControl = "AssumeControl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assumeControl = self.assumeControl {
            try encodeContainer.encode(assumeControl, forKey: .assumeControl)
        }
    }
}

extension StartProjectSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/projects/\(name.urlPercentEncoding())/startProjectSession"
    }
}

public struct StartProjectSessionInput: Swift.Equatable {
    /// A value that, if true, enables you to take control of a session, even if a different client is currently accessing the project.
    public var assumeControl: Swift.Bool?
    /// The name of the project to act upon.
    /// This member is required.
    public var name: Swift.String?

    public init(
        assumeControl: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.assumeControl = assumeControl
        self.name = name
    }
}

struct StartProjectSessionInputBody: Swift.Equatable {
    let assumeControl: Swift.Bool?
}

extension StartProjectSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeControl = "AssumeControl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumeControlDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assumeControl)
        assumeControl = assumeControlDecoded
    }
}

extension StartProjectSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartProjectSessionOutput(name: \(Swift.String(describing: name)), clientSessionId: \"CONTENT_REDACTED\")"}
}

extension StartProjectSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartProjectSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientSessionId = output.clientSessionId
            self.name = output.name
        } else {
            self.clientSessionId = nil
            self.name = nil
        }
    }
}

public struct StartProjectSessionOutput: Swift.Equatable {
    /// A system-generated identifier for the session.
    public var clientSessionId: Swift.String?
    /// The name of the project to be acted upon.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientSessionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientSessionId = clientSessionId
        self.name = name
    }
}

struct StartProjectSessionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let clientSessionId: Swift.String?
}

extension StartProjectSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientSessionId = "ClientSessionId"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSessionId)
        clientSessionId = clientSessionIdDecoded
    }
}

enum StartProjectSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.StatisticOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case statistic = "Statistic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statistic)
        statistic = statisticDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in parametersContainer {
                if let parametervalue0 = parametervalue0 {
                    parametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DataBrewClientTypes {
    /// Override of a particular evaluation for a profile job.
    public struct StatisticOverride: Swift.Equatable {
        /// A map that includes overrides of an evaluations parameters.
        /// This member is required.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of an evaluation
        /// This member is required.
        public var statistic: Swift.String?

        public init(
            parameters: [Swift.String:Swift.String]? = nil,
            statistic: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.statistic = statistic
        }
    }

}

extension DataBrewClientTypes.StatisticsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includedStatistics = "IncludedStatistics"
        case overrides = "Overrides"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includedStatistics = includedStatistics {
            var includedStatisticsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includedStatistics)
            for statistic0 in includedStatistics {
                try includedStatisticsContainer.encode(statistic0)
            }
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for statisticoverride0 in overrides {
                try overridesContainer.encode(statisticoverride0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includedStatisticsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includedStatistics)
        var includedStatisticsDecoded0:[Swift.String]? = nil
        if let includedStatisticsContainer = includedStatisticsContainer {
            includedStatisticsDecoded0 = [Swift.String]()
            for string0 in includedStatisticsContainer {
                if let string0 = string0 {
                    includedStatisticsDecoded0?.append(string0)
                }
            }
        }
        includedStatistics = includedStatisticsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.StatisticOverride?].self, forKey: .overrides)
        var overridesDecoded0:[DataBrewClientTypes.StatisticOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [DataBrewClientTypes.StatisticOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension DataBrewClientTypes {
    /// Configuration of evaluations for a profile job. This configuration can be used to select evaluations and override the parameters of selected evaluations.
    public struct StatisticsConfiguration: Swift.Equatable {
        /// List of included evaluations. When the list is undefined, all supported evaluations will be included.
        public var includedStatistics: [Swift.String]?
        /// List of overrides for evaluations.
        public var overrides: [DataBrewClientTypes.StatisticOverride]?

        public init(
            includedStatistics: [Swift.String]? = nil,
            overrides: [DataBrewClientTypes.StatisticOverride]? = nil
        )
        {
            self.includedStatistics = includedStatistics
            self.overrides = overrides
        }
    }

}

extension StopJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let runId = runId else {
            return nil
        }
        return "/jobs/\(name.urlPercentEncoding())/jobRun/\(runId.urlPercentEncoding())/stopJobRun"
    }
}

public struct StopJobRunInput: Swift.Equatable {
    /// The name of the job to be stopped.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the job run to be stopped.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        name: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct StopJobRunInputBody: Swift.Equatable {
}

extension StopJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.runId = output.runId
        } else {
            self.runId = nil
        }
    }
}

public struct StopJobRunOutput: Swift.Equatable {
    /// The ID of the job run that you stopped.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        runId: Swift.String? = nil
    )
    {
        self.runId = runId
    }
}

struct StopJobRunOutputBody: Swift.Equatable {
    let runId: Swift.String?
}

extension StopJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runId = "RunId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

enum StopJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The DataBrew resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DataBrew, you can tag a dataset, a job, a project, or a recipe.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.Threshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ThresholdType.self, forKey: .type)
        type = typeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ThresholdUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension DataBrewClientTypes {
    /// The threshold used with a non-aggregate check expression. The non-aggregate check expression will be applied to each row in a specific column. Then the threshold will be used to determine whether the validation succeeds.
    public struct Threshold: Swift.Equatable {
        /// The type of a threshold. Used for comparison of an actual count of rows that satisfy the rule to the threshold value.
        public var type: DataBrewClientTypes.ThresholdType?
        /// Unit of threshold value. Can be either a COUNT or PERCENTAGE of the full sample size used for validation.
        public var unit: DataBrewClientTypes.ThresholdUnit?
        /// The value of a threshold.
        /// This member is required.
        public var value: Swift.Double

        public init(
            type: DataBrewClientTypes.ThresholdType? = nil,
            unit: DataBrewClientTypes.ThresholdUnit? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.type = type
            self.unit = unit
            self.value = value
        }
    }

}

extension DataBrewClientTypes {
    public enum ThresholdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greaterThan
        case greaterThanOrEqual
        case lessThan
        case lessThanOrEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdType] {
            return [
                .greaterThan,
                .greaterThanOrEqual,
                .lessThan,
                .lessThanOrEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThresholdType(rawValue: rawValue) ?? ThresholdType.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes {
    public enum ThresholdUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdUnit] {
            return [
                .count,
                .percentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThresholdUnit(rawValue: rawValue) ?? ThresholdUnit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// A DataBrew resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys (names) of one or more tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case pathOptions = "PathOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let pathOptions = self.pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
    }
}

extension UpdateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/datasets/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDatasetInput: Swift.Equatable {
    /// The file format of a dataset that is created from an Amazon S3 file or folder.
    public var format: DataBrewClientTypes.InputFormat?
    /// Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.
    public var formatOptions: DataBrewClientTypes.FormatOptions?
    /// Represents information on how DataBrew can find data, in either the Glue Data Catalog or Amazon S3.
    /// This member is required.
    public var input: DataBrewClientTypes.Input?
    /// The name of the dataset to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// A set of options that defines how DataBrew interprets an Amazon S3 path of the dataset.
    public var pathOptions: DataBrewClientTypes.PathOptions?

    public init(
        format: DataBrewClientTypes.InputFormat? = nil,
        formatOptions: DataBrewClientTypes.FormatOptions? = nil,
        input: DataBrewClientTypes.Input? = nil,
        name: Swift.String? = nil,
        pathOptions: DataBrewClientTypes.PathOptions? = nil
    )
    {
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.name = name
        self.pathOptions = pathOptions
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    let format: DataBrewClientTypes.InputFormat?
    let formatOptions: DataBrewClientTypes.FormatOptions?
    let input: DataBrewClientTypes.Input?
    let pathOptions: DataBrewClientTypes.PathOptions?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case pathOptions = "PathOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Input.self, forKey: .input)
        input = inputDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
    }
}

extension UpdateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateDatasetOutput: Swift.Equatable {
    /// The name of the dataset that you updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateDatasetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
        case validationConfigurations = "ValidationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = self.jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let validationConfigurations = validationConfigurations {
            var validationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationConfigurations)
            for validationconfiguration0 in validationConfigurations {
                try validationConfigurationsContainer.encode(validationconfiguration0)
            }
        }
    }
}

extension UpdateProfileJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/profileJobs/\(name.urlPercentEncoding())"
    }
}

public struct UpdateProfileJobInput: Swift.Equatable {
    /// Configuration for profile jobs. Used to select columns, do evaluations, and override default parameters of evaluations. When configuration is null, the profile job will run with default settings.
    public var configuration: DataBrewClientTypes.ProfileConfiguration?
    /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    public var encryptionKeyArn: Swift.String?
    /// The encryption mode for the job, which can be one of the following:
    ///
    /// * SSE-KMS - Server-side encryption with keys managed by KMS.
    ///
    /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    public var encryptionMode: DataBrewClientTypes.EncryptionMode?
    /// Sample configuration for Profile Jobs only. Determines the number of rows on which the Profile job will be executed. If a JobSample value is not provided for profile jobs, the default value will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
    public var jobSample: DataBrewClientTypes.JobSample?
    /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// The maximum number of compute nodes that DataBrew can use when the job processes data.
    public var maxCapacity: Swift.Int?
    /// The maximum number of times to retry the job after a job run fails.
    public var maxRetries: Swift.Int?
    /// The name of the job to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// Represents an Amazon S3 location (bucket name, bucket owner, and object key) where DataBrew can read input data, or write output from a job.
    /// This member is required.
    public var outputLocation: DataBrewClientTypes.S3Location?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    public var timeout: Swift.Int?
    /// List of validation configurations that are applied to the profile job.
    public var validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?

    public init(
        configuration: DataBrewClientTypes.ProfileConfiguration? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
        jobSample: DataBrewClientTypes.JobSample? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        maxCapacity: Swift.Int? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputLocation: DataBrewClientTypes.S3Location? = nil,
        roleArn: Swift.String? = nil,
        timeout: Swift.Int? = nil,
        validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]? = nil
    )
    {
        self.configuration = configuration
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputLocation = outputLocation
        self.roleArn = roleArn
        self.timeout = timeout
        self.validationConfigurations = validationConfigurations
    }
}

struct UpdateProfileJobInputBody: Swift.Equatable {
    let configuration: DataBrewClientTypes.ProfileConfiguration?
    let encryptionKeyArn: Swift.String?
    let encryptionMode: DataBrewClientTypes.EncryptionMode?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let maxCapacity: Swift.Int?
    let maxRetries: Swift.Int?
    let outputLocation: DataBrewClientTypes.S3Location?
    let validationConfigurations: [DataBrewClientTypes.ValidationConfiguration]?
    let roleArn: Swift.String?
    let timeout: Swift.Int?
    let jobSample: DataBrewClientTypes.JobSample?
}

extension UpdateProfileJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
        case validationConfigurations = "ValidationConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ProfileConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let validationConfigurationsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.ValidationConfiguration?].self, forKey: .validationConfigurations)
        var validationConfigurationsDecoded0:[DataBrewClientTypes.ValidationConfiguration]? = nil
        if let validationConfigurationsContainer = validationConfigurationsContainer {
            validationConfigurationsDecoded0 = [DataBrewClientTypes.ValidationConfiguration]()
            for structure0 in validationConfigurationsContainer {
                if let structure0 = structure0 {
                    validationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        validationConfigurations = validationConfigurationsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension UpdateProfileJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateProfileJobOutput: Swift.Equatable {
    /// The name of the job that was updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateProfileJobOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateProfileJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateProfileJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case sample = "Sample"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = self.sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/projects/\(name.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The name of the project to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to be assumed for this request.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Represents the sample size and sampling type for DataBrew to use for interactive data analysis.
    public var sample: DataBrewClientTypes.Sample?

    public init(
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sample: DataBrewClientTypes.Sample? = nil
    )
    {
        self.name = name
        self.roleArn = roleArn
        self.sample = sample
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let sample: DataBrewClientTypes.Sample?
    let roleArn: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case sample = "Sample"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
        } else {
            self.lastModifiedDate = nil
            self.name = nil
        }
    }
}

public struct UpdateProjectOutput: Swift.Equatable {
    /// The date and time that the project was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the project that you updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.lastModifiedDate = lastModifiedDate
        self.name = name
    }
}

struct UpdateProjectOutputBody: Swift.Equatable {
    let lastModifiedDate: ClientRuntime.Date?
    let name: Swift.String?
}

extension UpdateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case steps = "Steps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipestep0 in steps {
                try stepsContainer.encode(recipestep0)
            }
        }
    }
}

extension UpdateRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/recipes/\(name.urlPercentEncoding())"
    }
}

public struct UpdateRecipeInput: Swift.Equatable {
    /// A description of the recipe.
    public var description: Swift.String?
    /// The name of the recipe to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// One or more steps to be performed by the recipe. Each step consists of an action, and the conditions under which the action should succeed.
    public var steps: [DataBrewClientTypes.RecipeStep]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        steps: [DataBrewClientTypes.RecipeStep]? = nil
    )
    {
        self.description = description
        self.name = name
        self.steps = steps
    }
}

struct UpdateRecipeInputBody: Swift.Equatable {
    let description: Swift.String?
    let steps: [DataBrewClientTypes.RecipeStep]?
}

extension UpdateRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case steps = "Steps"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[DataBrewClientTypes.RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DataBrewClientTypes.RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension UpdateRecipeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputs = "Outputs"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCatalogOutputs = dataCatalogOutputs {
            var dataCatalogOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataCatalogOutputs)
            for datacatalogoutput0 in dataCatalogOutputs {
                try dataCatalogOutputsContainer.encode(datacatalogoutput0)
            }
        }
        if let databaseOutputs = databaseOutputs {
            var databaseOutputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseOutputs)
            for databaseoutput0 in databaseOutputs {
                try databaseOutputsContainer.encode(databaseoutput0)
            }
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let logSubscription = self.logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let maxCapacity = self.maxCapacity {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if let maxRetries = self.maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

extension UpdateRecipeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/recipeJobs/\(name.urlPercentEncoding())"
    }
}

public struct UpdateRecipeJobInput: Swift.Equatable {
    /// One or more artifacts that represent the Glue Data Catalog output from running the job.
    public var dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    /// Represents a list of JDBC database output objects which defines the output destination for a DataBrew recipe job to write into.
    public var databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    /// The Amazon Resource Name (ARN) of an encryption key that is used to protect the job.
    public var encryptionKeyArn: Swift.String?
    /// The encryption mode for the job, which can be one of the following:
    ///
    /// * SSE-KMS - Server-side encryption with keys managed by KMS.
    ///
    /// * SSE-S3 - Server-side encryption with keys managed by Amazon S3.
    public var encryptionMode: DataBrewClientTypes.EncryptionMode?
    /// Enables or disables Amazon CloudWatch logging for the job. If logging is enabled, CloudWatch writes one log stream for each job run.
    public var logSubscription: DataBrewClientTypes.LogSubscription?
    /// The maximum number of nodes that DataBrew can consume when the job processes data.
    public var maxCapacity: Swift.Int?
    /// The maximum number of times to retry the job after a job run fails.
    public var maxRetries: Swift.Int?
    /// The name of the job to update.
    /// This member is required.
    public var name: Swift.String?
    /// One or more artifacts that represent the output from running the job.
    public var outputs: [DataBrewClientTypes.Output]?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be assumed when DataBrew runs the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's timeout in minutes. A job that attempts to run longer than this timeout period ends with a status of TIMEOUT.
    public var timeout: Swift.Int?

    public init(
        dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]? = nil,
        databaseOutputs: [DataBrewClientTypes.DatabaseOutput]? = nil,
        encryptionKeyArn: Swift.String? = nil,
        encryptionMode: DataBrewClientTypes.EncryptionMode? = nil,
        logSubscription: DataBrewClientTypes.LogSubscription? = nil,
        maxCapacity: Swift.Int? = nil,
        maxRetries: Swift.Int? = nil,
        name: Swift.String? = nil,
        outputs: [DataBrewClientTypes.Output]? = nil,
        roleArn: Swift.String? = nil,
        timeout: Swift.Int? = nil
    )
    {
        self.dataCatalogOutputs = dataCatalogOutputs
        self.databaseOutputs = databaseOutputs
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.roleArn = roleArn
        self.timeout = timeout
    }
}

struct UpdateRecipeJobInputBody: Swift.Equatable {
    let encryptionKeyArn: Swift.String?
    let encryptionMode: DataBrewClientTypes.EncryptionMode?
    let logSubscription: DataBrewClientTypes.LogSubscription?
    let maxCapacity: Swift.Int?
    let maxRetries: Swift.Int?
    let outputs: [DataBrewClientTypes.Output]?
    let dataCatalogOutputs: [DataBrewClientTypes.DataCatalogOutput]?
    let databaseOutputs: [DataBrewClientTypes.DatabaseOutput]?
    let roleArn: Swift.String?
    let timeout: Swift.Int?
}

extension UpdateRecipeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogOutputs = "DataCatalogOutputs"
        case databaseOutputs = "DatabaseOutputs"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputs = "Outputs"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[DataBrewClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [DataBrewClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let dataCatalogOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DataCatalogOutput?].self, forKey: .dataCatalogOutputs)
        var dataCatalogOutputsDecoded0:[DataBrewClientTypes.DataCatalogOutput]? = nil
        if let dataCatalogOutputsContainer = dataCatalogOutputsContainer {
            dataCatalogOutputsDecoded0 = [DataBrewClientTypes.DataCatalogOutput]()
            for structure0 in dataCatalogOutputsContainer {
                if let structure0 = structure0 {
                    dataCatalogOutputsDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogOutputs = dataCatalogOutputsDecoded0
        let databaseOutputsContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.DatabaseOutput?].self, forKey: .databaseOutputs)
        var databaseOutputsDecoded0:[DataBrewClientTypes.DatabaseOutput]? = nil
        if let databaseOutputsContainer = databaseOutputsContainer {
            databaseOutputsDecoded0 = [DataBrewClientTypes.DatabaseOutput]()
            for structure0 in databaseOutputsContainer {
                if let structure0 = structure0 {
                    databaseOutputsDecoded0?.append(structure0)
                }
            }
        }
        databaseOutputs = databaseOutputsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension UpdateRecipeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecipeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateRecipeJobOutput: Swift.Equatable {
    /// The name of the job that you updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateRecipeJobOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateRecipeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateRecipeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateRecipeOutput: Swift.Equatable {
    /// The name of the recipe that was updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateRecipeOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRulesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension UpdateRulesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/rulesets/\(name.urlPercentEncoding())"
    }
}

public struct UpdateRulesetInput: Swift.Equatable {
    /// The description of the ruleset.
    public var description: Swift.String?
    /// The name of the ruleset to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// A list of rules that are defined with the ruleset. A rule includes one or more checks to be validated on a DataBrew dataset.
    /// This member is required.
    public var rules: [DataBrewClientTypes.Rule]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        rules: [DataBrewClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.name = name
        self.rules = rules
    }
}

struct UpdateRulesetInputBody: Swift.Equatable {
    let description: Swift.String?
    let rules: [DataBrewClientTypes.Rule]?
}

extension UpdateRulesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case rules = "Rules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([DataBrewClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[DataBrewClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DataBrewClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension UpdateRulesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRulesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateRulesetOutput: Swift.Equatable {
    /// The name of the updated ruleset.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateRulesetOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateRulesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateRulesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = self.cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobname0 in jobNames {
                try jobNamesContainer.encode(jobname0)
            }
        }
    }
}

extension UpdateScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct UpdateScheduleInput: Swift.Equatable {
    /// The date or dates and time or times when the jobs are to be run. For more information, see [Cron expressions](https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html) in the Glue DataBrew Developer Guide.
    /// This member is required.
    public var cronExpression: Swift.String?
    /// The name or names of one or more jobs to be run for this schedule.
    public var jobNames: [Swift.String]?
    /// The name of the schedule to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        cronExpression: Swift.String? = nil,
        jobNames: [Swift.String]? = nil,
        name: Swift.String? = nil
    )
    {
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.name = name
    }
}

struct UpdateScheduleInputBody: Swift.Equatable {
    let jobNames: [Swift.String]?
    let cronExpression: Swift.String?
}

extension UpdateScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[Swift.String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [Swift.String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
    }
}

extension UpdateScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateScheduleOutput: Swift.Equatable {
    /// The name of the schedule that was updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateScheduleOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataBrewClientTypes.ValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rulesetArn = "RulesetArn"
        case validationMode = "ValidationMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rulesetArn = self.rulesetArn {
            try encodeContainer.encode(rulesetArn, forKey: .rulesetArn)
        }
        if let validationMode = self.validationMode {
            try encodeContainer.encode(validationMode.rawValue, forKey: .validationMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rulesetArn)
        rulesetArn = rulesetArnDecoded
        let validationModeDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.ValidationMode.self, forKey: .validationMode)
        validationMode = validationModeDecoded
    }
}

extension DataBrewClientTypes {
    /// Configuration for data quality validation. Used to select the Rulesets and Validation Mode to be used in the profile job. When ValidationConfiguration is null, the profile job will run without data quality validation.
    public struct ValidationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the ruleset to be validated in the profile job. The TargetArn of the selected ruleset should be the same as the Amazon Resource Name (ARN) of the dataset that is associated with the profile job.
        /// This member is required.
        public var rulesetArn: Swift.String?
        /// Mode of data quality validation. Default mode is CHECK_ALL which verifies all rules defined in the selected ruleset.
        public var validationMode: DataBrewClientTypes.ValidationMode?

        public init(
            rulesetArn: Swift.String? = nil,
            validationMode: DataBrewClientTypes.ValidationMode? = nil
        )
        {
            self.rulesetArn = rulesetArn
            self.validationMode = validationMode
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters for this request failed validation.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataBrewClientTypes {
    public enum ValidationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checkAll
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationMode] {
            return [
                .checkAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checkAll: return "CHECK_ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationMode(rawValue: rawValue) ?? ValidationMode.sdkUnknown(rawValue)
        }
    }
}

extension DataBrewClientTypes.ViewFrame: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analytics = "Analytics"
        case columnRange = "ColumnRange"
        case hiddenColumns = "HiddenColumns"
        case rowRange = "RowRange"
        case startColumnIndex = "StartColumnIndex"
        case startRowIndex = "StartRowIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analytics = self.analytics {
            try encodeContainer.encode(analytics.rawValue, forKey: .analytics)
        }
        if let columnRange = self.columnRange {
            try encodeContainer.encode(columnRange, forKey: .columnRange)
        }
        if let hiddenColumns = hiddenColumns {
            var hiddenColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hiddenColumns)
            for columnname0 in hiddenColumns {
                try hiddenColumnsContainer.encode(columnname0)
            }
        }
        if let rowRange = self.rowRange {
            try encodeContainer.encode(rowRange, forKey: .rowRange)
        }
        if let startColumnIndex = self.startColumnIndex {
            try encodeContainer.encode(startColumnIndex, forKey: .startColumnIndex)
        }
        if let startRowIndex = self.startRowIndex {
            try encodeContainer.encode(startRowIndex, forKey: .startRowIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startColumnIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startColumnIndex)
        startColumnIndex = startColumnIndexDecoded
        let columnRangeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnRange)
        columnRange = columnRangeDecoded
        let hiddenColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hiddenColumns)
        var hiddenColumnsDecoded0:[Swift.String]? = nil
        if let hiddenColumnsContainer = hiddenColumnsContainer {
            hiddenColumnsDecoded0 = [Swift.String]()
            for string0 in hiddenColumnsContainer {
                if let string0 = string0 {
                    hiddenColumnsDecoded0?.append(string0)
                }
            }
        }
        hiddenColumns = hiddenColumnsDecoded0
        let startRowIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startRowIndex)
        startRowIndex = startRowIndexDecoded
        let rowRangeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowRange)
        rowRange = rowRangeDecoded
        let analyticsDecoded = try containerValues.decodeIfPresent(DataBrewClientTypes.AnalyticsMode.self, forKey: .analytics)
        analytics = analyticsDecoded
    }
}

extension DataBrewClientTypes {
    /// Represents the data being transformed during an action.
    public struct ViewFrame: Swift.Equatable {
        /// Controls if analytics computation is enabled or disabled. Enabled by default.
        public var analytics: DataBrewClientTypes.AnalyticsMode?
        /// The number of columns to include in the view frame, beginning with the StartColumnIndex value and ignoring any columns in the HiddenColumns list.
        public var columnRange: Swift.Int?
        /// A list of columns to hide in the view frame.
        public var hiddenColumns: [Swift.String]?
        /// The number of rows to include in the view frame, beginning with the StartRowIndex value.
        public var rowRange: Swift.Int?
        /// The starting index for the range of columns to return in the view frame.
        /// This member is required.
        public var startColumnIndex: Swift.Int?
        /// The starting index for the range of rows to return in the view frame.
        public var startRowIndex: Swift.Int?

        public init(
            analytics: DataBrewClientTypes.AnalyticsMode? = nil,
            columnRange: Swift.Int? = nil,
            hiddenColumns: [Swift.String]? = nil,
            rowRange: Swift.Int? = nil,
            startColumnIndex: Swift.Int? = nil,
            startRowIndex: Swift.Int? = nil
        )
        {
            self.analytics = analytics
            self.columnRange = columnRange
            self.hiddenColumns = hiddenColumns
            self.rowRange = rowRange
            self.startColumnIndex = startColumnIndex
            self.startRowIndex = startRowIndex
        }
    }

}
