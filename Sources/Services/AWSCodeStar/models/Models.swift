// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AssociateTeamMemberInput {

    static func urlPathProvider(_ value: AssociateTeamMemberInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateTeamMemberInput {

    static func write(value: AssociateTeamMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["projectId"].write(value.projectId)
        try writer["projectRole"].write(value.projectRole)
        try writer["remoteAccessAllowed"].write(value.remoteAccessAllowed)
        try writer["userArn"].write(value.userArn)
    }
}

public struct AssociateTeamMemberInput {
    /// A user- or system-generated token that identifies the entity that requested the team member association to the project. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The ID of the project to which you will add the IAM user.
    /// This member is required.
    public var projectId: Swift.String?
    /// The AWS CodeStar project role that will apply to this user. This role determines what actions a user can take in an AWS CodeStar project.
    /// This member is required.
    public var projectRole: Swift.String?
    /// Whether the team member is allowed to use an SSH public/private key pair to remotely access project resources, for example Amazon EC2 instances.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the IAM user you want to add to the AWS CodeStar project.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

extension AssociateTeamMemberOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateTeamMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateTeamMemberOutput()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        return value
    }
}

public struct AssociateTeamMemberOutput {
    /// The user- or system-generated token from the initial request that can be used to repeat the request.
    public var clientRequestToken: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
    }
}

enum AssociateTeamMemberOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProjectConfigurationException": return try ProjectConfigurationException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "TeamMemberAlreadyAssociatedException": return try TeamMemberAlreadyAssociatedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodeStarClientTypes.Code {

    static func write(value: CodeStarClientTypes.Code?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination, with: CodeStarClientTypes.CodeDestination.write(value:to:))
        try writer["source"].write(value.source, with: CodeStarClientTypes.CodeSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.Code {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.Code()
        value.source = try reader["source"].readIfPresent(with: CodeStarClientTypes.CodeSource.read(from:))
        value.destination = try reader["destination"].readIfPresent(with: CodeStarClientTypes.CodeDestination.read(from:))
        return value
    }
}

extension CodeStarClientTypes {
    /// Location and destination information about the source code files provided with the project request. The source code is uploaded to the new project source repository after project creation.
    public struct Code {
        /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
        /// This member is required.
        public var destination: CodeStarClientTypes.CodeDestination?
        /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.CodeSource?

        public init(
            destination: CodeStarClientTypes.CodeDestination? = nil,
            source: CodeStarClientTypes.CodeSource? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeStarClientTypes.CodeCommitCodeDestination {

    static func write(value: CodeStarClientTypes.CodeCommitCodeDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.CodeCommitCodeDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.CodeCommitCodeDestination()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct CodeCommitCodeDestination {
        /// The name of the AWS CodeCommit repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodeStarClientTypes.CodeDestination {

    static func write(value: CodeStarClientTypes.CodeDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["codeCommit"].write(value.codeCommit, with: CodeStarClientTypes.CodeCommitCodeDestination.write(value:to:))
        try writer["gitHub"].write(value.gitHub, with: CodeStarClientTypes.GitHubCodeDestination.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.CodeDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.CodeDestination()
        value.codeCommit = try reader["codeCommit"].readIfPresent(with: CodeStarClientTypes.CodeCommitCodeDestination.read(from:))
        value.gitHub = try reader["gitHub"].readIfPresent(with: CodeStarClientTypes.GitHubCodeDestination.read(from:))
        return value
    }
}

extension CodeStarClientTypes {
    /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
    public struct CodeDestination {
        /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var codeCommit: CodeStarClientTypes.CodeCommitCodeDestination?
        /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var gitHub: CodeStarClientTypes.GitHubCodeDestination?

        public init(
            codeCommit: CodeStarClientTypes.CodeCommitCodeDestination? = nil,
            gitHub: CodeStarClientTypes.GitHubCodeDestination? = nil
        )
        {
            self.codeCommit = codeCommit
            self.gitHub = gitHub
        }
    }

}

extension CodeStarClientTypes.CodeSource {

    static func write(value: CodeStarClientTypes.CodeSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3"].write(value.s3, with: CodeStarClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.CodeSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.CodeSource()
        value.s3 = try reader["s3"].readIfPresent(with: CodeStarClientTypes.S3Location.read(from:))
        return value
    }
}

extension CodeStarClientTypes {
    /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
    public struct CodeSource {
        /// Information about the Amazon S3 location where the source code files provided with the project request are stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init(
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

public enum CodeStarClientTypes {}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Another modification is being made. That modification must complete before you can make your change.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), id: \(Swift.String(describing: id)), sourceCode: \(Swift.String(describing: sourceCode)), tags: \(Swift.String(describing: tags)), toolchain: \(Swift.String(describing: toolchain)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["sourceCode"].writeList(value.sourceCode, memberWritingClosure: CodeStarClientTypes.Code.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["toolchain"].write(value.toolchain, with: CodeStarClientTypes.Toolchain.write(value:to:))
    }
}

public struct CreateProjectInput {
    /// A user- or system-generated token that identifies the entity that requested project creation. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project to be created in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?
    /// The display name for the project to be created in AWS CodeStar.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Code objects submitted with the project request. If this parameter is specified, the request must also include the toolchain parameter.
    public var sourceCode: [CodeStarClientTypes.Code]?
    /// The tags created for the project.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the toolchain template file submitted with the project request. If this parameter is specified, the request must also include the sourceCode parameter.
    public var toolchain: CodeStarClientTypes.Toolchain?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceCode: [CodeStarClientTypes.Code]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        toolchain: CodeStarClientTypes.Toolchain? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.id = id
        self.name = name
        self.sourceCode = sourceCode
        self.tags = tags
        self.toolchain = toolchain
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.projectTemplateId = try reader["projectTemplateId"].readIfPresent()
        return value
    }
}

public struct CreateProjectOutput {
    /// The Amazon Resource Name (ARN) of the created project.
    /// This member is required.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var projectTemplateId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        id: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.id = id
        self.projectTemplateId = projectTemplateId
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProjectAlreadyExistsException": return try ProjectAlreadyExistsException.makeError(baseError: baseError)
            case "ProjectConfigurationException": return try ProjectConfigurationException.makeError(baseError: baseError)
            case "ProjectCreationFailedException": return try ProjectCreationFailedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileInput {

    static func urlPathProvider(_ value: CreateUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserProfileInput {

    static func write(value: CreateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["emailAddress"].write(value.emailAddress)
        try writer["sshPublicKey"].write(value.sshPublicKey)
        try writer["userArn"].write(value.userArn)
    }
}

public struct CreateUserProfileInput {
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var displayName: Swift.String?
    /// The email address that will be displayed as part of the user's profile in AWS CodeStar.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

extension CreateUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserProfileOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.sshPublicKey = try reader["sshPublicKey"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        return value
    }
}

public struct CreateUserProfileOutput {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

enum CreateUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UserProfileAlreadyExistsException": return try UserProfileAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProjectInput {

    static func write(value: DeleteProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["deleteStack"].write(value.deleteStack)
        try writer["id"].write(value.id)
    }
}

public struct DeleteProjectInput {
    /// A user- or system-generated token that identifies the entity that requested project deletion. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// Whether to send a delete request for the primary stack in AWS CloudFormation originally used to generate the project and its resources. This option will delete all AWS resources for the project (except for any buckets in Amazon S3) as well as deleting the project itself. Recommended for most use cases.
    public var deleteStack: Swift.Bool?
    /// The ID of the project to be deleted in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        deleteStack: Swift.Bool? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deleteStack = deleteStack
        self.id = id
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent()
        value.stackId = try reader["stackId"].readIfPresent()
        return value
    }
}

public struct DeleteProjectOutput {
    /// The Amazon Resource Name (ARN) of the deleted project.
    public var projectArn: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation that will be deleted as part of deleting the project and its resources.
    public var stackId: Swift.String?

    public init(
        projectArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.stackId = stackId
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteUserProfileInput {

    static func urlPathProvider(_ value: DeleteUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserProfileInput {

    static func write(value: DeleteUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userArn"].write(value.userArn)
    }
}

public struct DeleteUserProfileInput {
    /// The Amazon Resource Name (ARN) of the user to delete from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

extension DeleteUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUserProfileOutput()
        value.userArn = try reader["userArn"].readIfPresent()
        return value
    }
}

public struct DeleteUserProfileOutput {
    /// The Amazon Resource Name (ARN) of the user deleted from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

enum DeleteUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeProjectInput {

    static func urlPathProvider(_ value: DescribeProjectInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProjectInput {

    static func write(value: DescribeProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }
}

public struct DescribeProjectInput {
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DescribeProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutput(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), id: \(Swift.String(describing: id)), projectTemplateId: \(Swift.String(describing: projectTemplateId)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DescribeProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProjectOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.createdTimeStamp = try reader["createdTimeStamp"].readTimestampIfPresent(format: .epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.projectTemplateId = try reader["projectTemplateId"].readIfPresent()
        value.stackId = try reader["stackId"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: CodeStarClientTypes.ProjectStatus.read(from:))
        return value
    }
}

public struct DescribeProjectOutput {
    /// The Amazon Resource Name (ARN) for the project.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The date and time the project was created, in timestamp format.
    public var createdTimeStamp: ClientRuntime.Date?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project.
    public var id: Swift.String?
    /// The display name for the project.
    public var name: Swift.String?
    /// The ID for the AWS CodeStar project template used to create the project.
    public var projectTemplateId: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation used to generate resources for the project.
    public var stackId: Swift.String?
    /// The project creation or deletion status.
    public var status: CodeStarClientTypes.ProjectStatus?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdTimeStamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        status: CodeStarClientTypes.ProjectStatus? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdTimeStamp = createdTimeStamp
        self.description = description
        self.id = id
        self.name = name
        self.projectTemplateId = projectTemplateId
        self.stackId = stackId
        self.status = status
    }
}

enum DescribeProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "ProjectConfigurationException": return try ProjectConfigurationException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeUserProfileInput {

    static func urlPathProvider(_ value: DescribeUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUserProfileInput {

    static func write(value: DescribeUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userArn"].write(value.userArn)
    }
}

public struct DescribeUserProfileInput {
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

extension DescribeUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension DescribeUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserProfileOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.sshPublicKey = try reader["sshPublicKey"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        return value
    }
}

public struct DescribeUserProfileOutput {
    /// The date and time when the user profile was created in AWS CodeStar, in timestamp format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The display name shown for the user in AWS CodeStar projects. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
    public var displayName: Swift.String?
    /// The email address for the user. Optional.
    public var emailAddress: Swift.String?
    /// The date and time when the user profile was last modified, in timestamp format.
    /// This member is required.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user. This SSH public key is associated with the user profile, and can be used in conjunction with the associated private key for access to project resources, such as Amazon EC2 instances, if a project owner grants remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

enum DescribeUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UserProfileNotFoundException": return try UserProfileNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateTeamMemberInput {

    static func urlPathProvider(_ value: DisassociateTeamMemberInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateTeamMemberInput {

    static func write(value: DisassociateTeamMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectId"].write(value.projectId)
        try writer["userArn"].write(value.userArn)
    }
}

public struct DisassociateTeamMemberInput {
    /// The ID of the AWS CodeStar project from which you want to remove a team member.
    /// This member is required.
    public var projectId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM user or group whom you want to remove from the project.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        projectId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.userArn = userArn
    }
}

extension DisassociateTeamMemberOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateTeamMemberOutput {
        return DisassociateTeamMemberOutput()
    }
}

public struct DisassociateTeamMemberOutput {

    public init() { }
}

enum DisassociateTeamMemberOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GitHubCodeDestination(description: \(Swift.String(describing: description)), issuesEnabled: \(Swift.String(describing: issuesEnabled)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), privateRepository: \(Swift.String(describing: privateRepository)), type: \(Swift.String(describing: type)), token: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes.GitHubCodeDestination {

    static func write(value: CodeStarClientTypes.GitHubCodeDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["issuesEnabled"].write(value.issuesEnabled)
        try writer["name"].write(value.name)
        try writer["owner"].write(value.owner)
        try writer["privateRepository"].write(value.privateRepository)
        try writer["token"].write(value.token)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.GitHubCodeDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.GitHubCodeDestination()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.privateRepository = try reader["privateRepository"].readIfPresent() ?? false
        value.issuesEnabled = try reader["issuesEnabled"].readIfPresent() ?? false
        value.token = try reader["token"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct GitHubCodeDestination {
        /// Description for the GitHub repository to be created in AWS CodeStar. This description displays in GitHub after the repository is created.
        public var description: Swift.String?
        /// Whether to enable issues for the GitHub repository.
        /// This member is required.
        public var issuesEnabled: Swift.Bool
        /// Name of the GitHub repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?
        /// The GitHub username for the owner of the GitHub repository to be created in AWS CodeStar. If this repository should be owned by a GitHub organization, provide its name.
        /// This member is required.
        public var owner: Swift.String?
        /// Whether the GitHub repository is to be a private repository.
        /// This member is required.
        public var privateRepository: Swift.Bool
        /// The GitHub user's personal access token for the GitHub repository.
        /// This member is required.
        public var token: Swift.String?
        /// The type of GitHub repository to be created in AWS CodeStar. Valid values are User or Organization.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            issuesEnabled: Swift.Bool = false,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            privateRepository: Swift.Bool = false,
            token: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.issuesEnabled = issuesEnabled
            self.name = name
            self.owner = owner
            self.privateRepository = privateRepository
            self.token = token
            self.type = type
        }
    }

}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The next token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidServiceRoleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidServiceRoleException {
        let reader = baseError.errorBodyReader
        var value = InvalidServiceRoleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The service role is not valid.
public struct InvalidServiceRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidServiceRoleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A resource limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProjectsInput {

    static func write(value: ListProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListProjectsInput {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token to be used to return the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: CodeStarClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListProjectsOutput {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of projects.
    /// This member is required.
    public var projects: [CodeStarClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [CodeStarClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListResourcesInput {

    static func urlPathProvider(_ value: ListResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourcesInput {

    static func write(value: ListResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectId"].write(value.projectId)
    }
}

public struct ListResourcesInput {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

extension ListResourcesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: CodeStarClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListResourcesOutput {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// An array of resources associated with the project.
    public var resources: [CodeStarClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [CodeStarClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

enum ListResourcesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForProjectInput {

    static func urlPathProvider(_ value: ListTagsForProjectInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForProjectInput {

    static func write(value: ListTagsForProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListTagsForProjectInput {
    /// The ID of the project to get tags for.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var maxResults: Swift.Int?
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTagsForProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForProjectOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForProjectOutput {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

enum ListTagsForProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTeamMembersInput {

    static func urlPathProvider(_ value: ListTeamMembersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTeamMembersInput {

    static func write(value: ListTeamMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectId"].write(value.projectId)
    }
}

public struct ListTeamMembersInput {
    /// The maximum number of team members you want returned in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project for which you want to list team members.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

extension ListTeamMembersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTeamMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTeamMembersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.teamMembers = try reader["teamMembers"].readListIfPresent(memberReadingClosure: CodeStarClientTypes.TeamMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTeamMembersOutput {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of team member objects for the project.
    /// This member is required.
    public var teamMembers: [CodeStarClientTypes.TeamMember]?

    public init(
        nextToken: Swift.String? = nil,
        teamMembers: [CodeStarClientTypes.TeamMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamMembers = teamMembers
    }
}

enum ListTeamMembersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListUserProfilesInput {

    static func urlPathProvider(_ value: ListUserProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListUserProfilesInput {

    static func write(value: ListUserProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListUserProfilesInput {
    /// The maximum number of results to return in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListUserProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListUserProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.userProfiles = try reader["userProfiles"].readListIfPresent(memberReadingClosure: CodeStarClientTypes.UserProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListUserProfilesOutput {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// All the user profiles configured in AWS CodeStar for an AWS account.
    /// This member is required.
    public var userProfiles: [CodeStarClientTypes.UserProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userProfiles: [CodeStarClientTypes.UserProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userProfiles = userProfiles
    }
}

enum ListUserProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ProjectAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ProjectAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ProjectAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An AWS CodeStar project with the same ID already exists in this region for the AWS account. AWS CodeStar project IDs must be unique within a region for the AWS account.
public struct ProjectAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ProjectConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ProjectConfigurationException {
        let reader = baseError.errorBodyReader
        var value = ProjectConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Project configuration information is required but not specified.
public struct ProjectConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ProjectCreationFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ProjectCreationFailedException {
        let reader = baseError.errorBodyReader
        var value = ProjectCreationFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The project creation request was valid, but a nonspecific exception or error occurred during project creation. The project could not be created in AWS CodeStar.
public struct ProjectCreationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectCreationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ProjectNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ProjectNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ProjectNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified AWS CodeStar project was not found.
public struct ProjectNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeStarClientTypes.ProjectStatus {

    static func write(value: CodeStarClientTypes.ProjectStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reason"].write(value.reason)
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.ProjectStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.ProjectStatus()
        value.state = try reader["state"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// An indication of whether a project creation or deletion is failed or successful.
    public struct ProjectStatus {
        /// In the case of a project creation or deletion failure, a reason for the failure.
        public var reason: Swift.String?
        /// The phase of completion for a project creation or deletion.
        /// This member is required.
        public var state: Swift.String?

        public init(
            reason: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.reason = reason
            self.state = state
        }
    }

}

extension CodeStarClientTypes.ProjectSummary {

    static func write(value: CodeStarClientTypes.ProjectSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
        try writer["projectId"].write(value.projectId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.ProjectSummary()
        value.projectId = try reader["projectId"].readIfPresent()
        value.projectArn = try reader["projectArn"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about the metadata for a project.
    public struct ProjectSummary {
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The ID of the project.
        public var projectId: Swift.String?

        public init(
            projectArn: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.projectArn = projectArn
            self.projectId = projectId
        }
    }

}

extension CodeStarClientTypes.Resource {

    static func write(value: CodeStarClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.Resource()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about a resource for a project.
    public struct Resource {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension CodeStarClientTypes.S3Location {

    static func write(value: CodeStarClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketKey"].write(value.bucketKey)
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.S3Location()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.bucketKey = try reader["bucketKey"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the source code files provided with the project request are stored.
    public struct S3Location {
        /// The Amazon S3 object key where the source code files provided with the project request are stored.
        public var bucketKey: Swift.String?
        /// The Amazon S3 bucket name where the source code files provided with the project request are stored.
        public var bucketName: Swift.String?

        public init(
            bucketKey: Swift.String? = nil,
            bucketName: Swift.String? = nil
        )
        {
            self.bucketKey = bucketKey
            self.bucketName = bucketName
        }
    }

}

extension TagProjectInput {

    static func urlPathProvider(_ value: TagProjectInput) -> Swift.String? {
        return "/"
    }
}

extension TagProjectInput {

    static func write(value: TagProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagProjectInput {
    /// The ID of the project you want to add a tag to.
    /// This member is required.
    public var id: Swift.String?
    /// The tags you want to add to the project.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

extension TagProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagProjectOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct TagProjectOutput {
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum TagProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodeStarClientTypes.TeamMember {

    static func write(value: CodeStarClientTypes.TeamMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectRole"].write(value.projectRole)
        try writer["remoteAccessAllowed"].write(value.remoteAccessAllowed)
        try writer["userArn"].write(value.userArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.TeamMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.TeamMember()
        value.userArn = try reader["userArn"].readIfPresent()
        value.projectRole = try reader["projectRole"].readIfPresent()
        value.remoteAccessAllowed = try reader["remoteAccessAllowed"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about a team member in a project.
    public struct TeamMember {
        /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
        /// This member is required.
        public var projectRole: Swift.String?
        /// Whether the user is allowed to remotely access project resources using an SSH public/private key pair.
        public var remoteAccessAllowed: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        /// This member is required.
        public var userArn: Swift.String?

        public init(
            projectRole: Swift.String? = nil,
            remoteAccessAllowed: Swift.Bool? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.projectRole = projectRole
            self.remoteAccessAllowed = remoteAccessAllowed
            self.userArn = userArn
        }
    }

}

extension TeamMemberAlreadyAssociatedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TeamMemberAlreadyAssociatedException {
        let reader = baseError.errorBodyReader
        var value = TeamMemberAlreadyAssociatedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The team member is already associated with a role in this project.
public struct TeamMemberAlreadyAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TeamMemberAlreadyAssociatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TeamMemberNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TeamMemberNotFoundException {
        let reader = baseError.errorBodyReader
        var value = TeamMemberNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified team member was not found.
public struct TeamMemberNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TeamMemberNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeStarClientTypes.Toolchain {

    static func write(value: CodeStarClientTypes.Toolchain?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["source"].write(value.source, with: CodeStarClientTypes.ToolchainSource.write(value:to:))
        try writer["stackParameters"].writeMap(value.stackParameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.Toolchain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.Toolchain()
        value.source = try reader["source"].readIfPresent(with: CodeStarClientTypes.ToolchainSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.stackParameters = try reader["stackParameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CodeStarClientTypes {
    /// The toolchain template file provided with the project request. AWS CodeStar uses the template to provision the toolchain stack in AWS CloudFormation.
    public struct Toolchain {
        /// The service role ARN for AWS CodeStar to use for the toolchain template during stack provisioning.
        public var roleArn: Swift.String?
        /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.ToolchainSource?
        /// The list of parameter overrides to be passed into the toolchain template during stack provisioning, if any.
        public var stackParameters: [Swift.String:Swift.String]?

        public init(
            roleArn: Swift.String? = nil,
            source: CodeStarClientTypes.ToolchainSource? = nil,
            stackParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.source = source
            self.stackParameters = stackParameters
        }
    }

}

extension CodeStarClientTypes.ToolchainSource {

    static func write(value: CodeStarClientTypes.ToolchainSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3"].write(value.s3, with: CodeStarClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.ToolchainSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.ToolchainSource()
        value.s3 = try reader["s3"].readIfPresent(with: CodeStarClientTypes.S3Location.read(from:))
        return value
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
    public struct ToolchainSource {
        /// The Amazon S3 bucket where the toolchain template file provided with the project request is stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init(
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension UntagProjectInput {

    static func urlPathProvider(_ value: UntagProjectInput) -> Swift.String? {
        return "/"
    }
}

extension UntagProjectInput {

    static func write(value: UntagProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["tags"].writeList(value.tags, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagProjectInput {
    /// The ID of the project to remove tags from.
    /// This member is required.
    public var id: Swift.String?
    /// The tags to remove from the project.
    /// This member is required.
    public var tags: [Swift.String]?

    public init(
        id: Swift.String? = nil,
        tags: [Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

extension UntagProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagProjectOutput {
        return UntagProjectOutput()
    }
}

public struct UntagProjectOutput {

    public init() { }
}

enum UntagProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(id: \(Swift.String(describing: id)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }
}

public struct UpdateProjectInput {
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project you want to update.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateProjectOutput {
        return UpdateProjectOutput()
    }
}

public struct UpdateProjectOutput {

    public init() { }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateTeamMemberInput {

    static func urlPathProvider(_ value: UpdateTeamMemberInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTeamMemberInput {

    static func write(value: UpdateTeamMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectId"].write(value.projectId)
        try writer["projectRole"].write(value.projectRole)
        try writer["remoteAccessAllowed"].write(value.remoteAccessAllowed)
        try writer["userArn"].write(value.userArn)
    }
}

public struct UpdateTeamMemberInput {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile. Even if this is set to True, the user must associate a public key with their profile before the user can access resources.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user for whom you want to change team membership attributes.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

extension UpdateTeamMemberOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateTeamMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTeamMemberOutput()
        value.projectRole = try reader["projectRole"].readIfPresent()
        value.remoteAccessAllowed = try reader["remoteAccessAllowed"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        return value
    }
}

public struct UpdateTeamMemberOutput {
    /// The project role granted to the user.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user whose team membership attributes were updated.
    public var userArn: Swift.String?

    public init(
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

enum UpdateTeamMemberOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidServiceRoleException": return try InvalidServiceRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProjectConfigurationException": return try ProjectConfigurationException.makeError(baseError: baseError)
            case "ProjectNotFoundException": return try ProjectNotFoundException.makeError(baseError: baseError)
            case "TeamMemberNotFoundException": return try TeamMemberNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileInput {

    static func urlPathProvider(_ value: UpdateUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserProfileInput {

    static func write(value: UpdateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["emailAddress"].write(value.emailAddress)
        try writer["sshPublicKey"].write(value.sshPublicKey)
        try writer["userArn"].write(value.userArn)
    }
}

public struct UpdateUserProfileInput {
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

extension UpdateUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserProfileOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.lastModifiedTimestamp = try reader["lastModifiedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.sshPublicKey = try reader["sshPublicKey"].readIfPresent()
        value.userArn = try reader["userArn"].readIfPresent()
        return value
    }
}

public struct UpdateUserProfileOutput {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

enum UpdateUserProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UserProfileNotFoundException": return try UserProfileNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UserProfileAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UserProfileAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = UserProfileAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A user profile with that name already exists in this region for the AWS account. AWS CodeStar user profile names must be unique within a region for the AWS account.
public struct UserProfileAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserProfileAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UserProfileNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UserProfileNotFoundException {
        let reader = baseError.errorBodyReader
        var value = UserProfileNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The user profile was not found.
public struct UserProfileNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserProfileNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileSummary(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes.UserProfileSummary {

    static func write(value: CodeStarClientTypes.UserProfileSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["emailAddress"].write(value.emailAddress)
        try writer["sshPublicKey"].write(value.sshPublicKey)
        try writer["userArn"].write(value.userArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeStarClientTypes.UserProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeStarClientTypes.UserProfileSummary()
        value.userArn = try reader["userArn"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.sshPublicKey = try reader["sshPublicKey"].readIfPresent()
        return value
    }
}

extension CodeStarClientTypes {
    /// Information about a user's profile in AWS CodeStar.
    public struct UserProfileSummary {
        /// The display name of a user in AWS CodeStar. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
        public var displayName: Swift.String?
        /// The email address associated with the user.
        public var emailAddress: Swift.String?
        /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
        public var sshPublicKey: Swift.String?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        public var userArn: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.sshPublicKey = sshPublicKey
            self.userArn = userArn
        }
    }

}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified input is either not valid, or it could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
