// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension AssociateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateTeamMemberInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested the team member association to the project. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The ID of the project to which you will add the IAM user.
    /// This member is required.
    public var projectId: Swift.String?
    /// The AWS CodeStar project role that will apply to this user. This role determines what actions a user can take in an AWS CodeStar project.
    /// This member is required.
    public var projectRole: Swift.String?
    /// Whether the team member is allowed to use an SSH public/private key pair to remotely access project resources, for example Amazon EC2 instances.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the IAM user you want to add to the AWS CodeStar project.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct AssociateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let clientRequestToken: Swift.String?
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension AssociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension AssociateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberAlreadyAssociatedException" : self = .teamMemberAlreadyAssociatedException(try TeamMemberAlreadyAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberAlreadyAssociatedException(TeamMemberAlreadyAssociatedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientRequestToken = output.clientRequestToken
        } else {
            self.clientRequestToken = nil
        }
    }
}

public struct AssociateTeamMemberOutputResponse: Swift.Equatable {
    /// The user- or system-generated token from the initial request that can be used to repeat the request.
    public var clientRequestToken: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
    }
}

struct AssociateTeamMemberOutputResponseBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
}

extension AssociateTeamMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CodeStarClientTypes.Code: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeSource.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CodeStarClientTypes {
    /// Location and destination information about the source code files provided with the project request. The source code is uploaded to the new project source repository after project creation.
    public struct Code: Swift.Equatable {
        /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
        /// This member is required.
        public var destination: CodeStarClientTypes.CodeDestination?
        /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.CodeSource?

        public init (
            destination: CodeStarClientTypes.CodeDestination? = nil,
            source: CodeStarClientTypes.CodeSource? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeStarClientTypes.CodeCommitCodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct CodeCommitCodeDestination: Swift.Equatable {
        /// The name of the AWS CodeCommit repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodeStarClientTypes.CodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeCommit
        case gitHub
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeCommit = self.codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHub = self.gitHub {
            try encodeContainer.encode(gitHub, forKey: .gitHub)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeCommitCodeDestination.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let gitHubDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.GitHubCodeDestination.self, forKey: .gitHub)
        gitHub = gitHubDecoded
    }
}

extension CodeStarClientTypes {
    /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
    public struct CodeDestination: Swift.Equatable {
        /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var codeCommit: CodeStarClientTypes.CodeCommitCodeDestination?
        /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var gitHub: CodeStarClientTypes.GitHubCodeDestination?

        public init (
            codeCommit: CodeStarClientTypes.CodeCommitCodeDestination? = nil,
            gitHub: CodeStarClientTypes.GitHubCodeDestination? = nil
        )
        {
            self.codeCommit = codeCommit
            self.gitHub = gitHub
        }
    }

}

extension CodeStarClientTypes.CodeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes {
    /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
    public struct CodeSource: Swift.Equatable {
        /// Information about the Amazon S3 location where the source code files provided with the project request are stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init (
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another modification is being made. That modification must complete before you can make your change.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), id: \(Swift.String(describing: id)), sourceCode: \(Swift.String(describing: sourceCode)), tags: \(Swift.String(describing: tags)), toolchain: \(Swift.String(describing: toolchain)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceCode = sourceCode {
            var sourceCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCode)
            for code0 in sourceCode {
                try sourceCodeContainer.encode(code0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toolchain = self.toolchain {
            try encodeContainer.encode(toolchain, forKey: .toolchain)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project creation. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project to be created in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?
    /// The display name for the project to be created in AWS CodeStar.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Code objects submitted with the project request. If this parameter is specified, the request must also include the toolchain parameter.
    public var sourceCode: [CodeStarClientTypes.Code]?
    /// The tags created for the project.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the toolchain template file submitted with the project request. If this parameter is specified, the request must also include the sourceCode parameter.
    public var toolchain: CodeStarClientTypes.Toolchain?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceCode: [CodeStarClientTypes.Code]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        toolchain: CodeStarClientTypes.Toolchain? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.id = id
        self.name = name
        self.sourceCode = sourceCode
        self.tags = tags
        self.toolchain = toolchain
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let sourceCode: [CodeStarClientTypes.Code]?
    let toolchain: CodeStarClientTypes.Toolchain?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceCodeContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Code?].self, forKey: .sourceCode)
        var sourceCodeDecoded0:[CodeStarClientTypes.Code]? = nil
        if let sourceCodeContainer = sourceCodeContainer {
            sourceCodeDecoded0 = [CodeStarClientTypes.Code]()
            for structure0 in sourceCodeContainer {
                if let structure0 = structure0 {
                    sourceCodeDecoded0?.append(structure0)
                }
            }
        }
        sourceCode = sourceCodeDecoded0
        let toolchainDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.Toolchain.self, forKey: .toolchain)
        toolchain = toolchainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectAlreadyExistsException" : self = .projectAlreadyExistsException(try ProjectAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectCreationFailedException" : self = .projectCreationFailedException(try ProjectCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectAlreadyExistsException(ProjectAlreadyExistsException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectCreationFailedException(ProjectCreationFailedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.id = output.id
            self.projectTemplateId = output.projectTemplateId
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.id = nil
            self.projectTemplateId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created project.
    /// This member is required.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var projectTemplateId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        id: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.id = id
        self.projectTemplateId = projectTemplateId
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let projectTemplateId: Swift.String?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case id
        case projectTemplateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
    }
}

extension CreateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension CreateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var displayName: Swift.String?
    /// The email address that will be displayed as part of the user's profile in AWS CodeStar.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CreateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileAlreadyExistsException" : self = .userProfileAlreadyExistsException(try UserProfileAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileAlreadyExistsException(UserProfileAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct CreateUserProfileOutputResponse: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension CreateUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension DeleteProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if deleteStack != false {
            try encodeContainer.encode(deleteStack, forKey: .deleteStack)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project deletion. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// Whether to send a delete request for the primary stack in AWS CloudFormation originally used to generate the project and its resources. This option will delete all AWS resources for the project (except for any buckets in Amazon S3) as well as deleting the project itself. Recommended for most use cases.
    public var deleteStack: Swift.Bool
    /// The ID of the project to be deleted in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        deleteStack: Swift.Bool = false,
        id: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deleteStack = deleteStack
        self.id = id
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientRequestToken: Swift.String?
    let deleteStack: Swift.Bool
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let deleteStackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteStack) ?? false
        deleteStack = deleteStackDecoded
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.stackId = output.stackId
        } else {
            self.projectArn = nil
            self.stackId = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted project.
    public var projectArn: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation that will be deleted as part of deleting the project and its resources.
    public var stackId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.stackId = stackId
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    let stackId: Swift.String?
    let projectArn: Swift.String?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case stackId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DeleteUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DeleteUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user to delete from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DeleteUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserProfileOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct DeleteUserProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user deleted from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DeleteUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DescribeProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DescribeProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), id: \(Swift.String(describing: id)), projectTemplateId: \(Swift.String(describing: projectTemplateId)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdTimeStamp = output.createdTimeStamp
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.projectTemplateId = output.projectTemplateId
            self.stackId = output.stackId
            self.status = output.status
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdTimeStamp = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.projectTemplateId = nil
            self.stackId = nil
            self.status = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the project.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The date and time the project was created, in timestamp format.
    public var createdTimeStamp: ClientRuntime.Date?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project.
    public var id: Swift.String?
    /// The display name for the project.
    public var name: Swift.String?
    /// The ID for the AWS CodeStar project template used to create the project.
    public var projectTemplateId: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation used to generate resources for the project.
    public var stackId: Swift.String?
    /// The project creation or deletion status.
    public var status: CodeStarClientTypes.ProjectStatus?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdTimeStamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        status: CodeStarClientTypes.ProjectStatus? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdTimeStamp = createdTimeStamp
        self.description = description
        self.id = id
        self.name = name
        self.projectTemplateId = projectTemplateId
        self.stackId = stackId
        self.status = status
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let createdTimeStamp: ClientRuntime.Date?
    let stackId: Swift.String?
    let projectTemplateId: Swift.String?
    let status: CodeStarClientTypes.ProjectStatus?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdTimeStamp
        case description
        case id
        case name
        case projectTemplateId
        case stackId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdTimeStampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DescribeUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DescribeUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DescribeUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DescribeUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension DescribeUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct DescribeUserProfileOutputResponse: Swift.Equatable {
    /// The date and time when the user profile was created in AWS CodeStar, in timestamp format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The display name shown for the user in AWS CodeStar projects. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
    public var displayName: Swift.String?
    /// The email address for the user. Optional.
    public var emailAddress: Swift.String?
    /// The date and time when the user profile was last modified, in timestamp format.
    /// This member is required.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user. This SSH public key is associated with the user profile, and can be used in conjunction with the associated private key for access to project resources, such as Amazon EC2 instances, if a project owner grants remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct DescribeUserProfileOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension DescribeUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension DisassociateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DisassociateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateTeamMemberInput: Swift.Equatable {
    /// The ID of the AWS CodeStar project from which you want to remove a team member.
    /// This member is required.
    public var projectId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM user or group whom you want to remove from the project.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        projectId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.userArn = userArn
    }
}

struct DisassociateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let userArn: Swift.String?
}

extension DisassociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DisassociateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTeamMemberOutputResponse: Swift.Equatable {

    public init () { }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case issuesEnabled
        case name
        case owner
        case privateRepository
        case token
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if issuesEnabled != false {
            try encodeContainer.encode(issuesEnabled, forKey: .issuesEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if privateRepository != false {
            try encodeContainer.encode(privateRepository, forKey: .privateRepository)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let privateRepositoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privateRepository) ?? false
        privateRepository = privateRepositoryDecoded
        let issuesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .issuesEnabled) ?? false
        issuesEnabled = issuesEnabledDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GitHubCodeDestination(description: \(Swift.String(describing: description)), issuesEnabled: \(Swift.String(describing: issuesEnabled)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), privateRepository: \(Swift.String(describing: privateRepository)), type: \(Swift.String(describing: type)), token: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes {
    /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct GitHubCodeDestination: Swift.Equatable {
        /// Description for the GitHub repository to be created in AWS CodeStar. This description displays in GitHub after the repository is created.
        public var description: Swift.String?
        /// Whether to enable issues for the GitHub repository.
        /// This member is required.
        public var issuesEnabled: Swift.Bool
        /// Name of the GitHub repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?
        /// The GitHub username for the owner of the GitHub repository to be created in AWS CodeStar. If this repository should be owned by a GitHub organization, provide its name.
        /// This member is required.
        public var owner: Swift.String?
        /// Whether the GitHub repository is to be a private repository.
        /// This member is required.
        public var privateRepository: Swift.Bool
        /// The GitHub user's personal access token for the GitHub repository.
        /// This member is required.
        public var token: Swift.String?
        /// The type of GitHub repository to be created in AWS CodeStar. Valid values are User or Organization.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            issuesEnabled: Swift.Bool = false,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            privateRepository: Swift.Bool = false,
            token: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.issuesEnabled = issuesEnabled
            self.name = name
            self.owner = owner
            self.privateRepository = privateRepository
            self.token = token
            self.type = type
        }
    }

}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The next token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidServiceRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service role is not valid.
public struct InvalidServiceRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidServiceRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidServiceRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource limit has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token to be used to return the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of projects.
    /// This member is required.
    public var projects: [CodeStarClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [CodeStarClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projects: [CodeStarClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[CodeStarClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [CodeStarClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// An array of resources associated with the project.
    public var resources: [CodeStarClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [CodeStarClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    let resources: [CodeStarClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CodeStarClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CodeStarClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsForProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForProjectInput: Swift.Equatable {
    /// The ID of the project to get tags for.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var maxResults: Swift.Int?
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForProjectOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForProjectOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTeamMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

extension ListTeamMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTeamMembersInput: Swift.Equatable {
    /// The maximum number of team members you want returned in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project for which you want to list team members.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListTeamMembersInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTeamMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTeamMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTeamMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTeamMembersOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTeamMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTeamMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.teamMembers = output.teamMembers
        } else {
            self.nextToken = nil
            self.teamMembers = nil
        }
    }
}

public struct ListTeamMembersOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of team member objects for the project.
    /// This member is required.
    public var teamMembers: [CodeStarClientTypes.TeamMember]?

    public init (
        nextToken: Swift.String? = nil,
        teamMembers: [CodeStarClientTypes.TeamMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamMembers = teamMembers
    }
}

struct ListTeamMembersOutputResponseBody: Swift.Equatable {
    let teamMembers: [CodeStarClientTypes.TeamMember]?
    let nextToken: Swift.String?
}

extension ListTeamMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case teamMembers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamMembersContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.TeamMember?].self, forKey: .teamMembers)
        var teamMembersDecoded0:[CodeStarClientTypes.TeamMember]? = nil
        if let teamMembersContainer = teamMembersContainer {
            teamMembersDecoded0 = [CodeStarClientTypes.TeamMember]()
            for structure0 in teamMembersContainer {
                if let structure0 = structure0 {
                    teamMembersDecoded0?.append(structure0)
                }
            }
        }
        teamMembers = teamMembersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUserProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUserProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserProfilesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userProfiles = output.userProfiles
        } else {
            self.nextToken = nil
            self.userProfiles = nil
        }
    }
}

public struct ListUserProfilesOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// All the user profiles configured in AWS CodeStar for an AWS account.
    /// This member is required.
    public var userProfiles: [CodeStarClientTypes.UserProfileSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userProfiles: [CodeStarClientTypes.UserProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userProfiles = userProfiles
    }
}

struct ListUserProfilesOutputResponseBody: Swift.Equatable {
    let userProfiles: [CodeStarClientTypes.UserProfileSummary]?
    let nextToken: Swift.String?
}

extension ListUserProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userProfiles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.UserProfileSummary?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[CodeStarClientTypes.UserProfileSummary]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [CodeStarClientTypes.UserProfileSummary]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ProjectAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProjectAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An AWS CodeStar project with the same ID already exists in this region for the AWS account. AWS CodeStar project IDs must be unique within a region for the AWS account.
public struct ProjectAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProjectConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Project configuration information is required but not specified.
public struct ProjectConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectCreationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProjectCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The project creation request was valid, but a nonspecific exception or error occurred during project creation. The project could not be created in AWS CodeStar.
public struct ProjectCreationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectCreationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ProjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified AWS CodeStar project was not found.
public struct ProjectNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.ProjectStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeStarClientTypes {
    /// An indication of whether a project creation or deletion is failed or successful.
    public struct ProjectStatus: Swift.Equatable {
        /// In the case of a project creation or deletion failure, a reason for the failure.
        public var reason: Swift.String?
        /// The phase of completion for a project creation or deletion.
        /// This member is required.
        public var state: Swift.String?

        public init (
            reason: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.reason = reason
            self.state = state
        }
    }

}

extension CodeStarClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about the metadata for a project.
    public struct ProjectSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The ID of the project.
        public var projectId: Swift.String?

        public init (
            projectArn: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.projectArn = projectArn
            self.projectId = projectId
        }
    }

}

extension CodeStarClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about a resource for a project.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension CodeStarClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketKey
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketKey = self.bucketKey {
            try encodeContainer.encode(bucketKey, forKey: .bucketKey)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketKey)
        bucketKey = bucketKeyDecoded
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the source code files provided with the project request are stored.
    public struct S3Location: Swift.Equatable {
        /// The Amazon S3 object key where the source code files provided with the project request are stored.
        public var bucketKey: Swift.String?
        /// The Amazon S3 bucket name where the source code files provided with the project request are stored.
        public var bucketName: Swift.String?

        public init (
            bucketKey: Swift.String? = nil,
            bucketName: Swift.String? = nil
        )
        {
            self.bucketKey = bucketKey
            self.bucketName = bucketName
        }
    }

}

extension TagProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagProjectInput: Swift.Equatable {
    /// The ID of the project you want to add a tag to.
    /// This member is required.
    public var id: Swift.String?
    /// The tags you want to add to the project.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct TagProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagProjectOutputResponse: Swift.Equatable {
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagProjectOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeStarClientTypes.TeamMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about a team member in a project.
    public struct TeamMember: Swift.Equatable {
        /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
        /// This member is required.
        public var projectRole: Swift.String?
        /// Whether the user is allowed to remotely access project resources using an SSH public/private key pair.
        public var remoteAccessAllowed: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        /// This member is required.
        public var userArn: Swift.String?

        public init (
            projectRole: Swift.String? = nil,
            remoteAccessAllowed: Swift.Bool? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.projectRole = projectRole
            self.remoteAccessAllowed = remoteAccessAllowed
            self.userArn = userArn
        }
    }

}

extension TeamMemberAlreadyAssociatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TeamMemberAlreadyAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The team member is already associated with a role in this project.
public struct TeamMemberAlreadyAssociatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberAlreadyAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TeamMemberAlreadyAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TeamMemberNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TeamMemberNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified team member was not found.
public struct TeamMemberNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TeamMemberNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.Toolchain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case source
        case stackParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let stackParameters = stackParameters {
            var stackParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stackParameters)
            for (dictKey0, templateParameterMap0) in stackParameters {
                try stackParametersContainer.encode(templateParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ToolchainSource.self, forKey: .source)
        source = sourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stackParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stackParameters)
        var stackParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let stackParametersContainer = stackParametersContainer {
            stackParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templateparametervalue0) in stackParametersContainer {
                if let templateparametervalue0 = templateparametervalue0 {
                    stackParametersDecoded0?[key0] = templateparametervalue0
                }
            }
        }
        stackParameters = stackParametersDecoded0
    }
}

extension CodeStarClientTypes {
    /// The toolchain template file provided with the project request. AWS CodeStar uses the template to provision the toolchain stack in AWS CloudFormation.
    public struct Toolchain: Swift.Equatable {
        /// The service role ARN for AWS CodeStar to use for the toolchain template during stack provisioning.
        public var roleArn: Swift.String?
        /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.ToolchainSource?
        /// The list of parameter overrides to be passed into the toolchain template during stack provisioning, if any.
        public var stackParameters: [Swift.String:Swift.String]?

        public init (
            roleArn: Swift.String? = nil,
            source: CodeStarClientTypes.ToolchainSource? = nil,
            stackParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.source = source
            self.stackParameters = stackParameters
        }
    }

}

extension CodeStarClientTypes.ToolchainSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
    public struct ToolchainSource: Swift.Equatable {
        /// The Amazon S3 bucket where the toolchain template file provided with the project request is stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init (
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension UntagProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagkey0 in tags {
                try tagsContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagProjectInput: Swift.Equatable {
    /// The ID of the project to remove tags from.
    /// This member is required.
    public var id: Swift.String?
    /// The tags to remove from the project.
    /// This member is required.
    public var tags: [Swift.String]?

    public init (
        id: Swift.String? = nil,
        tags: [Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct UntagProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let tags: [Swift.String]?
}

extension UntagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(id: \(Swift.String(describing: id)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project you want to update.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension UpdateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTeamMemberInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile. Even if this is set to True, the user must associate a public key with their profile before the user can access resources.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user for whom you want to change team membership attributes.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension UpdateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension UpdateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberNotFoundException" : self = .teamMemberNotFoundException(try TeamMemberNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberNotFoundException(TeamMemberNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectRole = output.projectRole
            self.remoteAccessAllowed = output.remoteAccessAllowed
            self.userArn = output.userArn
        } else {
            self.projectRole = nil
            self.remoteAccessAllowed = nil
            self.userArn = nil
        }
    }
}

public struct UpdateTeamMemberOutputResponse: Swift.Equatable {
    /// The project role granted to the user.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user whose team membership attributes were updated.
    public var userArn: Swift.String?

    public init (
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension UpdateTeamMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension UpdateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension UpdateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct UpdateUserProfileOutputResponse: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension UpdateUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension UserProfileAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UserProfileAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A user profile with that name already exists in this region for the AWS account. AWS CodeStar user profile names must be unique within a region for the AWS account.
public struct UserProfileAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserProfileAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserProfileNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UserProfileNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user profile was not found.
public struct UserProfileNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserProfileNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileSummary(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes {
    /// Information about a user's profile in AWS CodeStar.
    public struct UserProfileSummary: Swift.Equatable {
        /// The display name of a user in AWS CodeStar. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
        public var displayName: Swift.String?
        /// The email address associated with the user.
        public var emailAddress: Swift.String?
        /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
        public var sshPublicKey: Swift.String?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        public var userArn: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.sshPublicKey = sshPublicKey
            self.userArn = userArn
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified input is either not valid, or it could not be validated.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
