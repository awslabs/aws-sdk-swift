// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension AssociateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateTeamMemberInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested the team member association to the project. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The ID of the project to which you will add the IAM user.
    /// This member is required.
    public var projectId: Swift.String?
    /// The AWS CodeStar project role that will apply to this user. This role determines what actions a user can take in an AWS CodeStar project.
    /// This member is required.
    public var projectRole: Swift.String?
    /// Whether the team member is allowed to use an SSH public/private key pair to remotely access project resources, for example Amazon EC2 instances.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the IAM user you want to add to the AWS CodeStar project.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct AssociateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let clientRequestToken: Swift.String?
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension AssociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension AssociateTeamMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateTeamMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientRequestToken = output.clientRequestToken
        } else {
            self.clientRequestToken = nil
        }
    }
}

public struct AssociateTeamMemberOutput: Swift.Equatable {
    /// The user- or system-generated token from the initial request that can be used to repeat the request.
    public var clientRequestToken: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
    }
}

struct AssociateTeamMemberOutputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
}

extension AssociateTeamMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

enum AssociateTeamMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectConfigurationException": return try await ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TeamMemberAlreadyAssociatedException": return try await TeamMemberAlreadyAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeStarClientTypes.Code: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeSource.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CodeStarClientTypes {
    /// Location and destination information about the source code files provided with the project request. The source code is uploaded to the new project source repository after project creation.
    public struct Code: Swift.Equatable {
        /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
        /// This member is required.
        public var destination: CodeStarClientTypes.CodeDestination?
        /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.CodeSource?

        public init(
            destination: CodeStarClientTypes.CodeDestination? = nil,
            source: CodeStarClientTypes.CodeSource? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeStarClientTypes.CodeCommitCodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct CodeCommitCodeDestination: Swift.Equatable {
        /// The name of the AWS CodeCommit repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodeStarClientTypes.CodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeCommit
        case gitHub
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeCommit = self.codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHub = self.gitHub {
            try encodeContainer.encode(gitHub, forKey: .gitHub)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeCommitCodeDestination.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let gitHubDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.GitHubCodeDestination.self, forKey: .gitHub)
        gitHub = gitHubDecoded
    }
}

extension CodeStarClientTypes {
    /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the source code files provided with the project request are placed in the repository.
    public struct CodeDestination: Swift.Equatable {
        /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var codeCommit: CodeStarClientTypes.CodeCommitCodeDestination?
        /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
        public var gitHub: CodeStarClientTypes.GitHubCodeDestination?

        public init(
            codeCommit: CodeStarClientTypes.CodeCommitCodeDestination? = nil,
            gitHub: CodeStarClientTypes.GitHubCodeDestination? = nil
        )
        {
            self.codeCommit = codeCommit
            self.gitHub = gitHub
        }
    }

}

extension CodeStarClientTypes.CodeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes {
    /// The location where the source code files provided with the project request are stored. AWS CodeStar retrieves the files during project creation.
    public struct CodeSource: Swift.Equatable {
        /// Information about the Amazon S3 location where the source code files provided with the project request are stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init(
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Another modification is being made. That modification must complete before you can make your change.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), id: \(Swift.String(describing: id)), sourceCode: \(Swift.String(describing: sourceCode)), tags: \(Swift.String(describing: tags)), toolchain: \(Swift.String(describing: toolchain)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceCode = sourceCode {
            var sourceCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCode)
            for code0 in sourceCode {
                try sourceCodeContainer.encode(code0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toolchain = self.toolchain {
            try encodeContainer.encode(toolchain, forKey: .toolchain)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project creation. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project to be created in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?
    /// The display name for the project to be created in AWS CodeStar.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Code objects submitted with the project request. If this parameter is specified, the request must also include the toolchain parameter.
    public var sourceCode: [CodeStarClientTypes.Code]?
    /// The tags created for the project.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the toolchain template file submitted with the project request. If this parameter is specified, the request must also include the sourceCode parameter.
    public var toolchain: CodeStarClientTypes.Toolchain?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceCode: [CodeStarClientTypes.Code]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        toolchain: CodeStarClientTypes.Toolchain? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.id = id
        self.name = name
        self.sourceCode = sourceCode
        self.tags = tags
        self.toolchain = toolchain
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let sourceCode: [CodeStarClientTypes.Code]?
    let toolchain: CodeStarClientTypes.Toolchain?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceCodeContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Code?].self, forKey: .sourceCode)
        var sourceCodeDecoded0:[CodeStarClientTypes.Code]? = nil
        if let sourceCodeContainer = sourceCodeContainer {
            sourceCodeDecoded0 = [CodeStarClientTypes.Code]()
            for structure0 in sourceCodeContainer {
                if let structure0 = structure0 {
                    sourceCodeDecoded0?.append(structure0)
                }
            }
        }
        sourceCode = sourceCodeDecoded0
        let toolchainDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.Toolchain.self, forKey: .toolchain)
        toolchain = toolchainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.id = output.id
            self.projectTemplateId = output.projectTemplateId
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.id = nil
            self.projectTemplateId = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created project.
    /// This member is required.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var projectTemplateId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        id: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.id = id
        self.projectTemplateId = projectTemplateId
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let clientRequestToken: Swift.String?
    let projectTemplateId: Swift.String?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case id
        case projectTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectAlreadyExistsException": return try await ProjectAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectConfigurationException": return try await ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectCreationFailedException": return try await ProjectCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension CreateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var displayName: Swift.String?
    /// The email address that will be displayed as part of the user's profile in AWS CodeStar.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CreateUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CreateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct CreateUserProfileOutput: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileOutputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension CreateUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum CreateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UserProfileAlreadyExistsException": return try await UserProfileAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let deleteStack = self.deleteStack {
            try encodeContainer.encode(deleteStack, forKey: .deleteStack)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project deletion. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// Whether to send a delete request for the primary stack in AWS CloudFormation originally used to generate the project and its resources. This option will delete all AWS resources for the project (except for any buckets in Amazon S3) as well as deleting the project itself. Recommended for most use cases.
    public var deleteStack: Swift.Bool?
    /// The ID of the project to be deleted in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        deleteStack: Swift.Bool? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deleteStack = deleteStack
        self.id = id
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientRequestToken: Swift.String?
    let deleteStack: Swift.Bool?
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let deleteStackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteStack)
        deleteStack = deleteStackDecoded
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.stackId = output.stackId
        } else {
            self.projectArn = nil
            self.stackId = nil
        }
    }
}

public struct DeleteProjectOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted project.
    public var projectArn: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation that will be deleted as part of deleting the project and its resources.
    public var stackId: Swift.String?

    public init(
        projectArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.stackId = stackId
    }
}

struct DeleteProjectOutputBody: Swift.Equatable {
    let stackId: Swift.String?
    let projectArn: Swift.String?
}

extension DeleteProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case stackId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DeleteUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user to delete from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DeleteUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct DeleteUserProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user deleted from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileOutputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DeleteUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

enum DeleteUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DescribeProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProjectOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutput(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), id: \(Swift.String(describing: id)), projectTemplateId: \(Swift.String(describing: projectTemplateId)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension DescribeProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdTimeStamp = output.createdTimeStamp
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.projectTemplateId = output.projectTemplateId
            self.stackId = output.stackId
            self.status = output.status
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdTimeStamp = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.projectTemplateId = nil
            self.stackId = nil
            self.status = nil
        }
    }
}

public struct DescribeProjectOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the project.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project creation.
    public var clientRequestToken: Swift.String?
    /// The date and time the project was created, in timestamp format.
    public var createdTimeStamp: ClientRuntime.Date?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project.
    public var id: Swift.String?
    /// The display name for the project.
    public var name: Swift.String?
    /// The ID for the AWS CodeStar project template used to create the project.
    public var projectTemplateId: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation used to generate resources for the project.
    public var stackId: Swift.String?
    /// The project creation or deletion status.
    public var status: CodeStarClientTypes.ProjectStatus?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdTimeStamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        status: CodeStarClientTypes.ProjectStatus? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdTimeStamp = createdTimeStamp
        self.description = description
        self.id = id
        self.name = name
        self.projectTemplateId = projectTemplateId
        self.stackId = stackId
        self.status = status
    }
}

struct DescribeProjectOutputBody: Swift.Equatable {
    let name: Swift.String?
    let id: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let createdTimeStamp: ClientRuntime.Date?
    let stackId: Swift.String?
    let projectTemplateId: Swift.String?
    let status: CodeStarClientTypes.ProjectStatus?
}

extension DescribeProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdTimeStamp
        case description
        case id
        case name
        case projectTemplateId
        case stackId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdTimeStampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectConfigurationException": return try await ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DescribeUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DescribeUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension DescribeUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DescribeUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension DescribeUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct DescribeUserProfileOutput: Swift.Equatable {
    /// The date and time when the user profile was created in AWS CodeStar, in timestamp format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The display name shown for the user in AWS CodeStar projects. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
    public var displayName: Swift.String?
    /// The email address for the user. Optional.
    public var emailAddress: Swift.String?
    /// The date and time when the user profile was last modified, in timestamp format.
    /// This member is required.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user. This SSH public key is associated with the user profile, and can be used in conjunction with the associated private key for access to project resources, such as Amazon EC2 instances, if a project owner grants remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct DescribeUserProfileOutputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension DescribeUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum DescribeUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UserProfileNotFoundException": return try await UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DisassociateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateTeamMemberInput: Swift.Equatable {
    /// The ID of the AWS CodeStar project from which you want to remove a team member.
    /// This member is required.
    public var projectId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM user or group whom you want to remove from the project.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        projectId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.userArn = userArn
    }
}

struct DisassociateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let userArn: Swift.String?
}

extension DisassociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DisassociateTeamMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTeamMemberOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTeamMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case issuesEnabled
        case name
        case owner
        case privateRepository
        case token
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if issuesEnabled != false {
            try encodeContainer.encode(issuesEnabled, forKey: .issuesEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if privateRepository != false {
            try encodeContainer.encode(privateRepository, forKey: .privateRepository)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let privateRepositoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privateRepository) ?? false
        privateRepository = privateRepositoryDecoded
        let issuesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .issuesEnabled) ?? false
        issuesEnabled = issuesEnabledDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GitHubCodeDestination(description: \(Swift.String(describing: description)), issuesEnabled: \(Swift.String(describing: issuesEnabled)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), privateRepository: \(Swift.String(describing: privateRepository)), type: \(Swift.String(describing: type)), token: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes {
    /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the project request will be uploaded after project creation.
    public struct GitHubCodeDestination: Swift.Equatable {
        /// Description for the GitHub repository to be created in AWS CodeStar. This description displays in GitHub after the repository is created.
        public var description: Swift.String?
        /// Whether to enable issues for the GitHub repository.
        /// This member is required.
        public var issuesEnabled: Swift.Bool
        /// Name of the GitHub repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?
        /// The GitHub username for the owner of the GitHub repository to be created in AWS CodeStar. If this repository should be owned by a GitHub organization, provide its name.
        /// This member is required.
        public var owner: Swift.String?
        /// Whether the GitHub repository is to be a private repository.
        /// This member is required.
        public var privateRepository: Swift.Bool
        /// The GitHub user's personal access token for the GitHub repository.
        /// This member is required.
        public var token: Swift.String?
        /// The type of GitHub repository to be created in AWS CodeStar. Valid values are User or Organization.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            issuesEnabled: Swift.Bool = false,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            privateRepository: Swift.Bool = false,
            token: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.issuesEnabled = issuesEnabled
            self.name = name
            self.owner = owner
            self.privateRepository = privateRepository
            self.token = token
            self.type = type
        }
    }

}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The next token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceRoleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidServiceRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service role is not valid.
public struct InvalidServiceRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidServiceRoleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidServiceRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidServiceRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token to be used to return the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of projects.
    /// This member is required.
    public var projects: [CodeStarClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [CodeStarClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projects: [CodeStarClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[CodeStarClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [CodeStarClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutput: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// An array of resources associated with the project.
    public var resources: [CodeStarClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [CodeStarClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputBody: Swift.Equatable {
    let resources: [CodeStarClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CodeStarClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CodeStarClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsForProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForProjectInput: Swift.Equatable {
    /// The ID of the project to get tags for.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var maxResults: Swift.Int?
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForProjectOutput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForProjectOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTeamMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

extension ListTeamMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTeamMembersInput: Swift.Equatable {
    /// The maximum number of team members you want returned in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?
    /// The ID of the project for which you want to list team members.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListTeamMembersInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTeamMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTeamMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTeamMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.teamMembers = output.teamMembers
        } else {
            self.nextToken = nil
            self.teamMembers = nil
        }
    }
}

public struct ListTeamMembersOutput: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// A list of team member objects for the project.
    /// This member is required.
    public var teamMembers: [CodeStarClientTypes.TeamMember]?

    public init(
        nextToken: Swift.String? = nil,
        teamMembers: [CodeStarClientTypes.TeamMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamMembers = teamMembers
    }
}

struct ListTeamMembersOutputBody: Swift.Equatable {
    let teamMembers: [CodeStarClientTypes.TeamMember]?
    let nextToken: Swift.String?
}

extension ListTeamMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case teamMembers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamMembersContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.TeamMember?].self, forKey: .teamMembers)
        var teamMembersDecoded0:[CodeStarClientTypes.TeamMember]? = nil
        if let teamMembersContainer = teamMembersContainer {
            teamMembersDecoded0 = [CodeStarClientTypes.TeamMember]()
            for structure0 in teamMembersContainer {
                if let structure0 = structure0 {
                    teamMembersDecoded0?.append(structure0)
                }
            }
        }
        teamMembers = teamMembersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTeamMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUserProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUserProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in a response.
    public var maxResults: Swift.Int?
    /// The continuation token for the next set of results, if the results cannot be returned in one response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUserProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userProfiles = output.userProfiles
        } else {
            self.nextToken = nil
            self.userProfiles = nil
        }
    }
}

public struct ListUserProfilesOutput: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are more results to be returned.
    public var nextToken: Swift.String?
    /// All the user profiles configured in AWS CodeStar for an AWS account.
    /// This member is required.
    public var userProfiles: [CodeStarClientTypes.UserProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        userProfiles: [CodeStarClientTypes.UserProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userProfiles = userProfiles
    }
}

struct ListUserProfilesOutputBody: Swift.Equatable {
    let userProfiles: [CodeStarClientTypes.UserProfileSummary]?
    let nextToken: Swift.String?
}

extension ListUserProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userProfiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.UserProfileSummary?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[CodeStarClientTypes.UserProfileSummary]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [CodeStarClientTypes.UserProfileSummary]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUserProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ProjectAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProjectAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An AWS CodeStar project with the same ID already exists in this region for the AWS account. AWS CodeStar project IDs must be unique within a region for the AWS account.
public struct ProjectAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ProjectAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProjectConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Project configuration information is required but not specified.
public struct ProjectConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ProjectConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectCreationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProjectCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The project creation request was valid, but a nonspecific exception or error occurred during project creation. The project could not be created in AWS CodeStar.
public struct ProjectCreationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectCreationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ProjectCreationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified AWS CodeStar project was not found.
public struct ProjectNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProjectNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ProjectNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProjectNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.ProjectStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeStarClientTypes {
    /// An indication of whether a project creation or deletion is failed or successful.
    public struct ProjectStatus: Swift.Equatable {
        /// In the case of a project creation or deletion failure, a reason for the failure.
        public var reason: Swift.String?
        /// The phase of completion for a project creation or deletion.
        /// This member is required.
        public var state: Swift.String?

        public init(
            reason: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.reason = reason
            self.state = state
        }
    }

}

extension CodeStarClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = self.projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about the metadata for a project.
    public struct ProjectSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The ID of the project.
        public var projectId: Swift.String?

        public init(
            projectArn: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.projectArn = projectArn
            self.projectId = projectId
        }
    }

}

extension CodeStarClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about a resource for a project.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension CodeStarClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketKey
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketKey = self.bucketKey {
            try encodeContainer.encode(bucketKey, forKey: .bucketKey)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketKey)
        bucketKey = bucketKeyDecoded
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the source code files provided with the project request are stored.
    public struct S3Location: Swift.Equatable {
        /// The Amazon S3 object key where the source code files provided with the project request are stored.
        public var bucketKey: Swift.String?
        /// The Amazon S3 bucket name where the source code files provided with the project request are stored.
        public var bucketName: Swift.String?

        public init(
            bucketKey: Swift.String? = nil,
            bucketName: Swift.String? = nil
        )
        {
            self.bucketKey = bucketKey
            self.bucketName = bucketName
        }
    }

}

extension TagProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagProjectInput: Swift.Equatable {
    /// The ID of the project you want to add a tag to.
    /// This member is required.
    public var id: Swift.String?
    /// The tags you want to add to the project.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct TagProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagProjectOutput: Swift.Equatable {
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagProjectOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum TagProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeStarClientTypes.TeamMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension CodeStarClientTypes {
    /// Information about a team member in a project.
    public struct TeamMember: Swift.Equatable {
        /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
        /// This member is required.
        public var projectRole: Swift.String?
        /// Whether the user is allowed to remotely access project resources using an SSH public/private key pair.
        public var remoteAccessAllowed: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        /// This member is required.
        public var userArn: Swift.String?

        public init(
            projectRole: Swift.String? = nil,
            remoteAccessAllowed: Swift.Bool? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.projectRole = projectRole
            self.remoteAccessAllowed = remoteAccessAllowed
            self.userArn = userArn
        }
    }

}

extension TeamMemberAlreadyAssociatedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TeamMemberAlreadyAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The team member is already associated with a role in this project.
public struct TeamMemberAlreadyAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TeamMemberAlreadyAssociatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TeamMemberAlreadyAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TeamMemberAlreadyAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TeamMemberNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TeamMemberNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified team member was not found.
public struct TeamMemberNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TeamMemberNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TeamMemberNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TeamMemberNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.Toolchain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case source
        case stackParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let stackParameters = stackParameters {
            var stackParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stackParameters)
            for (dictKey0, templateParameterMap0) in stackParameters {
                try stackParametersContainer.encode(templateParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ToolchainSource.self, forKey: .source)
        source = sourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stackParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stackParameters)
        var stackParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let stackParametersContainer = stackParametersContainer {
            stackParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templateparametervalue0) in stackParametersContainer {
                if let templateparametervalue0 = templateparametervalue0 {
                    stackParametersDecoded0?[key0] = templateparametervalue0
                }
            }
        }
        stackParameters = stackParametersDecoded0
    }
}

extension CodeStarClientTypes {
    /// The toolchain template file provided with the project request. AWS CodeStar uses the template to provision the toolchain stack in AWS CloudFormation.
    public struct Toolchain: Swift.Equatable {
        /// The service role ARN for AWS CodeStar to use for the toolchain template during stack provisioning.
        public var roleArn: Swift.String?
        /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.ToolchainSource?
        /// The list of parameter overrides to be passed into the toolchain template during stack provisioning, if any.
        public var stackParameters: [Swift.String:Swift.String]?

        public init(
            roleArn: Swift.String? = nil,
            source: CodeStarClientTypes.ToolchainSource? = nil,
            stackParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.source = source
            self.stackParameters = stackParameters
        }
    }

}

extension CodeStarClientTypes.ToolchainSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the toolchain template file provided with the project request is stored. AWS CodeStar retrieves the file during project creation.
    public struct ToolchainSource: Swift.Equatable {
        /// The Amazon S3 bucket where the toolchain template file provided with the project request is stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init(
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension UntagProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagkey0 in tags {
                try tagsContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagProjectInput: Swift.Equatable {
    /// The ID of the project to remove tags from.
    /// This member is required.
    public var id: Swift.String?
    /// The tags to remove from the project.
    /// This member is required.
    public var tags: [Swift.String]?

    public init(
        id: Swift.String? = nil,
        tags: [Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct UntagProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let tags: [Swift.String]?
}

extension UntagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagProjectOutput: Swift.Equatable {

    public init() { }
}

enum UntagProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(id: \(Swift.String(describing: id)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project you want to update.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProjectOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTeamMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = self.projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if let remoteAccessAllowed = self.remoteAccessAllowed {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension UpdateTeamMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTeamMemberInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The role assigned to the user in the project. Project roles have different levels of access. For more information, see [Working with Teams](http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html) in the AWS CodeStar User Guide.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile. Even if this is set to True, the user must associate a public key with their profile before the user can access resources.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user for whom you want to change team membership attributes.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension UpdateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension UpdateTeamMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTeamMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.projectRole = output.projectRole
            self.remoteAccessAllowed = output.remoteAccessAllowed
            self.userArn = output.userArn
        } else {
            self.projectRole = nil
            self.remoteAccessAllowed = nil
            self.userArn = nil
        }
    }
}

public struct UpdateTeamMemberOutput: Swift.Equatable {
    /// The project role granted to the user.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH public key associated with the user's profile.
    public var remoteAccessAllowed: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the user whose team membership attributes were updated.
    public var userArn: Swift.String?

    public init(
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberOutputBody: Swift.Equatable {
    let userArn: Swift.String?
    let projectRole: Swift.String?
    let remoteAccessAllowed: Swift.Bool?
}

extension UpdateTeamMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

enum UpdateTeamMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceRoleException": return try await InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectConfigurationException": return try await ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ProjectNotFoundException": return try await ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TeamMemberNotFoundException": return try await TeamMemberNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileInput(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension UpdateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateUserProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileOutput(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension UpdateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct UpdateUserProfileOutput: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the public/private keypair the user can use to access project resources if a project owner allows the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileOutputBody: Swift.Equatable {
    let userArn: Swift.String?
    let displayName: Swift.String?
    let emailAddress: Swift.String?
    let sshPublicKey: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
    let lastModifiedTimestamp: ClientRuntime.Date?
}

extension UpdateUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

enum UpdateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UserProfileNotFoundException": return try await UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UserProfileAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserProfileAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A user profile with that name already exists in this region for the AWS account. AWS CodeStar user profile names must be unique within a region for the AWS account.
public struct UserProfileAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserProfileAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserProfileAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserProfileAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserProfileNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UserProfileNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user profile was not found.
public struct UserProfileNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserProfileNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UserProfileNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UserProfileNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileSummary(sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)), displayName: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\")"}
}

extension CodeStarClientTypes {
    /// Information about a user's profile in AWS CodeStar.
    public struct UserProfileSummary: Swift.Equatable {
        /// The display name of a user in AWS CodeStar. For example, this could be set to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the display name, the first character that appears after the space will be used as the second character in the user initial icon. The initial icon displays a maximum of two characters, so a display name with more than one space (for example "Mary Jane Major") would generate an initial icon using the first character and the first character after the space ("MJ", not "MM").
        public var displayName: Swift.String?
        /// The email address associated with the user.
        public var emailAddress: Swift.String?
        /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the user remote access to project resources, this public key will be used along with the user's private key for SSH access.
        public var sshPublicKey: Swift.String?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        public var userArn: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.sshPublicKey = sshPublicKey
            self.userArn = userArn
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified input is either not valid, or it could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
