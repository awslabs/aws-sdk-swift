// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConfigClientTypes.AccountAggregationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case allAwsRegions = "AllAwsRegions"
        case awsRegions = "AwsRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if allAwsRegions != false {
            try encodeContainer.encode(allAwsRegions, forKey: .allAwsRegions)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for string0 in awsRegions {
                try awsRegionsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let allAwsRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allAwsRegions) ?? false
        allAwsRegions = allAwsRegionsDecoded
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
    }
}

extension ConfigClientTypes {
    /// A collection of accounts and regions.
    public struct AccountAggregationSource: Swift.Equatable {
        /// The 12-digit account ID of the account being aggregated.
        /// This member is required.
        public var accountIds: [Swift.String]?
        /// If true, aggregate existing Config regions and future regions.
        public var allAwsRegions: Swift.Bool
        /// The source regions being aggregated.
        public var awsRegions: [Swift.String]?

        public init (
            accountIds: [Swift.String]? = nil,
            allAwsRegions: Swift.Bool = false,
            awsRegions: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
        }
    }

}

extension ConfigClientTypes.AggregateComplianceByConfigRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case compliance = "Compliance"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let compliance = self.compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Indicates whether an Config rule is compliant based on account ID, region, compliance, and rule name. A rule is compliant if all of the resources that the rule evaluated comply with it. It is noncompliant if any of these resources do not comply.
    public struct AggregateComplianceByConfigRule: Swift.Equatable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.
        public var compliance: ConfigClientTypes.Compliance?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            compliance: ConfigClientTypes.Compliance? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.configRuleName = configRuleName
        }
    }

}

extension ConfigClientTypes.AggregateComplianceByConformancePack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case compliance = "Compliance"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let compliance = self.compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateConformancePackCompliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Provides aggregate compliance of the conformance pack. Indicates whether a conformance pack is compliant based on the name of the conformance pack, account ID, and region. A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.
    public struct AggregateComplianceByConformancePack: Swift.Equatable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The compliance status of the conformance pack.
        public var compliance: ConfigClientTypes.AggregateConformancePackCompliance?
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            compliance: ConfigClientTypes.AggregateConformancePackCompliance? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.conformancePackName = conformancePackName
        }
    }

}

extension ConfigClientTypes.AggregateComplianceCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummary = "ComplianceSummary"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = self.complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension ConfigClientTypes {
    /// Returns the number of compliant and noncompliant rules for one or more accounts and regions in an aggregator.
    public struct AggregateComplianceCount: Swift.Equatable {
        /// The number of compliant and noncompliant Config rules.
        public var complianceSummary: ConfigClientTypes.ComplianceSummary?
        /// The 12-digit account ID or region based on the GroupByKey value.
        public var groupName: Swift.String?

        public init (
            complianceSummary: ConfigClientTypes.ComplianceSummary? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }
    }

}

extension ConfigClientTypes.AggregateConformancePackCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantRuleCount = "CompliantRuleCount"
        case nonCompliantRuleCount = "NonCompliantRuleCount"
        case totalRuleCount = "TotalRuleCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if compliantRuleCount != 0 {
            try encodeContainer.encode(compliantRuleCount, forKey: .compliantRuleCount)
        }
        if nonCompliantRuleCount != 0 {
            try encodeContainer.encode(nonCompliantRuleCount, forKey: .nonCompliantRuleCount)
        }
        if totalRuleCount != 0 {
            try encodeContainer.encode(totalRuleCount, forKey: .totalRuleCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let compliantRuleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantRuleCount) ?? 0
        compliantRuleCount = compliantRuleCountDecoded
        let nonCompliantRuleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantRuleCount) ?? 0
        nonCompliantRuleCount = nonCompliantRuleCountDecoded
        let totalRuleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRuleCount) ?? 0
        totalRuleCount = totalRuleCountDecoded
    }
}

extension ConfigClientTypes {
    /// Provides the number of compliant and noncompliant rules within a conformance pack. Also provides the compliance status of the conformance pack and the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data. A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.
    public struct AggregateConformancePackCompliance: Swift.Equatable {
        /// The compliance status of the conformance pack.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The number of compliant Config Rules.
        public var compliantRuleCount: Swift.Int
        /// The number of noncompliant Config Rules.
        public var nonCompliantRuleCount: Swift.Int
        /// Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.
        public var totalRuleCount: Swift.Int

        public init (
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            compliantRuleCount: Swift.Int = 0,
            nonCompliantRuleCount: Swift.Int = 0,
            totalRuleCount: Swift.Int = 0
        )
        {
            self.complianceType = complianceType
            self.compliantRuleCount = compliantRuleCount
            self.nonCompliantRuleCount = nonCompliantRuleCount
            self.totalRuleCount = totalRuleCount
        }
    }

}

extension ConfigClientTypes.AggregateConformancePackComplianceCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliantConformancePackCount = "CompliantConformancePackCount"
        case nonCompliantConformancePackCount = "NonCompliantConformancePackCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compliantConformancePackCount != 0 {
            try encodeContainer.encode(compliantConformancePackCount, forKey: .compliantConformancePackCount)
        }
        if nonCompliantConformancePackCount != 0 {
            try encodeContainer.encode(nonCompliantConformancePackCount, forKey: .nonCompliantConformancePackCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantConformancePackCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantConformancePackCount) ?? 0
        compliantConformancePackCount = compliantConformancePackCountDecoded
        let nonCompliantConformancePackCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantConformancePackCount) ?? 0
        nonCompliantConformancePackCount = nonCompliantConformancePackCountDecoded
    }
}

extension ConfigClientTypes {
    /// The number of conformance packs that are compliant and noncompliant.
    public struct AggregateConformancePackComplianceCount: Swift.Equatable {
        /// Number of compliant conformance packs.
        public var compliantConformancePackCount: Swift.Int
        /// Number of noncompliant conformance packs.
        public var nonCompliantConformancePackCount: Swift.Int

        public init (
            compliantConformancePackCount: Swift.Int = 0,
            nonCompliantConformancePackCount: Swift.Int = 0
        )
        {
            self.compliantConformancePackCount = compliantConformancePackCount
            self.nonCompliantConformancePackCount = nonCompliantConformancePackCount
        }
    }

}

extension ConfigClientTypes.AggregateConformancePackComplianceFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the conformance packs based on an account ID, region, compliance type, and the name of the conformance pack.
    public struct AggregateConformancePackComplianceFilters: Swift.Equatable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The compliance status of the conformance pack.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.conformancePackName = conformancePackName
        }
    }

}

extension ConfigClientTypes.AggregateConformancePackComplianceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummary = "ComplianceSummary"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = self.complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateConformancePackComplianceCount.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension ConfigClientTypes {
    /// Provides a summary of compliance based on either account ID or region.
    public struct AggregateConformancePackComplianceSummary: Swift.Equatable {
        /// Returns an AggregateConformancePackComplianceCount object.
        public var complianceSummary: ConfigClientTypes.AggregateConformancePackComplianceCount?
        /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
        public var groupName: Swift.String?

        public init (
            complianceSummary: ConfigClientTypes.AggregateConformancePackComplianceCount? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }
    }

}

extension ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the results based on account ID and region.
    public struct AggregateConformancePackComplianceSummaryFilters: Swift.Equatable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }
    }

}

extension ConfigClientTypes {
    public enum AggregateConformancePackComplianceSummaryGroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case awsRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateConformancePackComplianceSummaryGroupKey] {
            return [
                .accountId,
                .awsRegion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregateConformancePackComplianceSummaryGroupKey(rawValue: rawValue) ?? AggregateConformancePackComplianceSummaryGroupKey.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.AggregateEvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case annotation = "Annotation"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let annotation = self.annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = self.configRuleInvokedTime {
            try encodeContainer.encodeTimestamp(configRuleInvokedTime, format: .epochSeconds, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = self.evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = self.resultRecordedTime {
            try encodeContainer.encodeTimestamp(resultRecordedTime, format: .epochSeconds, forKey: .resultRecordedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .annotation)
        annotation = annotationDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// The details of an Config evaluation for an account ID and region in an aggregator. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information.
    public struct AggregateEvaluationResult: Swift.Equatable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// Supplementary information about how the agrregate evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The source region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The resource compliance status. For the AggregationEvaluationResult data type, Config supports only the COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA value.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services resource.
        public var configRuleInvokedTime: ClientRuntime.Date?
        /// Uniquely identifies the evaluation result.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the aggregate evaluation result.
        public var resultRecordedTime: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            annotation: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleInvokedTime: ClientRuntime.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.annotation = annotation
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }
    }

}

extension ConfigClientTypes.AggregateResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceAccountId = "SourceAccountId"
        case sourceRegion = "SourceRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sourceAccountId = self.sourceAccountId {
            try encodeContainer.encode(sourceAccountId, forKey: .sourceAccountId)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccountId)
        sourceAccountId = sourceAccountIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ConfigClientTypes {
    /// The details that identify a resource that is collected by Config aggregator, including the resource type, ID, (if available) the custom resource name, the source account, and source region.
    public struct AggregateResourceIdentifier: Swift.Equatable {
        /// The ID of the Amazon Web Services resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The name of the Amazon Web Services resource.
        public var resourceName: Swift.String?
        /// The type of the Amazon Web Services resource.
        /// This member is required.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// The 12-digit account ID of the source account.
        /// This member is required.
        public var sourceAccountId: Swift.String?
        /// The source region where data is aggregated.
        /// This member is required.
        public var sourceRegion: Swift.String?

        public init (
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceRegion: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceAccountId = sourceAccountId
            self.sourceRegion = sourceRegion
        }
    }

}

extension ConfigClientTypes.AggregatedSourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case lastErrorCode = "LastErrorCode"
        case lastErrorMessage = "LastErrorMessage"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateTime = "LastUpdateTime"
        case sourceId = "SourceId"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let lastErrorCode = self.lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = self.lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastUpdateStatus = self.lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregatedSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregatedSourceStatusType.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
    }
}

extension ConfigClientTypes {
    /// The current sync status between the source and the aggregator account.
    public struct AggregatedSourceStatus: Swift.Equatable {
        /// The region authorized to collect aggregated data.
        public var awsRegion: Swift.String?
        /// The error code that Config returned when the source account aggregation last failed.
        public var lastErrorCode: Swift.String?
        /// The message indicating that the source account aggregation failed due to an error.
        public var lastErrorMessage: Swift.String?
        /// Filters the last updated status type.
        ///
        /// * Valid value FAILED indicates errors while moving data.
        ///
        /// * Valid value SUCCEEDED indicates the data was successfully moved.
        ///
        /// * Valid value OUTDATED indicates the data is not the most recent.
        public var lastUpdateStatus: ConfigClientTypes.AggregatedSourceStatusType?
        /// The time of the last update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The source account ID or an organization.
        public var sourceId: Swift.String?
        /// The source account or an organization.
        public var sourceType: ConfigClientTypes.AggregatedSourceType?

        public init (
            awsRegion: Swift.String? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastUpdateStatus: ConfigClientTypes.AggregatedSourceStatusType? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            sourceId: Swift.String? = nil,
            sourceType: ConfigClientTypes.AggregatedSourceType? = nil
        )
        {
            self.awsRegion = awsRegion
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateTime = lastUpdateTime
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }

}

extension ConfigClientTypes {
    public enum AggregatedSourceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case outdated
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedSourceStatusType] {
            return [
                .failed,
                .outdated,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .outdated: return "OUTDATED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregatedSourceStatusType(rawValue: rawValue) ?? AggregatedSourceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes {
    public enum AggregatedSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedSourceType] {
            return [
                .account,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregatedSourceType(rawValue: rawValue) ?? AggregatedSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.AggregationAuthorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationAuthorizationArn = "AggregationAuthorizationArn"
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case creationTime = "CreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationAuthorizationArn = self.aggregationAuthorizationArn {
            try encodeContainer.encode(aggregationAuthorizationArn, forKey: .aggregationAuthorizationArn)
        }
        if let authorizedAccountId = self.authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = self.authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationAuthorizationArn)
        aggregationAuthorizationArn = aggregationAuthorizationArnDecoded
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ConfigClientTypes {
    /// An object that represents the authorizations granted to aggregator accounts and regions.
    public struct AggregationAuthorization: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the aggregation object.
        public var aggregationAuthorizationArn: Swift.String?
        /// The 12-digit account ID of the account authorized to aggregate data.
        public var authorizedAccountId: Swift.String?
        /// The region authorized to collect aggregated data.
        public var authorizedAwsRegion: Swift.String?
        /// The time stamp when the aggregation authorization was created.
        public var creationTime: ClientRuntime.Date?

        public init (
            aggregationAuthorizationArn: Swift.String? = nil,
            authorizedAccountId: Swift.String? = nil,
            authorizedAwsRegion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil
        )
        {
            self.aggregationAuthorizationArn = aggregationAuthorizationArn
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.creationTime = creationTime
        }
    }

}

extension ConfigClientTypes.BaseConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case arn
        case availabilityZone
        case awsRegion
        case configuration
        case configurationItemCaptureTime
        case configurationItemStatus
        case configurationStateId
        case resourceCreationTime
        case resourceId
        case resourceName
        case resourceType
        case supplementaryConfiguration
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let configurationItemCaptureTime = self.configurationItemCaptureTime {
            try encodeContainer.encodeTimestamp(configurationItemCaptureTime, format: .epochSeconds, forKey: .configurationItemCaptureTime)
        }
        if let configurationItemStatus = self.configurationItemStatus {
            try encodeContainer.encode(configurationItemStatus.rawValue, forKey: .configurationItemStatus)
        }
        if let configurationStateId = self.configurationStateId {
            try encodeContainer.encode(configurationStateId, forKey: .configurationStateId)
        }
        if let resourceCreationTime = self.resourceCreationTime {
            try encodeContainer.encodeTimestamp(resourceCreationTime, format: .epochSeconds, forKey: .resourceCreationTime)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let supplementaryConfiguration = supplementaryConfiguration {
            var supplementaryConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supplementaryConfiguration)
            for (dictKey0, supplementaryConfiguration0) in supplementaryConfiguration {
                try supplementaryConfigurationContainer.encode(supplementaryConfiguration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configurationItemCaptureTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .configurationItemCaptureTime)
        configurationItemCaptureTime = configurationItemCaptureTimeDecoded
        let configurationItemStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigurationItemStatus.self, forKey: .configurationItemStatus)
        configurationItemStatus = configurationItemStatusDecoded
        let configurationStateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationStateId)
        configurationStateId = configurationStateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let resourceCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resourceCreationTime)
        resourceCreationTime = resourceCreationTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let supplementaryConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supplementaryConfiguration)
        var supplementaryConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let supplementaryConfigurationContainer = supplementaryConfigurationContainer {
            supplementaryConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, supplementaryconfigurationvalue0) in supplementaryConfigurationContainer {
                if let supplementaryconfigurationvalue0 = supplementaryconfigurationvalue0 {
                    supplementaryConfigurationDecoded0?[key0] = supplementaryconfigurationvalue0
                }
            }
        }
        supplementaryConfiguration = supplementaryConfigurationDecoded0
    }
}

extension ConfigClientTypes {
    /// The detailed configuration of a specified resource.
    public struct BaseConfigurationItem: Swift.Equatable {
        /// The 12-digit Amazon Web Services account ID associated with the resource.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The Availability Zone associated with the resource.
        public var availabilityZone: Swift.String?
        /// The region where the resource resides.
        public var awsRegion: Swift.String?
        /// The description of the resource configuration.
        public var configuration: Swift.String?
        /// The time when the configuration recording was initiated.
        public var configurationItemCaptureTime: ClientRuntime.Date?
        /// The configuration item status. The valid values are:
        ///
        /// * OK – The resource configuration has been updated
        ///
        /// * ResourceDiscovered – The resource was newly discovered
        ///
        /// * ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type
        ///
        /// * ResourceDeleted – The resource was deleted
        ///
        /// * ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type
        ///
        ///
        /// The CIs do not incur any cost.
        public var configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public var configurationStateId: Swift.String?
        /// The time stamp when the resource was created.
        public var resourceCreationTime: ClientRuntime.Date?
        /// The ID of the resource (for example., sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource, if available.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public var supplementaryConfiguration: [Swift.String:Swift.String]?
        /// The version number of the resource configuration.
        public var version: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            configuration: Swift.String? = nil,
            configurationItemCaptureTime: ClientRuntime.Date? = nil,
            configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus? = nil,
            configurationStateId: Swift.String? = nil,
            resourceCreationTime: ClientRuntime.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            supplementaryConfiguration: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.version = version
        }
    }

}

extension BatchGetAggregateResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let resourceIdentifiers = resourceIdentifiers {
            var resourceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdentifiers)
            for aggregateresourceidentifier0 in resourceIdentifiers {
                try resourceIdentifiersContainer.encode(aggregateresourceidentifier0)
            }
        }
    }
}

extension BatchGetAggregateResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetAggregateResourceConfigInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// A list of aggregate ResourceIdentifiers objects.
    /// This member is required.
    public var resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct BatchGetAggregateResourceConfigInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?
}

extension BatchGetAggregateResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ConfigClientTypes.AggregateResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ConfigClientTypes.AggregateResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
    }
}

extension BatchGetAggregateResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAggregateResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetAggregateResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAggregateResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseConfigurationItems = output.baseConfigurationItems
            self.unprocessedResourceIdentifiers = output.unprocessedResourceIdentifiers
        } else {
            self.baseConfigurationItems = nil
            self.unprocessedResourceIdentifiers = nil
        }
    }
}

public struct BatchGetAggregateResourceConfigOutputResponse: Swift.Equatable {
    /// A list that contains the current configuration of one or more resources.
    public var baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    /// A list of resource identifiers that were not processed with current scope. The list is empty if all the resources are processed.
    public var unprocessedResourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init (
        baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]? = nil,
        unprocessedResourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceIdentifiers = unprocessedResourceIdentifiers
    }
}

struct BatchGetAggregateResourceConfigOutputResponseBody: Swift.Equatable {
    let baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    let unprocessedResourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?
}

extension BatchGetAggregateResourceConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseConfigurationItems = "BaseConfigurationItems"
        case unprocessedResourceIdentifiers = "UnprocessedResourceIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseConfigurationItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.BaseConfigurationItem?].self, forKey: .baseConfigurationItems)
        var baseConfigurationItemsDecoded0:[ConfigClientTypes.BaseConfigurationItem]? = nil
        if let baseConfigurationItemsContainer = baseConfigurationItemsContainer {
            baseConfigurationItemsDecoded0 = [ConfigClientTypes.BaseConfigurationItem]()
            for structure0 in baseConfigurationItemsContainer {
                if let structure0 = structure0 {
                    baseConfigurationItemsDecoded0?.append(structure0)
                }
            }
        }
        baseConfigurationItems = baseConfigurationItemsDecoded0
        let unprocessedResourceIdentifiersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateResourceIdentifier?].self, forKey: .unprocessedResourceIdentifiers)
        var unprocessedResourceIdentifiersDecoded0:[ConfigClientTypes.AggregateResourceIdentifier]? = nil
        if let unprocessedResourceIdentifiersContainer = unprocessedResourceIdentifiersContainer {
            unprocessedResourceIdentifiersDecoded0 = [ConfigClientTypes.AggregateResourceIdentifier]()
            for structure0 in unprocessedResourceIdentifiersContainer {
                if let structure0 = structure0 {
                    unprocessedResourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedResourceIdentifiers = unprocessedResourceIdentifiersDecoded0
    }
}

extension BatchGetResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekey0)
            }
        }
    }
}

extension BatchGetResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetResourceConfigInput: Swift.Equatable {
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init (
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.resourceKeys = resourceKeys
    }
}

struct BatchGetResourceConfigInputBody: Swift.Equatable {
    let resourceKeys: [ConfigClientTypes.ResourceKey]?
}

extension BatchGetResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension BatchGetResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseConfigurationItems = output.baseConfigurationItems
            self.unprocessedResourceKeys = output.unprocessedResourceKeys
        } else {
            self.baseConfigurationItems = nil
            self.unprocessedResourceKeys = nil
        }
    }
}

public struct BatchGetResourceConfigOutputResponse: Swift.Equatable {
    /// A list that contains the current configuration of one or more resources.
    public var baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    /// A list of resource keys that were not processed with the current response. The unprocessesResourceKeys value is in the same form as ResourceKeys, so the value can be directly provided to a subsequent BatchGetResourceConfig operation. If there are no unprocessed resource keys, the response contains an empty unprocessedResourceKeys list.
    public var unprocessedResourceKeys: [ConfigClientTypes.ResourceKey]?

    public init (
        baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]? = nil,
        unprocessedResourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceKeys = unprocessedResourceKeys
    }
}

struct BatchGetResourceConfigOutputResponseBody: Swift.Equatable {
    let baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    let unprocessedResourceKeys: [ConfigClientTypes.ResourceKey]?
}

extension BatchGetResourceConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseConfigurationItems
        case unprocessedResourceKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseConfigurationItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.BaseConfigurationItem?].self, forKey: .baseConfigurationItems)
        var baseConfigurationItemsDecoded0:[ConfigClientTypes.BaseConfigurationItem]? = nil
        if let baseConfigurationItemsContainer = baseConfigurationItemsContainer {
            baseConfigurationItemsDecoded0 = [ConfigClientTypes.BaseConfigurationItem]()
            for structure0 in baseConfigurationItemsContainer {
                if let structure0 = structure0 {
                    baseConfigurationItemsDecoded0?.append(structure0)
                }
            }
        }
        baseConfigurationItems = baseConfigurationItemsDecoded0
        let unprocessedResourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceKey?].self, forKey: .unprocessedResourceKeys)
        var unprocessedResourceKeysDecoded0:[ConfigClientTypes.ResourceKey]? = nil
        if let unprocessedResourceKeysContainer = unprocessedResourceKeysContainer {
            unprocessedResourceKeysDecoded0 = [ConfigClientTypes.ResourceKey]()
            for structure0 in unprocessedResourceKeysContainer {
                if let structure0 = structure0 {
                    unprocessedResourceKeysDecoded0?.append(structure0)
                }
            }
        }
        unprocessedResourceKeys = unprocessedResourceKeysDecoded0
    }
}

extension ConfigClientTypes {
    public enum ChronologicalOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forward
        case reverse
        case sdkUnknown(Swift.String)

        public static var allCases: [ChronologicalOrder] {
            return [
                .forward,
                .reverse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forward: return "Forward"
            case .reverse: return "Reverse"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChronologicalOrder(rawValue: rawValue) ?? ChronologicalOrder.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.Compliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceContributorCount = "ComplianceContributorCount"
        case complianceType = "ComplianceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceContributorCount = self.complianceContributorCount {
            try encodeContainer.encode(complianceContributorCount, forKey: .complianceContributorCount)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let complianceContributorCountDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceContributorCount.self, forKey: .complianceContributorCount)
        complianceContributorCount = complianceContributorCountDecoded
    }
}

extension ConfigClientTypes {
    /// Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.
    public struct Compliance: Swift.Equatable {
        /// The number of Amazon Web Services resources or Config rules that cause a result of NON_COMPLIANT, up to a maximum number.
        public var complianceContributorCount: ConfigClientTypes.ComplianceContributorCount?
        /// Indicates whether an Amazon Web Services resource or Config rule is compliant. A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules. A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply. Config returns the INSUFFICIENT_DATA value when no evaluation results are available for the Amazon Web Services resource or Config rule. For the Compliance data type, Config supports only COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA values. Config does not support the NOT_APPLICABLE value for the Compliance data type.
        public var complianceType: ConfigClientTypes.ComplianceType?

        public init (
            complianceContributorCount: ConfigClientTypes.ComplianceContributorCount? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil
        )
        {
            self.complianceContributorCount = complianceContributorCount
            self.complianceType = complianceType
        }
    }

}

extension ConfigClientTypes.ComplianceByConfigRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliance = "Compliance"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliance = self.compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
    }
}

extension ConfigClientTypes {
    /// Indicates whether an Config rule is compliant. A rule is compliant if all of the resources that the rule evaluated comply with it. A rule is noncompliant if any of these resources do not comply.
    public struct ComplianceByConfigRule: Swift.Equatable {
        /// Indicates whether the Config rule is compliant.
        public var compliance: ConfigClientTypes.Compliance?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init (
            compliance: ConfigClientTypes.Compliance? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.compliance = compliance
            self.configRuleName = configRuleName
        }
    }

}

extension ConfigClientTypes.ComplianceByResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliance = "Compliance"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliance = self.compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
    }
}

extension ConfigClientTypes {
    /// Indicates whether an Amazon Web Services resource that is evaluated according to one or more Config rules is compliant. A resource is compliant if it complies with all of the rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.
    public struct ComplianceByResource: Swift.Equatable {
        /// Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.
        public var compliance: ConfigClientTypes.Compliance?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceId: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceType: Swift.String?

        public init (
            compliance: ConfigClientTypes.Compliance? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.compliance = compliance
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.ComplianceContributorCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capExceeded = "CapExceeded"
        case cappedCount = "CappedCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if capExceeded != false {
            try encodeContainer.encode(capExceeded, forKey: .capExceeded)
        }
        if cappedCount != 0 {
            try encodeContainer.encode(cappedCount, forKey: .cappedCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cappedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cappedCount) ?? 0
        cappedCount = cappedCountDecoded
        let capExceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .capExceeded) ?? false
        capExceeded = capExceededDecoded
    }
}

extension ConfigClientTypes {
    /// The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item, up to a maximum number.
    public struct ComplianceContributorCount: Swift.Equatable {
        /// Indicates whether the maximum count is reached.
        public var capExceeded: Swift.Bool
        /// The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.
        public var cappedCount: Swift.Int

        public init (
            capExceeded: Swift.Bool = false,
            cappedCount: Swift.Int = 0
        )
        {
            self.capExceeded = capExceeded
            self.cappedCount = cappedCount
        }
    }

}

extension ConfigClientTypes.ComplianceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummaryTimestamp = "ComplianceSummaryTimestamp"
        case compliantResourceCount = "CompliantResourceCount"
        case nonCompliantResourceCount = "NonCompliantResourceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummaryTimestamp = self.complianceSummaryTimestamp {
            try encodeContainer.encodeTimestamp(complianceSummaryTimestamp, format: .epochSeconds, forKey: .complianceSummaryTimestamp)
        }
        if let compliantResourceCount = self.compliantResourceCount {
            try encodeContainer.encode(compliantResourceCount, forKey: .compliantResourceCount)
        }
        if let nonCompliantResourceCount = self.nonCompliantResourceCount {
            try encodeContainer.encode(nonCompliantResourceCount, forKey: .nonCompliantResourceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantResourceCountDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceContributorCount.self, forKey: .compliantResourceCount)
        compliantResourceCount = compliantResourceCountDecoded
        let nonCompliantResourceCountDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceContributorCount.self, forKey: .nonCompliantResourceCount)
        nonCompliantResourceCount = nonCompliantResourceCountDecoded
        let complianceSummaryTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .complianceSummaryTimestamp)
        complianceSummaryTimestamp = complianceSummaryTimestampDecoded
    }
}

extension ConfigClientTypes {
    /// The number of Config rules or Amazon Web Services resources that are compliant and noncompliant.
    public struct ComplianceSummary: Swift.Equatable {
        /// The time that Config created the compliance summary.
        public var complianceSummaryTimestamp: ClientRuntime.Date?
        /// The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.
        public var compliantResourceCount: ConfigClientTypes.ComplianceContributorCount?
        /// The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.
        public var nonCompliantResourceCount: ConfigClientTypes.ComplianceContributorCount?

        public init (
            complianceSummaryTimestamp: ClientRuntime.Date? = nil,
            compliantResourceCount: ConfigClientTypes.ComplianceContributorCount? = nil,
            nonCompliantResourceCount: ConfigClientTypes.ComplianceContributorCount? = nil
        )
        {
            self.complianceSummaryTimestamp = complianceSummaryTimestamp
            self.compliantResourceCount = compliantResourceCount
            self.nonCompliantResourceCount = nonCompliantResourceCount
        }
    }

}

extension ConfigClientTypes.ComplianceSummaryByResourceType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummary = "ComplianceSummary"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = self.complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension ConfigClientTypes {
    /// The number of Amazon Web Services resources of a specific type that are compliant or noncompliant, up to a maximum of 100 for each.
    public struct ComplianceSummaryByResourceType: Swift.Equatable {
        /// The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.
        public var complianceSummary: ConfigClientTypes.ComplianceSummary?
        /// The type of Amazon Web Services resource.
        public var resourceType: Swift.String?

        public init (
            complianceSummary: ConfigClientTypes.ComplianceSummary? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes {
    public enum ComplianceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case insufficientData
        case nonCompliant
        case notApplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceType] {
            return [
                .compliant,
                .insufficientData,
                .nonCompliant,
                .notApplicable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .nonCompliant: return "NON_COMPLIANT"
            case .notApplicable: return "NOT_APPLICABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceType(rawValue: rawValue) ?? ComplianceType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConfigExportDeliveryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAttemptTime
        case lastErrorCode
        case lastErrorMessage
        case lastStatus
        case lastSuccessfulTime
        case nextDeliveryTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastAttemptTime = self.lastAttemptTime {
            try encodeContainer.encodeTimestamp(lastAttemptTime, format: .epochSeconds, forKey: .lastAttemptTime)
        }
        if let lastErrorCode = self.lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = self.lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStatus = self.lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastSuccessfulTime = self.lastSuccessfulTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulTime, format: .epochSeconds, forKey: .lastSuccessfulTime)
        }
        if let nextDeliveryTime = self.nextDeliveryTime {
            try encodeContainer.encodeTimestamp(nextDeliveryTime, format: .epochSeconds, forKey: .nextDeliveryTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.DeliveryStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastAttemptTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAttemptTime)
        lastAttemptTime = lastAttemptTimeDecoded
        let lastSuccessfulTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulTime)
        lastSuccessfulTime = lastSuccessfulTimeDecoded
        let nextDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextDeliveryTime)
        nextDeliveryTime = nextDeliveryTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Provides status of the delivery of the snapshot or the configuration history to the specified Amazon S3 bucket. Also provides the status of notifications about the Amazon S3 delivery to the specified Amazon SNS topic.
    public struct ConfigExportDeliveryInfo: Swift.Equatable {
        /// The time of the last attempted delivery.
        public var lastAttemptTime: ClientRuntime.Date?
        /// The error code from the last attempted delivery.
        public var lastErrorCode: Swift.String?
        /// The error message from the last attempted delivery.
        public var lastErrorMessage: Swift.String?
        /// Status of the last attempted delivery.
        public var lastStatus: ConfigClientTypes.DeliveryStatus?
        /// The time of the last successful delivery.
        public var lastSuccessfulTime: ClientRuntime.Date?
        /// The time that the next delivery occurs.
        public var nextDeliveryTime: ClientRuntime.Date?

        public init (
            lastAttemptTime: ClientRuntime.Date? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStatus: ConfigClientTypes.DeliveryStatus? = nil,
            lastSuccessfulTime: ClientRuntime.Date? = nil,
            nextDeliveryTime: ClientRuntime.Date? = nil
        )
        {
            self.lastAttemptTime = lastAttemptTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastSuccessfulTime = lastSuccessfulTime
            self.nextDeliveryTime = nextDeliveryTime
        }
    }

}

extension ConfigClientTypes.ConfigRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleArn = "ConfigRuleArn"
        case configRuleId = "ConfigRuleId"
        case configRuleName = "ConfigRuleName"
        case configRuleState = "ConfigRuleState"
        case createdBy = "CreatedBy"
        case description = "Description"
        case evaluationModes = "EvaluationModes"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case scope = "Scope"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleArn = self.configRuleArn {
            try encodeContainer.encode(configRuleArn, forKey: .configRuleArn)
        }
        if let configRuleId = self.configRuleId {
            try encodeContainer.encode(configRuleId, forKey: .configRuleId)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let configRuleState = self.configRuleState {
            try encodeContainer.encode(configRuleState.rawValue, forKey: .configRuleState)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationModes = evaluationModes {
            var evaluationModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationModes)
            for evaluationmodeconfiguration0 in evaluationModes {
                try evaluationModesContainer.encode(evaluationmodeconfiguration0)
            }
        }
        if let inputParameters = self.inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let configRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleArn)
        configRuleArn = configRuleArnDecoded
        let configRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleId)
        configRuleId = configRuleIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let inputParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let configRuleStateDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigRuleState.self, forKey: .configRuleState)
        configRuleState = configRuleStateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let evaluationModesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.EvaluationModeConfiguration?].self, forKey: .evaluationModes)
        var evaluationModesDecoded0:[ConfigClientTypes.EvaluationModeConfiguration]? = nil
        if let evaluationModesContainer = evaluationModesContainer {
            evaluationModesDecoded0 = [ConfigClientTypes.EvaluationModeConfiguration]()
            for structure0 in evaluationModesContainer {
                if let structure0 = structure0 {
                    evaluationModesDecoded0?.append(structure0)
                }
            }
        }
        evaluationModes = evaluationModesDecoded0
    }
}

extension ConfigClientTypes {
    /// Config rules evaluate the configuration settings of your Amazon Web Services resources. A rule can run when Config detects a configuration change to an Amazon Web Services resource or at a periodic frequency that you choose (for example, every 24 hours). There are two types of rules: Config Managed Rules and Config Custom Rules. Managed rules are predefined, customizable rules created by Config. For a list of managed rules, see [List of Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). Custom rules are rules that you can create using either Guard or Lambda functions. Guard ([Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard)) is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. Lambda uses custom code that you upload to evaluate a custom rule. It is invoked by events that are published to it by an event source, which Config invokes when the custom rule is initiated. For more information about developing and using Config rules, see [Evaluating Amazon Web Services resource Configurations with Config](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html) in the Config Developer Guide. You can use the Amazon Web Services CLI and Amazon Web Services SDKs if you want to create a rule that triggers evaluations for your resources when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
    public struct ConfigRule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Config rule.
        public var configRuleArn: Swift.String?
        /// The ID of the Config rule.
        public var configRuleId: Swift.String?
        /// The name that you assign to the Config rule. The name is required if you are adding a new rule.
        public var configRuleName: Swift.String?
        /// Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule. Config sets the state of the rule to EVALUATING temporarily after you use the StartConfigRulesEvaluation request to evaluate your resources against the Config rule. Config sets the state of the rule to DELETING_RESULTS temporarily after you use the DeleteEvaluationResults request to delete the current evaluation results for the Config rule. Config temporarily sets the state of a rule to DELETING after you use the DeleteConfigRule request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.
        public var configRuleState: ConfigClientTypes.ConfigRuleState?
        /// Service principal name of the service that created the rule. The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.
        public var createdBy: Swift.String?
        /// The description that you provide for the Config rule.
        public var description: Swift.String?
        /// The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.
        public var evaluationModes: [ConfigClientTypes.EvaluationModeConfiguration]?
        /// A string, in JSON format, that is passed to the Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. You can specify a value for MaximumExecutionFrequency when:
        ///
        /// * This is for an Config managed rule that is triggered at a periodic frequency.
        ///
        /// * Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        ///
        ///
        /// By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes. The scope can be empty.
        public var scope: ConfigClientTypes.Scope?
        /// Provides the rule owner (Amazon Web Services for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.
        /// This member is required.
        public var source: ConfigClientTypes.Source?

        public init (
            configRuleArn: Swift.String? = nil,
            configRuleId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            configRuleState: ConfigClientTypes.ConfigRuleState? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            evaluationModes: [ConfigClientTypes.EvaluationModeConfiguration]? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            scope: ConfigClientTypes.Scope? = nil,
            source: ConfigClientTypes.Source? = nil
        )
        {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.configRuleState = configRuleState
            self.createdBy = createdBy
            self.description = description
            self.evaluationModes = evaluationModes
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.scope = scope
            self.source = source
        }
    }

}

extension ConfigClientTypes.ConfigRuleComplianceFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the compliance results based on account ID, region, compliance type, and rule name.
    public struct ConfigRuleComplianceFilters: Swift.Equatable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The rule compliance status. For the ConfigRuleComplianceFilters data type, Config supports only COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and the INSUFFICIENT_DATA values.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
        }
    }

}

extension ConfigClientTypes.ConfigRuleComplianceSummaryFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the results based on the account IDs and regions.
    public struct ConfigRuleComplianceSummaryFilters: Swift.Equatable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region where the data is aggregated.
        public var awsRegion: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }
    }

}

extension ConfigClientTypes {
    public enum ConfigRuleComplianceSummaryGroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case awsRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRuleComplianceSummaryGroupKey] {
            return [
                .accountId,
                .awsRegion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigRuleComplianceSummaryGroupKey(rawValue: rawValue) ?? ConfigRuleComplianceSummaryGroupKey.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConfigRuleEvaluationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleArn = "ConfigRuleArn"
        case configRuleId = "ConfigRuleId"
        case configRuleName = "ConfigRuleName"
        case firstActivatedTime = "FirstActivatedTime"
        case firstEvaluationStarted = "FirstEvaluationStarted"
        case lastDeactivatedTime = "LastDeactivatedTime"
        case lastDebugLogDeliveryStatus = "LastDebugLogDeliveryStatus"
        case lastDebugLogDeliveryStatusReason = "LastDebugLogDeliveryStatusReason"
        case lastDebugLogDeliveryTime = "LastDebugLogDeliveryTime"
        case lastErrorCode = "LastErrorCode"
        case lastErrorMessage = "LastErrorMessage"
        case lastFailedEvaluationTime = "LastFailedEvaluationTime"
        case lastFailedInvocationTime = "LastFailedInvocationTime"
        case lastSuccessfulEvaluationTime = "LastSuccessfulEvaluationTime"
        case lastSuccessfulInvocationTime = "LastSuccessfulInvocationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleArn = self.configRuleArn {
            try encodeContainer.encode(configRuleArn, forKey: .configRuleArn)
        }
        if let configRuleId = self.configRuleId {
            try encodeContainer.encode(configRuleId, forKey: .configRuleId)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let firstActivatedTime = self.firstActivatedTime {
            try encodeContainer.encodeTimestamp(firstActivatedTime, format: .epochSeconds, forKey: .firstActivatedTime)
        }
        if firstEvaluationStarted != false {
            try encodeContainer.encode(firstEvaluationStarted, forKey: .firstEvaluationStarted)
        }
        if let lastDeactivatedTime = self.lastDeactivatedTime {
            try encodeContainer.encodeTimestamp(lastDeactivatedTime, format: .epochSeconds, forKey: .lastDeactivatedTime)
        }
        if let lastDebugLogDeliveryStatus = self.lastDebugLogDeliveryStatus {
            try encodeContainer.encode(lastDebugLogDeliveryStatus, forKey: .lastDebugLogDeliveryStatus)
        }
        if let lastDebugLogDeliveryStatusReason = self.lastDebugLogDeliveryStatusReason {
            try encodeContainer.encode(lastDebugLogDeliveryStatusReason, forKey: .lastDebugLogDeliveryStatusReason)
        }
        if let lastDebugLogDeliveryTime = self.lastDebugLogDeliveryTime {
            try encodeContainer.encodeTimestamp(lastDebugLogDeliveryTime, format: .epochSeconds, forKey: .lastDebugLogDeliveryTime)
        }
        if let lastErrorCode = self.lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = self.lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastFailedEvaluationTime = self.lastFailedEvaluationTime {
            try encodeContainer.encodeTimestamp(lastFailedEvaluationTime, format: .epochSeconds, forKey: .lastFailedEvaluationTime)
        }
        if let lastFailedInvocationTime = self.lastFailedInvocationTime {
            try encodeContainer.encodeTimestamp(lastFailedInvocationTime, format: .epochSeconds, forKey: .lastFailedInvocationTime)
        }
        if let lastSuccessfulEvaluationTime = self.lastSuccessfulEvaluationTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulEvaluationTime, format: .epochSeconds, forKey: .lastSuccessfulEvaluationTime)
        }
        if let lastSuccessfulInvocationTime = self.lastSuccessfulInvocationTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulInvocationTime, format: .epochSeconds, forKey: .lastSuccessfulInvocationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let configRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleArn)
        configRuleArn = configRuleArnDecoded
        let configRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleId)
        configRuleId = configRuleIdDecoded
        let lastSuccessfulInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulInvocationTime)
        lastSuccessfulInvocationTime = lastSuccessfulInvocationTimeDecoded
        let lastFailedInvocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastFailedInvocationTime)
        lastFailedInvocationTime = lastFailedInvocationTimeDecoded
        let lastSuccessfulEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulEvaluationTime)
        lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTimeDecoded
        let lastFailedEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastFailedEvaluationTime)
        lastFailedEvaluationTime = lastFailedEvaluationTimeDecoded
        let firstActivatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstActivatedTime)
        firstActivatedTime = firstActivatedTimeDecoded
        let lastDeactivatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeactivatedTime)
        lastDeactivatedTime = lastDeactivatedTimeDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let firstEvaluationStartedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .firstEvaluationStarted) ?? false
        firstEvaluationStarted = firstEvaluationStartedDecoded
        let lastDebugLogDeliveryStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDebugLogDeliveryStatus)
        lastDebugLogDeliveryStatus = lastDebugLogDeliveryStatusDecoded
        let lastDebugLogDeliveryStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDebugLogDeliveryStatusReason)
        lastDebugLogDeliveryStatusReason = lastDebugLogDeliveryStatusReasonDecoded
        let lastDebugLogDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDebugLogDeliveryTime)
        lastDebugLogDeliveryTime = lastDebugLogDeliveryTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Status information for your Config Managed rules and Config Custom Policy rules. The status includes information such as the last time the rule ran, the last time it failed, and the related error for the last failure. This action does not return status information about Config Custom Lambda rules.
    public struct ConfigRuleEvaluationStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Config rule.
        public var configRuleArn: Swift.String?
        /// The ID of the Config rule.
        public var configRuleId: Swift.String?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?
        /// The time that you first activated the Config rule.
        public var firstActivatedTime: ClientRuntime.Date?
        /// Indicates whether Config has evaluated your resources against the rule at least once.
        ///
        /// * true - Config has evaluated your Amazon Web Services resources against the rule at least once.
        ///
        /// * false - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.
        public var firstEvaluationStarted: Swift.Bool
        /// The time that you last turned off the Config rule.
        public var lastDeactivatedTime: ClientRuntime.Date?
        /// The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either Successful or Failed.
        public var lastDebugLogDeliveryStatus: Swift.String?
        /// The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.
        public var lastDebugLogDeliveryStatusReason: Swift.String?
        /// The time Config last attempted to deliver a debug log for your Config Custom Policy rules.
        public var lastDebugLogDeliveryTime: ClientRuntime.Date?
        /// The error code that Config returned when the rule last failed.
        public var lastErrorCode: Swift.String?
        /// The error message that Config returned when the rule last failed.
        public var lastErrorMessage: Swift.String?
        /// The time that Config last failed to evaluate your Amazon Web Services resources against the rule.
        public var lastFailedEvaluationTime: ClientRuntime.Date?
        /// The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.
        public var lastFailedInvocationTime: ClientRuntime.Date?
        /// The time that Config last successfully evaluated your Amazon Web Services resources against the rule.
        public var lastSuccessfulEvaluationTime: ClientRuntime.Date?
        /// The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.
        public var lastSuccessfulInvocationTime: ClientRuntime.Date?

        public init (
            configRuleArn: Swift.String? = nil,
            configRuleId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            firstActivatedTime: ClientRuntime.Date? = nil,
            firstEvaluationStarted: Swift.Bool = false,
            lastDeactivatedTime: ClientRuntime.Date? = nil,
            lastDebugLogDeliveryStatus: Swift.String? = nil,
            lastDebugLogDeliveryStatusReason: Swift.String? = nil,
            lastDebugLogDeliveryTime: ClientRuntime.Date? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastFailedEvaluationTime: ClientRuntime.Date? = nil,
            lastFailedInvocationTime: ClientRuntime.Date? = nil,
            lastSuccessfulEvaluationTime: ClientRuntime.Date? = nil,
            lastSuccessfulInvocationTime: ClientRuntime.Date? = nil
        )
        {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.firstActivatedTime = firstActivatedTime
            self.firstEvaluationStarted = firstEvaluationStarted
            self.lastDeactivatedTime = lastDeactivatedTime
            self.lastDebugLogDeliveryStatus = lastDebugLogDeliveryStatus
            self.lastDebugLogDeliveryStatusReason = lastDebugLogDeliveryStatusReason
            self.lastDebugLogDeliveryTime = lastDebugLogDeliveryTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastFailedEvaluationTime = lastFailedEvaluationTime
            self.lastFailedInvocationTime = lastFailedInvocationTime
            self.lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime
            self.lastSuccessfulInvocationTime = lastSuccessfulInvocationTime
        }
    }

}

extension ConfigClientTypes {
    public enum ConfigRuleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case deletingResults
        case evaluating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRuleState] {
            return [
                .active,
                .deleting,
                .deletingResults,
                .evaluating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .deletingResults: return "DELETING_RESULTS"
            case .evaluating: return "EVALUATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigRuleState(rawValue: rawValue) ?? ConfigRuleState.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConfigSnapshotDeliveryProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryFrequency = self.deliveryFrequency {
            try encodeContainer.encode(deliveryFrequency.rawValue, forKey: .deliveryFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .deliveryFrequency)
        deliveryFrequency = deliveryFrequencyDecoded
    }
}

extension ConfigClientTypes {
    /// Provides options for how often Config delivers configuration snapshots to the Amazon S3 bucket in your delivery channel. The frequency for a rule that triggers evaluations for your resources when Config delivers the configuration snapshot is set by one of two values, depending on which is less frequent:
    ///
    /// * The value for the deliveryFrequency parameter within the delivery channel configuration, which sets how often Config delivers configuration snapshots. This value also sets how often Config invokes evaluations for Config rules.
    ///
    /// * The value for the MaximumExecutionFrequency parameter, which sets the maximum frequency with which Config invokes evaluations for the rule. For more information, see [ConfigRule].
    ///
    ///
    /// If the deliveryFrequency value is less frequent than the MaximumExecutionFrequency value for a rule, Config invokes the rule only as often as the deliveryFrequency value.
    ///
    /// * For example, you want your rule to run evaluations when Config delivers the configuration snapshot.
    ///
    /// * You specify the MaximumExecutionFrequency value for Six_Hours.
    ///
    /// * You then specify the delivery channel deliveryFrequency value for TwentyFour_Hours.
    ///
    /// * Because the value for deliveryFrequency is less frequent than MaximumExecutionFrequency, Config invokes evaluations for the rule every 24 hours.
    ///
    ///
    /// You should set the MaximumExecutionFrequency value to be at least as frequent as the deliveryFrequency value. You can view the deliveryFrequency value by using the DescribeDeliveryChannnels action. To update the deliveryFrequency with which Config delivers your configuration snapshots, use the PutDeliveryChannel action.
    public struct ConfigSnapshotDeliveryProperties: Swift.Equatable {
        /// The frequency with which Config delivers configuration snapshots.
        public var deliveryFrequency: ConfigClientTypes.MaximumExecutionFrequency?

        public init (
            deliveryFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil
        )
        {
            self.deliveryFrequency = deliveryFrequency
        }
    }

}

extension ConfigClientTypes.ConfigStreamDeliveryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastErrorCode
        case lastErrorMessage
        case lastStatus
        case lastStatusChangeTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastErrorCode = self.lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = self.lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStatus = self.lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusChangeTime = self.lastStatusChangeTime {
            try encodeContainer.encodeTimestamp(lastStatusChangeTime, format: .epochSeconds, forKey: .lastStatusChangeTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.DeliveryStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastStatusChangeTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusChangeTime)
        lastStatusChangeTime = lastStatusChangeTimeDecoded
    }
}

extension ConfigClientTypes {
    /// A list that contains the status of the delivery of the configuration stream notification to the Amazon SNS topic.
    public struct ConfigStreamDeliveryInfo: Swift.Equatable {
        /// The error code from the last attempted delivery.
        public var lastErrorCode: Swift.String?
        /// The error message from the last attempted delivery.
        public var lastErrorMessage: Swift.String?
        /// Status of the last attempted delivery. Note Providing an SNS topic on a [DeliveryChannel](https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html) for Config is optional. If the SNS delivery is turned off, the last status will be Not_Applicable.
        public var lastStatus: ConfigClientTypes.DeliveryStatus?
        /// The time from the last status change.
        public var lastStatusChangeTime: ClientRuntime.Date?

        public init (
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStatus: ConfigClientTypes.DeliveryStatus? = nil,
            lastStatusChangeTime: ClientRuntime.Date? = nil
        )
        {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
        }
    }

}

extension ConfigClientTypes.ConfigurationAggregator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorArn = "ConfigurationAggregatorArn"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case organizationAggregationSource = "OrganizationAggregationSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAggregationSources = accountAggregationSources {
            var accountAggregationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountAggregationSources)
            for accountaggregationsource0 in accountAggregationSources {
                try accountAggregationSourcesContainer.encode(accountaggregationsource0)
            }
        }
        if let configurationAggregatorArn = self.configurationAggregatorArn {
            try encodeContainer.encode(configurationAggregatorArn, forKey: .configurationAggregatorArn)
        }
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let organizationAggregationSource = self.organizationAggregationSource {
            try encodeContainer.encode(organizationAggregationSource, forKey: .organizationAggregationSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let configurationAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorArn)
        configurationAggregatorArn = configurationAggregatorArnDecoded
        let accountAggregationSourcesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AccountAggregationSource?].self, forKey: .accountAggregationSources)
        var accountAggregationSourcesDecoded0:[ConfigClientTypes.AccountAggregationSource]? = nil
        if let accountAggregationSourcesContainer = accountAggregationSourcesContainer {
            accountAggregationSourcesDecoded0 = [ConfigClientTypes.AccountAggregationSource]()
            for structure0 in accountAggregationSourcesContainer {
                if let structure0 = structure0 {
                    accountAggregationSourcesDecoded0?.append(structure0)
                }
            }
        }
        accountAggregationSources = accountAggregationSourcesDecoded0
        let organizationAggregationSourceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationAggregationSource.self, forKey: .organizationAggregationSource)
        organizationAggregationSource = organizationAggregationSourceDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ConfigClientTypes {
    /// The details about the configuration aggregator, including information about source accounts, regions, and metadata of the aggregator.
    public struct ConfigurationAggregator: Swift.Equatable {
        /// Provides a list of source accounts and regions to be aggregated.
        public var accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]?
        /// The Amazon Resource Name (ARN) of the aggregator.
        public var configurationAggregatorArn: Swift.String?
        /// The name of the aggregator.
        public var configurationAggregatorName: Swift.String?
        /// Amazon Web Services service that created the configuration aggregator.
        public var createdBy: Swift.String?
        /// The time stamp when the configuration aggregator was created.
        public var creationTime: ClientRuntime.Date?
        /// The time of the last update.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Provides an organization and list of regions to be aggregated.
        public var organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource?

        public init (
            accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]? = nil,
            configurationAggregatorArn: Swift.String? = nil,
            configurationAggregatorName: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource? = nil
        )
        {
            self.accountAggregationSources = accountAggregationSources
            self.configurationAggregatorArn = configurationAggregatorArn
            self.configurationAggregatorName = configurationAggregatorName
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.organizationAggregationSource = organizationAggregationSource
        }
    }

}

extension ConfigClientTypes.ConfigurationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case arn
        case availabilityZone
        case awsRegion
        case configuration
        case configurationItemCaptureTime
        case configurationItemMD5Hash
        case configurationItemStatus
        case configurationStateId
        case relatedEvents
        case relationships
        case resourceCreationTime
        case resourceId
        case resourceName
        case resourceType
        case supplementaryConfiguration
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let configurationItemCaptureTime = self.configurationItemCaptureTime {
            try encodeContainer.encodeTimestamp(configurationItemCaptureTime, format: .epochSeconds, forKey: .configurationItemCaptureTime)
        }
        if let configurationItemMD5Hash = self.configurationItemMD5Hash {
            try encodeContainer.encode(configurationItemMD5Hash, forKey: .configurationItemMD5Hash)
        }
        if let configurationItemStatus = self.configurationItemStatus {
            try encodeContainer.encode(configurationItemStatus.rawValue, forKey: .configurationItemStatus)
        }
        if let configurationStateId = self.configurationStateId {
            try encodeContainer.encode(configurationStateId, forKey: .configurationStateId)
        }
        if let relatedEvents = relatedEvents {
            var relatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedEvents)
            for relatedevent0 in relatedEvents {
                try relatedEventsContainer.encode(relatedevent0)
            }
        }
        if let relationships = relationships {
            var relationshipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationships)
            for relationship0 in relationships {
                try relationshipsContainer.encode(relationship0)
            }
        }
        if let resourceCreationTime = self.resourceCreationTime {
            try encodeContainer.encodeTimestamp(resourceCreationTime, format: .epochSeconds, forKey: .resourceCreationTime)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let supplementaryConfiguration = supplementaryConfiguration {
            var supplementaryConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .supplementaryConfiguration)
            for (dictKey0, supplementaryConfiguration0) in supplementaryConfiguration {
                try supplementaryConfigurationContainer.encode(supplementaryConfiguration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configurationItemCaptureTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .configurationItemCaptureTime)
        configurationItemCaptureTime = configurationItemCaptureTimeDecoded
        let configurationItemStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigurationItemStatus.self, forKey: .configurationItemStatus)
        configurationItemStatus = configurationItemStatusDecoded
        let configurationStateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationStateId)
        configurationStateId = configurationStateIdDecoded
        let configurationItemMD5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationItemMD5Hash)
        configurationItemMD5Hash = configurationItemMD5HashDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let resourceCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resourceCreationTime)
        resourceCreationTime = resourceCreationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in tagsContainer {
                if let value0 = value0 {
                    tagsDecoded0?[key0] = value0
                }
            }
        }
        tags = tagsDecoded0
        let relatedEventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedEvents)
        var relatedEventsDecoded0:[Swift.String]? = nil
        if let relatedEventsContainer = relatedEventsContainer {
            relatedEventsDecoded0 = [Swift.String]()
            for string0 in relatedEventsContainer {
                if let string0 = string0 {
                    relatedEventsDecoded0?.append(string0)
                }
            }
        }
        relatedEvents = relatedEventsDecoded0
        let relationshipsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[ConfigClientTypes.Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [ConfigClientTypes.Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let supplementaryConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .supplementaryConfiguration)
        var supplementaryConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let supplementaryConfigurationContainer = supplementaryConfigurationContainer {
            supplementaryConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, supplementaryconfigurationvalue0) in supplementaryConfigurationContainer {
                if let supplementaryconfigurationvalue0 = supplementaryconfigurationvalue0 {
                    supplementaryConfigurationDecoded0?[key0] = supplementaryconfigurationvalue0
                }
            }
        }
        supplementaryConfiguration = supplementaryConfigurationDecoded0
    }
}

extension ConfigClientTypes {
    /// A list that contains detailed configurations of a specified resource.
    public struct ConfigurationItem: Swift.Equatable {
        /// The 12-digit Amazon Web Services account ID associated with the resource.
        public var accountId: Swift.String?
        /// Amazon Resource Name (ARN) associated with the resource.
        public var arn: Swift.String?
        /// The Availability Zone associated with the resource.
        public var availabilityZone: Swift.String?
        /// The region where the resource resides.
        public var awsRegion: Swift.String?
        /// The description of the resource configuration.
        public var configuration: Swift.String?
        /// The time when the configuration recording was initiated.
        public var configurationItemCaptureTime: ClientRuntime.Date?
        /// Unique MD5 hash that represents the configuration item's state. You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.
        public var configurationItemMD5Hash: Swift.String?
        /// The configuration item status. The valid values are:
        ///
        /// * OK – The resource configuration has been updated
        ///
        /// * ResourceDiscovered – The resource was newly discovered
        ///
        /// * ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type
        ///
        /// * ResourceDeleted – The resource was deleted
        ///
        /// * ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type
        ///
        ///
        /// The CIs do not incur any cost.
        public var configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public var configurationStateId: Swift.String?
        /// A list of CloudTrail event IDs. A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see [What Is CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html). An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the [LookupEvents API](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html) in the CloudTrail API Reference to retrieve the events for the resource.
        public var relatedEvents: [Swift.String]?
        /// A list of related Amazon Web Services resources.
        public var relationships: [ConfigClientTypes.Relationship]?
        /// The time stamp when the resource was created.
        public var resourceCreationTime: ClientRuntime.Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource, if available.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public var supplementaryConfiguration: [Swift.String:Swift.String]?
        /// A mapping of key value tags associated with the resource.
        public var tags: [Swift.String:Swift.String]?
        /// The version number of the resource configuration.
        public var version: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            configuration: Swift.String? = nil,
            configurationItemCaptureTime: ClientRuntime.Date? = nil,
            configurationItemMD5Hash: Swift.String? = nil,
            configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus? = nil,
            configurationStateId: Swift.String? = nil,
            relatedEvents: [Swift.String]? = nil,
            relationships: [ConfigClientTypes.Relationship]? = nil,
            resourceCreationTime: ClientRuntime.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            supplementaryConfiguration: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemMD5Hash = configurationItemMD5Hash
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.relatedEvents = relatedEvents
            self.relationships = relationships
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.tags = tags
            self.version = version
        }
    }

}

extension ConfigClientTypes {
    public enum ConfigurationItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ok
        case resourcedeleted
        case resourcedeletednotrecorded
        case resourcediscovered
        case resourcenotrecorded
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationItemStatus] {
            return [
                .ok,
                .resourcedeleted,
                .resourcedeletednotrecorded,
                .resourcediscovered,
                .resourcenotrecorded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ok: return "OK"
            case .resourcedeleted: return "ResourceDeleted"
            case .resourcedeletednotrecorded: return "ResourceDeletedNotRecorded"
            case .resourcediscovered: return "ResourceDiscovered"
            case .resourcenotrecorded: return "ResourceNotRecorded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationItemStatus(rawValue: rawValue) ?? ConfigurationItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConfigurationRecorder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case recordingGroup
        case roleARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingGroup = self.recordingGroup {
            try encodeContainer.encode(recordingGroup, forKey: .recordingGroup)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let recordingGroupDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RecordingGroup.self, forKey: .recordingGroup)
        recordingGroup = recordingGroupDecoded
    }
}

extension ConfigClientTypes {
    /// An object that represents the recording of configuration changes of an Amazon Web Services resource.
    public struct ConfigurationRecorder: Swift.Equatable {
        /// The name of the recorder. By default, Config automatically assigns the name "default" when creating the configuration recorder. You cannot change the assigned name.
        public var name: Swift.String?
        /// Specifies the types of Amazon Web Services resources for which Config records configuration changes.
        public var recordingGroup: ConfigClientTypes.RecordingGroup?
        /// Amazon Resource Name (ARN) of the IAM role used to describe the Amazon Web Services resources associated with the account. While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder.
        public var roleARN: Swift.String?

        public init (
            name: Swift.String? = nil,
            recordingGroup: ConfigClientTypes.RecordingGroup? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.name = name
            self.recordingGroup = recordingGroup
            self.roleARN = roleARN
        }
    }

}

extension ConfigClientTypes.ConfigurationRecorderStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastErrorCode
        case lastErrorMessage
        case lastStartTime
        case lastStatus
        case lastStatusChangeTime
        case lastStopTime
        case name
        case recording
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastErrorCode = self.lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = self.lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStartTime = self.lastStartTime {
            try encodeContainer.encodeTimestamp(lastStartTime, format: .epochSeconds, forKey: .lastStartTime)
        }
        if let lastStatus = self.lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusChangeTime = self.lastStatusChangeTime {
            try encodeContainer.encodeTimestamp(lastStatusChangeTime, format: .epochSeconds, forKey: .lastStatusChangeTime)
        }
        if let lastStopTime = self.lastStopTime {
            try encodeContainer.encodeTimestamp(lastStopTime, format: .epochSeconds, forKey: .lastStopTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recording != false {
            try encodeContainer.encode(recording, forKey: .recording)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let lastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
        let recordingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recording) ?? false
        recording = recordingDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RecorderStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastStatusChangeTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusChangeTime)
        lastStatusChangeTime = lastStatusChangeTimeDecoded
    }
}

extension ConfigClientTypes {
    /// The current status of the configuration recorder.
    public struct ConfigurationRecorderStatus: Swift.Equatable {
        /// The error code indicating that the recording failed.
        public var lastErrorCode: Swift.String?
        /// The message indicating that the recording failed due to an error.
        public var lastErrorMessage: Swift.String?
        /// The time the recorder was last started.
        public var lastStartTime: ClientRuntime.Date?
        /// The last (previous) status of the recorder.
        public var lastStatus: ConfigClientTypes.RecorderStatus?
        /// The time when the status was last changed.
        public var lastStatusChangeTime: ClientRuntime.Date?
        /// The time the recorder was last stopped.
        public var lastStopTime: ClientRuntime.Date?
        /// The name of the configuration recorder.
        public var name: Swift.String?
        /// Specifies whether or not the recorder is currently recording.
        public var recording: Swift.Bool

        public init (
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStartTime: ClientRuntime.Date? = nil,
            lastStatus: ConfigClientTypes.RecorderStatus? = nil,
            lastStatusChangeTime: ClientRuntime.Date? = nil,
            lastStopTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recording: Swift.Bool = false
        )
        {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStartTime = lastStartTime
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
            self.lastStopTime = lastStopTime
            self.name = name
            self.recording = recording
        }
    }

}

extension ConfigClientTypes.ConformancePackComplianceFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for stringwithcharlimit640 in configRuleNames {
                try configRuleNamesContainer.encode(stringwithcharlimit640)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the conformance pack by compliance types and Config rule names.
    public struct ConformancePackComplianceFilters: Swift.Equatable {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public var configRuleNames: [Swift.String]?

        public init (
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleNames: [Swift.String]? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
        }
    }

}

extension ConfigClientTypes.ConformancePackComplianceScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case lastUpdatedTime = "LastUpdatedTime"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .score)
        score = scoreDecoded
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ConfigClientTypes {
    /// A compliance score is the percentage of the number of compliant rule-resource combinations in a conformance pack compared to the number of total possible rule-resource combinations in the conformance pack. This metric provides you with a high-level view of the compliance state of your conformance packs. You can use it to identify, investigate, and understand the level of compliance in your conformance packs.
    public struct ConformancePackComplianceScore: Swift.Equatable {
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?
        /// The time that the conformance pack compliance score was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of INSUFFICIENT_DATA.
        public var score: Swift.String?

        public init (
            conformancePackName: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            score: Swift.String? = nil
        )
        {
            self.conformancePackName = conformancePackName
            self.lastUpdatedTime = lastUpdatedTime
            self.score = score
        }
    }

}

extension ConfigClientTypes.ConformancePackComplianceScoresFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepackname0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepackname0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[Swift.String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [Swift.String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
    }
}

extension ConfigClientTypes {
    /// A list of filters to apply to the conformance pack compliance score result set.
    public struct ConformancePackComplianceScoresFilters: Swift.Equatable {
        /// The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the ConformancePackNames array of strings, each with a character limit of 256 characters for the conformance pack name.
        /// This member is required.
        public var conformancePackNames: [Swift.String]?

        public init (
            conformancePackNames: [Swift.String]? = nil
        )
        {
            self.conformancePackNames = conformancePackNames
        }
    }

}

extension ConfigClientTypes.ConformancePackComplianceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackComplianceStatus = "ConformancePackComplianceStatus"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackComplianceStatus = self.conformancePackComplianceStatus {
            try encodeContainer.encode(conformancePackComplianceStatus.rawValue, forKey: .conformancePackComplianceStatus)
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackComplianceStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .conformancePackComplianceStatus)
        conformancePackComplianceStatus = conformancePackComplianceStatusDecoded
    }
}

extension ConfigClientTypes {
    /// Summary includes the name and status of the conformance pack.
    public struct ConformancePackComplianceSummary: Swift.Equatable {
        /// The status of the conformance pack. The allowed values are COMPLIANT, NON_COMPLIANT and INSUFFICIENT_DATA.
        /// This member is required.
        public var conformancePackComplianceStatus: ConfigClientTypes.ConformancePackComplianceType?
        /// The name of the conformance pack name.
        /// This member is required.
        public var conformancePackName: Swift.String?

        public init (
            conformancePackComplianceStatus: ConfigClientTypes.ConformancePackComplianceType? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.conformancePackComplianceStatus = conformancePackComplianceStatus
            self.conformancePackName = conformancePackName
        }
    }

}

extension ConfigClientTypes {
    public enum ConformancePackComplianceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case insufficientData
        case nonCompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [ConformancePackComplianceType] {
            return [
                .compliant,
                .insufficientData,
                .nonCompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .nonCompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConformancePackComplianceType(rawValue: rawValue) ?? ConformancePackComplianceType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConformancePackDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackArn = "ConformancePackArn"
        case conformancePackId = "ConformancePackId"
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case createdBy = "CreatedBy"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case lastUpdateRequestedTime = "LastUpdateRequestedTime"
        case templateSSMDocumentDetails = "TemplateSSMDocumentDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackArn = self.conformancePackArn {
            try encodeContainer.encode(conformancePackArn, forKey: .conformancePackArn)
        }
        if let conformancePackId = self.conformancePackId {
            try encodeContainer.encode(conformancePackId, forKey: .conformancePackId)
        }
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameter0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameter0)
            }
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let deliveryS3Bucket = self.deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = self.deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let lastUpdateRequestedTime = self.lastUpdateRequestedTime {
            try encodeContainer.encodeTimestamp(lastUpdateRequestedTime, format: .epochSeconds, forKey: .lastUpdateRequestedTime)
        }
        if let templateSSMDocumentDetails = self.templateSSMDocumentDetails {
            try encodeContainer.encode(templateSSMDocumentDetails, forKey: .templateSSMDocumentDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
        let conformancePackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackId)
        conformancePackId = conformancePackIdDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConfigClientTypes.ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConfigClientTypes.ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let lastUpdateRequestedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateRequestedTime)
        lastUpdateRequestedTime = lastUpdateRequestedTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let templateSSMDocumentDetailsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.TemplateSSMDocumentDetails.self, forKey: .templateSSMDocumentDetails)
        templateSSMDocumentDetails = templateSSMDocumentDetailsDecoded
    }
}

extension ConfigClientTypes {
    /// Returns details of a conformance pack. A conformance pack is a collection of Config rules and remediation actions that can be easily deployed in an account and a region.
    public struct ConformancePackDetail: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the conformance pack.
        /// This member is required.
        public var conformancePackArn: Swift.String?
        /// ID of the conformance pack.
        /// This member is required.
        public var conformancePackId: Swift.String?
        /// A list of ConformancePackInputParameter objects.
        public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
        /// Name of the conformance pack.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// The Amazon Web Services service that created the conformance pack.
        public var createdBy: Swift.String?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
        public var deliveryS3Bucket: Swift.String?
        /// The prefix for the Amazon S3 bucket. This field is optional.
        public var deliveryS3KeyPrefix: Swift.String?
        /// The last time a conformation pack update was requested.
        public var lastUpdateRequestedTime: ClientRuntime.Date?
        /// An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
        public var templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails?

        public init (
            conformancePackArn: Swift.String? = nil,
            conformancePackId: Swift.String? = nil,
            conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
            conformancePackName: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            deliveryS3Bucket: Swift.String? = nil,
            deliveryS3KeyPrefix: Swift.String? = nil,
            lastUpdateRequestedTime: ClientRuntime.Date? = nil,
            templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails? = nil
        )
        {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.createdBy = createdBy
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.templateSSMDocumentDetails = templateSSMDocumentDetails
        }
    }

}

extension ConfigClientTypes.ConformancePackEvaluationFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case configRuleNames = "ConfigRuleNames"
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for stringwithcharlimit640 in configRuleNames {
                try configRuleNamesContainer.encode(stringwithcharlimit640)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringwithcharlimit2560 in resourceIds {
                try resourceIdsContainer.encode(stringwithcharlimit2560)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension ConfigClientTypes {
    /// Filters a conformance pack by Config rule names, compliance types, Amazon Web Services resource types, and resource IDs.
    public struct ConformancePackEvaluationFilters: Swift.Equatable {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public var configRuleNames: [Swift.String]?
        /// Filters the results by resource IDs. This is valid only when you provide resource type. If there is no resource type, you will see an error.
        public var resourceIds: [Swift.String]?
        /// Filters the results by the resource type (for example, "AWS::EC2::Instance").
        public var resourceType: Swift.String?

        public init (
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleNames: [Swift.String]? = nil,
            resourceIds: [Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.ConformancePackEvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotation = "Annotation"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = self.annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = self.configRuleInvokedTime {
            try encodeContainer.encodeTimestamp(configRuleInvokedTime, format: .epochSeconds, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = self.evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = self.resultRecordedTime {
            try encodeContainer.encodeTimestamp(resultRecordedTime, format: .epochSeconds, forKey: .resultRecordedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .annotation)
        annotation = annotationDecoded
    }
}

extension ConfigClientTypes {
    /// The details of a conformance pack evaluation. Provides Config rule and Amazon Web Services resource type that was evaluated, the compliance of the conformance pack, related time stamps, and supplementary information.
    public struct ConformancePackEvaluationResult: Swift.Equatable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The compliance type. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The time when Config rule evaluated Amazon Web Services resource.
        /// This member is required.
        public var configRuleInvokedTime: ClientRuntime.Date?
        /// Uniquely identifies an evaluation result.
        /// This member is required.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the evaluation result.
        /// This member is required.
        public var resultRecordedTime: ClientRuntime.Date?

        public init (
            annotation: Swift.String? = nil,
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleInvokedTime: ClientRuntime.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: ClientRuntime.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }
    }

}

extension ConfigClientTypes.ConformancePackInputParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension ConfigClientTypes {
    /// Input parameters in the form of key-value pairs for the conformance pack, both of which you define. Keys can have a maximum character length of 255 characters, and values can have a maximum length of 4096 characters.
    public struct ConformancePackInputParameter: Swift.Equatable {
        /// One part of a key-value pair.
        /// This member is required.
        public var parameterName: Swift.String?
        /// Another part of the key-value pair.
        /// This member is required.
        public var parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension ConfigClientTypes.ConformancePackRuleCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case controls = "Controls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for stringwithcharlimit1280 in controls {
                try controlsContainer.encode(stringwithcharlimit1280)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .controls)
        var controlsDecoded0:[Swift.String]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [Swift.String]()
            for string0 in controlsContainer {
                if let string0 = string0 {
                    controlsDecoded0?.append(string0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension ConfigClientTypes {
    /// Compliance information of one or more Config rules within a conformance pack. You can filter using Config rule names and compliance types.
    public struct ConformancePackRuleCompliance: Swift.Equatable {
        /// Compliance of the Config rule. The allowed values are COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Name of the Config rule.
        public var configRuleName: Swift.String?
        /// Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.
        public var controls: [Swift.String]?

        public init (
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleName: Swift.String? = nil,
            controls: [Swift.String]? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.controls = controls
        }
    }

}

extension ConfigClientTypes {
    public enum ConformancePackState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConformancePackState] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConformancePackState(rawValue: rawValue) ?? ConformancePackState.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ConformancePackStatusDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackArn = "ConformancePackArn"
        case conformancePackId = "ConformancePackId"
        case conformancePackName = "ConformancePackName"
        case conformancePackState = "ConformancePackState"
        case conformancePackStatusReason = "ConformancePackStatusReason"
        case lastUpdateCompletedTime = "LastUpdateCompletedTime"
        case lastUpdateRequestedTime = "LastUpdateRequestedTime"
        case stackArn = "StackArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackArn = self.conformancePackArn {
            try encodeContainer.encode(conformancePackArn, forKey: .conformancePackArn)
        }
        if let conformancePackId = self.conformancePackId {
            try encodeContainer.encode(conformancePackId, forKey: .conformancePackId)
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let conformancePackState = self.conformancePackState {
            try encodeContainer.encode(conformancePackState.rawValue, forKey: .conformancePackState)
        }
        if let conformancePackStatusReason = self.conformancePackStatusReason {
            try encodeContainer.encode(conformancePackStatusReason, forKey: .conformancePackStatusReason)
        }
        if let lastUpdateCompletedTime = self.lastUpdateCompletedTime {
            try encodeContainer.encodeTimestamp(lastUpdateCompletedTime, format: .epochSeconds, forKey: .lastUpdateCompletedTime)
        }
        if let lastUpdateRequestedTime = self.lastUpdateRequestedTime {
            try encodeContainer.encodeTimestamp(lastUpdateRequestedTime, format: .epochSeconds, forKey: .lastUpdateRequestedTime)
        }
        if let stackArn = self.stackArn {
            try encodeContainer.encode(stackArn, forKey: .stackArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackId)
        conformancePackId = conformancePackIdDecoded
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
        let conformancePackStateDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackState.self, forKey: .conformancePackState)
        conformancePackState = conformancePackStateDecoded
        let stackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackArn)
        stackArn = stackArnDecoded
        let conformancePackStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackStatusReason)
        conformancePackStatusReason = conformancePackStatusReasonDecoded
        let lastUpdateRequestedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateRequestedTime)
        lastUpdateRequestedTime = lastUpdateRequestedTimeDecoded
        let lastUpdateCompletedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateCompletedTime)
        lastUpdateCompletedTime = lastUpdateCompletedTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Status details of a conformance pack.
    public struct ConformancePackStatusDetail: Swift.Equatable {
        /// Amazon Resource Name (ARN) of comformance pack.
        /// This member is required.
        public var conformancePackArn: Swift.String?
        /// ID of the conformance pack.
        /// This member is required.
        public var conformancePackId: Swift.String?
        /// Name of the conformance pack.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// Indicates deployment status of conformance pack. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.
        ///
        /// * CREATE_COMPLETE when a conformance pack has been successfully created in your account.
        ///
        /// * CREATE_FAILED when a conformance pack creation failed in your account.
        ///
        /// * DELETE_IN_PROGRESS when a conformance pack deletion is in progress.
        ///
        /// * DELETE_FAILED when a conformance pack deletion failed in your account.
        /// This member is required.
        public var conformancePackState: ConfigClientTypes.ConformancePackState?
        /// The reason of conformance pack creation failure.
        public var conformancePackStatusReason: Swift.String?
        /// Last time when conformation pack creation and update was successful.
        public var lastUpdateCompletedTime: ClientRuntime.Date?
        /// Last time when conformation pack creation and update was requested.
        /// This member is required.
        public var lastUpdateRequestedTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of CloudFormation stack.
        /// This member is required.
        public var stackArn: Swift.String?

        public init (
            conformancePackArn: Swift.String? = nil,
            conformancePackId: Swift.String? = nil,
            conformancePackName: Swift.String? = nil,
            conformancePackState: ConfigClientTypes.ConformancePackState? = nil,
            conformancePackStatusReason: Swift.String? = nil,
            lastUpdateCompletedTime: ClientRuntime.Date? = nil,
            lastUpdateRequestedTime: ClientRuntime.Date? = nil,
            stackArn: Swift.String? = nil
        )
        {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackName = conformancePackName
            self.conformancePackState = conformancePackState
            self.conformancePackStatusReason = conformancePackStatusReason
            self.lastUpdateCompletedTime = lastUpdateCompletedTime
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.stackArn = stackArn
        }
    }

}

extension ConformancePackTemplateValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConformancePackTemplateValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a template that is invalid or supported.
public struct ConformancePackTemplateValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConformancePackTemplateValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConformancePackTemplateValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.CustomPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDebugLogDelivery = "EnableDebugLogDelivery"
        case policyRuntime = "PolicyRuntime"
        case policyText = "PolicyText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDebugLogDelivery != false {
            try encodeContainer.encode(enableDebugLogDelivery, forKey: .enableDebugLogDelivery)
        }
        if let policyRuntime = self.policyRuntime {
            try encodeContainer.encode(policyRuntime, forKey: .policyRuntime)
        }
        if let policyText = self.policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRuntime)
        policyRuntime = policyRuntimeDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let enableDebugLogDeliveryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDebugLogDelivery) ?? false
        enableDebugLogDelivery = enableDebugLogDeliveryDecoded
    }
}

extension ConfigClientTypes {
    /// Provides the runtime system, policy definition, and whether debug logging enabled. You can specify the following CustomPolicyDetails parameter values only for Config Custom Policy rules.
    public struct CustomPolicyDetails: Swift.Equatable {
        /// The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is false.
        public var enableDebugLogDelivery: Swift.Bool
        /// The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        /// This member is required.
        public var policyRuntime: Swift.String?
        /// The policy definition containing the logic for your Config Custom Policy rule.
        /// This member is required.
        public var policyText: Swift.String?

        public init (
            enableDebugLogDelivery: Swift.Bool = false,
            policyRuntime: Swift.String? = nil,
            policyText: Swift.String? = nil
        )
        {
            self.enableDebugLogDelivery = enableDebugLogDelivery
            self.policyRuntime = policyRuntime
            self.policyText = policyText
        }
    }

}

extension DeleteAggregationAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedAccountId = self.authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = self.authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
    }
}

extension DeleteAggregationAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAggregationAuthorizationInput: Swift.Equatable {
    /// The 12-digit account ID of the account authorized to aggregate data.
    /// This member is required.
    public var authorizedAccountId: Swift.String?
    /// The region authorized to collect aggregated data.
    /// This member is required.
    public var authorizedAwsRegion: Swift.String?

    public init (
        authorizedAccountId: Swift.String? = nil,
        authorizedAwsRegion: Swift.String? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
    }
}

struct DeleteAggregationAuthorizationInputBody: Swift.Equatable {
    let authorizedAccountId: Swift.String?
    let authorizedAwsRegion: Swift.String?
}

extension DeleteAggregationAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
    }
}

extension DeleteAggregationAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAggregationAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAggregationAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAggregationAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAggregationAuthorizationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }
}

extension DeleteConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteConfigRuleInput: Swift.Equatable {
    /// The name of the Config rule that you want to delete.
    /// This member is required.
    public var configRuleName: Swift.String?

    public init (
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

struct DeleteConfigRuleInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
}

extension DeleteConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
    }
}

extension DeleteConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConfigurationAggregatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
    }
}

extension DeleteConfigurationAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConfigurationAggregatorInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
    }
}

struct DeleteConfigurationAggregatorInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
}

extension DeleteConfigurationAggregatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
    }
}

extension DeleteConfigurationAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConfigurationAggregatorOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationAggregatorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConfigurationRecorderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = self.configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

extension DeleteConfigurationRecorderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request object for the DeleteConfigurationRecorder action.
public struct DeleteConfigurationRecorderInput: Swift.Equatable {
    /// The name of the configuration recorder to be deleted. You can retrieve the name of your configuration recorder by using the DescribeConfigurationRecorders action.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init (
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct DeleteConfigurationRecorderInputBody: Swift.Equatable {
    let configurationRecorderName: Swift.String?
}

extension DeleteConfigurationRecorderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension DeleteConfigurationRecorderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationRecorderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConfigurationRecorderOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationRecorderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationRecorderOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConformancePackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }
}

extension DeleteConformancePackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConformancePackInput: Swift.Equatable {
    /// Name of the conformance pack you want to delete.
    /// This member is required.
    public var conformancePackName: Swift.String?

    public init (
        conformancePackName: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
    }
}

struct DeleteConformancePackInputBody: Swift.Equatable {
    let conformancePackName: Swift.String?
}

extension DeleteConformancePackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
    }
}

extension DeleteConformancePackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConformancePackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConformancePackOutputError: Swift.Error, Swift.Equatable {
    case noSuchConformancePackException(NoSuchConformancePackException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConformancePackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConformancePackOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDeliveryChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelName = "DeliveryChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelName = self.deliveryChannelName {
            try encodeContainer.encode(deliveryChannelName, forKey: .deliveryChannelName)
        }
    }
}

extension DeleteDeliveryChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DeleteDeliveryChannel] action. The action accepts the following data, in JSON format.
public struct DeleteDeliveryChannelInput: Swift.Equatable {
    /// The name of the delivery channel to delete.
    /// This member is required.
    public var deliveryChannelName: Swift.String?

    public init (
        deliveryChannelName: Swift.String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

struct DeleteDeliveryChannelInputBody: Swift.Equatable {
    let deliveryChannelName: Swift.String?
}

extension DeleteDeliveryChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelName = "DeliveryChannelName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryChannelName)
        deliveryChannelName = deliveryChannelNameDecoded
    }
}

extension DeleteDeliveryChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeliveryChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LastDeliveryChannelDeleteFailedException" : self = .lastDeliveryChannelDeleteFailedException(try LastDeliveryChannelDeleteFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDeliveryChannelOutputError: Swift.Error, Swift.Equatable {
    case lastDeliveryChannelDeleteFailedException(LastDeliveryChannelDeleteFailedException)
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeliveryChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeliveryChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteEvaluationResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }
}

extension DeleteEvaluationResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEvaluationResultsInput: Swift.Equatable {
    /// The name of the Config rule for which you want to delete the evaluation results.
    /// This member is required.
    public var configRuleName: Swift.String?

    public init (
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

struct DeleteEvaluationResultsInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
}

extension DeleteEvaluationResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
    }
}

extension DeleteEvaluationResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEvaluationResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEvaluationResultsOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEvaluationResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The output when you delete the evaluation results for the specified Config rule.
public struct DeleteEvaluationResultsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOrganizationConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
    }
}

extension DeleteOrganizationConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOrganizationConfigRuleInput: Swift.Equatable {
    /// The name of organization Config rule that you want to delete.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init (
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

struct DeleteOrganizationConfigRuleInputBody: Swift.Equatable {
    let organizationConfigRuleName: Swift.String?
}

extension DeleteOrganizationConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
    }
}

extension DeleteOrganizationConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOrganizationConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOrganizationConfigRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteOrganizationConformancePackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationConformancePackName = self.organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }
}

extension DeleteOrganizationConformancePackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOrganizationConformancePackInput: Swift.Equatable {
    /// The name of organization conformance pack that you want to delete.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?

    public init (
        organizationConformancePackName: Swift.String? = nil
    )
    {
        self.organizationConformancePackName = organizationConformancePackName
    }
}

struct DeleteOrganizationConformancePackInputBody: Swift.Equatable {
    let organizationConformancePackName: Swift.String?
}

extension DeleteOrganizationConformancePackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
    }
}

extension DeleteOrganizationConformancePackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationConformancePackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteOrganizationConformancePackOutputError: Swift.Error, Swift.Equatable {
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationConformancePackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOrganizationConformancePackOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePendingAggregationRequestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requesterAccountId = self.requesterAccountId {
            try encodeContainer.encode(requesterAccountId, forKey: .requesterAccountId)
        }
        if let requesterAwsRegion = self.requesterAwsRegion {
            try encodeContainer.encode(requesterAwsRegion, forKey: .requesterAwsRegion)
        }
    }
}

extension DeletePendingAggregationRequestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePendingAggregationRequestInput: Swift.Equatable {
    /// The 12-digit account ID of the account requesting to aggregate data.
    /// This member is required.
    public var requesterAccountId: Swift.String?
    /// The region requesting to aggregate data.
    /// This member is required.
    public var requesterAwsRegion: Swift.String?

    public init (
        requesterAccountId: Swift.String? = nil,
        requesterAwsRegion: Swift.String? = nil
    )
    {
        self.requesterAccountId = requesterAccountId
        self.requesterAwsRegion = requesterAwsRegion
    }
}

struct DeletePendingAggregationRequestInputBody: Swift.Equatable {
    let requesterAccountId: Swift.String?
    let requesterAwsRegion: Swift.String?
}

extension DeletePendingAggregationRequestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requesterAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAccountId)
        requesterAccountId = requesterAccountIdDecoded
        let requesterAwsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAwsRegion)
        requesterAwsRegion = requesterAwsRegionDecoded
    }
}

extension DeletePendingAggregationRequestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePendingAggregationRequestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePendingAggregationRequestOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePendingAggregationRequestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePendingAggregationRequestOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRemediationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension DeleteRemediationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRemediationConfigurationInput: Swift.Equatable {
    /// The name of the Config rule for which you want to delete remediation configuration.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The type of a resource.
    public var resourceType: Swift.String?

    public init (
        configRuleName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceType = resourceType
    }
}

struct DeleteRemediationConfigurationInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceType: Swift.String?
}

extension DeleteRemediationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DeleteRemediationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemediationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RemediationInProgressException" : self = .remediationInProgressException(try RemediationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRemediationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case remediationInProgressException(RemediationInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemediationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRemediationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRemediationExceptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekey0)
            }
        }
    }
}

extension DeleteRemediationExceptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRemediationExceptionsInput: Swift.Equatable {
    /// The name of the Config rule for which you want to delete remediation exception configuration.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init (
        configRuleName: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

struct DeleteRemediationExceptionsInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?
}

extension DeleteRemediationExceptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension DeleteRemediationExceptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemediationExceptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchRemediationExceptionException" : self = .noSuchRemediationExceptionException(try NoSuchRemediationExceptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRemediationExceptionsOutputError: Swift.Error, Swift.Equatable {
    case noSuchRemediationExceptionException(NoSuchRemediationExceptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemediationExceptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct DeleteRemediationExceptionsOutputResponse: Swift.Equatable {
    /// Returns a list of failed delete remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
    public var failedBatches: [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]?

    public init (
        failedBatches: [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct DeleteRemediationExceptionsOutputResponseBody: Swift.Equatable {
    let failedBatches: [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]?
}

extension DeleteRemediationExceptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.FailedDeleteRemediationExceptionsBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

extension DeleteResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension DeleteResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourceConfigInput: Swift.Equatable {
    /// Unique identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct DeleteResourceConfigInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let resourceId: Swift.String?
}

extension DeleteResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceConfigOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRetentionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionConfigurationName = "RetentionConfigurationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionConfigurationName = self.retentionConfigurationName {
            try encodeContainer.encode(retentionConfigurationName, forKey: .retentionConfigurationName)
        }
    }
}

extension DeleteRetentionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRetentionConfigurationInput: Swift.Equatable {
    /// The name of the retention configuration to delete.
    /// This member is required.
    public var retentionConfigurationName: Swift.String?

    public init (
        retentionConfigurationName: Swift.String? = nil
    )
    {
        self.retentionConfigurationName = retentionConfigurationName
    }
}

struct DeleteRetentionConfigurationInputBody: Swift.Equatable {
    let retentionConfigurationName: Swift.String?
}

extension DeleteRetentionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionConfigurationName = "RetentionConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retentionConfigurationName)
        retentionConfigurationName = retentionConfigurationNameDecoded
    }
}

extension DeleteRetentionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRetentionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRetentionConfigurationException" : self = .noSuchRetentionConfigurationException(try NoSuchRetentionConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRetentionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRetentionConfigurationException(NoSuchRetentionConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRetentionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRetentionConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteStoredQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryName = "QueryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryName = self.queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }
}

extension DeleteStoredQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteStoredQueryInput: Swift.Equatable {
    /// The name of the query that you want to delete.
    /// This member is required.
    public var queryName: Swift.String?

    public init (
        queryName: Swift.String? = nil
    )
    {
        self.queryName = queryName
    }
}

struct DeleteStoredQueryInputBody: Swift.Equatable {
    let queryName: Swift.String?
}

extension DeleteStoredQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryName = "QueryName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryName)
        queryName = queryNameDecoded
    }
}

extension DeleteStoredQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStoredQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteStoredQueryOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStoredQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStoredQueryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeliverConfigSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelName = self.deliveryChannelName {
            try encodeContainer.encode(deliveryChannelName, forKey: .deliveryChannelName)
        }
    }
}

extension DeliverConfigSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DeliverConfigSnapshot] action.
public struct DeliverConfigSnapshotInput: Swift.Equatable {
    /// The name of the delivery channel through which the snapshot is delivered.
    /// This member is required.
    public var deliveryChannelName: Swift.String?

    public init (
        deliveryChannelName: Swift.String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

struct DeliverConfigSnapshotInputBody: Swift.Equatable {
    let deliveryChannelName: Swift.String?
}

extension DeliverConfigSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryChannelName)
        deliveryChannelName = deliveryChannelNameDecoded
    }
}

extension DeliverConfigSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeliverConfigSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeliverConfigSnapshotOutputError: Swift.Error, Swift.Equatable {
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeliverConfigSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeliverConfigSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configSnapshotId = output.configSnapshotId
        } else {
            self.configSnapshotId = nil
        }
    }
}

/// The output for the [DeliverConfigSnapshot] action, in JSON format.
public struct DeliverConfigSnapshotOutputResponse: Swift.Equatable {
    /// The ID of the snapshot that is being created.
    public var configSnapshotId: Swift.String?

    public init (
        configSnapshotId: Swift.String? = nil
    )
    {
        self.configSnapshotId = configSnapshotId
    }
}

struct DeliverConfigSnapshotOutputResponseBody: Swift.Equatable {
    let configSnapshotId: Swift.String?
}

extension DeliverConfigSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configSnapshotId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configSnapshotId)
        configSnapshotId = configSnapshotIdDecoded
    }
}

extension ConfigClientTypes.DeliveryChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configSnapshotDeliveryProperties
        case name
        case s3BucketName
        case s3KeyPrefix
        case s3KmsKeyArn
        case snsTopicARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configSnapshotDeliveryProperties = self.configSnapshotDeliveryProperties {
            try encodeContainer.encode(configSnapshotDeliveryProperties, forKey: .configSnapshotDeliveryProperties)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let s3KmsKeyArn = self.s3KmsKeyArn {
            try encodeContainer.encode(s3KmsKeyArn, forKey: .s3KmsKeyArn)
        }
        if let snsTopicARN = self.snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let s3KmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KmsKeyArn)
        s3KmsKeyArn = s3KmsKeyArnDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let configSnapshotDeliveryPropertiesDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigSnapshotDeliveryProperties.self, forKey: .configSnapshotDeliveryProperties)
        configSnapshotDeliveryProperties = configSnapshotDeliveryPropertiesDecoded
    }
}

extension ConfigClientTypes {
    /// The channel through which Config delivers notifications and updated configuration states.
    public struct DeliveryChannel: Swift.Equatable {
        /// The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.
        public var configSnapshotDeliveryProperties: ConfigClientTypes.ConfigSnapshotDeliveryProperties?
        /// The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.
        public var name: Swift.String?
        /// The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files. If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see [Permissions for the Amazon S3 Bucket](https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html) in the Config Developer Guide.
        public var s3BucketName: Swift.String?
        /// The prefix for the specified Amazon S3 bucket.
        public var s3KeyPrefix: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.
        public var s3KmsKeyArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes. If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see [Permissions for the Amazon SNS Topic](https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html) in the Config Developer Guide.
        public var snsTopicARN: Swift.String?

        public init (
            configSnapshotDeliveryProperties: ConfigClientTypes.ConfigSnapshotDeliveryProperties? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            s3KmsKeyArn: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.configSnapshotDeliveryProperties = configSnapshotDeliveryProperties
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3KmsKeyArn = s3KmsKeyArn
            self.snsTopicARN = snsTopicARN
        }
    }

}

extension ConfigClientTypes.DeliveryChannelStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configHistoryDeliveryInfo
        case configSnapshotDeliveryInfo
        case configStreamDeliveryInfo
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configHistoryDeliveryInfo = self.configHistoryDeliveryInfo {
            try encodeContainer.encode(configHistoryDeliveryInfo, forKey: .configHistoryDeliveryInfo)
        }
        if let configSnapshotDeliveryInfo = self.configSnapshotDeliveryInfo {
            try encodeContainer.encode(configSnapshotDeliveryInfo, forKey: .configSnapshotDeliveryInfo)
        }
        if let configStreamDeliveryInfo = self.configStreamDeliveryInfo {
            try encodeContainer.encode(configStreamDeliveryInfo, forKey: .configStreamDeliveryInfo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configSnapshotDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigExportDeliveryInfo.self, forKey: .configSnapshotDeliveryInfo)
        configSnapshotDeliveryInfo = configSnapshotDeliveryInfoDecoded
        let configHistoryDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigExportDeliveryInfo.self, forKey: .configHistoryDeliveryInfo)
        configHistoryDeliveryInfo = configHistoryDeliveryInfoDecoded
        let configStreamDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigStreamDeliveryInfo.self, forKey: .configStreamDeliveryInfo)
        configStreamDeliveryInfo = configStreamDeliveryInfoDecoded
    }
}

extension ConfigClientTypes {
    /// The status of a specified delivery channel. Valid values: Success | Failure
    public struct DeliveryChannelStatus: Swift.Equatable {
        /// A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.
        public var configHistoryDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.
        public var configSnapshotDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.
        public var configStreamDeliveryInfo: ConfigClientTypes.ConfigStreamDeliveryInfo?
        /// The name of the delivery channel.
        public var name: Swift.String?

        public init (
            configHistoryDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo? = nil,
            configSnapshotDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo? = nil,
            configStreamDeliveryInfo: ConfigClientTypes.ConfigStreamDeliveryInfo? = nil,
            name: Swift.String? = nil
        )
        {
            self.configHistoryDeliveryInfo = configHistoryDeliveryInfo
            self.configSnapshotDeliveryInfo = configSnapshotDeliveryInfo
            self.configStreamDeliveryInfo = configStreamDeliveryInfo
            self.name = name
        }
    }

}

extension ConfigClientTypes {
    public enum DeliveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case notApplicable
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .failure,
                .notApplicable,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "Failure"
            case .notApplicable: return "Not_Applicable"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryStatus(rawValue: rawValue) ?? DeliveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeAggregateComplianceByConfigRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAggregateComplianceByConfigRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAggregateComplianceByConfigRulesInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results by ConfigRuleComplianceFilters object.
    public var filters: ConfigClientTypes.ConfigRuleComplianceFilters?
    /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ConfigRuleComplianceFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConfigRulesInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let filters: ConfigClientTypes.ConfigRuleComplianceFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAggregateComplianceByConfigRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigRuleComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregateComplianceByConfigRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregateComplianceByConfigRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAggregateComplianceByConfigRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregateComplianceByConfigRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAggregateComplianceByConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregateComplianceByConfigRules = output.aggregateComplianceByConfigRules
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceByConfigRules = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregateComplianceByConfigRulesOutputResponse: Swift.Equatable {
    /// Returns a list of AggregateComplianceByConfigRule object.
    public var aggregateComplianceByConfigRules: [ConfigClientTypes.AggregateComplianceByConfigRule]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregateComplianceByConfigRules: [ConfigClientTypes.AggregateComplianceByConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceByConfigRules = aggregateComplianceByConfigRules
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConfigRulesOutputResponseBody: Swift.Equatable {
    let aggregateComplianceByConfigRules: [ConfigClientTypes.AggregateComplianceByConfigRule]?
    let nextToken: Swift.String?
}

extension DescribeAggregateComplianceByConfigRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateComplianceByConfigRules = "AggregateComplianceByConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateComplianceByConfigRulesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateComplianceByConfigRule?].self, forKey: .aggregateComplianceByConfigRules)
        var aggregateComplianceByConfigRulesDecoded0:[ConfigClientTypes.AggregateComplianceByConfigRule]? = nil
        if let aggregateComplianceByConfigRulesContainer = aggregateComplianceByConfigRulesContainer {
            aggregateComplianceByConfigRulesDecoded0 = [ConfigClientTypes.AggregateComplianceByConfigRule]()
            for structure0 in aggregateComplianceByConfigRulesContainer {
                if let structure0 = structure0 {
                    aggregateComplianceByConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceByConfigRules = aggregateComplianceByConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregateComplianceByConformancePacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAggregateComplianceByConformancePacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAggregateComplianceByConformancePacksInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the result by AggregateConformancePackComplianceFilters object.
    public var filters: ConfigClientTypes.AggregateConformancePackComplianceFilters?
    /// The maximum number of conformance packs compliance details returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.AggregateConformancePackComplianceFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConformancePacksInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let filters: ConfigClientTypes.AggregateConformancePackComplianceFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAggregateComplianceByConformancePacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateConformancePackComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregateComplianceByConformancePacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregateComplianceByConformancePacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAggregateComplianceByConformancePacksOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregateComplianceByConformancePacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAggregateComplianceByConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregateComplianceByConformancePacks = output.aggregateComplianceByConformancePacks
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceByConformancePacks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregateComplianceByConformancePacksOutputResponse: Swift.Equatable {
    /// Returns the AggregateComplianceByConformancePack object.
    public var aggregateComplianceByConformancePacks: [ConfigClientTypes.AggregateComplianceByConformancePack]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregateComplianceByConformancePacks: [ConfigClientTypes.AggregateComplianceByConformancePack]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacks
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConformancePacksOutputResponseBody: Swift.Equatable {
    let aggregateComplianceByConformancePacks: [ConfigClientTypes.AggregateComplianceByConformancePack]?
    let nextToken: Swift.String?
}

extension DescribeAggregateComplianceByConformancePacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateComplianceByConformancePacks = "AggregateComplianceByConformancePacks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateComplianceByConformancePacksContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateComplianceByConformancePack?].self, forKey: .aggregateComplianceByConformancePacks)
        var aggregateComplianceByConformancePacksDecoded0:[ConfigClientTypes.AggregateComplianceByConformancePack]? = nil
        if let aggregateComplianceByConformancePacksContainer = aggregateComplianceByConformancePacksContainer {
            aggregateComplianceByConformancePacksDecoded0 = [ConfigClientTypes.AggregateComplianceByConformancePack]()
            for structure0 in aggregateComplianceByConformancePacksContainer {
                if let structure0 = structure0 {
                    aggregateComplianceByConformancePacksDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregationAuthorizationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAggregationAuthorizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAggregationAuthorizationsInput: Swift.Equatable {
    /// The maximum number of AggregationAuthorizations returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregationAuthorizationsInputBody: Swift.Equatable {
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAggregationAuthorizationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregationAuthorizationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregationAuthorizationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAggregationAuthorizationsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregationAuthorizationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAggregationAuthorizationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregationAuthorizations = output.aggregationAuthorizations
            self.nextToken = output.nextToken
        } else {
            self.aggregationAuthorizations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregationAuthorizationsOutputResponse: Swift.Equatable {
    /// Returns a list of authorizations granted to various aggregator accounts and regions.
    public var aggregationAuthorizations: [ConfigClientTypes.AggregationAuthorization]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregationAuthorizations: [ConfigClientTypes.AggregationAuthorization]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationAuthorizations = aggregationAuthorizations
        self.nextToken = nextToken
    }
}

struct DescribeAggregationAuthorizationsOutputResponseBody: Swift.Equatable {
    let aggregationAuthorizations: [ConfigClientTypes.AggregationAuthorization]?
    let nextToken: Swift.String?
}

extension DescribeAggregationAuthorizationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationAuthorizations = "AggregationAuthorizations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregationAuthorization?].self, forKey: .aggregationAuthorizations)
        var aggregationAuthorizationsDecoded0:[ConfigClientTypes.AggregationAuthorization]? = nil
        if let aggregationAuthorizationsContainer = aggregationAuthorizationsContainer {
            aggregationAuthorizationsDecoded0 = [ConfigClientTypes.AggregationAuthorization]()
            for structure0 in aggregationAuthorizationsContainer {
                if let structure0 = structure0 {
                    aggregationAuthorizationsDecoded0?.append(structure0)
                }
            }
        }
        aggregationAuthorizations = aggregationAuthorizationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetype0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetype0.rawValue)
            }
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulename0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulename0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeComplianceByConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeComplianceByConfigRuleInput: Swift.Equatable {
    /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// Specify one or more Config rule names to filter the results by rule.
    public var configRuleNames: [Swift.String]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        configRuleNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleNames = configRuleNames
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByConfigRuleInputBody: Swift.Equatable {
    let configRuleNames: [Swift.String]?
    let complianceTypes: [ConfigClientTypes.ComplianceType]?
    let nextToken: Swift.String?
}

extension DescribeComplianceByConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ConfigClientTypes.ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ConfigClientTypes.ComplianceType]()
            for enum0 in complianceTypesContainer {
                if let enum0 = enum0 {
                    complianceTypesDecoded0?.append(enum0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComplianceByConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeComplianceByConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComplianceByConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeComplianceByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceByConfigRules = output.complianceByConfigRules
            self.nextToken = output.nextToken
        } else {
            self.complianceByConfigRules = nil
            self.nextToken = nil
        }
    }
}

///
public struct DescribeComplianceByConfigRuleOutputResponse: Swift.Equatable {
    /// Indicates whether each of the specified Config rules is compliant.
    public var complianceByConfigRules: [ConfigClientTypes.ComplianceByConfigRule]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        complianceByConfigRules: [ConfigClientTypes.ComplianceByConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceByConfigRules = complianceByConfigRules
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByConfigRuleOutputResponseBody: Swift.Equatable {
    let complianceByConfigRules: [ConfigClientTypes.ComplianceByConfigRule]?
    let nextToken: Swift.String?
}

extension DescribeComplianceByConfigRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceByConfigRules = "ComplianceByConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceByConfigRulesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceByConfigRule?].self, forKey: .complianceByConfigRules)
        var complianceByConfigRulesDecoded0:[ConfigClientTypes.ComplianceByConfigRule]? = nil
        if let complianceByConfigRulesContainer = complianceByConfigRulesContainer {
            complianceByConfigRulesDecoded0 = [ConfigClientTypes.ComplianceByConfigRule]()
            for structure0 in complianceByConfigRulesContainer {
                if let structure0 = structure0 {
                    complianceByConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        complianceByConfigRules = complianceByConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetype0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetype0.rawValue)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension DescribeComplianceByResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeComplianceByResourceInput: Swift.Equatable {
    /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The ID of the Amazon Web Services resource for which you want compliance information. You can specify only one resource ID. If you specify a resource ID, you must also specify a type for ResourceType.
    public var resourceId: Swift.String?
    /// The types of Amazon Web Services resources for which you want compliance information (for example, AWS::EC2::Instance). For this action, you can specify that the resource type is an Amazon Web Services account by specifying AWS::::Account.
    public var resourceType: Swift.String?

    public init (
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct DescribeComplianceByResourceInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let resourceId: Swift.String?
    let complianceTypes: [ConfigClientTypes.ComplianceType]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeComplianceByResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ConfigClientTypes.ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ConfigClientTypes.ComplianceType]()
            for enum0 in complianceTypesContainer {
                if let enum0 = enum0 {
                    complianceTypesDecoded0?.append(enum0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComplianceByResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeComplianceByResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComplianceByResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeComplianceByResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceByResources = output.complianceByResources
            self.nextToken = output.nextToken
        } else {
            self.complianceByResources = nil
            self.nextToken = nil
        }
    }
}

///
public struct DescribeComplianceByResourceOutputResponse: Swift.Equatable {
    /// Indicates whether the specified Amazon Web Services resource complies with all of the Config rules that evaluate it.
    public var complianceByResources: [ConfigClientTypes.ComplianceByResource]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        complianceByResources: [ConfigClientTypes.ComplianceByResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceByResources = complianceByResources
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByResourceOutputResponseBody: Swift.Equatable {
    let complianceByResources: [ConfigClientTypes.ComplianceByResource]?
    let nextToken: Swift.String?
}

extension DescribeComplianceByResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceByResources = "ComplianceByResources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceByResourcesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceByResource?].self, forKey: .complianceByResources)
        var complianceByResourcesDecoded0:[ConfigClientTypes.ComplianceByResource]? = nil
        if let complianceByResourcesContainer = complianceByResourcesContainer {
            complianceByResourcesDecoded0 = [ConfigClientTypes.ComplianceByResource]()
            for structure0 in complianceByResourcesContainer {
                if let structure0 = structure0 {
                    complianceByResourcesDecoded0?.append(structure0)
                }
            }
        }
        complianceByResources = complianceByResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigRuleEvaluationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulename0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulename0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConfigRuleEvaluationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeConfigRuleEvaluationStatusInput: Swift.Equatable {
    /// The name of the Config managed rules for which you want status information. If you do not specify any names, Config returns status information for all Config managed rules that you use.
    public var configRuleNames: [Swift.String]?
    /// The number of rule evaluation results that you want returned. This parameter is required if the rule limit for your account is more than the default of 150 rules. For information about requesting a rule limit increase, see [Config Limits](http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config) in the Amazon Web Services General Reference Guide.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configRuleNames: [Swift.String]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConfigRuleEvaluationStatusInputBody: Swift.Equatable {
    let configRuleNames: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int
}

extension DescribeConfigRuleEvaluationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension DescribeConfigRuleEvaluationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigRuleEvaluationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigRuleEvaluationStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigRuleEvaluationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigRuleEvaluationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configRulesEvaluationStatus = output.configRulesEvaluationStatus
            self.nextToken = output.nextToken
        } else {
            self.configRulesEvaluationStatus = nil
            self.nextToken = nil
        }
    }
}

///
public struct DescribeConfigRuleEvaluationStatusOutputResponse: Swift.Equatable {
    /// Status information about your Config managed rules.
    public var configRulesEvaluationStatus: [ConfigClientTypes.ConfigRuleEvaluationStatus]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configRulesEvaluationStatus: [ConfigClientTypes.ConfigRuleEvaluationStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRulesEvaluationStatus = configRulesEvaluationStatus
        self.nextToken = nextToken
    }
}

struct DescribeConfigRuleEvaluationStatusOutputResponseBody: Swift.Equatable {
    let configRulesEvaluationStatus: [ConfigClientTypes.ConfigRuleEvaluationStatus]?
    let nextToken: Swift.String?
}

extension DescribeConfigRuleEvaluationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRulesEvaluationStatus = "ConfigRulesEvaluationStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRulesEvaluationStatusContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigRuleEvaluationStatus?].self, forKey: .configRulesEvaluationStatus)
        var configRulesEvaluationStatusDecoded0:[ConfigClientTypes.ConfigRuleEvaluationStatus]? = nil
        if let configRulesEvaluationStatusContainer = configRulesEvaluationStatusContainer {
            configRulesEvaluationStatusDecoded0 = [ConfigClientTypes.ConfigRuleEvaluationStatus]()
            for structure0 in configRulesEvaluationStatusContainer {
                if let structure0 = structure0 {
                    configRulesEvaluationStatusDecoded0?.append(structure0)
                }
            }
        }
        configRulesEvaluationStatus = configRulesEvaluationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ConfigClientTypes.DescribeConfigRulesFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationMode = "EvaluationMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationMode = self.evaluationMode {
            try encodeContainer.encode(evaluationMode.rawValue, forKey: .evaluationMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
    }
}

extension ConfigClientTypes {
    /// Returns a filtered list of Detective or Proactive Config rules. By default, if the filter is not defined, this API returns an unfiltered list.
    public struct DescribeConfigRulesFilters: Swift.Equatable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?

        public init (
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil
        )
        {
            self.evaluationMode = evaluationMode
        }
    }

}

extension DescribeConfigRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulename0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulename0)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConfigRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeConfigRulesInput: Swift.Equatable {
    /// The names of the Config rules for which you want details. If you do not specify any names, Config returns details for all your rules.
    public var configRuleNames: [Swift.String]?
    /// Returns a list of Detecive or Proactive Config rules. By default, this API returns an unfiltered list.
    public var filters: ConfigClientTypes.DescribeConfigRulesFilters?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configRuleNames: [Swift.String]? = nil,
        filters: ConfigClientTypes.DescribeConfigRulesFilters? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct DescribeConfigRulesInputBody: Swift.Equatable {
    let configRuleNames: [Swift.String]?
    let nextToken: Swift.String?
    let filters: ConfigClientTypes.DescribeConfigRulesFilters?
}

extension DescribeConfigRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.DescribeConfigRulesFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension DescribeConfigRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configRules = output.configRules
            self.nextToken = output.nextToken
        } else {
            self.configRules = nil
            self.nextToken = nil
        }
    }
}

///
public struct DescribeConfigRulesOutputResponse: Swift.Equatable {
    /// The details about your Config rules.
    public var configRules: [ConfigClientTypes.ConfigRule]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configRules: [ConfigClientTypes.ConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRules = configRules
        self.nextToken = nextToken
    }
}

struct DescribeConfigRulesOutputResponseBody: Swift.Equatable {
    let configRules: [ConfigClientTypes.ConfigRule]?
    let nextToken: Swift.String?
}

extension DescribeConfigRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRules = "ConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRulesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigRule?].self, forKey: .configRules)
        var configRulesDecoded0:[ConfigClientTypes.ConfigRule]? = nil
        if let configRulesContainer = configRulesContainer {
            configRulesDecoded0 = [ConfigClientTypes.ConfigRule]()
            for structure0 in configRulesContainer {
                if let structure0 = structure0 {
                    configRulesDecoded0?.append(structure0)
                }
            }
        }
        configRules = configRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigurationAggregatorSourcesStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let updateStatus = updateStatus {
            var updateStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateStatus)
            for aggregatedsourcestatustype0 in updateStatus {
                try updateStatusContainer.encode(aggregatedsourcestatustype0.rawValue)
            }
        }
    }
}

extension DescribeConfigurationAggregatorSourcesStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The maximum number of AggregatorSourceStatus returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Filters the status type.
    ///
    /// * Valid value FAILED indicates errors while moving data.
    ///
    /// * Valid value SUCCEEDED indicates the data was successfully moved.
    ///
    /// * Valid value OUTDATED indicates the data is not the most recent.
    public var updateStatus: [ConfigClientTypes.AggregatedSourceStatusType]?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        updateStatus: [ConfigClientTypes.AggregatedSourceStatusType]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
        self.updateStatus = updateStatus
    }
}

struct DescribeConfigurationAggregatorSourcesStatusInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let updateStatus: [ConfigClientTypes.AggregatedSourceStatusType]?
    let nextToken: Swift.String?
    let limit: Swift.Int
}

extension DescribeConfigurationAggregatorSourcesStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let updateStatusContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregatedSourceStatusType?].self, forKey: .updateStatus)
        var updateStatusDecoded0:[ConfigClientTypes.AggregatedSourceStatusType]? = nil
        if let updateStatusContainer = updateStatusContainer {
            updateStatusDecoded0 = [ConfigClientTypes.AggregatedSourceStatusType]()
            for enum0 in updateStatusContainer {
                if let enum0 = enum0 {
                    updateStatusDecoded0?.append(enum0)
                }
            }
        }
        updateStatus = updateStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension DescribeConfigurationAggregatorSourcesStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationAggregatorSourcesStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigurationAggregatorSourcesStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationAggregatorSourcesStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigurationAggregatorSourcesStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregatedSourceStatusList = output.aggregatedSourceStatusList
            self.nextToken = output.nextToken
        } else {
            self.aggregatedSourceStatusList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusOutputResponse: Swift.Equatable {
    /// Returns an AggregatedSourceStatus object.
    public var aggregatedSourceStatusList: [ConfigClientTypes.AggregatedSourceStatus]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregatedSourceStatusList: [ConfigClientTypes.AggregatedSourceStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedSourceStatusList = aggregatedSourceStatusList
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorSourcesStatusOutputResponseBody: Swift.Equatable {
    let aggregatedSourceStatusList: [ConfigClientTypes.AggregatedSourceStatus]?
    let nextToken: Swift.String?
}

extension DescribeConfigurationAggregatorSourcesStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedSourceStatusList = "AggregatedSourceStatusList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedSourceStatusListContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregatedSourceStatus?].self, forKey: .aggregatedSourceStatusList)
        var aggregatedSourceStatusListDecoded0:[ConfigClientTypes.AggregatedSourceStatus]? = nil
        if let aggregatedSourceStatusListContainer = aggregatedSourceStatusListContainer {
            aggregatedSourceStatusListDecoded0 = [ConfigClientTypes.AggregatedSourceStatus]()
            for structure0 in aggregatedSourceStatusListContainer {
                if let structure0 = structure0 {
                    aggregatedSourceStatusListDecoded0?.append(structure0)
                }
            }
        }
        aggregatedSourceStatusList = aggregatedSourceStatusListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigurationAggregatorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorNames = "ConfigurationAggregatorNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorNames = configurationAggregatorNames {
            var configurationAggregatorNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationAggregatorNames)
            for configurationaggregatorname0 in configurationAggregatorNames {
                try configurationAggregatorNamesContainer.encode(configurationaggregatorname0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConfigurationAggregatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationAggregatorsInput: Swift.Equatable {
    /// The name of the configuration aggregators.
    public var configurationAggregatorNames: [Swift.String]?
    /// The maximum number of configuration aggregators returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorNames: [Swift.String]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorNames = configurationAggregatorNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorsInputBody: Swift.Equatable {
    let configurationAggregatorNames: [Swift.String]?
    let nextToken: Swift.String?
    let limit: Swift.Int
}

extension DescribeConfigurationAggregatorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorNames = "ConfigurationAggregatorNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationAggregatorNames)
        var configurationAggregatorNamesDecoded0:[Swift.String]? = nil
        if let configurationAggregatorNamesContainer = configurationAggregatorNamesContainer {
            configurationAggregatorNamesDecoded0 = [Swift.String]()
            for string0 in configurationAggregatorNamesContainer {
                if let string0 = string0 {
                    configurationAggregatorNamesDecoded0?.append(string0)
                }
            }
        }
        configurationAggregatorNames = configurationAggregatorNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension DescribeConfigurationAggregatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationAggregatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigurationAggregatorsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationAggregatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigurationAggregatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationAggregators = output.configurationAggregators
            self.nextToken = output.nextToken
        } else {
            self.configurationAggregators = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationAggregatorsOutputResponse: Swift.Equatable {
    /// Returns a ConfigurationAggregators object.
    public var configurationAggregators: [ConfigClientTypes.ConfigurationAggregator]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregators: [ConfigClientTypes.ConfigurationAggregator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregators = configurationAggregators
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorsOutputResponseBody: Swift.Equatable {
    let configurationAggregators: [ConfigClientTypes.ConfigurationAggregator]?
    let nextToken: Swift.String?
}

extension DescribeConfigurationAggregatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregators = "ConfigurationAggregators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigurationAggregator?].self, forKey: .configurationAggregators)
        var configurationAggregatorsDecoded0:[ConfigClientTypes.ConfigurationAggregator]? = nil
        if let configurationAggregatorsContainer = configurationAggregatorsContainer {
            configurationAggregatorsDecoded0 = [ConfigClientTypes.ConfigurationAggregator]()
            for structure0 in configurationAggregatorsContainer {
                if let structure0 = structure0 {
                    configurationAggregatorsDecoded0?.append(structure0)
                }
            }
        }
        configurationAggregators = configurationAggregatorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigurationRecorderStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderNames = configurationRecorderNames {
            var configurationRecorderNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationRecorderNames)
            for recordername0 in configurationRecorderNames {
                try configurationRecorderNamesContainer.encode(recordername0)
            }
        }
    }
}

extension DescribeConfigurationRecorderStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DescribeConfigurationRecorderStatus] action.
public struct DescribeConfigurationRecorderStatusInput: Swift.Equatable {
    /// The name(s) of the configuration recorder. If the name is not specified, the action returns the current status of all the configuration recorders associated with the account.
    public var configurationRecorderNames: [Swift.String]?

    public init (
        configurationRecorderNames: [Swift.String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

struct DescribeConfigurationRecorderStatusInputBody: Swift.Equatable {
    let configurationRecorderNames: [Swift.String]?
}

extension DescribeConfigurationRecorderStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationRecorderNames)
        var configurationRecorderNamesDecoded0:[Swift.String]? = nil
        if let configurationRecorderNamesContainer = configurationRecorderNamesContainer {
            configurationRecorderNamesDecoded0 = [Swift.String]()
            for string0 in configurationRecorderNamesContainer {
                if let string0 = string0 {
                    configurationRecorderNamesDecoded0?.append(string0)
                }
            }
        }
        configurationRecorderNames = configurationRecorderNamesDecoded0
    }
}

extension DescribeConfigurationRecorderStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRecorderStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigurationRecorderStatusOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRecorderStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigurationRecorderStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationRecordersStatus = output.configurationRecordersStatus
        } else {
            self.configurationRecordersStatus = nil
        }
    }
}

/// The output for the [DescribeConfigurationRecorderStatus] action, in JSON format.
public struct DescribeConfigurationRecorderStatusOutputResponse: Swift.Equatable {
    /// A list that contains status of the specified recorders.
    public var configurationRecordersStatus: [ConfigClientTypes.ConfigurationRecorderStatus]?

    public init (
        configurationRecordersStatus: [ConfigClientTypes.ConfigurationRecorderStatus]? = nil
    )
    {
        self.configurationRecordersStatus = configurationRecordersStatus
    }
}

struct DescribeConfigurationRecorderStatusOutputResponseBody: Swift.Equatable {
    let configurationRecordersStatus: [ConfigClientTypes.ConfigurationRecorderStatus]?
}

extension DescribeConfigurationRecorderStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecordersStatus = "ConfigurationRecordersStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecordersStatusContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigurationRecorderStatus?].self, forKey: .configurationRecordersStatus)
        var configurationRecordersStatusDecoded0:[ConfigClientTypes.ConfigurationRecorderStatus]? = nil
        if let configurationRecordersStatusContainer = configurationRecordersStatusContainer {
            configurationRecordersStatusDecoded0 = [ConfigClientTypes.ConfigurationRecorderStatus]()
            for structure0 in configurationRecordersStatusContainer {
                if let structure0 = structure0 {
                    configurationRecordersStatusDecoded0?.append(structure0)
                }
            }
        }
        configurationRecordersStatus = configurationRecordersStatusDecoded0
    }
}

extension DescribeConfigurationRecordersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderNames = configurationRecorderNames {
            var configurationRecorderNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationRecorderNames)
            for recordername0 in configurationRecorderNames {
                try configurationRecorderNamesContainer.encode(recordername0)
            }
        }
    }
}

extension DescribeConfigurationRecordersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DescribeConfigurationRecorders] action.
public struct DescribeConfigurationRecordersInput: Swift.Equatable {
    /// A list of configuration recorder names.
    public var configurationRecorderNames: [Swift.String]?

    public init (
        configurationRecorderNames: [Swift.String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

struct DescribeConfigurationRecordersInputBody: Swift.Equatable {
    let configurationRecorderNames: [Swift.String]?
}

extension DescribeConfigurationRecordersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationRecorderNames)
        var configurationRecorderNamesDecoded0:[Swift.String]? = nil
        if let configurationRecorderNamesContainer = configurationRecorderNamesContainer {
            configurationRecorderNamesDecoded0 = [Swift.String]()
            for string0 in configurationRecorderNamesContainer {
                if let string0 = string0 {
                    configurationRecorderNamesDecoded0?.append(string0)
                }
            }
        }
        configurationRecorderNames = configurationRecorderNamesDecoded0
    }
}

extension DescribeConfigurationRecordersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRecordersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigurationRecordersOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRecordersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigurationRecordersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationRecorders = output.configurationRecorders
        } else {
            self.configurationRecorders = nil
        }
    }
}

/// The output for the [DescribeConfigurationRecorders] action.
public struct DescribeConfigurationRecordersOutputResponse: Swift.Equatable {
    /// A list that contains the descriptions of the specified configuration recorders.
    public var configurationRecorders: [ConfigClientTypes.ConfigurationRecorder]?

    public init (
        configurationRecorders: [ConfigClientTypes.ConfigurationRecorder]? = nil
    )
    {
        self.configurationRecorders = configurationRecorders
    }
}

struct DescribeConfigurationRecordersOutputResponseBody: Swift.Equatable {
    let configurationRecorders: [ConfigClientTypes.ConfigurationRecorder]?
}

extension DescribeConfigurationRecordersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorders = "ConfigurationRecorders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecordersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigurationRecorder?].self, forKey: .configurationRecorders)
        var configurationRecordersDecoded0:[ConfigClientTypes.ConfigurationRecorder]? = nil
        if let configurationRecordersContainer = configurationRecordersContainer {
            configurationRecordersDecoded0 = [ConfigClientTypes.ConfigurationRecorder]()
            for structure0 in configurationRecordersContainer {
                if let structure0 = structure0 {
                    configurationRecordersDecoded0?.append(structure0)
                }
            }
        }
        configurationRecorders = configurationRecordersDecoded0
    }
}

extension DescribeConformancePackComplianceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConformancePackComplianceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConformancePackComplianceInput: Swift.Equatable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// A ConformancePackComplianceFilters object.
    public var filters: ConfigClientTypes.ConformancePackComplianceFilters?
    /// The maximum number of Config rules within a conformance pack are returned on each page.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackName: Swift.String? = nil,
        filters: ConfigClientTypes.ConformancePackComplianceFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackComplianceInputBody: Swift.Equatable {
    let conformancePackName: Swift.String?
    let filters: ConfigClientTypes.ConformancePackComplianceFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeConformancePackComplianceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePackComplianceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePackComplianceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleInConformancePackException" : self = .noSuchConfigRuleInConformancePackException(try NoSuchConfigRuleInConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConformancePackComplianceOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleInConformancePackException(NoSuchConfigRuleInConformancePackException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePackComplianceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConformancePackComplianceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackName = output.conformancePackName
            self.conformancePackRuleComplianceList = output.conformancePackRuleComplianceList
            self.nextToken = output.nextToken
        } else {
            self.conformancePackName = nil
            self.conformancePackRuleComplianceList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePackComplianceOutputResponse: Swift.Equatable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// Returns a list of ConformancePackRuleCompliance objects.
    /// This member is required.
    public var conformancePackRuleComplianceList: [ConfigClientTypes.ConformancePackRuleCompliance]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackName: Swift.String? = nil,
        conformancePackRuleComplianceList: [ConfigClientTypes.ConformancePackRuleCompliance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleComplianceList = conformancePackRuleComplianceList
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackComplianceOutputResponseBody: Swift.Equatable {
    let conformancePackName: Swift.String?
    let conformancePackRuleComplianceList: [ConfigClientTypes.ConformancePackRuleCompliance]?
    let nextToken: Swift.String?
}

extension DescribeConformancePackComplianceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case conformancePackRuleComplianceList = "ConformancePackRuleComplianceList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackRuleComplianceListContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackRuleCompliance?].self, forKey: .conformancePackRuleComplianceList)
        var conformancePackRuleComplianceListDecoded0:[ConfigClientTypes.ConformancePackRuleCompliance]? = nil
        if let conformancePackRuleComplianceListContainer = conformancePackRuleComplianceListContainer {
            conformancePackRuleComplianceListDecoded0 = [ConfigClientTypes.ConformancePackRuleCompliance]()
            for structure0 in conformancePackRuleComplianceListContainer {
                if let structure0 = structure0 {
                    conformancePackRuleComplianceListDecoded0?.append(structure0)
                }
            }
        }
        conformancePackRuleComplianceList = conformancePackRuleComplianceListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePackStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepackname0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepackname0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConformancePackStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConformancePackStatusInput: Swift.Equatable {
    /// Comma-separated list of conformance pack names.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs status returned on each page.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackStatusInputBody: Swift.Equatable {
    let conformancePackNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeConformancePackStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[Swift.String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [Swift.String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePackStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePackStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConformancePackStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePackStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConformancePackStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackStatusDetails = output.conformancePackStatusDetails
            self.nextToken = output.nextToken
        } else {
            self.conformancePackStatusDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePackStatusOutputResponse: Swift.Equatable {
    /// A list of ConformancePackStatusDetail objects.
    public var conformancePackStatusDetails: [ConfigClientTypes.ConformancePackStatusDetail]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackStatusDetails: [ConfigClientTypes.ConformancePackStatusDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackStatusDetails = conformancePackStatusDetails
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackStatusOutputResponseBody: Swift.Equatable {
    let conformancePackStatusDetails: [ConfigClientTypes.ConformancePackStatusDetail]?
    let nextToken: Swift.String?
}

extension DescribeConformancePackStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackStatusDetails = "ConformancePackStatusDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackStatusDetailsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackStatusDetail?].self, forKey: .conformancePackStatusDetails)
        var conformancePackStatusDetailsDecoded0:[ConfigClientTypes.ConformancePackStatusDetail]? = nil
        if let conformancePackStatusDetailsContainer = conformancePackStatusDetailsContainer {
            conformancePackStatusDetailsDecoded0 = [ConfigClientTypes.ConformancePackStatusDetail]()
            for structure0 in conformancePackStatusDetailsContainer {
                if let structure0 = structure0 {
                    conformancePackStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackStatusDetails = conformancePackStatusDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepackname0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepackname0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConformancePacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConformancePacksInput: Swift.Equatable {
    /// Comma-separated list of conformance pack names for which you want details. If you do not specify any names, Config returns details for all your conformance packs.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs returned on each page.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePacksInputBody: Swift.Equatable {
    let conformancePackNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeConformancePacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[Swift.String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [Swift.String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConformancePacksOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackDetails = output.conformancePackDetails
            self.nextToken = output.nextToken
        } else {
            self.conformancePackDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePacksOutputResponse: Swift.Equatable {
    /// Returns a list of ConformancePackDetail objects.
    public var conformancePackDetails: [ConfigClientTypes.ConformancePackDetail]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackDetails: [ConfigClientTypes.ConformancePackDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackDetails = conformancePackDetails
        self.nextToken = nextToken
    }
}

struct DescribeConformancePacksOutputResponseBody: Swift.Equatable {
    let conformancePackDetails: [ConfigClientTypes.ConformancePackDetail]?
    let nextToken: Swift.String?
}

extension DescribeConformancePacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackDetails = "ConformancePackDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackDetailsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackDetail?].self, forKey: .conformancePackDetails)
        var conformancePackDetailsDecoded0:[ConfigClientTypes.ConformancePackDetail]? = nil
        if let conformancePackDetailsContainer = conformancePackDetailsContainer {
            conformancePackDetailsDecoded0 = [ConfigClientTypes.ConformancePackDetail]()
            for structure0 in conformancePackDetailsContainer {
                if let structure0 = structure0 {
                    conformancePackDetailsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackDetails = conformancePackDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDeliveryChannelStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelNames = deliveryChannelNames {
            var deliveryChannelNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deliveryChannelNames)
            for channelname0 in deliveryChannelNames {
                try deliveryChannelNamesContainer.encode(channelname0)
            }
        }
    }
}

extension DescribeDeliveryChannelStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DeliveryChannelStatus] action.
public struct DescribeDeliveryChannelStatusInput: Swift.Equatable {
    /// A list of delivery channel names.
    public var deliveryChannelNames: [Swift.String]?

    public init (
        deliveryChannelNames: [Swift.String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

struct DescribeDeliveryChannelStatusInputBody: Swift.Equatable {
    let deliveryChannelNames: [Swift.String]?
}

extension DescribeDeliveryChannelStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deliveryChannelNames)
        var deliveryChannelNamesDecoded0:[Swift.String]? = nil
        if let deliveryChannelNamesContainer = deliveryChannelNamesContainer {
            deliveryChannelNamesDecoded0 = [Swift.String]()
            for string0 in deliveryChannelNamesContainer {
                if let string0 = string0 {
                    deliveryChannelNamesDecoded0?.append(string0)
                }
            }
        }
        deliveryChannelNames = deliveryChannelNamesDecoded0
    }
}

extension DescribeDeliveryChannelStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeliveryChannelStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeliveryChannelStatusOutputError: Swift.Error, Swift.Equatable {
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeliveryChannelStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeliveryChannelStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliveryChannelsStatus = output.deliveryChannelsStatus
        } else {
            self.deliveryChannelsStatus = nil
        }
    }
}

/// The output for the [DescribeDeliveryChannelStatus] action.
public struct DescribeDeliveryChannelStatusOutputResponse: Swift.Equatable {
    /// A list that contains the status of a specified delivery channel.
    public var deliveryChannelsStatus: [ConfigClientTypes.DeliveryChannelStatus]?

    public init (
        deliveryChannelsStatus: [ConfigClientTypes.DeliveryChannelStatus]? = nil
    )
    {
        self.deliveryChannelsStatus = deliveryChannelsStatus
    }
}

struct DescribeDeliveryChannelStatusOutputResponseBody: Swift.Equatable {
    let deliveryChannelsStatus: [ConfigClientTypes.DeliveryChannelStatus]?
}

extension DescribeDeliveryChannelStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelsStatus = "DeliveryChannelsStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelsStatusContainer = try containerValues.decodeIfPresent([ConfigClientTypes.DeliveryChannelStatus?].self, forKey: .deliveryChannelsStatus)
        var deliveryChannelsStatusDecoded0:[ConfigClientTypes.DeliveryChannelStatus]? = nil
        if let deliveryChannelsStatusContainer = deliveryChannelsStatusContainer {
            deliveryChannelsStatusDecoded0 = [ConfigClientTypes.DeliveryChannelStatus]()
            for structure0 in deliveryChannelsStatusContainer {
                if let structure0 = structure0 {
                    deliveryChannelsStatusDecoded0?.append(structure0)
                }
            }
        }
        deliveryChannelsStatus = deliveryChannelsStatusDecoded0
    }
}

extension DescribeDeliveryChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelNames = deliveryChannelNames {
            var deliveryChannelNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deliveryChannelNames)
            for channelname0 in deliveryChannelNames {
                try deliveryChannelNamesContainer.encode(channelname0)
            }
        }
    }
}

extension DescribeDeliveryChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [DescribeDeliveryChannels] action.
public struct DescribeDeliveryChannelsInput: Swift.Equatable {
    /// A list of delivery channel names.
    public var deliveryChannelNames: [Swift.String]?

    public init (
        deliveryChannelNames: [Swift.String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

struct DescribeDeliveryChannelsInputBody: Swift.Equatable {
    let deliveryChannelNames: [Swift.String]?
}

extension DescribeDeliveryChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deliveryChannelNames)
        var deliveryChannelNamesDecoded0:[Swift.String]? = nil
        if let deliveryChannelNamesContainer = deliveryChannelNamesContainer {
            deliveryChannelNamesDecoded0 = [Swift.String]()
            for string0 in deliveryChannelNamesContainer {
                if let string0 = string0 {
                    deliveryChannelNamesDecoded0?.append(string0)
                }
            }
        }
        deliveryChannelNames = deliveryChannelNamesDecoded0
    }
}

extension DescribeDeliveryChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeliveryChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeliveryChannelsOutputError: Swift.Error, Swift.Equatable {
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeliveryChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeliveryChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deliveryChannels = output.deliveryChannels
        } else {
            self.deliveryChannels = nil
        }
    }
}

/// The output for the [DescribeDeliveryChannels] action.
public struct DescribeDeliveryChannelsOutputResponse: Swift.Equatable {
    /// A list that contains the descriptions of the specified delivery channel.
    public var deliveryChannels: [ConfigClientTypes.DeliveryChannel]?

    public init (
        deliveryChannels: [ConfigClientTypes.DeliveryChannel]? = nil
    )
    {
        self.deliveryChannels = deliveryChannels
    }
}

struct DescribeDeliveryChannelsOutputResponseBody: Swift.Equatable {
    let deliveryChannels: [ConfigClientTypes.DeliveryChannel]?
}

extension DescribeDeliveryChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannels = "DeliveryChannels"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.DeliveryChannel?].self, forKey: .deliveryChannels)
        var deliveryChannelsDecoded0:[ConfigClientTypes.DeliveryChannel]? = nil
        if let deliveryChannelsContainer = deliveryChannelsContainer {
            deliveryChannelsDecoded0 = [ConfigClientTypes.DeliveryChannel]()
            for structure0 in deliveryChannelsContainer {
                if let structure0 = structure0 {
                    deliveryChannelsDecoded0?.append(structure0)
                }
            }
        }
        deliveryChannels = deliveryChannelsDecoded0
    }
}

extension DescribeOrganizationConfigRuleStatusesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleNames = organizationConfigRuleNames {
            var organizationConfigRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleNames)
            for stringwithcharlimit640 in organizationConfigRuleNames {
                try organizationConfigRuleNamesContainer.encode(stringwithcharlimit640)
            }
        }
    }
}

extension DescribeOrganizationConfigRuleStatusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationConfigRuleStatusesInput: Swift.Equatable {
    /// The maximum number of OrganizationConfigRuleStatuses returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization Config rules for which you want status details. If you do not specify any names, Config returns details for all your organization Config rules.
    public var organizationConfigRuleNames: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

struct DescribeOrganizationConfigRuleStatusesInputBody: Swift.Equatable {
    let organizationConfigRuleNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeOrganizationConfigRuleStatusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationConfigRuleNames)
        var organizationConfigRuleNamesDecoded0:[Swift.String]? = nil
        if let organizationConfigRuleNamesContainer = organizationConfigRuleNamesContainer {
            organizationConfigRuleNamesDecoded0 = [Swift.String]()
            for string0 in organizationConfigRuleNamesContainer {
                if let string0 = string0 {
                    organizationConfigRuleNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConfigRuleNames = organizationConfigRuleNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigRuleStatusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigRuleStatusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConfigRuleStatusesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigRuleStatusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConfigRuleStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConfigRuleStatuses = output.organizationConfigRuleStatuses
        } else {
            self.nextToken = nil
            self.organizationConfigRuleStatuses = nil
        }
    }
}

public struct DescribeOrganizationConfigRuleStatusesOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConfigRuleStatus objects.
    public var organizationConfigRuleStatuses: [ConfigClientTypes.OrganizationConfigRuleStatus]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConfigRuleStatuses: [ConfigClientTypes.OrganizationConfigRuleStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleStatuses = organizationConfigRuleStatuses
    }
}

struct DescribeOrganizationConfigRuleStatusesOutputResponseBody: Swift.Equatable {
    let organizationConfigRuleStatuses: [ConfigClientTypes.OrganizationConfigRuleStatus]?
    let nextToken: Swift.String?
}

extension DescribeOrganizationConfigRuleStatusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRuleStatuses = "OrganizationConfigRuleStatuses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleStatusesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConfigRuleStatus?].self, forKey: .organizationConfigRuleStatuses)
        var organizationConfigRuleStatusesDecoded0:[ConfigClientTypes.OrganizationConfigRuleStatus]? = nil
        if let organizationConfigRuleStatusesContainer = organizationConfigRuleStatusesContainer {
            organizationConfigRuleStatusesDecoded0 = [ConfigClientTypes.OrganizationConfigRuleStatus]()
            for structure0 in organizationConfigRuleStatusesContainer {
                if let structure0 = structure0 {
                    organizationConfigRuleStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRuleStatuses = organizationConfigRuleStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleNames = organizationConfigRuleNames {
            var organizationConfigRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleNames)
            for stringwithcharlimit640 in organizationConfigRuleNames {
                try organizationConfigRuleNamesContainer.encode(stringwithcharlimit640)
            }
        }
    }
}

extension DescribeOrganizationConfigRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationConfigRulesInput: Swift.Equatable {
    /// The maximum number of organization Config rules returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization Config rules for which you want details. If you do not specify any names, Config returns details for all your organization Config rules.
    public var organizationConfigRuleNames: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

struct DescribeOrganizationConfigRulesInputBody: Swift.Equatable {
    let organizationConfigRuleNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeOrganizationConfigRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationConfigRuleNames)
        var organizationConfigRuleNamesDecoded0:[Swift.String]? = nil
        if let organizationConfigRuleNamesContainer = organizationConfigRuleNamesContainer {
            organizationConfigRuleNamesDecoded0 = [Swift.String]()
            for string0 in organizationConfigRuleNamesContainer {
                if let string0 = string0 {
                    organizationConfigRuleNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConfigRuleNames = organizationConfigRuleNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConfigRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConfigRules = output.organizationConfigRules
        } else {
            self.nextToken = nil
            self.organizationConfigRules = nil
        }
    }
}

public struct DescribeOrganizationConfigRulesOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of OrganizationConfigRule objects.
    public var organizationConfigRules: [ConfigClientTypes.OrganizationConfigRule]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConfigRules: [ConfigClientTypes.OrganizationConfigRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRules = organizationConfigRules
    }
}

struct DescribeOrganizationConfigRulesOutputResponseBody: Swift.Equatable {
    let organizationConfigRules: [ConfigClientTypes.OrganizationConfigRule]?
    let nextToken: Swift.String?
}

extension DescribeOrganizationConfigRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRules = "OrganizationConfigRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRulesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConfigRule?].self, forKey: .organizationConfigRules)
        var organizationConfigRulesDecoded0:[ConfigClientTypes.OrganizationConfigRule]? = nil
        if let organizationConfigRulesContainer = organizationConfigRulesContainer {
            organizationConfigRulesDecoded0 = [ConfigClientTypes.OrganizationConfigRule]()
            for structure0 in organizationConfigRulesContainer {
                if let structure0 = structure0 {
                    organizationConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRules = organizationConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePackStatusesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackNames = organizationConformancePackNames {
            var organizationConformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConformancePackNames)
            for organizationconformancepackname0 in organizationConformancePackNames {
                try organizationConformancePackNamesContainer.encode(organizationconformancepackname0)
            }
        }
    }
}

extension DescribeOrganizationConformancePackStatusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationConformancePackStatusesInput: Swift.Equatable {
    /// The maximum number of OrganizationConformancePackStatuses returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization conformance packs for which you want status details. If you do not specify any names, Config returns details for all your organization conformance packs.
    public var organizationConformancePackNames: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

struct DescribeOrganizationConformancePackStatusesInputBody: Swift.Equatable {
    let organizationConformancePackNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeOrganizationConformancePackStatusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationConformancePackNames)
        var organizationConformancePackNamesDecoded0:[Swift.String]? = nil
        if let organizationConformancePackNamesContainer = organizationConformancePackNamesContainer {
            organizationConformancePackNamesDecoded0 = [Swift.String]()
            for string0 in organizationConformancePackNamesContainer {
                if let string0 = string0 {
                    organizationConformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConformancePackNames = organizationConformancePackNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePackStatusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConformancePackStatusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConformancePackStatusesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConformancePackStatusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConformancePackStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConformancePackStatuses = output.organizationConformancePackStatuses
        } else {
            self.nextToken = nil
            self.organizationConformancePackStatuses = nil
        }
    }
}

public struct DescribeOrganizationConformancePackStatusesOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConformancePackStatus objects.
    public var organizationConformancePackStatuses: [ConfigClientTypes.OrganizationConformancePackStatus]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConformancePackStatuses: [ConfigClientTypes.OrganizationConformancePackStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackStatuses = organizationConformancePackStatuses
    }
}

struct DescribeOrganizationConformancePackStatusesOutputResponseBody: Swift.Equatable {
    let organizationConformancePackStatuses: [ConfigClientTypes.OrganizationConformancePackStatus]?
    let nextToken: Swift.String?
}

extension DescribeOrganizationConformancePackStatusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePackStatuses = "OrganizationConformancePackStatuses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackStatusesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConformancePackStatus?].self, forKey: .organizationConformancePackStatuses)
        var organizationConformancePackStatusesDecoded0:[ConfigClientTypes.OrganizationConformancePackStatus]? = nil
        if let organizationConformancePackStatusesContainer = organizationConformancePackStatusesContainer {
            organizationConformancePackStatusesDecoded0 = [ConfigClientTypes.OrganizationConformancePackStatus]()
            for structure0 in organizationConformancePackStatusesContainer {
                if let structure0 = structure0 {
                    organizationConformancePackStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePackStatuses = organizationConformancePackStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackNames = organizationConformancePackNames {
            var organizationConformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConformancePackNames)
            for organizationconformancepackname0 in organizationConformancePackNames {
                try organizationConformancePackNamesContainer.encode(organizationconformancepackname0)
            }
        }
    }
}

extension DescribeOrganizationConformancePacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOrganizationConformancePacksInput: Swift.Equatable {
    /// The maximum number of organization config packs returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name that you assign to an organization conformance pack.
    public var organizationConformancePackNames: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

struct DescribeOrganizationConformancePacksInputBody: Swift.Equatable {
    let organizationConformancePackNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeOrganizationConformancePacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationConformancePackNames)
        var organizationConformancePackNamesDecoded0:[Swift.String]? = nil
        if let organizationConformancePackNamesContainer = organizationConformancePackNamesContainer {
            organizationConformancePackNamesDecoded0 = [Swift.String]()
            for string0 in organizationConformancePackNamesContainer {
                if let string0 = string0 {
                    organizationConformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConformancePackNames = organizationConformancePackNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConformancePacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConformancePacksOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConformancePacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConformancePacks = output.organizationConformancePacks
        } else {
            self.nextToken = nil
            self.organizationConformancePacks = nil
        }
    }
}

public struct DescribeOrganizationConformancePacksOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of OrganizationConformancePacks objects.
    public var organizationConformancePacks: [ConfigClientTypes.OrganizationConformancePack]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConformancePacks: [ConfigClientTypes.OrganizationConformancePack]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePacks = organizationConformancePacks
    }
}

struct DescribeOrganizationConformancePacksOutputResponseBody: Swift.Equatable {
    let organizationConformancePacks: [ConfigClientTypes.OrganizationConformancePack]?
    let nextToken: Swift.String?
}

extension DescribeOrganizationConformancePacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePacks = "OrganizationConformancePacks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePacksContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConformancePack?].self, forKey: .organizationConformancePacks)
        var organizationConformancePacksDecoded0:[ConfigClientTypes.OrganizationConformancePack]? = nil
        if let organizationConformancePacksContainer = organizationConformancePacksContainer {
            organizationConformancePacksDecoded0 = [ConfigClientTypes.OrganizationConformancePack]()
            for structure0 in organizationConformancePacksContainer {
                if let structure0 = structure0 {
                    organizationConformancePacksDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePacks = organizationConformancePacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePendingAggregationRequestsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribePendingAggregationRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePendingAggregationRequestsInput: Swift.Equatable {
    /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribePendingAggregationRequestsInputBody: Swift.Equatable {
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribePendingAggregationRequestsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePendingAggregationRequestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePendingAggregationRequestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePendingAggregationRequestsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingAggregationRequestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePendingAggregationRequestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pendingAggregationRequests = output.pendingAggregationRequests
        } else {
            self.nextToken = nil
            self.pendingAggregationRequests = nil
        }
    }
}

public struct DescribePendingAggregationRequestsOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a PendingAggregationRequests object.
    public var pendingAggregationRequests: [ConfigClientTypes.PendingAggregationRequest]?

    public init (
        nextToken: Swift.String? = nil,
        pendingAggregationRequests: [ConfigClientTypes.PendingAggregationRequest]? = nil
    )
    {
        self.nextToken = nextToken
        self.pendingAggregationRequests = pendingAggregationRequests
    }
}

struct DescribePendingAggregationRequestsOutputResponseBody: Swift.Equatable {
    let pendingAggregationRequests: [ConfigClientTypes.PendingAggregationRequest]?
    let nextToken: Swift.String?
}

extension DescribePendingAggregationRequestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pendingAggregationRequests = "PendingAggregationRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingAggregationRequestsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.PendingAggregationRequest?].self, forKey: .pendingAggregationRequests)
        var pendingAggregationRequestsDecoded0:[ConfigClientTypes.PendingAggregationRequest]? = nil
        if let pendingAggregationRequestsContainer = pendingAggregationRequestsContainer {
            pendingAggregationRequestsDecoded0 = [ConfigClientTypes.PendingAggregationRequest]()
            for structure0 in pendingAggregationRequestsContainer {
                if let structure0 = structure0 {
                    pendingAggregationRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingAggregationRequests = pendingAggregationRequestsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulename0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulename0)
            }
        }
    }
}

extension DescribeRemediationConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRemediationConfigurationsInput: Swift.Equatable {
    /// A list of Config rule names of remediation configurations for which you want details.
    /// This member is required.
    public var configRuleNames: [Swift.String]?

    public init (
        configRuleNames: [Swift.String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

struct DescribeRemediationConfigurationsInputBody: Swift.Equatable {
    let configRuleNames: [Swift.String]?
}

extension DescribeRemediationConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
    }
}

extension DescribeRemediationConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRemediationConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRemediationConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.remediationConfigurations = output.remediationConfigurations
        } else {
            self.remediationConfigurations = nil
        }
    }
}

public struct DescribeRemediationConfigurationsOutputResponse: Swift.Equatable {
    /// Returns a remediation configuration object.
    public var remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?

    public init (
        remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

struct DescribeRemediationConfigurationsOutputResponseBody: Swift.Equatable {
    let remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?
}

extension DescribeRemediationConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationConfigurationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationConfiguration?].self, forKey: .remediationConfigurations)
        var remediationConfigurationsDecoded0:[ConfigClientTypes.RemediationConfiguration]? = nil
        if let remediationConfigurationsContainer = remediationConfigurationsContainer {
            remediationConfigurationsDecoded0 = [ConfigClientTypes.RemediationConfiguration]()
            for structure0 in remediationConfigurationsContainer {
                if let structure0 = structure0 {
                    remediationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        remediationConfigurations = remediationConfigurationsDecoded0
    }
}

extension DescribeRemediationExceptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekey0)
            }
        }
    }
}

extension DescribeRemediationExceptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRemediationExceptionsInput: Swift.Equatable {
    /// The name of the Config rule.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of RemediationExceptionResourceKey returned on each page. The default is 25. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init (
        configRuleName: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

struct DescribeRemediationExceptionsInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRemediationExceptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationExceptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationExceptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRemediationExceptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationExceptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.remediationExceptions = output.remediationExceptions
        } else {
            self.nextToken = nil
            self.remediationExceptions = nil
        }
    }
}

public struct DescribeRemediationExceptionsOutputResponse: Swift.Equatable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of remediation exception objects.
    public var remediationExceptions: [ConfigClientTypes.RemediationException]?

    public init (
        nextToken: Swift.String? = nil,
        remediationExceptions: [ConfigClientTypes.RemediationException]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExceptions = remediationExceptions
    }
}

struct DescribeRemediationExceptionsOutputResponseBody: Swift.Equatable {
    let remediationExceptions: [ConfigClientTypes.RemediationException]?
    let nextToken: Swift.String?
}

extension DescribeRemediationExceptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case remediationExceptions = "RemediationExceptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationExceptionsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationException?].self, forKey: .remediationExceptions)
        var remediationExceptionsDecoded0:[ConfigClientTypes.RemediationException]? = nil
        if let remediationExceptionsContainer = remediationExceptionsContainer {
            remediationExceptionsDecoded0 = [ConfigClientTypes.RemediationException]()
            for structure0 in remediationExceptionsContainer {
                if let structure0 = structure0 {
                    remediationExceptionsDecoded0?.append(structure0)
                }
            }
        }
        remediationExceptions = remediationExceptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationExecutionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekey0)
            }
        }
    }
}

extension DescribeRemediationExecutionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRemediationExecutionStatusInput: Swift.Equatable {
    /// A list of Config rule names.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of RemediationExecutionStatuses returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init (
        configRuleName: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

struct DescribeRemediationExecutionStatusInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceKeys: [ConfigClientTypes.ResourceKey]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRemediationExecutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationExecutionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationExecutionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRemediationExecutionStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationExecutionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRemediationExecutionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.remediationExecutionStatuses = output.remediationExecutionStatuses
        } else {
            self.nextToken = nil
            self.remediationExecutionStatuses = nil
        }
    }
}

public struct DescribeRemediationExecutionStatusOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of remediation execution statuses objects.
    public var remediationExecutionStatuses: [ConfigClientTypes.RemediationExecutionStatus]?

    public init (
        nextToken: Swift.String? = nil,
        remediationExecutionStatuses: [ConfigClientTypes.RemediationExecutionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExecutionStatuses = remediationExecutionStatuses
    }
}

struct DescribeRemediationExecutionStatusOutputResponseBody: Swift.Equatable {
    let remediationExecutionStatuses: [ConfigClientTypes.RemediationExecutionStatus]?
    let nextToken: Swift.String?
}

extension DescribeRemediationExecutionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case remediationExecutionStatuses = "RemediationExecutionStatuses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationExecutionStatusesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExecutionStatus?].self, forKey: .remediationExecutionStatuses)
        var remediationExecutionStatusesDecoded0:[ConfigClientTypes.RemediationExecutionStatus]? = nil
        if let remediationExecutionStatusesContainer = remediationExecutionStatusesContainer {
            remediationExecutionStatusesDecoded0 = [ConfigClientTypes.RemediationExecutionStatus]()
            for structure0 in remediationExecutionStatusesContainer {
                if let structure0 = structure0 {
                    remediationExecutionStatusesDecoded0?.append(structure0)
                }
            }
        }
        remediationExecutionStatuses = remediationExecutionStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRetentionConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurationNames = "RetentionConfigurationNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let retentionConfigurationNames = retentionConfigurationNames {
            var retentionConfigurationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retentionConfigurationNames)
            for retentionconfigurationname0 in retentionConfigurationNames {
                try retentionConfigurationNamesContainer.encode(retentionconfigurationname0)
            }
        }
    }
}

extension DescribeRetentionConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRetentionConfigurationsInput: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of names of retention configurations for which you want details. If you do not specify a name, Config returns details for all the retention configurations for that account. Currently, Config supports only one retention configuration per region in your account.
    public var retentionConfigurationNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        retentionConfigurationNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurationNames = retentionConfigurationNames
    }
}

struct DescribeRetentionConfigurationsInputBody: Swift.Equatable {
    let retentionConfigurationNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeRetentionConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurationNames = "RetentionConfigurationNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .retentionConfigurationNames)
        var retentionConfigurationNamesDecoded0:[Swift.String]? = nil
        if let retentionConfigurationNamesContainer = retentionConfigurationNamesContainer {
            retentionConfigurationNamesDecoded0 = [Swift.String]()
            for string0 in retentionConfigurationNamesContainer {
                if let string0 = string0 {
                    retentionConfigurationNamesDecoded0?.append(string0)
                }
            }
        }
        retentionConfigurationNames = retentionConfigurationNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRetentionConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRetentionConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRetentionConfigurationException" : self = .noSuchRetentionConfigurationException(try NoSuchRetentionConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRetentionConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRetentionConfigurationException(NoSuchRetentionConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRetentionConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRetentionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.retentionConfigurations = output.retentionConfigurations
        } else {
            self.nextToken = nil
            self.retentionConfigurations = nil
        }
    }
}

public struct DescribeRetentionConfigurationsOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a retention configuration object.
    public var retentionConfigurations: [ConfigClientTypes.RetentionConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        retentionConfigurations: [ConfigClientTypes.RetentionConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurations = retentionConfigurations
    }
}

struct DescribeRetentionConfigurationsOutputResponseBody: Swift.Equatable {
    let retentionConfigurations: [ConfigClientTypes.RetentionConfiguration]?
    let nextToken: Swift.String?
}

extension DescribeRetentionConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurations = "RetentionConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RetentionConfiguration?].self, forKey: .retentionConfigurations)
        var retentionConfigurationsDecoded0:[ConfigClientTypes.RetentionConfiguration]? = nil
        if let retentionConfigurationsContainer = retentionConfigurationsContainer {
            retentionConfigurationsDecoded0 = [ConfigClientTypes.RetentionConfiguration]()
            for structure0 in retentionConfigurationsContainer {
                if let structure0 = structure0 {
                    retentionConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        retentionConfigurations = retentionConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ConfigClientTypes.Evaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotation = "Annotation"
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceType = "ComplianceResourceType"
        case complianceType = "ComplianceType"
        case orderingTimestamp = "OrderingTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = self.annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceResourceId = self.complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceType = self.complianceResourceType {
            try encodeContainer.encode(complianceResourceType, forKey: .complianceResourceType)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let orderingTimestamp = self.orderingTimestamp {
            try encodeContainer.encodeTimestamp(orderingTimestamp, format: .epochSeconds, forKey: .orderingTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceResourceType)
        complianceResourceType = complianceResourceTypeDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .annotation)
        annotation = annotationDecoded
        let orderingTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
    }
}

extension ConfigClientTypes {
    /// Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.
    public struct Evaluation: Swift.Equatable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        /// This member is required.
        public var complianceResourceId: Swift.String?
        /// The type of Amazon Web Services resource that was evaluated.
        /// This member is required.
        public var complianceResourceType: Swift.String?
        /// Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against. For the Evaluation data type, Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. Config does not support the INSUFFICIENT_DATA value for this data type. Similarly, Config does not accept INSUFFICIENT_DATA as the value for ComplianceType from a PutEvaluations request. For example, an Lambda function for a custom Config rule cannot pass an INSUFFICIENT_DATA value to Config.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).
        /// This member is required.
        public var orderingTimestamp: ClientRuntime.Date?

        public init (
            annotation: Swift.String? = nil,
            complianceResourceId: Swift.String? = nil,
            complianceResourceType: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            orderingTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }
    }

}

extension ConfigClientTypes.EvaluationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationContextIdentifier = "EvaluationContextIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationContextIdentifier = self.evaluationContextIdentifier {
            try encodeContainer.encode(evaluationContextIdentifier, forKey: .evaluationContextIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationContextIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContextIdentifier)
        evaluationContextIdentifier = evaluationContextIdentifierDecoded
    }
}

extension ConfigClientTypes {
    /// Use EvaluationContext to group independently initiated proactive resource evaluations. For example, CFN Stack. If you want to check just a resource definition, you do not need to provide evaluation context.
    public struct EvaluationContext: Swift.Equatable {
        /// A unique EvaluationContextIdentifier ID for an EvaluationContext.
        public var evaluationContextIdentifier: Swift.String?

        public init (
            evaluationContextIdentifier: Swift.String? = nil
        )
        {
            self.evaluationContextIdentifier = evaluationContextIdentifier
        }
    }

}

extension ConfigClientTypes {
    public enum EvaluationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detective
        case proactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationMode] {
            return [
                .detective,
                .proactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detective: return "DETECTIVE"
            case .proactive: return "PROACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationMode(rawValue: rawValue) ?? EvaluationMode.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.EvaluationModeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension ConfigClientTypes {
    /// The configuration object for Config rule evaluation mode. The Supported valid values are Detective or Proactive.
    public struct EvaluationModeConfiguration: Swift.Equatable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var mode: ConfigClientTypes.EvaluationMode?

        public init (
            mode: ConfigClientTypes.EvaluationMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension ConfigClientTypes.EvaluationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotation = "Annotation"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
        case resultToken = "ResultToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = self.annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = self.configRuleInvokedTime {
            try encodeContainer.encodeTimestamp(configRuleInvokedTime, format: .epochSeconds, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = self.evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = self.resultRecordedTime {
            try encodeContainer.encodeTimestamp(resultRecordedTime, format: .epochSeconds, forKey: .resultRecordedTime)
        }
        if let resultToken = self.resultToken {
            try encodeContainer.encode(resultToken, forKey: .resultToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .annotation)
        annotation = annotationDecoded
        let resultTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultToken)
        resultToken = resultTokenDecoded
    }
}

extension ConfigClientTypes {
    /// The details of an Config evaluation. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information.
    public struct EvaluationResult: Swift.Equatable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it. For the EvaluationResult data type, Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. Config does not support the INSUFFICIENT_DATA value for the EvaluationResult data type.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services resource.
        public var configRuleInvokedTime: ClientRuntime.Date?
        /// Uniquely identifies the evaluation result.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the evaluation result.
        public var resultRecordedTime: ClientRuntime.Date?
        /// An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.
        public var resultToken: Swift.String?

        public init (
            annotation: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleInvokedTime: ClientRuntime.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: ClientRuntime.Date? = nil,
            resultToken: Swift.String? = nil
        )
        {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
            self.resultToken = resultToken
        }
    }

}

extension ConfigClientTypes.EvaluationResultIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResultQualifier = "EvaluationResultQualifier"
        case orderingTimestamp = "OrderingTimestamp"
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationResultQualifier = self.evaluationResultQualifier {
            try encodeContainer.encode(evaluationResultQualifier, forKey: .evaluationResultQualifier)
        }
        if let orderingTimestamp = self.orderingTimestamp {
            try encodeContainer.encodeTimestamp(orderingTimestamp, format: .epochSeconds, forKey: .orderingTimestamp)
        }
        if let resourceEvaluationId = self.resourceEvaluationId {
            try encodeContainer.encode(resourceEvaluationId, forKey: .resourceEvaluationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultQualifierDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationResultQualifier.self, forKey: .evaluationResultQualifier)
        evaluationResultQualifier = evaluationResultQualifierDecoded
        let orderingTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
    }
}

extension ConfigClientTypes {
    /// Uniquely identifies an evaluation result.
    public struct EvaluationResultIdentifier: Swift.Equatable {
        /// Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.
        public var evaluationResultQualifier: ConfigClientTypes.EvaluationResultQualifier?
        /// The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.
        public var orderingTimestamp: ClientRuntime.Date?
        /// A Unique ID for an evaluation result.
        public var resourceEvaluationId: Swift.String?

        public init (
            evaluationResultQualifier: ConfigClientTypes.EvaluationResultQualifier? = nil,
            orderingTimestamp: ClientRuntime.Date? = nil,
            resourceEvaluationId: Swift.String? = nil
        )
        {
            self.evaluationResultQualifier = evaluationResultQualifier
            self.orderingTimestamp = orderingTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }
    }

}

extension ConfigClientTypes.EvaluationResultQualifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case evaluationMode = "EvaluationMode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let evaluationMode = self.evaluationMode {
            try encodeContainer.encode(evaluationMode.rawValue, forKey: .evaluationMode)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
    }
}

extension ConfigClientTypes {
    /// Identifies an Config rule that evaluated an Amazon Web Services resource, and provides the type and ID of the resource that the rule evaluated.
    public struct EvaluationResultQualifier: Swift.Equatable {
        /// The name of the Config rule that was used in the evaluation.
        public var configRuleName: Swift.String?
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// The ID of the evaluated Amazon Web Services resource.
        public var resourceId: Swift.String?
        /// The type of Amazon Web Services resource that was evaluated.
        public var resourceType: Swift.String?

        public init (
            configRuleName: Swift.String? = nil,
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.configRuleName = configRuleName
            self.evaluationMode = evaluationMode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.EvaluationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceEvaluationStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ConfigClientTypes {
    /// Returns status details of an evaluation.
    public struct EvaluationStatus: Swift.Equatable {
        /// An explanation for failed execution status.
        public var failureReason: Swift.String?
        /// The status of an execution. The valid values are In_Progress, Succeeded or Failed.
        /// This member is required.
        public var status: ConfigClientTypes.ResourceEvaluationStatus?

        public init (
            failureReason: Swift.String? = nil,
            status: ConfigClientTypes.ResourceEvaluationStatus? = nil
        )
        {
            self.failureReason = failureReason
            self.status = status
        }
    }

}

extension ConfigClientTypes {
    public enum EventSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsConfig
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSource] {
            return [
                .awsConfig,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsConfig: return "aws.config"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSource(rawValue: rawValue) ?? EventSource.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ExecutionControls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssmControls = "SsmControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssmControls = self.ssmControls {
            try encodeContainer.encode(ssmControls, forKey: .ssmControls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmControlsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.SsmControls.self, forKey: .ssmControls)
        ssmControls = ssmControlsDecoded
    }
}

extension ConfigClientTypes {
    /// The controls that Config uses for executing remediations.
    public struct ExecutionControls: Swift.Equatable {
        /// A SsmControls object.
        public var ssmControls: ConfigClientTypes.SsmControls?

        public init (
            ssmControls: ConfigClientTypes.SsmControls? = nil
        )
        {
            self.ssmControls = ssmControls
        }
    }

}

extension ConfigClientTypes.ExternalEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotation = "Annotation"
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceType = "ComplianceResourceType"
        case complianceType = "ComplianceType"
        case orderingTimestamp = "OrderingTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = self.annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceResourceId = self.complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceType = self.complianceResourceType {
            try encodeContainer.encode(complianceResourceType, forKey: .complianceResourceType)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let orderingTimestamp = self.orderingTimestamp {
            try encodeContainer.encodeTimestamp(orderingTimestamp, format: .epochSeconds, forKey: .orderingTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceResourceType)
        complianceResourceType = complianceResourceTypeDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .annotation)
        annotation = annotationDecoded
        let orderingTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
    }
}

extension ConfigClientTypes {
    /// Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.
    public struct ExternalEvaluation: Swift.Equatable {
        /// Supplementary information about the reason of compliance. For example, this task was completed on a specific date.
        public var annotation: Swift.String?
        /// The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.
        /// This member is required.
        public var complianceResourceId: Swift.String?
        /// The evaluated compliance resource type. Config accepts AWS::::Account resource type.
        /// This member is required.
        public var complianceResourceType: Swift.String?
        /// The compliance of the Amazon Web Services resource. The valid values are COMPLIANT, NON_COMPLIANT,  and NOT_APPLICABLE.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the compliance was recorded.
        /// This member is required.
        public var orderingTimestamp: ClientRuntime.Date?

        public init (
            annotation: Swift.String? = nil,
            complianceResourceId: Swift.String? = nil,
            complianceResourceType: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            orderingTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }
    }

}

extension ConfigClientTypes.FailedDeleteRemediationExceptionsBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationexceptionresourcekey0 in failedItems {
                try failedItemsContainer.encode(remediationexceptionresourcekey0)
            }
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExceptionResourceKey?].self, forKey: .failedItems)
        var failedItemsDecoded0:[ConfigClientTypes.RemediationExceptionResourceKey]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [ConfigClientTypes.RemediationExceptionResourceKey]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension ConfigClientTypes {
    /// List of each of the failed delete remediation exceptions with specific reasons.
    public struct FailedDeleteRemediationExceptionsBatch: Swift.Equatable {
        /// Returns remediation exception resource key object of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationExceptionResourceKey]?
        /// Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.
        public var failureMessage: Swift.String?

        public init (
            failedItems: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }

}

extension ConfigClientTypes.FailedRemediationBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationconfiguration0 in failedItems {
                try failedItemsContainer.encode(remediationconfiguration0)
            }
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationConfiguration?].self, forKey: .failedItems)
        var failedItemsDecoded0:[ConfigClientTypes.RemediationConfiguration]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [ConfigClientTypes.RemediationConfiguration]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension ConfigClientTypes {
    /// List of each of the failed remediations with specific reasons.
    public struct FailedRemediationBatch: Swift.Equatable {
        /// Returns remediation configurations of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationConfiguration]?
        /// Returns a failure message. For example, the resource is already compliant.
        public var failureMessage: Swift.String?

        public init (
            failedItems: [ConfigClientTypes.RemediationConfiguration]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }

}

extension ConfigClientTypes.FailedRemediationExceptionBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationexception0 in failedItems {
                try failedItemsContainer.encode(remediationexception0)
            }
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationException?].self, forKey: .failedItems)
        var failedItemsDecoded0:[ConfigClientTypes.RemediationException]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [ConfigClientTypes.RemediationException]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension ConfigClientTypes {
    /// List of each of the failed remediation exceptions with specific reasons.
    public struct FailedRemediationExceptionBatch: Swift.Equatable {
        /// Returns remediation exception resource key object of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationException]?
        /// Returns a failure message. For example, the auto-remediation has failed.
        public var failureMessage: Swift.String?

        public init (
            failedItems: [ConfigClientTypes.RemediationException]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }

}

extension ConfigClientTypes.FieldInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConfigClientTypes {
    /// Details about the fields such as name of the field.
    public struct FieldInfo: Swift.Equatable {
        /// Name of the field.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension GetAggregateComplianceDetailsByConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetAggregateComplianceDetailsByConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleInput: Swift.Equatable {
    /// The 12-digit account ID of the source account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The source region from where the data is aggregated.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// The resource compliance status. For the GetAggregateComplianceDetailsByConfigRuleRequest data type, Config supports only the COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA values.
    public var complianceType: ConfigClientTypes.ComplianceType?
    /// The name of the Config rule for which you want compliance information.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The maximum number of evaluation results returned on each page. The default is 50. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        complianceType: ConfigClientTypes.ComplianceType? = nil,
        configRuleName: Swift.String? = nil,
        configurationAggregatorName: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.configRuleName = configRuleName
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateComplianceDetailsByConfigRuleInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let configRuleName: Swift.String?
    let accountId: Swift.String?
    let awsRegion: Swift.String?
    let complianceType: ConfigClientTypes.ComplianceType?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetAggregateComplianceDetailsByConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateComplianceDetailsByConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateComplianceDetailsByConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAggregateComplianceDetailsByConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateComplianceDetailsByConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAggregateComplianceDetailsByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregateEvaluationResults = output.aggregateEvaluationResults
            self.nextToken = output.nextToken
        } else {
            self.aggregateEvaluationResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleOutputResponse: Swift.Equatable {
    /// Returns an AggregateEvaluationResults object.
    public var aggregateEvaluationResults: [ConfigClientTypes.AggregateEvaluationResult]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregateEvaluationResults: [ConfigClientTypes.AggregateEvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateEvaluationResults = aggregateEvaluationResults
        self.nextToken = nextToken
    }
}

struct GetAggregateComplianceDetailsByConfigRuleOutputResponseBody: Swift.Equatable {
    let aggregateEvaluationResults: [ConfigClientTypes.AggregateEvaluationResult]?
    let nextToken: Swift.String?
}

extension GetAggregateComplianceDetailsByConfigRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateEvaluationResults = "AggregateEvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateEvaluationResultsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateEvaluationResult?].self, forKey: .aggregateEvaluationResults)
        var aggregateEvaluationResultsDecoded0:[ConfigClientTypes.AggregateEvaluationResult]? = nil
        if let aggregateEvaluationResultsContainer = aggregateEvaluationResultsContainer {
            aggregateEvaluationResultsDecoded0 = [ConfigClientTypes.AggregateEvaluationResult]()
            for structure0 in aggregateEvaluationResultsContainer {
                if let structure0 = structure0 {
                    aggregateEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        aggregateEvaluationResults = aggregateEvaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConfigRuleComplianceSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = self.groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetAggregateConfigRuleComplianceSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAggregateConfigRuleComplianceSummaryInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ConfigRuleComplianceSummaryFilters object.
    public var filters: ConfigClientTypes.ConfigRuleComplianceSummaryFilters?
    /// Groups the result based on ACCOUNT_ID or AWS_REGION.
    public var groupByKey: ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey?
    /// The maximum number of evaluation results returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ConfigRuleComplianceSummaryFilters? = nil,
        groupByKey: ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateConfigRuleComplianceSummaryInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let filters: ConfigClientTypes.ConfigRuleComplianceSummaryFilters?
    let groupByKey: ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetAggregateConfigRuleComplianceSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigRuleComplianceSummaryFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConfigRuleComplianceSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateConfigRuleComplianceSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAggregateConfigRuleComplianceSummaryOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateConfigRuleComplianceSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAggregateConfigRuleComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregateComplianceCounts = output.aggregateComplianceCounts
            self.groupByKey = output.groupByKey
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceCounts = nil
            self.groupByKey = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateConfigRuleComplianceSummaryOutputResponse: Swift.Equatable {
    /// Returns a list of AggregateComplianceCounts object.
    public var aggregateComplianceCounts: [ConfigClientTypes.AggregateComplianceCount]?
    /// Groups the result based on ACCOUNT_ID or AWS_REGION.
    public var groupByKey: Swift.String?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregateComplianceCounts: [ConfigClientTypes.AggregateComplianceCount]? = nil,
        groupByKey: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceCounts = aggregateComplianceCounts
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

struct GetAggregateConfigRuleComplianceSummaryOutputResponseBody: Swift.Equatable {
    let groupByKey: Swift.String?
    let aggregateComplianceCounts: [ConfigClientTypes.AggregateComplianceCount]?
    let nextToken: Swift.String?
}

extension GetAggregateConfigRuleComplianceSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateComplianceCounts = "AggregateComplianceCounts"
        case groupByKey = "GroupByKey"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let aggregateComplianceCountsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateComplianceCount?].self, forKey: .aggregateComplianceCounts)
        var aggregateComplianceCountsDecoded0:[ConfigClientTypes.AggregateComplianceCount]? = nil
        if let aggregateComplianceCountsContainer = aggregateComplianceCountsContainer {
            aggregateComplianceCountsDecoded0 = [ConfigClientTypes.AggregateComplianceCount]()
            for structure0 in aggregateComplianceCountsContainer {
                if let structure0 = structure0 {
                    aggregateComplianceCountsDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceCounts = aggregateComplianceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConformancePackComplianceSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = self.groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetAggregateConformancePackComplianceSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAggregateConformancePackComplianceSummaryInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the AggregateConformancePackComplianceSummaryFilters object.
    public var filters: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters?
    /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
    public var groupByKey: ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey?
    /// The maximum number of results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters? = nil,
        groupByKey: ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateConformancePackComplianceSummaryInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let filters: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters?
    let groupByKey: ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetAggregateConformancePackComplianceSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConformancePackComplianceSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateConformancePackComplianceSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAggregateConformancePackComplianceSummaryOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateConformancePackComplianceSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAggregateConformancePackComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregateConformancePackComplianceSummaries = output.aggregateConformancePackComplianceSummaries
            self.groupByKey = output.groupByKey
            self.nextToken = output.nextToken
        } else {
            self.aggregateConformancePackComplianceSummaries = nil
            self.groupByKey = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateConformancePackComplianceSummaryOutputResponse: Swift.Equatable {
    /// Returns a list of AggregateConformancePackComplianceSummary object.
    public var aggregateConformancePackComplianceSummaries: [ConfigClientTypes.AggregateConformancePackComplianceSummary]?
    /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
    public var groupByKey: Swift.String?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        aggregateConformancePackComplianceSummaries: [ConfigClientTypes.AggregateConformancePackComplianceSummary]? = nil,
        groupByKey: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummaries
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

struct GetAggregateConformancePackComplianceSummaryOutputResponseBody: Swift.Equatable {
    let aggregateConformancePackComplianceSummaries: [ConfigClientTypes.AggregateConformancePackComplianceSummary]?
    let groupByKey: Swift.String?
    let nextToken: Swift.String?
}

extension GetAggregateConformancePackComplianceSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateConformancePackComplianceSummaries = "AggregateConformancePackComplianceSummaries"
        case groupByKey = "GroupByKey"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateConformancePackComplianceSummariesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateConformancePackComplianceSummary?].self, forKey: .aggregateConformancePackComplianceSummaries)
        var aggregateConformancePackComplianceSummariesDecoded0:[ConfigClientTypes.AggregateConformancePackComplianceSummary]? = nil
        if let aggregateConformancePackComplianceSummariesContainer = aggregateConformancePackComplianceSummariesContainer {
            aggregateConformancePackComplianceSummariesDecoded0 = [ConfigClientTypes.AggregateConformancePackComplianceSummary]()
            for structure0 in aggregateConformancePackComplianceSummariesContainer {
                if let structure0 = structure0 {
                    aggregateConformancePackComplianceSummariesDecoded0?.append(structure0)
                }
            }
        }
        aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummariesDecoded0
        let groupByKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateDiscoveredResourceCountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = self.groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetAggregateDiscoveredResourceCountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAggregateDiscoveredResourceCountsInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ResourceCountFilters object.
    public var filters: ConfigClientTypes.ResourceCountFilters?
    /// The key to group the resource counts.
    public var groupByKey: ConfigClientTypes.ResourceCountGroupKey?
    /// The maximum number of [GroupedResourceCount] objects returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ResourceCountFilters? = nil,
        groupByKey: ConfigClientTypes.ResourceCountGroupKey? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateDiscoveredResourceCountsInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let filters: ConfigClientTypes.ResourceCountFilters?
    let groupByKey: ConfigClientTypes.ResourceCountGroupKey?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetAggregateDiscoveredResourceCountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceCountFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceCountGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateDiscoveredResourceCountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateDiscoveredResourceCountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAggregateDiscoveredResourceCountsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateDiscoveredResourceCountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAggregateDiscoveredResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupByKey = output.groupByKey
            self.groupedResourceCounts = output.groupedResourceCounts
            self.nextToken = output.nextToken
            self.totalDiscoveredResources = output.totalDiscoveredResources
        } else {
            self.groupByKey = nil
            self.groupedResourceCounts = nil
            self.nextToken = nil
            self.totalDiscoveredResources = 0
        }
    }
}

public struct GetAggregateDiscoveredResourceCountsOutputResponse: Swift.Equatable {
    /// The key passed into the request object. If GroupByKey is not provided, the result will be empty.
    public var groupByKey: Swift.String?
    /// Returns a list of GroupedResourceCount objects.
    public var groupedResourceCounts: [ConfigClientTypes.GroupedResourceCount]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The total number of resources that are present in an aggregator with the filters that you provide.
    /// This member is required.
    public var totalDiscoveredResources: Swift.Int

    public init (
        groupByKey: Swift.String? = nil,
        groupedResourceCounts: [ConfigClientTypes.GroupedResourceCount]? = nil,
        nextToken: Swift.String? = nil,
        totalDiscoveredResources: Swift.Int = 0
    )
    {
        self.groupByKey = groupByKey
        self.groupedResourceCounts = groupedResourceCounts
        self.nextToken = nextToken
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

struct GetAggregateDiscoveredResourceCountsOutputResponseBody: Swift.Equatable {
    let totalDiscoveredResources: Swift.Int
    let groupByKey: Swift.String?
    let groupedResourceCounts: [ConfigClientTypes.GroupedResourceCount]?
    let nextToken: Swift.String?
}

extension GetAggregateDiscoveredResourceCountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupByKey = "GroupByKey"
        case groupedResourceCounts = "GroupedResourceCounts"
        case nextToken = "NextToken"
        case totalDiscoveredResources = "TotalDiscoveredResources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDiscoveredResourcesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDiscoveredResources) ?? 0
        totalDiscoveredResources = totalDiscoveredResourcesDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let groupedResourceCountsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.GroupedResourceCount?].self, forKey: .groupedResourceCounts)
        var groupedResourceCountsDecoded0:[ConfigClientTypes.GroupedResourceCount]? = nil
        if let groupedResourceCountsContainer = groupedResourceCountsContainer {
            groupedResourceCountsDecoded0 = [ConfigClientTypes.GroupedResourceCount]()
            for structure0 in groupedResourceCountsContainer {
                if let structure0 = structure0 {
                    groupedResourceCountsDecoded0?.append(structure0)
                }
            }
        }
        groupedResourceCounts = groupedResourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension GetAggregateResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAggregateResourceConfigInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// An object that identifies aggregate resource.
    /// This member is required.
    public var resourceIdentifier: ConfigClientTypes.AggregateResourceIdentifier?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        resourceIdentifier: ConfigClientTypes.AggregateResourceIdentifier? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetAggregateResourceConfigInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let resourceIdentifier: ConfigClientTypes.AggregateResourceIdentifier?
}

extension GetAggregateResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregateResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension GetAggregateResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OversizedConfigurationItemException" : self = .oversizedConfigurationItemException(try OversizedConfigurationItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotDiscoveredException" : self = .resourceNotDiscoveredException(try ResourceNotDiscoveredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAggregateResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case oversizedConfigurationItemException(OversizedConfigurationItemException)
    case resourceNotDiscoveredException(ResourceNotDiscoveredException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationItem = output.configurationItem
        } else {
            self.configurationItem = nil
        }
    }
}

public struct GetAggregateResourceConfigOutputResponse: Swift.Equatable {
    /// Returns a ConfigurationItem object.
    public var configurationItem: ConfigClientTypes.ConfigurationItem?

    public init (
        configurationItem: ConfigClientTypes.ConfigurationItem? = nil
    )
    {
        self.configurationItem = configurationItem
    }
}

struct GetAggregateResourceConfigOutputResponseBody: Swift.Equatable {
    let configurationItem: ConfigClientTypes.ConfigurationItem?
}

extension GetAggregateResourceConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationItem = "ConfigurationItem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationItemDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigurationItem.self, forKey: .configurationItem)
        configurationItem = configurationItemDecoded
    }
}

extension GetComplianceDetailsByConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetype0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetype0.rawValue)
            }
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetComplianceDetailsByConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct GetComplianceDetailsByConfigRuleInput: Swift.Equatable {
    /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The name of the Config rule for which you want compliance information.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        configRuleName: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByConfigRuleInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let complianceTypes: [ConfigClientTypes.ComplianceType]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetComplianceDetailsByConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ConfigClientTypes.ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ConfigClientTypes.ComplianceType]()
            for enum0 in complianceTypesContainer {
                if let enum0 = enum0 {
                    complianceTypesDecoded0?.append(enum0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceDetailsByConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailsByConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComplianceDetailsByConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailsByConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComplianceDetailsByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.nextToken = output.nextToken
        } else {
            self.evaluationResults = nil
            self.nextToken = nil
        }
    }
}

///
public struct GetComplianceDetailsByConfigRuleOutputResponse: Swift.Equatable {
    /// Indicates whether the Amazon Web Services resource complies with the specified Config rule.
    public var evaluationResults: [ConfigClientTypes.EvaluationResult]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        evaluationResults: [ConfigClientTypes.EvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByConfigRuleOutputResponseBody: Swift.Equatable {
    let evaluationResults: [ConfigClientTypes.EvaluationResult]?
    let nextToken: Swift.String?
}

extension GetComplianceDetailsByConfigRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[ConfigClientTypes.EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [ConfigClientTypes.EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceDetailsByResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case nextToken = "NextToken"
        case resourceEvaluationId = "ResourceEvaluationId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetype0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetype0.rawValue)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceEvaluationId = self.resourceEvaluationId {
            try encodeContainer.encode(resourceEvaluationId, forKey: .resourceEvaluationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension GetComplianceDetailsByResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct GetComplianceDetailsByResourceInput: Swift.Equatable {
    /// Filters the results by compliance. The allowed values are COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The unique ID of Amazon Web Services resource execution for which you want to retrieve evaluation results. You need to only provide either a ResourceEvaluationID or a ResourceID and ResourceType.
    public var resourceEvaluationId: Swift.String?
    /// The ID of the Amazon Web Services resource for which you want compliance information.
    public var resourceId: Swift.String?
    /// The type of the Amazon Web Services resource for which you want compliance information.
    public var resourceType: Swift.String?

    public init (
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        nextToken: Swift.String? = nil,
        resourceEvaluationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.nextToken = nextToken
        self.resourceEvaluationId = resourceEvaluationId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetComplianceDetailsByResourceInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let resourceId: Swift.String?
    let complianceTypes: [ConfigClientTypes.ComplianceType]?
    let nextToken: Swift.String?
    let resourceEvaluationId: Swift.String?
}

extension GetComplianceDetailsByResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceTypes = "ComplianceTypes"
        case nextToken = "NextToken"
        case resourceEvaluationId = "ResourceEvaluationId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ConfigClientTypes.ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ConfigClientTypes.ComplianceType]()
            for enum0 in complianceTypesContainer {
                if let enum0 = enum0 {
                    complianceTypesDecoded0?.append(enum0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
    }
}

extension GetComplianceDetailsByResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailsByResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComplianceDetailsByResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailsByResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComplianceDetailsByResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evaluationResults = output.evaluationResults
            self.nextToken = output.nextToken
        } else {
            self.evaluationResults = nil
            self.nextToken = nil
        }
    }
}

///
public struct GetComplianceDetailsByResourceOutputResponse: Swift.Equatable {
    /// Indicates whether the specified Amazon Web Services resource complies each Config rule.
    public var evaluationResults: [ConfigClientTypes.EvaluationResult]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        evaluationResults: [ConfigClientTypes.EvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByResourceOutputResponseBody: Swift.Equatable {
    let evaluationResults: [ConfigClientTypes.EvaluationResult]?
    let nextToken: Swift.String?
}

extension GetComplianceDetailsByResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationResults = "EvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[ConfigClientTypes.EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [ConfigClientTypes.EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceSummaryByConfigRuleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetComplianceSummaryByConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetComplianceSummaryByConfigRuleInput: Swift.Equatable {

    public init () { }
}

struct GetComplianceSummaryByConfigRuleInputBody: Swift.Equatable {
}

extension GetComplianceSummaryByConfigRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComplianceSummaryByConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceSummaryByConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComplianceSummaryByConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceSummaryByConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComplianceSummaryByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceSummary = output.complianceSummary
        } else {
            self.complianceSummary = nil
        }
    }
}

///
public struct GetComplianceSummaryByConfigRuleOutputResponse: Swift.Equatable {
    /// The number of Config rules that are compliant and the number that are noncompliant, up to a maximum of 25 for each.
    public var complianceSummary: ConfigClientTypes.ComplianceSummary?

    public init (
        complianceSummary: ConfigClientTypes.ComplianceSummary? = nil
    )
    {
        self.complianceSummary = complianceSummary
    }
}

struct GetComplianceSummaryByConfigRuleOutputResponseBody: Swift.Equatable {
    let complianceSummary: ConfigClientTypes.ComplianceSummary?
}

extension GetComplianceSummaryByConfigRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummary = "ComplianceSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension GetComplianceSummaryByResourceTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for stringwithcharlimit2560 in resourceTypes {
                try resourceTypesContainer.encode(stringwithcharlimit2560)
            }
        }
    }
}

extension GetComplianceSummaryByResourceTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct GetComplianceSummaryByResourceTypeInput: Swift.Equatable {
    /// Specify one or more resource types to get the number of resources that are compliant and the number that are noncompliant for each resource type. For this request, you can specify an Amazon Web Services resource type such as AWS::EC2::Instance. You can specify that the resource type is an Amazon Web Services account by specifying AWS::::Account.
    public var resourceTypes: [Swift.String]?

    public init (
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetComplianceSummaryByResourceTypeInputBody: Swift.Equatable {
    let resourceTypes: [Swift.String]?
}

extension GetComplianceSummaryByResourceTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension GetComplianceSummaryByResourceTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceSummaryByResourceTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComplianceSummaryByResourceTypeOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceSummaryByResourceTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComplianceSummaryByResourceTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.complianceSummariesByResourceType = output.complianceSummariesByResourceType
        } else {
            self.complianceSummariesByResourceType = nil
        }
    }
}

///
public struct GetComplianceSummaryByResourceTypeOutputResponse: Swift.Equatable {
    /// The number of resources that are compliant and the number that are noncompliant. If one or more resource types were provided with the request, the numbers are returned for each resource type. The maximum number returned is 100.
    public var complianceSummariesByResourceType: [ConfigClientTypes.ComplianceSummaryByResourceType]?

    public init (
        complianceSummariesByResourceType: [ConfigClientTypes.ComplianceSummaryByResourceType]? = nil
    )
    {
        self.complianceSummariesByResourceType = complianceSummariesByResourceType
    }
}

struct GetComplianceSummaryByResourceTypeOutputResponseBody: Swift.Equatable {
    let complianceSummariesByResourceType: [ConfigClientTypes.ComplianceSummaryByResourceType]?
}

extension GetComplianceSummaryByResourceTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummariesByResourceType = "ComplianceSummariesByResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummariesByResourceTypeContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ComplianceSummaryByResourceType?].self, forKey: .complianceSummariesByResourceType)
        var complianceSummariesByResourceTypeDecoded0:[ConfigClientTypes.ComplianceSummaryByResourceType]? = nil
        if let complianceSummariesByResourceTypeContainer = complianceSummariesByResourceTypeContainer {
            complianceSummariesByResourceTypeDecoded0 = [ConfigClientTypes.ComplianceSummaryByResourceType]()
            for structure0 in complianceSummariesByResourceTypeContainer {
                if let structure0 = structure0 {
                    complianceSummariesByResourceTypeDecoded0?.append(structure0)
                }
            }
        }
        complianceSummariesByResourceType = complianceSummariesByResourceTypeDecoded0
    }
}

extension GetConformancePackComplianceDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetConformancePackComplianceDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConformancePackComplianceDetailsInput: Swift.Equatable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// A ConformancePackEvaluationFilters object.
    public var filters: ConfigClientTypes.ConformancePackEvaluationFilters?
    /// The maximum number of evaluation results returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackName: Swift.String? = nil,
        filters: ConfigClientTypes.ConformancePackEvaluationFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceDetailsInputBody: Swift.Equatable {
    let conformancePackName: Swift.String?
    let filters: ConfigClientTypes.ConformancePackEvaluationFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetConformancePackComplianceDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackEvaluationFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConformancePackComplianceDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConformancePackComplianceDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleInConformancePackException" : self = .noSuchConfigRuleInConformancePackException(try NoSuchConfigRuleInConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConformancePackComplianceDetailsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleInConformancePackException(NoSuchConfigRuleInConformancePackException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConformancePackComplianceDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConformancePackComplianceDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackName = output.conformancePackName
            self.conformancePackRuleEvaluationResults = output.conformancePackRuleEvaluationResults
            self.nextToken = output.nextToken
        } else {
            self.conformancePackName = nil
            self.conformancePackRuleEvaluationResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetConformancePackComplianceDetailsOutputResponse: Swift.Equatable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// Returns a list of ConformancePackEvaluationResult objects.
    public var conformancePackRuleEvaluationResults: [ConfigClientTypes.ConformancePackEvaluationResult]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackName: Swift.String? = nil,
        conformancePackRuleEvaluationResults: [ConfigClientTypes.ConformancePackEvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResults
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceDetailsOutputResponseBody: Swift.Equatable {
    let conformancePackName: Swift.String?
    let conformancePackRuleEvaluationResults: [ConfigClientTypes.ConformancePackEvaluationResult]?
    let nextToken: Swift.String?
}

extension GetConformancePackComplianceDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackName = "ConformancePackName"
        case conformancePackRuleEvaluationResults = "ConformancePackRuleEvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackRuleEvaluationResultsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackEvaluationResult?].self, forKey: .conformancePackRuleEvaluationResults)
        var conformancePackRuleEvaluationResultsDecoded0:[ConfigClientTypes.ConformancePackEvaluationResult]? = nil
        if let conformancePackRuleEvaluationResultsContainer = conformancePackRuleEvaluationResultsContainer {
            conformancePackRuleEvaluationResultsDecoded0 = [ConfigClientTypes.ConformancePackEvaluationResult]()
            for structure0 in conformancePackRuleEvaluationResultsContainer {
                if let structure0 = structure0 {
                    conformancePackRuleEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConformancePackComplianceSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepackname0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepackname0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetConformancePackComplianceSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConformancePackComplianceSummaryInput: Swift.Equatable {
    /// Names of conformance packs.
    /// This member is required.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs returned on each page.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceSummaryInputBody: Swift.Equatable {
    let conformancePackNames: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetConformancePackComplianceSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[Swift.String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [Swift.String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConformancePackComplianceSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConformancePackComplianceSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConformancePackComplianceSummaryOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConformancePackComplianceSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConformancePackComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackComplianceSummaryList = output.conformancePackComplianceSummaryList
            self.nextToken = output.nextToken
        } else {
            self.conformancePackComplianceSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct GetConformancePackComplianceSummaryOutputResponse: Swift.Equatable {
    /// A list of ConformancePackComplianceSummary objects.
    public var conformancePackComplianceSummaryList: [ConfigClientTypes.ConformancePackComplianceSummary]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackComplianceSummaryList: [ConfigClientTypes.ConformancePackComplianceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackComplianceSummaryList = conformancePackComplianceSummaryList
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceSummaryOutputResponseBody: Swift.Equatable {
    let conformancePackComplianceSummaryList: [ConfigClientTypes.ConformancePackComplianceSummary]?
    let nextToken: Swift.String?
}

extension GetConformancePackComplianceSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackComplianceSummaryList = "ConformancePackComplianceSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackComplianceSummaryListContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackComplianceSummary?].self, forKey: .conformancePackComplianceSummaryList)
        var conformancePackComplianceSummaryListDecoded0:[ConfigClientTypes.ConformancePackComplianceSummary]? = nil
        if let conformancePackComplianceSummaryListContainer = conformancePackComplianceSummaryListContainer {
            conformancePackComplianceSummaryListDecoded0 = [ConfigClientTypes.ConformancePackComplianceSummary]()
            for structure0 in conformancePackComplianceSummaryListContainer {
                if let structure0 = structure0 {
                    conformancePackComplianceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        conformancePackComplianceSummaryList = conformancePackComplianceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCustomRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }
}

extension GetCustomRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCustomRulePolicyInput: Swift.Equatable {
    /// The name of your Config Custom Policy rule.
    public var configRuleName: Swift.String?

    public init (
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

struct GetCustomRulePolicyInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
}

extension GetCustomRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
    }
}

extension GetCustomRulePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomRulePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCustomRulePolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomRulePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCustomRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
        } else {
            self.policyText = nil
        }
    }
}

public struct GetCustomRulePolicyOutputResponse: Swift.Equatable {
    /// The policy definition containing the logic for your Config Custom Policy rule.
    public var policyText: Swift.String?

    public init (
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

struct GetCustomRulePolicyOutputResponseBody: Swift.Equatable {
    let policyText: Swift.String?
}

extension GetCustomRulePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText = "PolicyText"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension GetDiscoveredResourceCountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case nextToken
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for stringwithcharlimit2560 in resourceTypes {
                try resourceTypesContainer.encode(stringwithcharlimit2560)
            }
        }
    }
}

extension GetDiscoveredResourceCountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDiscoveredResourceCountsInput: Swift.Equatable {
    /// The maximum number of [ResourceCount] objects returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The comma-separated list that specifies the resource types that you want Config to return (for example, "AWS::EC2::Instance", "AWS::IAM::User"). If a value for resourceTypes is not specified, Config returns all resource types that Config is recording in the region for your account. If the configuration recorder is turned off, Config returns an empty list of [ResourceCount] objects. If the configuration recorder is not recording a specific resource type (for example, S3 buckets), that resource type is not returned in the list of [ResourceCount] objects.
    public var resourceTypes: [Swift.String]?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct GetDiscoveredResourceCountsInputBody: Swift.Equatable {
    let resourceTypes: [Swift.String]?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetDiscoveredResourceCountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDiscoveredResourceCountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoveredResourceCountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDiscoveredResourceCountsOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoveredResourceCountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDiscoveredResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceCounts = output.resourceCounts
            self.totalDiscoveredResources = output.totalDiscoveredResources
        } else {
            self.nextToken = nil
            self.resourceCounts = nil
            self.totalDiscoveredResources = 0
        }
    }
}

public struct GetDiscoveredResourceCountsOutputResponse: Swift.Equatable {
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The list of ResourceCount objects. Each object is listed in descending order by the number of resources.
    public var resourceCounts: [ConfigClientTypes.ResourceCount]?
    /// The total number of resources that Config is recording in the region for your account. If you specify resource types in the request, Config returns only the total number of resources for those resource types. Example
    ///
    /// * Config is recording three resource types in the US East (Ohio) Region for your account: 25 EC2 instances, 20 IAM users, and 15 S3 buckets, for a total of 60 resources.
    ///
    /// * You make a call to the GetDiscoveredResourceCounts action and specify the resource type, "AWS::EC2::Instances", in the request.
    ///
    /// * Config returns 25 for totalDiscoveredResources.
    public var totalDiscoveredResources: Swift.Int

    public init (
        nextToken: Swift.String? = nil,
        resourceCounts: [ConfigClientTypes.ResourceCount]? = nil,
        totalDiscoveredResources: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resourceCounts = resourceCounts
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

struct GetDiscoveredResourceCountsOutputResponseBody: Swift.Equatable {
    let totalDiscoveredResources: Swift.Int
    let resourceCounts: [ConfigClientTypes.ResourceCount]?
    let nextToken: Swift.String?
}

extension GetDiscoveredResourceCountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceCounts
        case totalDiscoveredResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDiscoveredResourcesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDiscoveredResources) ?? 0
        totalDiscoveredResources = totalDiscoveredResourcesDecoded
        let resourceCountsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceCount?].self, forKey: .resourceCounts)
        var resourceCountsDecoded0:[ConfigClientTypes.ResourceCount]? = nil
        if let resourceCountsContainer = resourceCountsContainer {
            resourceCountsDecoded0 = [ConfigClientTypes.ResourceCount]()
            for structure0 in resourceCountsContainer {
                if let structure0 = structure0 {
                    resourceCountsDecoded0?.append(structure0)
                }
            }
        }
        resourceCounts = resourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConfigRuleDetailedStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
    }
}

extension GetOrganizationConfigRuleDetailedStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOrganizationConfigRuleDetailedStatusInput: Swift.Equatable {
    /// A StatusDetailFilters object.
    public var filters: ConfigClientTypes.StatusDetailFilters?
    /// The maximum number of OrganizationConfigRuleDetailedStatus returned on each page. If you do not specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name of your organization Config rule for which you want status details for member accounts.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init (
        filters: ConfigClientTypes.StatusDetailFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

struct GetOrganizationConfigRuleDetailedStatusInputBody: Swift.Equatable {
    let organizationConfigRuleName: Swift.String?
    let filters: ConfigClientTypes.StatusDetailFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetOrganizationConfigRuleDetailedStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.StatusDetailFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConfigRuleDetailedStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationConfigRuleDetailedStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrganizationConfigRuleDetailedStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationConfigRuleDetailedStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrganizationConfigRuleDetailedStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConfigRuleDetailedStatus = output.organizationConfigRuleDetailedStatus
        } else {
            self.nextToken = nil
            self.organizationConfigRuleDetailedStatus = nil
        }
    }
}

public struct GetOrganizationConfigRuleDetailedStatusOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of MemberAccountStatus objects.
    public var organizationConfigRuleDetailedStatus: [ConfigClientTypes.MemberAccountStatus]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConfigRuleDetailedStatus: [ConfigClientTypes.MemberAccountStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatus
    }
}

struct GetOrganizationConfigRuleDetailedStatusOutputResponseBody: Swift.Equatable {
    let organizationConfigRuleDetailedStatus: [ConfigClientTypes.MemberAccountStatus]?
    let nextToken: Swift.String?
}

extension GetOrganizationConfigRuleDetailedStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRuleDetailedStatus = "OrganizationConfigRuleDetailedStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleDetailedStatusContainer = try containerValues.decodeIfPresent([ConfigClientTypes.MemberAccountStatus?].self, forKey: .organizationConfigRuleDetailedStatus)
        var organizationConfigRuleDetailedStatusDecoded0:[ConfigClientTypes.MemberAccountStatus]? = nil
        if let organizationConfigRuleDetailedStatusContainer = organizationConfigRuleDetailedStatusContainer {
            organizationConfigRuleDetailedStatusDecoded0 = [ConfigClientTypes.MemberAccountStatus]()
            for structure0 in organizationConfigRuleDetailedStatusContainer {
                if let structure0 = structure0 {
                    organizationConfigRuleDetailedStatusDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConformancePackDetailedStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackName = self.organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }
}

extension GetOrganizationConformancePackDetailedStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOrganizationConformancePackDetailedStatusInput: Swift.Equatable {
    /// An OrganizationResourceDetailedStatusFilters object.
    public var filters: ConfigClientTypes.OrganizationResourceDetailedStatusFilters?
    /// The maximum number of OrganizationConformancePackDetailedStatuses returned on each page. If you do not specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name of organization conformance pack for which you want status details for member accounts.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?

    public init (
        filters: ConfigClientTypes.OrganizationResourceDetailedStatusFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackName = organizationConformancePackName
    }
}

struct GetOrganizationConformancePackDetailedStatusInputBody: Swift.Equatable {
    let organizationConformancePackName: Swift.String?
    let filters: ConfigClientTypes.OrganizationResourceDetailedStatusFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetOrganizationConformancePackDetailedStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationResourceDetailedStatusFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConformancePackDetailedStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationConformancePackDetailedStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrganizationConformancePackDetailedStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationConformancePackDetailedStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrganizationConformancePackDetailedStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationConformancePackDetailedStatuses = output.organizationConformancePackDetailedStatuses
        } else {
            self.nextToken = nil
            self.organizationConformancePackDetailedStatuses = nil
        }
    }
}

public struct GetOrganizationConformancePackDetailedStatusOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConformancePackDetailedStatus objects.
    public var organizationConformancePackDetailedStatuses: [ConfigClientTypes.OrganizationConformancePackDetailedStatus]?

    public init (
        nextToken: Swift.String? = nil,
        organizationConformancePackDetailedStatuses: [ConfigClientTypes.OrganizationConformancePackDetailedStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatuses
    }
}

struct GetOrganizationConformancePackDetailedStatusOutputResponseBody: Swift.Equatable {
    let organizationConformancePackDetailedStatuses: [ConfigClientTypes.OrganizationConformancePackDetailedStatus]?
    let nextToken: Swift.String?
}

extension GetOrganizationConformancePackDetailedStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePackDetailedStatuses = "OrganizationConformancePackDetailedStatuses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackDetailedStatusesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConformancePackDetailedStatus?].self, forKey: .organizationConformancePackDetailedStatuses)
        var organizationConformancePackDetailedStatusesDecoded0:[ConfigClientTypes.OrganizationConformancePackDetailedStatus]? = nil
        if let organizationConformancePackDetailedStatusesContainer = organizationConformancePackDetailedStatusesContainer {
            organizationConformancePackDetailedStatusesDecoded0 = [ConfigClientTypes.OrganizationConformancePackDetailedStatus]()
            for structure0 in organizationConformancePackDetailedStatusesContainer {
                if let structure0 = structure0 {
                    organizationConformancePackDetailedStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationCustomRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
    }
}

extension GetOrganizationCustomRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOrganizationCustomRulePolicyInput: Swift.Equatable {
    /// The name of your organization Config Custom Policy rule.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init (
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

struct GetOrganizationCustomRulePolicyInputBody: Swift.Equatable {
    let organizationConfigRuleName: Swift.String?
}

extension GetOrganizationCustomRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
    }
}

extension GetOrganizationCustomRulePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationCustomRulePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrganizationCustomRulePolicyOutputError: Swift.Error, Swift.Equatable {
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationCustomRulePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrganizationCustomRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
        } else {
            self.policyText = nil
        }
    }
}

public struct GetOrganizationCustomRulePolicyOutputResponse: Swift.Equatable {
    /// The policy definition containing the logic for your organization Config Custom Policy rule.
    public var policyText: Swift.String?

    public init (
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

struct GetOrganizationCustomRulePolicyOutputResponseBody: Swift.Equatable {
    let policyText: Swift.String?
}

extension GetOrganizationCustomRulePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText = "PolicyText"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension GetResourceConfigHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chronologicalOrder
        case earlierTime
        case laterTime
        case limit
        case nextToken
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chronologicalOrder = self.chronologicalOrder {
            try encodeContainer.encode(chronologicalOrder.rawValue, forKey: .chronologicalOrder)
        }
        if let earlierTime = self.earlierTime {
            try encodeContainer.encodeTimestamp(earlierTime, format: .epochSeconds, forKey: .earlierTime)
        }
        if let laterTime = self.laterTime {
            try encodeContainer.encodeTimestamp(laterTime, format: .epochSeconds, forKey: .laterTime)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension GetResourceConfigHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [GetResourceConfigHistory] action.
public struct GetResourceConfigHistoryInput: Swift.Equatable {
    /// The chronological order for configuration items listed. By default, the results are listed in reverse chronological order.
    public var chronologicalOrder: ConfigClientTypes.ChronologicalOrder?
    /// The time stamp that indicates an earlier time. If not specified, the action returns paginated results that contain configuration items that start when the first configuration item was recorded.
    public var earlierTime: ClientRuntime.Date?
    /// The time stamp that indicates a later time. If not specified, current time is taken.
    public var laterTime: ClientRuntime.Date?
    /// The maximum number of configuration items returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The ID of the resource (for example., sg-xxxxxx).
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init (
        chronologicalOrder: ConfigClientTypes.ChronologicalOrder? = nil,
        earlierTime: ClientRuntime.Date? = nil,
        laterTime: ClientRuntime.Date? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.chronologicalOrder = chronologicalOrder
        self.earlierTime = earlierTime
        self.laterTime = laterTime
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetResourceConfigHistoryInputBody: Swift.Equatable {
    let resourceType: ConfigClientTypes.ResourceType?
    let resourceId: Swift.String?
    let laterTime: ClientRuntime.Date?
    let earlierTime: ClientRuntime.Date?
    let chronologicalOrder: ConfigClientTypes.ChronologicalOrder?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension GetResourceConfigHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chronologicalOrder
        case earlierTime
        case laterTime
        case limit
        case nextToken
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let laterTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .laterTime)
        laterTime = laterTimeDecoded
        let earlierTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .earlierTime)
        earlierTime = earlierTimeDecoded
        let chronologicalOrderDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ChronologicalOrder.self, forKey: .chronologicalOrder)
        chronologicalOrder = chronologicalOrderDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceConfigHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceConfigHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRangeException" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotDiscoveredException" : self = .resourceNotDiscoveredException(try ResourceNotDiscoveredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceConfigHistoryOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case resourceNotDiscoveredException(ResourceNotDiscoveredException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceConfigHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceConfigHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationItems = output.configurationItems
            self.nextToken = output.nextToken
        } else {
            self.configurationItems = nil
            self.nextToken = nil
        }
    }
}

/// The output for the [GetResourceConfigHistory] action.
public struct GetResourceConfigHistoryOutputResponse: Swift.Equatable {
    /// A list that contains the configuration history of one or more resources.
    public var configurationItems: [ConfigClientTypes.ConfigurationItem]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationItems: [ConfigClientTypes.ConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationItems = configurationItems
        self.nextToken = nextToken
    }
}

struct GetResourceConfigHistoryOutputResponseBody: Swift.Equatable {
    let configurationItems: [ConfigClientTypes.ConfigurationItem]?
    let nextToken: Swift.String?
}

extension GetResourceConfigHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationItems
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConfigurationItem?].self, forKey: .configurationItems)
        var configurationItemsDecoded0:[ConfigClientTypes.ConfigurationItem]? = nil
        if let configurationItemsContainer = configurationItemsContainer {
            configurationItemsDecoded0 = [ConfigClientTypes.ConfigurationItem]()
            for structure0 in configurationItemsContainer {
                if let structure0 = structure0 {
                    configurationItemsDecoded0?.append(structure0)
                }
            }
        }
        configurationItems = configurationItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceEvaluationSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceEvaluationId = self.resourceEvaluationId {
            try encodeContainer.encode(resourceEvaluationId, forKey: .resourceEvaluationId)
        }
    }
}

extension GetResourceEvaluationSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourceEvaluationSummaryInput: Swift.Equatable {
    /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
    /// This member is required.
    public var resourceEvaluationId: Swift.String?

    public init (
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.resourceEvaluationId = resourceEvaluationId
    }
}

struct GetResourceEvaluationSummaryInputBody: Swift.Equatable {
    let resourceEvaluationId: Swift.String?
}

extension GetResourceEvaluationSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
    }
}

extension GetResourceEvaluationSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceEvaluationSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceEvaluationSummaryOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceEvaluationSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceEvaluationSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compliance = output.compliance
            self.evaluationContext = output.evaluationContext
            self.evaluationMode = output.evaluationMode
            self.evaluationStartTimestamp = output.evaluationStartTimestamp
            self.evaluationStatus = output.evaluationStatus
            self.resourceDetails = output.resourceDetails
            self.resourceEvaluationId = output.resourceEvaluationId
        } else {
            self.compliance = nil
            self.evaluationContext = nil
            self.evaluationMode = nil
            self.evaluationStartTimestamp = nil
            self.evaluationStatus = nil
            self.resourceDetails = nil
            self.resourceEvaluationId = nil
        }
    }
}

public struct GetResourceEvaluationSummaryOutputResponse: Swift.Equatable {
    /// The compliance status of the resource evaluation summary.
    public var compliance: ConfigClientTypes.ComplianceType?
    /// Returns an EvaluationContext object.
    public var evaluationContext: ConfigClientTypes.EvaluationContext?
    /// Lists results of the mode that you requested to retrieve the resource evaluation summary. The valid values are Detective or Proactive.
    public var evaluationMode: ConfigClientTypes.EvaluationMode?
    /// The start timestamp when Config rule starts evaluating compliance for the provided resource details.
    public var evaluationStartTimestamp: ClientRuntime.Date?
    /// Returns an EvaluationStatus object.
    public var evaluationStatus: ConfigClientTypes.EvaluationStatus?
    /// Returns a ResourceDetails object.
    public var resourceDetails: ConfigClientTypes.ResourceDetails?
    /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
    public var resourceEvaluationId: Swift.String?

    public init (
        compliance: ConfigClientTypes.ComplianceType? = nil,
        evaluationContext: ConfigClientTypes.EvaluationContext? = nil,
        evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
        evaluationStartTimestamp: ClientRuntime.Date? = nil,
        evaluationStatus: ConfigClientTypes.EvaluationStatus? = nil,
        resourceDetails: ConfigClientTypes.ResourceDetails? = nil,
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.compliance = compliance
        self.evaluationContext = evaluationContext
        self.evaluationMode = evaluationMode
        self.evaluationStartTimestamp = evaluationStartTimestamp
        self.evaluationStatus = evaluationStatus
        self.resourceDetails = resourceDetails
        self.resourceEvaluationId = resourceEvaluationId
    }
}

struct GetResourceEvaluationSummaryOutputResponseBody: Swift.Equatable {
    let resourceEvaluationId: Swift.String?
    let evaluationMode: ConfigClientTypes.EvaluationMode?
    let evaluationStatus: ConfigClientTypes.EvaluationStatus?
    let evaluationStartTimestamp: ClientRuntime.Date?
    let compliance: ConfigClientTypes.ComplianceType?
    let evaluationContext: ConfigClientTypes.EvaluationContext?
    let resourceDetails: ConfigClientTypes.ResourceDetails?
}

extension GetResourceEvaluationSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliance = "Compliance"
        case evaluationContext = "EvaluationContext"
        case evaluationMode = "EvaluationMode"
        case evaluationStartTimestamp = "EvaluationStartTimestamp"
        case evaluationStatus = "EvaluationStatus"
        case resourceDetails = "ResourceDetails"
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
        let evaluationStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationStatus.self, forKey: .evaluationStatus)
        evaluationStatus = evaluationStatusDecoded
        let evaluationStartTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .evaluationStartTimestamp)
        evaluationStartTimestamp = evaluationStartTimestampDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ComplianceType.self, forKey: .compliance)
        compliance = complianceDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationContext.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
    }
}

extension GetStoredQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryName = "QueryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryName = self.queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }
}

extension GetStoredQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetStoredQueryInput: Swift.Equatable {
    /// The name of the query.
    /// This member is required.
    public var queryName: Swift.String?

    public init (
        queryName: Swift.String? = nil
    )
    {
        self.queryName = queryName
    }
}

struct GetStoredQueryInputBody: Swift.Equatable {
    let queryName: Swift.String?
}

extension GetStoredQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryName = "QueryName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryName)
        queryName = queryNameDecoded
    }
}

extension GetStoredQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStoredQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStoredQueryOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStoredQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStoredQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.storedQuery = output.storedQuery
        } else {
            self.storedQuery = nil
        }
    }
}

public struct GetStoredQueryOutputResponse: Swift.Equatable {
    /// Returns a StoredQuery object.
    public var storedQuery: ConfigClientTypes.StoredQuery?

    public init (
        storedQuery: ConfigClientTypes.StoredQuery? = nil
    )
    {
        self.storedQuery = storedQuery
    }
}

struct GetStoredQueryOutputResponseBody: Swift.Equatable {
    let storedQuery: ConfigClientTypes.StoredQuery?
}

extension GetStoredQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storedQuery = "StoredQuery"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.StoredQuery.self, forKey: .storedQuery)
        storedQuery = storedQueryDecoded
    }
}

extension ConfigClientTypes.GroupedResourceCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case resourceCount = "ResourceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if resourceCount != 0 {
            try encodeContainer.encode(resourceCount, forKey: .resourceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let resourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceCount) ?? 0
        resourceCount = resourceCountDecoded
    }
}

extension ConfigClientTypes {
    /// The count of resources that are grouped by the group name.
    public struct GroupedResourceCount: Swift.Equatable {
        /// The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as GroupByKey.
        /// This member is required.
        public var groupName: Swift.String?
        /// The number of resources in the group.
        /// This member is required.
        public var resourceCount: Swift.Int

        public init (
            groupName: Swift.String? = nil,
            resourceCount: Swift.Int = 0
        )
        {
            self.groupName = groupName
            self.resourceCount = resourceCount
        }
    }

}

extension IdempotentParameterMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotentParameterMismatchBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Using the same client token with one or more different parameters. Specify a new client token with the parameter changes and try again.
public struct IdempotentParameterMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDeliveryPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientDeliveryPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your Amazon S3 bucket policy does not permit Config to write to it.
public struct InsufficientDeliveryPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDeliveryPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDeliveryPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientPermissionsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientPermissionsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates one of the following errors:
///
/// * For PutConfigRule, the rule cannot be created because the IAM role assigned to Config lacks permissions to perform the config:Put* action.
///
/// * For PutConfigRule, the Lambda function cannot be invoked. Check the function ARN, and check the function's permissions.
///
/// * For PutOrganizationConfigRule, organization Config rule cannot be created because you do not have permissions to call IAM GetRole action or create a service-linked role.
///
/// * For PutConformancePack and PutOrganizationConformancePack, a conformance pack cannot be created because you do not have the following permissions:
///
/// * You do not have permission to call IAM GetRole action or create a service-linked role.
///
/// * You do not have permission to read Amazon S3 bucket or call SSM:GetDocument.
public struct InsufficientPermissionsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientPermissionsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientPermissionsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationRecorderNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidConfigurationRecorderNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have provided a configuration recorder name that is not valid.
public struct InvalidConfigurationRecorderNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRecorderNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConfigurationRecorderNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeliveryChannelNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDeliveryChannelNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified delivery channel name is invalid.
public struct InvalidDeliveryChannelNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeliveryChannelNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeliveryChannelNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExpressionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidExpressionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The syntax of the query is incorrect.
public struct InvalidExpressionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExpressionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidExpressionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLimitException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified limit is outside the allowable range.
public struct InvalidLimitException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified next token is invalid. Specify the nextToken string that was returned in the previous response to get the next page of results.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified parameters are invalid. Verify that your parameters are valid and try again.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRecordingGroupException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRecordingGroupExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Config throws an exception if the recording group does not contain a valid list of resource types. Invalid values might also be incorrectly formatted.
public struct InvalidRecordingGroupException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRecordingGroupExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRecordingGroupExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResultTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResultTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified ResultToken is invalid.
public struct InvalidResultTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResultTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResultTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have provided a null or empty role ARN.
public struct InvalidRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyPrefixException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3KeyPrefixExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon S3 key prefix is invalid.
public struct InvalidS3KeyPrefixException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyPrefixExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3KeyPrefixExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KmsKeyArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidS3KmsKeyArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon KMS Key ARN is invalid.
public struct InvalidS3KmsKeyArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KmsKeyArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3KmsKeyArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSNSTopicARNException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSNSTopicARNExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon SNS topic does not exist.
public struct InvalidSNSTopicARNException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSNSTopicARNExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSNSTopicARNExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified time range is invalid. The earlier time is not chronologically before the later time.
public struct InvalidTimeRangeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTimeRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LastDeliveryChannelDeleteFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LastDeliveryChannelDeleteFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot delete the delivery channel you specified because the configuration recorder is running.
public struct LastDeliveryChannelDeleteFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LastDeliveryChannelDeleteFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LastDeliveryChannelDeleteFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// For StartConfigRulesEvaluation API, this exception is thrown if an evaluation is in progress or if you call the [StartConfigRulesEvaluation] API more than once per minute. For PutConfigurationAggregator API, this exception is thrown if the number of accounts and aggregators exceeds the limit.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAggregateDiscoveredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListAggregateDiscoveredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAggregateDiscoveredResourcesInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ResourceFilters object.
    public var filters: ConfigClientTypes.ResourceFilters?
    /// The maximum number of resource identifiers returned on each page. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The type of resources that you want Config to list in the response.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ResourceFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListAggregateDiscoveredResourcesInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let resourceType: ConfigClientTypes.ResourceType?
    let filters: ConfigClientTypes.ResourceFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension ListAggregateDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAggregateDiscoveredResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAggregateDiscoveredResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAggregateDiscoveredResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAggregateDiscoveredResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAggregateDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceIdentifiers = output.resourceIdentifiers
        } else {
            self.nextToken = nil
            self.resourceIdentifiers = nil
        }
    }
}

public struct ListAggregateDiscoveredResourcesOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of ResourceIdentifiers objects.
    public var resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init (
        nextToken: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct ListAggregateDiscoveredResourcesOutputResponseBody: Swift.Equatable {
    let resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?
    let nextToken: Swift.String?
}

extension ListAggregateDiscoveredResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AggregateResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ConfigClientTypes.AggregateResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ConfigClientTypes.AggregateResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConformancePackComplianceScoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListConformancePackComplianceScoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConformancePackComplianceScoresInput: Swift.Equatable {
    /// Filters the results based on the ConformancePackComplianceScoresFilters.
    public var filters: ConfigClientTypes.ConformancePackComplianceScoresFilters?
    /// The maximum number of conformance pack compliance scores returned on each page.
    public var limit: Swift.Int
    /// The nextToken string in a prior request that you can use to get the paginated response for next set of conformance pack compliance scores.
    public var nextToken: Swift.String?
    /// Sorts your conformance pack compliance scores in either ascending or descending order, depending on SortOrder. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack. Enter SCORE, to sort conformance pack compliance scores by the numerical value of the compliance score.
    public var sortBy: ConfigClientTypes.SortBy?
    /// Determines the order in which conformance pack compliance scores are sorted. Either in ascending or descending order. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack. Conformance pack compliance scores are sorted in reverse alphabetical order if you enter DESCENDING. You can sort conformance pack compliance scores by the numerical value of the compliance score by entering SCORE in the SortBy action. When compliance scores are sorted by SCORE, conformance packs with a compliance score of INSUFFICIENT_DATA will be last when sorting by ascending order and first when sorting by descending order.
    public var sortOrder: ConfigClientTypes.SortOrder?

    public init (
        filters: ConfigClientTypes.ConformancePackComplianceScoresFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortBy: ConfigClientTypes.SortBy? = nil,
        sortOrder: ConfigClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListConformancePackComplianceScoresInputBody: Swift.Equatable {
    let filters: ConfigClientTypes.ConformancePackComplianceScoresFilters?
    let sortOrder: ConfigClientTypes.SortOrder?
    let sortBy: ConfigClientTypes.SortBy?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension ListConformancePackComplianceScoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConformancePackComplianceScoresFilters.self, forKey: .filters)
        filters = filtersDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.SortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConformancePackComplianceScoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConformancePackComplianceScoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConformancePackComplianceScoresOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConformancePackComplianceScoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConformancePackComplianceScoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackComplianceScores = output.conformancePackComplianceScores
            self.nextToken = output.nextToken
        } else {
            self.conformancePackComplianceScores = nil
            self.nextToken = nil
        }
    }
}

public struct ListConformancePackComplianceScoresOutputResponse: Swift.Equatable {
    /// A list of ConformancePackComplianceScore objects.
    /// This member is required.
    public var conformancePackComplianceScores: [ConfigClientTypes.ConformancePackComplianceScore]?
    /// The nextToken string that you can use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        conformancePackComplianceScores: [ConfigClientTypes.ConformancePackComplianceScore]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackComplianceScores = conformancePackComplianceScores
        self.nextToken = nextToken
    }
}

struct ListConformancePackComplianceScoresOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let conformancePackComplianceScores: [ConfigClientTypes.ConformancePackComplianceScore]?
}

extension ListConformancePackComplianceScoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackComplianceScores = "ConformancePackComplianceScores"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let conformancePackComplianceScoresContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackComplianceScore?].self, forKey: .conformancePackComplianceScores)
        var conformancePackComplianceScoresDecoded0:[ConfigClientTypes.ConformancePackComplianceScore]? = nil
        if let conformancePackComplianceScoresContainer = conformancePackComplianceScoresContainer {
            conformancePackComplianceScoresDecoded0 = [ConfigClientTypes.ConformancePackComplianceScore]()
            for structure0 in conformancePackComplianceScoresContainer {
                if let structure0 = structure0 {
                    conformancePackComplianceScoresDecoded0?.append(structure0)
                }
            }
        }
        conformancePackComplianceScores = conformancePackComplianceScoresDecoded0
    }
}

extension ListDiscoveredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeletedResources
        case limit
        case nextToken
        case resourceIds
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeDeletedResources != false {
            try encodeContainer.encode(includeDeletedResources, forKey: .includeDeletedResources)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for resourceid0 in resourceIds {
                try resourceIdsContainer.encode(resourceid0)
            }
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListDiscoveredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ListDiscoveredResourcesInput: Swift.Equatable {
    /// Specifies whether Config includes deleted resources in the results. By default, deleted resources are not included.
    public var includeDeletedResources: Swift.Bool
    /// The maximum number of resource identifiers returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The IDs of only those resources that you want Config to list in the response. If you do not specify this parameter, Config lists all resources of the specified type that it has discovered.
    public var resourceIds: [Swift.String]?
    /// The custom name of only those resources that you want Config to list in the response. If you do not specify this parameter, Config lists all resources of the specified type that it has discovered.
    public var resourceName: Swift.String?
    /// The type of resources that you want Config to list in the response.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init (
        includeDeletedResources: Swift.Bool = false,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceName: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.includeDeletedResources = includeDeletedResources
        self.limit = limit
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ListDiscoveredResourcesInputBody: Swift.Equatable {
    let resourceType: ConfigClientTypes.ResourceType?
    let resourceIds: [Swift.String]?
    let resourceName: Swift.String?
    let limit: Swift.Int
    let includeDeletedResources: Swift.Bool
    let nextToken: Swift.String?
}

extension ListDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeDeletedResources
        case limit
        case nextToken
        case resourceIds
        case resourceName
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let includeDeletedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeletedResources) ?? false
        includeDeletedResources = includeDeletedResourcesDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDiscoveredResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceIdentifiers = output.resourceIdentifiers
        } else {
            self.nextToken = nil
            self.resourceIdentifiers = nil
        }
    }
}

///
public struct ListDiscoveredResourcesOutputResponse: Swift.Equatable {
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the custom resource name.
    public var resourceIdentifiers: [ConfigClientTypes.ResourceIdentifier]?

    public init (
        nextToken: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.ResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Swift.Equatable {
    let resourceIdentifiers: [ConfigClientTypes.ResourceIdentifier]?
    let nextToken: Swift.String?
}

extension ListDiscoveredResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceIdentifiers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ConfigClientTypes.ResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ConfigClientTypes.ResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceEvaluationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourceEvaluationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourceEvaluationsInput: Swift.Equatable {
    /// Returns a ResourceEvaluationFilters object.
    public var filters: ConfigClientTypes.ResourceEvaluationFilters?
    /// The maximum number of evaluations returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        filters: ConfigClientTypes.ResourceEvaluationFilters? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListResourceEvaluationsInputBody: Swift.Equatable {
    let filters: ConfigClientTypes.ResourceEvaluationFilters?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension ListResourceEvaluationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceEvaluationFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceEvaluationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceEvaluationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRangeException" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceEvaluationsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceEvaluationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceEvaluationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceEvaluations = output.resourceEvaluations
        } else {
            self.nextToken = nil
            self.resourceEvaluations = nil
        }
    }
}

public struct ListResourceEvaluationsOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a ResourceEvaluations object.
    public var resourceEvaluations: [ConfigClientTypes.ResourceEvaluation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceEvaluations: [ConfigClientTypes.ResourceEvaluation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceEvaluations = resourceEvaluations
    }
}

struct ListResourceEvaluationsOutputResponseBody: Swift.Equatable {
    let resourceEvaluations: [ConfigClientTypes.ResourceEvaluation]?
    let nextToken: Swift.String?
}

extension ListResourceEvaluationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceEvaluations = "ResourceEvaluations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEvaluationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceEvaluation?].self, forKey: .resourceEvaluations)
        var resourceEvaluationsDecoded0:[ConfigClientTypes.ResourceEvaluation]? = nil
        if let resourceEvaluationsContainer = resourceEvaluationsContainer {
            resourceEvaluationsDecoded0 = [ConfigClientTypes.ResourceEvaluation]()
            for structure0 in resourceEvaluationsContainer {
                if let structure0 = structure0 {
                    resourceEvaluationsDecoded0?.append(structure0)
                }
            }
        }
        resourceEvaluations = resourceEvaluationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStoredQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStoredQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListStoredQueriesInput: Swift.Equatable {
    /// The maximum number of results to be returned with a single call.
    public var maxResults: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStoredQueriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListStoredQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStoredQueriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStoredQueriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStoredQueriesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStoredQueriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStoredQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storedQueryMetadata = output.storedQueryMetadata
        } else {
            self.nextToken = nil
            self.storedQueryMetadata = nil
        }
    }
}

public struct ListStoredQueriesOutputResponse: Swift.Equatable {
    /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of StoredQueryMetadata objects.
    public var storedQueryMetadata: [ConfigClientTypes.StoredQueryMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        storedQueryMetadata: [ConfigClientTypes.StoredQueryMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.storedQueryMetadata = storedQueryMetadata
    }
}

struct ListStoredQueriesOutputResponseBody: Swift.Equatable {
    let storedQueryMetadata: [ConfigClientTypes.StoredQueryMetadata]?
    let nextToken: Swift.String?
}

extension ListStoredQueriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case storedQueryMetadata = "StoredQueryMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryMetadataContainer = try containerValues.decodeIfPresent([ConfigClientTypes.StoredQueryMetadata?].self, forKey: .storedQueryMetadata)
        var storedQueryMetadataDecoded0:[ConfigClientTypes.StoredQueryMetadata]? = nil
        if let storedQueryMetadataContainer = storedQueryMetadataContainer {
            storedQueryMetadataDecoded0 = [ConfigClientTypes.StoredQueryMetadata]()
            for structure0 in storedQueryMetadataContainer {
                if let structure0 = structure0 {
                    storedQueryMetadataDecoded0?.append(structure0)
                }
            }
        }
        storedQueryMetadata = storedQueryMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags returned on each page. The limit maximum is 50. You cannot specify a number greater than 50. If you specify 0, Config uses the default.
    public var limit: Swift.Int
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The tags for the resource.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ConfigClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MaxActiveResourcesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxActiveResourcesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of active custom resource types in your account. There is a limit of 100,000. Delete unused resources using [DeleteResourceConfig](https://docs.aws.amazon.com/config/latest/APIReference/API_DeleteResourceConfig.html).
public struct MaxActiveResourcesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxActiveResourcesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxActiveResourcesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConfigRulesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfConfigRulesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Failed to add the Config rule because the account already contains the maximum number of 150 rules. Consider deleting any deactivated rules before you add new rules.
public struct MaxNumberOfConfigRulesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConfigRulesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfConfigRulesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConfigurationRecordersExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfConfigurationRecordersExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of recorders you can create.
public struct MaxNumberOfConfigurationRecordersExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConfigurationRecordersExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfConfigurationRecordersExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConformancePacksExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfConformancePacksExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of conformance packs you can create in an account. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfConformancePacksExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConformancePacksExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfConformancePacksExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfDeliveryChannelsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfDeliveryChannelsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of delivery channels you can create.
public struct MaxNumberOfDeliveryChannelsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfDeliveryChannelsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfDeliveryChannelsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfOrganizationConfigRulesExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfOrganizationConfigRulesExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of organization Config rules you can create. For more information, see see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfOrganizationConfigRulesExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfOrganizationConfigRulesExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfOrganizationConfigRulesExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfOrganizationConformancePacksExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfOrganizationConformancePacksExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of organization conformance packs you can create in an account. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfOrganizationConformancePacksExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfOrganizationConformancePacksExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfOrganizationConformancePacksExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfRetentionConfigurationsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MaxNumberOfRetentionConfigurationsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Failed to add the retention configuration because a retention configuration with that name already exists.
public struct MaxNumberOfRetentionConfigurationsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfRetentionConfigurationsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxNumberOfRetentionConfigurationsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes {
    public enum MaximumExecutionFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneHour
        case sixHours
        case threeHours
        case twelveHours
        case twentyfourHours
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumExecutionFrequency] {
            return [
                .oneHour,
                .sixHours,
                .threeHours,
                .twelveHours,
                .twentyfourHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneHour: return "One_Hour"
            case .sixHours: return "Six_Hours"
            case .threeHours: return "Three_Hours"
            case .twelveHours: return "Twelve_Hours"
            case .twentyfourHours: return "TwentyFour_Hours"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaximumExecutionFrequency(rawValue: rawValue) ?? MaximumExecutionFrequency.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes {
    public enum MemberAccountRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberAccountRuleStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberAccountRuleStatus(rawValue: rawValue) ?? MemberAccountRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.MemberAccountStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case configRuleName = "ConfigRuleName"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case memberAccountRuleStatus = "MemberAccountRuleStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let memberAccountRuleStatus = self.memberAccountRuleStatus {
            try encodeContainer.encode(memberAccountRuleStatus.rawValue, forKey: .memberAccountRuleStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let memberAccountRuleStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MemberAccountRuleStatus.self, forKey: .memberAccountRuleStatus)
        memberAccountRuleStatus = memberAccountRuleStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Organization Config rule creation or deletion status in each member account. This includes the name of the rule, the status, error code and error message when the rule creation or deletion failed.
    public struct MemberAccountStatus: Swift.Equatable {
        /// The 12-digit account ID of a member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The name of Config rule deployed in the member account.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// An error code that is returned when Config rule creation or deletion failed in the member account.
        public var errorCode: Swift.String?
        /// An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.
        public var errorMessage: Swift.String?
        /// The timestamp of the last status update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// Indicates deployment status for Config rule in the member account. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when Config rule has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when Config rule is being created in the member account.
        ///
        /// * CREATE_FAILED when Config rule creation has failed in the member account.
        ///
        /// * DELETE_FAILED when Config rule deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when Config rule is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when Config rule has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when Config rule has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when Config rule is being updated in the member account.
        ///
        /// * UPDATE_FAILED when Config rule deletion has failed in the member account.
        /// This member is required.
        public var memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus?

        public init (
            accountId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus? = nil
        )
        {
            self.accountId = accountId
            self.configRuleName = configRuleName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }
    }

}

extension ConfigClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationitemchangenotification
        case configurationsnapshotdeliverycompleted
        case oversizedconfigurationitemchangenotification
        case schedulednotification
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .configurationitemchangenotification,
                .configurationsnapshotdeliverycompleted,
                .oversizedconfigurationitemchangenotification,
                .schedulednotification,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationitemchangenotification: return "ConfigurationItemChangeNotification"
            case .configurationsnapshotdeliverycompleted: return "ConfigurationSnapshotDeliveryCompleted"
            case .oversizedconfigurationitemchangenotification: return "OversizedConfigurationItemChangeNotification"
            case .schedulednotification: return "ScheduledNotification"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension NoAvailableConfigurationRecorderException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoAvailableConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are no configuration recorders available to provide the role needed to describe your resources. Create a configuration recorder.
public struct NoAvailableConfigurationRecorderException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableConfigurationRecorderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAvailableConfigurationRecorderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoAvailableDeliveryChannelException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoAvailableDeliveryChannelExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no delivery channel available to record configurations.
public struct NoAvailableDeliveryChannelException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableDeliveryChannelExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAvailableDeliveryChannelExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoAvailableOrganizationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Organization is no longer available.
public struct NoAvailableOrganizationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAvailableOrganizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoRunningConfigurationRecorderException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoRunningConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no configuration recorder running.
public struct NoRunningConfigurationRecorderException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoRunningConfigurationRecorderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoRunningConfigurationRecorderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchBucketException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchBucketExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon S3 bucket does not exist.
public struct NoSuchBucketException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchBucketExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchBucketExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigRuleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchConfigRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Config rule in the request is invalid. Verify that the rule is an Config Custom Policy rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
public struct NoSuchConfigRuleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigRuleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchConfigRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigRuleInConformancePackException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchConfigRuleInConformancePackExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Config rule that you passed in the filter does not exist.
public struct NoSuchConfigRuleInConformancePackException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigRuleInConformancePackExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchConfigRuleInConformancePackExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigurationAggregatorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchConfigurationAggregatorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a configuration aggregator that does not exist.
public struct NoSuchConfigurationAggregatorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigurationAggregatorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchConfigurationAggregatorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigurationRecorderException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a configuration recorder that does not exist.
public struct NoSuchConfigurationRecorderException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigurationRecorderExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchConfigurationRecorderExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConformancePackException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchConformancePackExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified one or more conformance packs that do not exist.
public struct NoSuchConformancePackException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConformancePackExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchConformancePackExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDeliveryChannelException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchDeliveryChannelExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a delivery channel that does not exist.
public struct NoSuchDeliveryChannelException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDeliveryChannelExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchDeliveryChannelExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrganizationConfigRuleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchOrganizationConfigRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Config rule in the request is invalid. Verify that the rule is an organization Config Custom Policy rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
public struct NoSuchOrganizationConfigRuleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOrganizationConfigRuleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOrganizationConfigRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrganizationConformancePackException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchOrganizationConformancePackExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Config organization conformance pack that you passed in the filter does not exist. For DeleteOrganizationConformancePack, you tried to delete an organization conformance pack that does not exist.
public struct NoSuchOrganizationConformancePackException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOrganizationConformancePackExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOrganizationConformancePackExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRemediationConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchRemediationConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You specified an Config rule without a remediation configuration.
public struct NoSuchRemediationConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRemediationConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchRemediationConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRemediationExceptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchRemediationExceptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You tried to delete a remediation exception that does not exist.
public struct NoSuchRemediationExceptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRemediationExceptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchRemediationExceptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRetentionConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoSuchRetentionConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a retention configuration that does not exist.
public struct NoSuchRetentionConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRetentionConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchRetentionConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// For PutConfigurationAggregator API, you can see this exception for the following reasons:
///
/// * No permission to call EnableAWSServiceAccess API
///
/// * The configuration aggregator cannot be updated because your Amazon Web Services Organization management account or the delegated administrator role changed. Delete this aggregator and create a new one with the current Amazon Web Services Organization.
///
/// * The configuration aggregator is associated with a previous Amazon Web Services Organization and Config cannot aggregate data with current Amazon Web Services Organization. Delete this aggregator and create a new one with the current Amazon Web Services Organization.
///
/// * You are not a registered delegated administrator for Config with permissions to call ListDelegatedAdministrators API. Ensure that the management account registers delagated administrator for Config service principle name before the delegated administrator creates an aggregator.
///
///
/// For all OrganizationConfigRule and OrganizationConformancePack APIs, Config throws an exception if APIs are called from member accounts. All APIs must be called from organization management account.
public struct OrganizationAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationAccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.OrganizationAggregationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allAwsRegions = "AllAwsRegions"
        case awsRegions = "AwsRegions"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allAwsRegions != false {
            try encodeContainer.encode(allAwsRegions, forKey: .allAwsRegions)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for string0 in awsRegions {
                try awsRegionsContainer.encode(string0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let allAwsRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allAwsRegions) ?? false
        allAwsRegions = allAwsRegionsDecoded
    }
}

extension ConfigClientTypes {
    /// This object contains regions to set up the aggregator and an IAM role to retrieve organization details.
    public struct OrganizationAggregationSource: Swift.Equatable {
        /// If true, aggregate existing Config regions and future regions.
        public var allAwsRegions: Swift.Bool
        /// The source regions being aggregated.
        public var awsRegions: [Swift.String]?
        /// ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            allAwsRegions: Swift.Bool = false,
            awsRegions: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
            self.roleArn = roleArn
        }
    }

}

extension OrganizationAllFeaturesNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationAllFeaturesNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Config resource cannot be created because your organization does not have all features enabled.
public struct OrganizationAllFeaturesNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationAllFeaturesNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationAllFeaturesNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.OrganizationConfigRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConfigRuleArn = "OrganizationConfigRuleArn"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomPolicyRuleMetadata = "OrganizationCustomPolicyRuleMetadata"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for accountid0 in excludedAccounts {
                try excludedAccountsContainer.encode(accountid0)
            }
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let organizationConfigRuleArn = self.organizationConfigRuleArn {
            try encodeContainer.encode(organizationConfigRuleArn, forKey: .organizationConfigRuleArn)
        }
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationCustomPolicyRuleMetadata = self.organizationCustomPolicyRuleMetadata {
            try encodeContainer.encode(organizationCustomPolicyRuleMetadata, forKey: .organizationCustomPolicyRuleMetadata)
        }
        if let organizationCustomRuleMetadata = self.organizationCustomRuleMetadata {
            try encodeContainer.encode(organizationCustomRuleMetadata, forKey: .organizationCustomRuleMetadata)
        }
        if let organizationManagedRuleMetadata = self.organizationManagedRuleMetadata {
            try encodeContainer.encode(organizationManagedRuleMetadata, forKey: .organizationManagedRuleMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationConfigRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleArn)
        organizationConfigRuleArn = organizationConfigRuleArnDecoded
        let organizationManagedRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationManagedRuleMetadata.self, forKey: .organizationManagedRuleMetadata)
        organizationManagedRuleMetadata = organizationManagedRuleMetadataDecoded
        let organizationCustomRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationCustomRuleMetadata.self, forKey: .organizationCustomRuleMetadata)
        organizationCustomRuleMetadata = organizationCustomRuleMetadataDecoded
        let excludedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[Swift.String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [Swift.String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let organizationCustomPolicyRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy.self, forKey: .organizationCustomPolicyRuleMetadata)
        organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadataDecoded
    }
}

extension ConfigClientTypes {
    /// An organization Config rule that has information about Config rules that Config creates in member accounts.
    public struct OrganizationConfigRule: Swift.Equatable {
        /// A comma-separated list of accounts excluded from organization Config rule.
        public var excludedAccounts: [Swift.String]?
        /// The timestamp of the last update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of organization Config rule.
        /// This member is required.
        public var organizationConfigRuleArn: Swift.String?
        /// The name that you assign to organization Config rule.
        /// This member is required.
        public var organizationConfigRuleName: Swift.String?
        /// An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
        public var organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy?
        /// An OrganizationCustomRuleMetadata object.
        public var organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object.
        public var organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata?

        public init (
            excludedAccounts: [Swift.String]? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            organizationConfigRuleArn: Swift.String? = nil,
            organizationConfigRuleName: Swift.String? = nil,
            organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy? = nil,
            organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata? = nil,
            organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata? = nil
        )
        {
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleArn = organizationConfigRuleArn
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }
    }

}

extension ConfigClientTypes.OrganizationConfigRuleStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationRuleStatus = "OrganizationRuleStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationRuleStatus = self.organizationRuleStatus {
            try encodeContainer.encode(organizationRuleStatus.rawValue, forKey: .organizationRuleStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationRuleStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationRuleStatus.self, forKey: .organizationRuleStatus)
        organizationRuleStatus = organizationRuleStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Returns the status for an organization Config rule in an organization.
    public struct OrganizationConfigRuleStatus: Swift.Equatable {
        /// An error code that is returned when organization Config rule creation or deletion has failed.
        public var errorCode: Swift.String?
        /// An error message indicating that organization Config rule creation or deletion failed due to an error.
        public var errorMessage: Swift.String?
        /// The timestamp of the last update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name that you assign to organization Config rule.
        /// This member is required.
        public var organizationConfigRuleName: Swift.String?
        /// Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when an organization Config rule has been successfully created in all the member accounts.
        ///
        /// * CREATE_IN_PROGRESS when an organization Config rule creation is in progress.
        ///
        /// * CREATE_FAILED when an organization Config rule creation failed in one or more member accounts within that organization.
        ///
        /// * DELETE_FAILED when an organization Config rule deletion failed in one or more member accounts within that organization.
        ///
        /// * DELETE_IN_PROGRESS when an organization Config rule deletion is in progress.
        ///
        /// * DELETE_SUCCESSFUL when an organization Config rule has been successfully deleted from all the member accounts.
        ///
        /// * UPDATE_SUCCESSFUL when an organization Config rule has been successfully updated in all the member accounts.
        ///
        /// * UPDATE_IN_PROGRESS when an organization Config rule update is in progress.
        ///
        /// * UPDATE_FAILED when an organization Config rule update failed in one or more member accounts within that organization.
        /// This member is required.
        public var organizationRuleStatus: ConfigClientTypes.OrganizationRuleStatus?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            organizationConfigRuleName: Swift.String? = nil,
            organizationRuleStatus: ConfigClientTypes.OrganizationRuleStatus? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationRuleStatus = organizationRuleStatus
        }
    }

}

extension ConfigClientTypes {
    public enum OrganizationConfigRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationItemChangeNotification
        case oversizedConfigurationItemChangeNotifcation
        case scheduledNotification
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigRuleTriggerType] {
            return [
                .configurationItemChangeNotification,
                .oversizedConfigurationItemChangeNotifcation,
                .scheduledNotification,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationItemChangeNotification: return "ConfigurationItemChangeNotification"
            case .oversizedConfigurationItemChangeNotifcation: return "OversizedConfigurationItemChangeNotification"
            case .scheduledNotification: return "ScheduledNotification"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationConfigRuleTriggerType(rawValue: rawValue) ?? OrganizationConfigRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes {
    public enum OrganizationConfigRuleTriggerTypeNoSN: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationItemChangeNotification
        case oversizedConfigurationItemChangeNotifcation
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigRuleTriggerTypeNoSN] {
            return [
                .configurationItemChangeNotification,
                .oversizedConfigurationItemChangeNotifcation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationItemChangeNotification: return "ConfigurationItemChangeNotification"
            case .oversizedConfigurationItemChangeNotifcation: return "OversizedConfigurationItemChangeNotification"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationConfigRuleTriggerTypeNoSN(rawValue: rawValue) ?? OrganizationConfigRuleTriggerTypeNoSN.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.OrganizationConformancePack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConformancePackArn = "OrganizationConformancePackArn"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameter0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameter0)
            }
        }
        if let deliveryS3Bucket = self.deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = self.deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for accountid0 in excludedAccounts {
                try excludedAccountsContainer.encode(accountid0)
            }
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let organizationConformancePackArn = self.organizationConformancePackArn {
            try encodeContainer.encode(organizationConformancePackArn, forKey: .organizationConformancePackArn)
        }
        if let organizationConformancePackName = self.organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let organizationConformancePackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackArn)
        organizationConformancePackArn = organizationConformancePackArnDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConfigClientTypes.ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConfigClientTypes.ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let excludedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[Swift.String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [Swift.String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ConfigClientTypes {
    /// An organization conformance pack that has information about conformance packs that Config creates in member accounts.
    public struct OrganizationConformancePack: Swift.Equatable {
        /// A list of ConformancePackInputParameter objects.
        public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
        public var deliveryS3Bucket: Swift.String?
        /// Any folder structure you want to add to an Amazon S3 bucket. This field is optional.
        public var deliveryS3KeyPrefix: Swift.String?
        /// A comma-separated list of accounts excluded from organization conformance pack.
        public var excludedAccounts: [Swift.String]?
        /// Last time when organization conformation pack was updated.
        /// This member is required.
        public var lastUpdateTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of organization conformance pack.
        /// This member is required.
        public var organizationConformancePackArn: Swift.String?
        /// The name you assign to an organization conformance pack.
        /// This member is required.
        public var organizationConformancePackName: Swift.String?

        public init (
            conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
            deliveryS3Bucket: Swift.String? = nil,
            deliveryS3KeyPrefix: Swift.String? = nil,
            excludedAccounts: [Swift.String]? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            organizationConformancePackArn: Swift.String? = nil,
            organizationConformancePackName: Swift.String? = nil
        )
        {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackArn = organizationConformancePackArn
            self.organizationConformancePackName = organizationConformancePackName
        }
    }

}

extension ConfigClientTypes.OrganizationConformancePackDetailedStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case conformancePackName = "ConformancePackName"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationResourceDetailedStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Organization conformance pack creation or deletion status in each member account. This includes the name of the conformance pack, the status, error code and error message when the conformance pack creation or deletion failed.
    public struct OrganizationConformancePackDetailedStatus: Swift.Equatable {
        /// The 12-digit account ID of a member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The name of conformance pack deployed in the member account.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// An error code that is returned when conformance pack creation or deletion failed in the member account.
        public var errorCode: Swift.String?
        /// An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account.
        public var errorMessage: Swift.String?
        /// The timestamp of the last status update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// Indicates deployment status for conformance pack in a member account. When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when conformance pack has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when conformance pack is being created in the member account.
        ///
        /// * CREATE_FAILED when conformance pack creation has failed in the member account.
        ///
        /// * DELETE_FAILED when conformance pack deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.
        ///
        /// * UPDATE_FAILED when conformance pack deletion has failed in the member account.
        /// This member is required.
        public var status: ConfigClientTypes.OrganizationResourceDetailedStatus?

        public init (
            accountId: Swift.String? = nil,
            conformancePackName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            status: ConfigClientTypes.OrganizationResourceDetailedStatus? = nil
        )
        {
            self.accountId = accountId
            self.conformancePackName = conformancePackName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }

}

extension ConfigClientTypes.OrganizationConformancePackStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let organizationConformancePackName = self.organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationResourceStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Returns the status for an organization conformance pack in an organization.
    public struct OrganizationConformancePackStatus: Swift.Equatable {
        /// An error code that is returned when organization conformance pack creation or deletion has failed in a member account.
        public var errorCode: Swift.String?
        /// An error message indicating that organization conformance pack creation or deletion failed due to an error.
        public var errorMessage: Swift.String?
        /// The timestamp of the last update.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name that you assign to organization conformance pack.
        /// This member is required.
        public var organizationConformancePackName: Swift.String?
        /// Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when an organization conformance pack has been successfully created in all the member accounts.
        ///
        /// * CREATE_IN_PROGRESS when an organization conformance pack creation is in progress.
        ///
        /// * CREATE_FAILED when an organization conformance pack creation failed in one or more member accounts within that organization.
        ///
        /// * DELETE_FAILED when an organization conformance pack deletion failed in one or more member accounts within that organization.
        ///
        /// * DELETE_IN_PROGRESS when an organization conformance pack deletion is in progress.
        ///
        /// * DELETE_SUCCESSFUL when an organization conformance pack has been successfully deleted from all the member accounts.
        ///
        /// * UPDATE_SUCCESSFUL when an organization conformance pack has been successfully updated in all the member accounts.
        ///
        /// * UPDATE_IN_PROGRESS when an organization conformance pack update is in progress.
        ///
        /// * UPDATE_FAILED when an organization conformance pack update failed in one or more member accounts within that organization.
        /// This member is required.
        public var status: ConfigClientTypes.OrganizationResourceStatus?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            organizationConformancePackName: Swift.String? = nil,
            status: ConfigClientTypes.OrganizationResourceStatus? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackName = organizationConformancePackName
            self.status = status
        }
    }

}

extension OrganizationConformancePackTemplateValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OrganizationConformancePackTemplateValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a template that is invalid or supported.
public struct OrganizationConformancePackTemplateValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationConformancePackTemplateValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationConformancePackTemplateValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.OrganizationCustomPolicyRuleMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case debugLogDeliveryAccounts = "DebugLogDeliveryAccounts"
        case description = "Description"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
        case policyRuntime = "PolicyRuntime"
        case policyText = "PolicyText"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let debugLogDeliveryAccounts = debugLogDeliveryAccounts {
            var debugLogDeliveryAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .debugLogDeliveryAccounts)
            for accountid0 in debugLogDeliveryAccounts {
                try debugLogDeliveryAccountsContainer.encode(accountid0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = self.inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes {
            var organizationConfigRuleTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleTriggerTypes)
            for organizationconfigruletriggertypenosn0 in organizationConfigRuleTriggerTypes {
                try organizationConfigRuleTriggerTypesContainer.encode(organizationconfigruletriggertypenosn0.rawValue)
            }
        }
        if let policyRuntime = self.policyRuntime {
            try encodeContainer.encode(policyRuntime, forKey: .policyRuntime)
        }
        if let policyText = self.policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let resourceIdScope = self.resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for stringwithcharlimit2560 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(stringwithcharlimit2560)
            }
        }
        if let tagKeyScope = self.tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = self.tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let organizationConfigRuleTriggerTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN?].self, forKey: .organizationConfigRuleTriggerTypes)
        var organizationConfigRuleTriggerTypesDecoded0:[ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil
        if let organizationConfigRuleTriggerTypesContainer = organizationConfigRuleTriggerTypesContainer {
            organizationConfigRuleTriggerTypesDecoded0 = [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]()
            for enum0 in organizationConfigRuleTriggerTypesContainer {
                if let enum0 = enum0 {
                    organizationConfigRuleTriggerTypesDecoded0?.append(enum0)
                }
            }
        }
        organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypesDecoded0
        let inputParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[Swift.String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [Swift.String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
        let policyRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRuntime)
        policyRuntime = policyRuntimeDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let debugLogDeliveryAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .debugLogDeliveryAccounts)
        var debugLogDeliveryAccountsDecoded0:[Swift.String]? = nil
        if let debugLogDeliveryAccountsContainer = debugLogDeliveryAccountsContainer {
            debugLogDeliveryAccountsDecoded0 = [Swift.String]()
            for string0 in debugLogDeliveryAccountsContainer {
                if let string0 = string0 {
                    debugLogDeliveryAccountsDecoded0?.append(string0)
                }
            }
        }
        debugLogDeliveryAccounts = debugLogDeliveryAccountsDecoded0
    }
}

extension ConfigClientTypes {
    /// An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
    public struct OrganizationCustomPolicyRuleMetadata: Swift.Equatable {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public var debugLogDeliveryAccounts: [Swift.String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:
        ///
        /// * ConfigurationItemChangeNotification - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        /// This member is required.
        public var policyRuntime: Swift.String?
        /// The policy definition containing the logic for your organization Config Custom Policy rule.
        /// This member is required.
        public var policyText: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init (
            debugLogDeliveryAccounts: [Swift.String]? = nil,
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil,
            policyRuntime: Swift.String? = nil,
            policyText: Swift.String? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.policyText = policyText
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }

}

extension ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case debugLogDeliveryAccounts = "DebugLogDeliveryAccounts"
        case description = "Description"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
        case policyRuntime = "PolicyRuntime"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let debugLogDeliveryAccounts = debugLogDeliveryAccounts {
            var debugLogDeliveryAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .debugLogDeliveryAccounts)
            for accountid0 in debugLogDeliveryAccounts {
                try debugLogDeliveryAccountsContainer.encode(accountid0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = self.inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes {
            var organizationConfigRuleTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleTriggerTypes)
            for organizationconfigruletriggertypenosn0 in organizationConfigRuleTriggerTypes {
                try organizationConfigRuleTriggerTypesContainer.encode(organizationconfigruletriggertypenosn0.rawValue)
            }
        }
        if let policyRuntime = self.policyRuntime {
            try encodeContainer.encode(policyRuntime, forKey: .policyRuntime)
        }
        if let resourceIdScope = self.resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for stringwithcharlimit2560 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(stringwithcharlimit2560)
            }
        }
        if let tagKeyScope = self.tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = self.tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let organizationConfigRuleTriggerTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN?].self, forKey: .organizationConfigRuleTriggerTypes)
        var organizationConfigRuleTriggerTypesDecoded0:[ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil
        if let organizationConfigRuleTriggerTypesContainer = organizationConfigRuleTriggerTypesContainer {
            organizationConfigRuleTriggerTypesDecoded0 = [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]()
            for enum0 in organizationConfigRuleTriggerTypesContainer {
                if let enum0 = enum0 {
                    organizationConfigRuleTriggerTypesDecoded0?.append(enum0)
                }
            }
        }
        organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypesDecoded0
        let inputParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[Swift.String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [Swift.String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
        let policyRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRuntime)
        policyRuntime = policyRuntimeDecoded
        let debugLogDeliveryAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .debugLogDeliveryAccounts)
        var debugLogDeliveryAccountsDecoded0:[Swift.String]? = nil
        if let debugLogDeliveryAccountsContainer = debugLogDeliveryAccountsContainer {
            debugLogDeliveryAccountsDecoded0 = [Swift.String]()
            for string0 in debugLogDeliveryAccountsContainer {
                if let string0 = string0 {
                    debugLogDeliveryAccountsDecoded0?.append(string0)
                }
            }
        }
        debugLogDeliveryAccounts = debugLogDeliveryAccountsDecoded0
    }
}

extension ConfigClientTypes {
    /// An object that specifies metadata for your organization Config Custom Policy rule including the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that trigger Config to evaluate Amazon Web Services resources against a rule.
    public struct OrganizationCustomPolicyRuleMetadataNoPolicy: Swift.Equatable {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public var debugLogDeliveryAccounts: [Swift.String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        public var policyRuntime: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init (
            debugLogDeliveryAccounts: [Swift.String]? = nil,
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil,
            policyRuntime: Swift.String? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }

}

extension ConfigClientTypes.OrganizationCustomRuleMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case inputParameters = "InputParameters"
        case lambdaFunctionArn = "LambdaFunctionArn"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = self.inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let lambdaFunctionArn = self.lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes {
            var organizationConfigRuleTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleTriggerTypes)
            for organizationconfigruletriggertype0 in organizationConfigRuleTriggerTypes {
                try organizationConfigRuleTriggerTypesContainer.encode(organizationconfigruletriggertype0.rawValue)
            }
        }
        if let resourceIdScope = self.resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for stringwithcharlimit2560 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(stringwithcharlimit2560)
            }
        }
        if let tagKeyScope = self.tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = self.tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        let organizationConfigRuleTriggerTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.OrganizationConfigRuleTriggerType?].self, forKey: .organizationConfigRuleTriggerTypes)
        var organizationConfigRuleTriggerTypesDecoded0:[ConfigClientTypes.OrganizationConfigRuleTriggerType]? = nil
        if let organizationConfigRuleTriggerTypesContainer = organizationConfigRuleTriggerTypesContainer {
            organizationConfigRuleTriggerTypesDecoded0 = [ConfigClientTypes.OrganizationConfigRuleTriggerType]()
            for enum0 in organizationConfigRuleTriggerTypesContainer {
                if let enum0 = enum0 {
                    organizationConfigRuleTriggerTypesDecoded0?.append(enum0)
                }
            }
        }
        organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypesDecoded0
        let inputParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[Swift.String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [Swift.String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
    }
}

extension ConfigClientTypes {
    /// An object that specifies organization custom rule metadata such as resource type, resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public struct OrganizationCustomRuleMetadata: Swift.Equatable {
        /// The description that you provide for your organization Config rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The lambda function ARN.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties]. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        ///
        /// * ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        /// This member is required.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerType]?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init (
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerType]? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.description = description
            self.inputParameters = inputParameters
            self.lambdaFunctionArn = lambdaFunctionArn
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }

}

extension ConfigClientTypes.OrganizationManagedRuleMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case ruleIdentifier = "RuleIdentifier"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = self.inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let resourceIdScope = self.resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for stringwithcharlimit2560 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(stringwithcharlimit2560)
            }
        }
        if let ruleIdentifier = self.ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
        if let tagKeyScope = self.tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = self.tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let inputParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[Swift.String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [Swift.String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
    }
}

extension ConfigClientTypes {
    /// An object that specifies organization managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public struct OrganizationManagedRuleMetadata: Swift.Equatable {
        /// The description that you provide for your organization Config rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// For organization config managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see [Using Config managed rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html).
        /// This member is required.
        public var ruleIdentifier: Swift.String?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init (
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            ruleIdentifier: Swift.String? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.ruleIdentifier = ruleIdentifier
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }

}

extension ConfigClientTypes {
    public enum OrganizationResourceDetailedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceDetailedStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationResourceDetailedStatus(rawValue: rawValue) ?? OrganizationResourceDetailedStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.OrganizationResourceDetailedStatusFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationResourceDetailedStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConfigClientTypes {
    /// Status filter object to filter results based on specific member account ID or status type for an organization conformance pack.
    public struct OrganizationResourceDetailedStatusFilters: Swift.Equatable {
        /// The 12-digit account ID of the member account within an organization.
        public var accountId: Swift.String?
        /// Indicates deployment status for conformance pack in a member account. When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when conformance pack has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when conformance pack is being created in the member account.
        ///
        /// * CREATE_FAILED when conformance pack creation has failed in the member account.
        ///
        /// * DELETE_FAILED when conformance pack deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.
        ///
        /// * UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public var status: ConfigClientTypes.OrganizationResourceDetailedStatus?

        public init (
            accountId: Swift.String? = nil,
            status: ConfigClientTypes.OrganizationResourceDetailedStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension ConfigClientTypes {
    public enum OrganizationResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationResourceStatus(rawValue: rawValue) ?? OrganizationResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes {
    public enum OrganizationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationRuleStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationRuleStatus(rawValue: rawValue) ?? OrganizationRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension OversizedConfigurationItemException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OversizedConfigurationItemExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration item size is outside the allowable range.
public struct OversizedConfigurationItemException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OversizedConfigurationItemExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OversizedConfigurationItemExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes {
    public enum Owner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case customLambda
        case customPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [Owner] {
            return [
                .aws,
                .customLambda,
                .customPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .customLambda: return "CUSTOM_LAMBDA"
            case .customPolicy: return "CUSTOM_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Owner(rawValue: rawValue) ?? Owner.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.PendingAggregationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requesterAccountId = self.requesterAccountId {
            try encodeContainer.encode(requesterAccountId, forKey: .requesterAccountId)
        }
        if let requesterAwsRegion = self.requesterAwsRegion {
            try encodeContainer.encode(requesterAwsRegion, forKey: .requesterAwsRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requesterAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAccountId)
        requesterAccountId = requesterAccountIdDecoded
        let requesterAwsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requesterAwsRegion)
        requesterAwsRegion = requesterAwsRegionDecoded
    }
}

extension ConfigClientTypes {
    /// An object that represents the account ID and region of an aggregator account that is requesting authorization but is not yet authorized.
    public struct PendingAggregationRequest: Swift.Equatable {
        /// The 12-digit account ID of the account requesting to aggregate data.
        public var requesterAccountId: Swift.String?
        /// The region requesting to aggregate data.
        public var requesterAwsRegion: Swift.String?

        public init (
            requesterAccountId: Swift.String? = nil,
            requesterAwsRegion: Swift.String? = nil
        )
        {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }
    }

}

extension PutAggregationAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedAccountId = self.authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = self.authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutAggregationAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAggregationAuthorizationInput: Swift.Equatable {
    /// The 12-digit account ID of the account authorized to aggregate data.
    /// This member is required.
    public var authorizedAccountId: Swift.String?
    /// The region authorized to collect aggregated data.
    /// This member is required.
    public var authorizedAwsRegion: Swift.String?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        authorizedAccountId: Swift.String? = nil,
        authorizedAwsRegion: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
        self.tags = tags
    }
}

struct PutAggregationAuthorizationInputBody: Swift.Equatable {
    let authorizedAccountId: Swift.String?
    let authorizedAwsRegion: Swift.String?
    let tags: [ConfigClientTypes.Tag]?
}

extension PutAggregationAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutAggregationAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAggregationAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAggregationAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAggregationAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutAggregationAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregationAuthorization = output.aggregationAuthorization
        } else {
            self.aggregationAuthorization = nil
        }
    }
}

public struct PutAggregationAuthorizationOutputResponse: Swift.Equatable {
    /// Returns an AggregationAuthorization object.
    public var aggregationAuthorization: ConfigClientTypes.AggregationAuthorization?

    public init (
        aggregationAuthorization: ConfigClientTypes.AggregationAuthorization? = nil
    )
    {
        self.aggregationAuthorization = aggregationAuthorization
    }
}

struct PutAggregationAuthorizationOutputResponseBody: Swift.Equatable {
    let aggregationAuthorization: ConfigClientTypes.AggregationAuthorization?
}

extension PutAggregationAuthorizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationAuthorization = "AggregationAuthorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.AggregationAuthorization.self, forKey: .aggregationAuthorization)
        aggregationAuthorization = aggregationAuthorizationDecoded
    }
}

extension PutConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRule = "ConfigRule"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRule = self.configRule {
            try encodeContainer.encode(configRule, forKey: .configRule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutConfigRuleInput: Swift.Equatable {
    /// The rule that you want to add to your account.
    /// This member is required.
    public var configRule: ConfigClientTypes.ConfigRule?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        configRule: ConfigClientTypes.ConfigRule? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.configRule = configRule
        self.tags = tags
    }
}

struct PutConfigRuleInputBody: Swift.Equatable {
    let configRule: ConfigClientTypes.ConfigRule?
    let tags: [ConfigClientTypes.Tag]?
}

extension PutConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRule = "ConfigRule"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigRule.self, forKey: .configRule)
        configRule = configRuleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConfigRulesExceededException" : self = .maxNumberOfConfigRulesExceededException(try MaxNumberOfConfigRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfConfigRulesExceededException(MaxNumberOfConfigRulesExceededException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutConfigRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutConfigurationAggregatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case organizationAggregationSource = "OrganizationAggregationSource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAggregationSources = accountAggregationSources {
            var accountAggregationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountAggregationSources)
            for accountaggregationsource0 in accountAggregationSources {
                try accountAggregationSourcesContainer.encode(accountaggregationsource0)
            }
        }
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let organizationAggregationSource = self.organizationAggregationSource {
            try encodeContainer.encode(organizationAggregationSource, forKey: .organizationAggregationSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutConfigurationAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutConfigurationAggregatorInput: Swift.Equatable {
    /// A list of AccountAggregationSource object.
    public var accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]?
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// An OrganizationAggregationSource object.
    public var organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]? = nil,
        configurationAggregatorName: Swift.String? = nil,
        organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.accountAggregationSources = accountAggregationSources
        self.configurationAggregatorName = configurationAggregatorName
        self.organizationAggregationSource = organizationAggregationSource
        self.tags = tags
    }
}

struct PutConfigurationAggregatorInputBody: Swift.Equatable {
    let configurationAggregatorName: Swift.String?
    let accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]?
    let organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource?
    let tags: [ConfigClientTypes.Tag]?
}

extension PutConfigurationAggregatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case organizationAggregationSource = "OrganizationAggregationSource"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let accountAggregationSourcesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.AccountAggregationSource?].self, forKey: .accountAggregationSources)
        var accountAggregationSourcesDecoded0:[ConfigClientTypes.AccountAggregationSource]? = nil
        if let accountAggregationSourcesContainer = accountAggregationSourcesContainer {
            accountAggregationSourcesDecoded0 = [ConfigClientTypes.AccountAggregationSource]()
            for structure0 in accountAggregationSourcesContainer {
                if let structure0 = structure0 {
                    accountAggregationSourcesDecoded0?.append(structure0)
                }
            }
        }
        accountAggregationSources = accountAggregationSourcesDecoded0
        let organizationAggregationSourceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationAggregationSource.self, forKey: .organizationAggregationSource)
        organizationAggregationSource = organizationAggregationSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutConfigurationAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutConfigurationAggregatorOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutConfigurationAggregatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationAggregator = output.configurationAggregator
        } else {
            self.configurationAggregator = nil
        }
    }
}

public struct PutConfigurationAggregatorOutputResponse: Swift.Equatable {
    /// Returns a ConfigurationAggregator object.
    public var configurationAggregator: ConfigClientTypes.ConfigurationAggregator?

    public init (
        configurationAggregator: ConfigClientTypes.ConfigurationAggregator? = nil
    )
    {
        self.configurationAggregator = configurationAggregator
    }
}

struct PutConfigurationAggregatorOutputResponseBody: Swift.Equatable {
    let configurationAggregator: ConfigClientTypes.ConfigurationAggregator?
}

extension PutConfigurationAggregatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregator = "ConfigurationAggregator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigurationAggregator.self, forKey: .configurationAggregator)
        configurationAggregator = configurationAggregatorDecoded
    }
}

extension PutConfigurationRecorderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorder = "ConfigurationRecorder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorder = self.configurationRecorder {
            try encodeContainer.encode(configurationRecorder, forKey: .configurationRecorder)
        }
    }
}

extension PutConfigurationRecorderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [PutConfigurationRecorder] action.
public struct PutConfigurationRecorderInput: Swift.Equatable {
    /// The configuration recorder object that records each configuration change made to the resources.
    /// This member is required.
    public var configurationRecorder: ConfigClientTypes.ConfigurationRecorder?

    public init (
        configurationRecorder: ConfigClientTypes.ConfigurationRecorder? = nil
    )
    {
        self.configurationRecorder = configurationRecorder
    }
}

struct PutConfigurationRecorderInputBody: Swift.Equatable {
    let configurationRecorder: ConfigClientTypes.ConfigurationRecorder?
}

extension PutConfigurationRecorderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorder = "ConfigurationRecorder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ConfigurationRecorder.self, forKey: .configurationRecorder)
        configurationRecorder = configurationRecorderDecoded
    }
}

extension PutConfigurationRecorderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationRecorderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRecorderNameException" : self = .invalidConfigurationRecorderNameException(try InvalidConfigurationRecorderNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRecordingGroupException" : self = .invalidRecordingGroupException(try InvalidRecordingGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConfigurationRecordersExceededException" : self = .maxNumberOfConfigurationRecordersExceededException(try MaxNumberOfConfigurationRecordersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutConfigurationRecorderOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRecorderNameException(InvalidConfigurationRecorderNameException)
    case invalidRecordingGroupException(InvalidRecordingGroupException)
    case invalidRoleException(InvalidRoleException)
    case maxNumberOfConfigurationRecordersExceededException(MaxNumberOfConfigurationRecordersExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationRecorderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutConfigurationRecorderOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutConformancePackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
        case templateSSMDocumentDetails = "TemplateSSMDocumentDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameter0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameter0)
            }
        }
        if let conformancePackName = self.conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let deliveryS3Bucket = self.deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = self.deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateS3Uri = self.templateS3Uri {
            try encodeContainer.encode(templateS3Uri, forKey: .templateS3Uri)
        }
        if let templateSSMDocumentDetails = self.templateSSMDocumentDetails {
            try encodeContainer.encode(templateSSMDocumentDetails, forKey: .templateSSMDocumentDetails)
        }
    }
}

extension PutConformancePackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutConformancePackInput: Swift.Equatable {
    /// A list of ConformancePackInputParameter objects.
    public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    /// The unique name of the conformance pack you want to deploy.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
    public var deliveryS3Bucket: Swift.String?
    /// The prefix for the Amazon S3 bucket. This field is optional.
    public var deliveryS3KeyPrefix: Swift.String?
    /// A string containing the full conformance pack template body. The structure containing the template body has a minimum length of 1 byte and a maximum length of 51,200 bytes. You can use a YAML template with two resource types: Config rule (AWS::Config::ConfigRule) and remediation action (AWS::Config::RemediationConfiguration).
    public var templateBody: Swift.String?
    /// The location of the file containing the template body (s3://bucketname/prefix). The uri must point to a conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket in the same Region as the conformance pack. You must have access to read Amazon S3 bucket.
    public var templateS3Uri: Swift.String?
    /// An object of type TemplateSSMDocumentDetails, which contains the name or the Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
    public var templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails?

    public init (
        conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
        conformancePackName: Swift.String? = nil,
        deliveryS3Bucket: Swift.String? = nil,
        deliveryS3KeyPrefix: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateS3Uri: Swift.String? = nil,
        templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.conformancePackName = conformancePackName
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
        self.templateSSMDocumentDetails = templateSSMDocumentDetails
    }
}

struct PutConformancePackInputBody: Swift.Equatable {
    let conformancePackName: Swift.String?
    let templateS3Uri: Swift.String?
    let templateBody: Swift.String?
    let deliveryS3Bucket: Swift.String?
    let deliveryS3KeyPrefix: Swift.String?
    let conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    let templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails?
}

extension PutConformancePackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
        case templateSSMDocumentDetails = "TemplateSSMDocumentDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let templateS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateS3Uri)
        templateS3Uri = templateS3UriDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConfigClientTypes.ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConfigClientTypes.ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let templateSSMDocumentDetailsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.TemplateSSMDocumentDetails.self, forKey: .templateSSMDocumentDetails)
        templateSSMDocumentDetails = templateSSMDocumentDetailsDecoded
    }
}

extension PutConformancePackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConformancePackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConformancePackTemplateValidationException" : self = .conformancePackTemplateValidationException(try ConformancePackTemplateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConformancePacksExceededException" : self = .maxNumberOfConformancePacksExceededException(try MaxNumberOfConformancePacksExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutConformancePackOutputError: Swift.Error, Swift.Equatable {
    case conformancePackTemplateValidationException(ConformancePackTemplateValidationException)
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfConformancePacksExceededException(MaxNumberOfConformancePacksExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConformancePackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutConformancePackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conformancePackArn = output.conformancePackArn
        } else {
            self.conformancePackArn = nil
        }
    }
}

public struct PutConformancePackOutputResponse: Swift.Equatable {
    /// ARN of the conformance pack.
    public var conformancePackArn: Swift.String?

    public init (
        conformancePackArn: Swift.String? = nil
    )
    {
        self.conformancePackArn = conformancePackArn
    }
}

struct PutConformancePackOutputResponseBody: Swift.Equatable {
    let conformancePackArn: Swift.String?
}

extension PutConformancePackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackArn = "ConformancePackArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
    }
}

extension PutDeliveryChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannel = "DeliveryChannel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannel = self.deliveryChannel {
            try encodeContainer.encode(deliveryChannel, forKey: .deliveryChannel)
        }
    }
}

extension PutDeliveryChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [PutDeliveryChannel] action.
public struct PutDeliveryChannelInput: Swift.Equatable {
    /// The configuration delivery channel object that delivers the configuration information to an Amazon S3 bucket and to an Amazon SNS topic.
    /// This member is required.
    public var deliveryChannel: ConfigClientTypes.DeliveryChannel?

    public init (
        deliveryChannel: ConfigClientTypes.DeliveryChannel? = nil
    )
    {
        self.deliveryChannel = deliveryChannel
    }
}

struct PutDeliveryChannelInputBody: Swift.Equatable {
    let deliveryChannel: ConfigClientTypes.DeliveryChannel?
}

extension PutDeliveryChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryChannel = "DeliveryChannel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.DeliveryChannel.self, forKey: .deliveryChannel)
        deliveryChannel = deliveryChannelDecoded
    }
}

extension PutDeliveryChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDeliveryChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientDeliveryPolicyException" : self = .insufficientDeliveryPolicyException(try InsufficientDeliveryPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeliveryChannelNameException" : self = .invalidDeliveryChannelNameException(try InvalidDeliveryChannelNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyPrefixException" : self = .invalidS3KeyPrefixException(try InvalidS3KeyPrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KmsKeyArnException" : self = .invalidS3KmsKeyArnException(try InvalidS3KmsKeyArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSNSTopicARNException" : self = .invalidSNSTopicARNException(try InvalidSNSTopicARNException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfDeliveryChannelsExceededException" : self = .maxNumberOfDeliveryChannelsExceededException(try MaxNumberOfDeliveryChannelsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchBucketException" : self = .noSuchBucketException(try NoSuchBucketException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutDeliveryChannelOutputError: Swift.Error, Swift.Equatable {
    case insufficientDeliveryPolicyException(InsufficientDeliveryPolicyException)
    case invalidDeliveryChannelNameException(InvalidDeliveryChannelNameException)
    case invalidS3KeyPrefixException(InvalidS3KeyPrefixException)
    case invalidS3KmsKeyArnException(InvalidS3KmsKeyArnException)
    case invalidSNSTopicARNException(InvalidSNSTopicARNException)
    case maxNumberOfDeliveryChannelsExceededException(MaxNumberOfDeliveryChannelsExceededException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case noSuchBucketException(NoSuchBucketException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDeliveryChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutDeliveryChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutEvaluationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluations = "Evaluations"
        case resultToken = "ResultToken"
        case testMode = "TestMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluations = evaluations {
            var evaluationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluations)
            for evaluation0 in evaluations {
                try evaluationsContainer.encode(evaluation0)
            }
        }
        if let resultToken = self.resultToken {
            try encodeContainer.encode(resultToken, forKey: .resultToken)
        }
        if testMode != false {
            try encodeContainer.encode(testMode, forKey: .testMode)
        }
    }
}

extension PutEvaluationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct PutEvaluationsInput: Swift.Equatable {
    /// The assessments that the Lambda function performs. Each evaluation identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that invokes the Lambda function.
    public var evaluations: [ConfigClientTypes.Evaluation]?
    /// An encrypted token that associates an evaluation with an Config rule. Identifies the rule and the event that triggered the evaluation.
    /// This member is required.
    public var resultToken: Swift.String?
    /// Use this parameter to specify a test run for PutEvaluations. You can verify whether your Lambda function will deliver evaluation results to Config. No updates occur to your existing evaluations, and evaluation results are not sent to Config. When TestMode is true, PutEvaluations doesn't require a valid value for the ResultToken parameter, but the value cannot be null.
    public var testMode: Swift.Bool

    public init (
        evaluations: [ConfigClientTypes.Evaluation]? = nil,
        resultToken: Swift.String? = nil,
        testMode: Swift.Bool = false
    )
    {
        self.evaluations = evaluations
        self.resultToken = resultToken
        self.testMode = testMode
    }
}

struct PutEvaluationsInputBody: Swift.Equatable {
    let evaluations: [ConfigClientTypes.Evaluation]?
    let resultToken: Swift.String?
    let testMode: Swift.Bool
}

extension PutEvaluationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluations = "Evaluations"
        case resultToken = "ResultToken"
        case testMode = "TestMode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Evaluation?].self, forKey: .evaluations)
        var evaluationsDecoded0:[ConfigClientTypes.Evaluation]? = nil
        if let evaluationsContainer = evaluationsContainer {
            evaluationsDecoded0 = [ConfigClientTypes.Evaluation]()
            for structure0 in evaluationsContainer {
                if let structure0 = structure0 {
                    evaluationsDecoded0?.append(structure0)
                }
            }
        }
        evaluations = evaluationsDecoded0
        let resultTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultToken)
        resultToken = resultTokenDecoded
        let testModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .testMode) ?? false
        testMode = testModeDecoded
    }
}

extension PutEvaluationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEvaluationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResultTokenException" : self = .invalidResultTokenException(try InvalidResultTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutEvaluationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidResultTokenException(InvalidResultTokenException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEvaluationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutEvaluationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedEvaluations = output.failedEvaluations
        } else {
            self.failedEvaluations = nil
        }
    }
}

///
public struct PutEvaluationsOutputResponse: Swift.Equatable {
    /// Requests that failed because of a client or server error.
    public var failedEvaluations: [ConfigClientTypes.Evaluation]?

    public init (
        failedEvaluations: [ConfigClientTypes.Evaluation]? = nil
    )
    {
        self.failedEvaluations = failedEvaluations
    }
}

struct PutEvaluationsOutputResponseBody: Swift.Equatable {
    let failedEvaluations: [ConfigClientTypes.Evaluation]?
}

extension PutEvaluationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedEvaluations = "FailedEvaluations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEvaluationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Evaluation?].self, forKey: .failedEvaluations)
        var failedEvaluationsDecoded0:[ConfigClientTypes.Evaluation]? = nil
        if let failedEvaluationsContainer = failedEvaluationsContainer {
            failedEvaluationsDecoded0 = [ConfigClientTypes.Evaluation]()
            for structure0 in failedEvaluationsContainer {
                if let structure0 = structure0 {
                    failedEvaluationsDecoded0?.append(structure0)
                }
            }
        }
        failedEvaluations = failedEvaluationsDecoded0
    }
}

extension PutExternalEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case externalEvaluation = "ExternalEvaluation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let externalEvaluation = self.externalEvaluation {
            try encodeContainer.encode(externalEvaluation, forKey: .externalEvaluation)
        }
    }
}

extension PutExternalEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutExternalEvaluationInput: Swift.Equatable {
    /// The name of the Config rule.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// An ExternalEvaluation object that provides details about compliance.
    /// This member is required.
    public var externalEvaluation: ConfigClientTypes.ExternalEvaluation?

    public init (
        configRuleName: Swift.String? = nil,
        externalEvaluation: ConfigClientTypes.ExternalEvaluation? = nil
    )
    {
        self.configRuleName = configRuleName
        self.externalEvaluation = externalEvaluation
    }
}

struct PutExternalEvaluationInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let externalEvaluation: ConfigClientTypes.ExternalEvaluation?
}

extension PutExternalEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case externalEvaluation = "ExternalEvaluation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let externalEvaluationDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ExternalEvaluation.self, forKey: .externalEvaluation)
        externalEvaluation = externalEvaluationDecoded
    }
}

extension PutExternalEvaluationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutExternalEvaluationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutExternalEvaluationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutExternalEvaluationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutExternalEvaluationOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutOrganizationConfigRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomPolicyRuleMetadata = "OrganizationCustomPolicyRuleMetadata"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for accountid0 in excludedAccounts {
                try excludedAccountsContainer.encode(accountid0)
            }
        }
        if let organizationConfigRuleName = self.organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationCustomPolicyRuleMetadata = self.organizationCustomPolicyRuleMetadata {
            try encodeContainer.encode(organizationCustomPolicyRuleMetadata, forKey: .organizationCustomPolicyRuleMetadata)
        }
        if let organizationCustomRuleMetadata = self.organizationCustomRuleMetadata {
            try encodeContainer.encode(organizationCustomRuleMetadata, forKey: .organizationCustomRuleMetadata)
        }
        if let organizationManagedRuleMetadata = self.organizationManagedRuleMetadata {
            try encodeContainer.encode(organizationManagedRuleMetadata, forKey: .organizationManagedRuleMetadata)
        }
    }
}

extension PutOrganizationConfigRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutOrganizationConfigRuleInput: Swift.Equatable {
    /// A comma-separated list of accounts that you want to exclude from an organization Config rule.
    public var excludedAccounts: [Swift.String]?
    /// The name that you assign to an organization Config rule.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?
    /// An OrganizationCustomPolicyRuleMetadata object. This object specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
    public var organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata?
    /// An OrganizationCustomRuleMetadata object. This object specifies organization custom rule metadata such as resource type, resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public var organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata?
    /// An OrganizationManagedRuleMetadata object. This object specifies organization managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public var organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata?

    public init (
        excludedAccounts: [Swift.String]? = nil,
        organizationConfigRuleName: Swift.String? = nil,
        organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata? = nil,
        organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata? = nil,
        organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata? = nil
    )
    {
        self.excludedAccounts = excludedAccounts
        self.organizationConfigRuleName = organizationConfigRuleName
        self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
        self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
        self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
    }
}

struct PutOrganizationConfigRuleInputBody: Swift.Equatable {
    let organizationConfigRuleName: Swift.String?
    let organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata?
    let organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata?
    let excludedAccounts: [Swift.String]?
    let organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata?
}

extension PutOrganizationConfigRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomPolicyRuleMetadata = "OrganizationCustomPolicyRuleMetadata"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationManagedRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationManagedRuleMetadata.self, forKey: .organizationManagedRuleMetadata)
        organizationManagedRuleMetadata = organizationManagedRuleMetadataDecoded
        let organizationCustomRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationCustomRuleMetadata.self, forKey: .organizationCustomRuleMetadata)
        organizationCustomRuleMetadata = organizationCustomRuleMetadataDecoded
        let excludedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[Swift.String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [Swift.String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
        let organizationCustomPolicyRuleMetadataDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.OrganizationCustomPolicyRuleMetadata.self, forKey: .organizationCustomPolicyRuleMetadata)
        organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadataDecoded
    }
}

extension PutOrganizationConfigRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOrganizationConfigRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfOrganizationConfigRulesExceededException" : self = .maxNumberOfOrganizationConfigRulesExceededException(try MaxNumberOfOrganizationConfigRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutOrganizationConfigRuleOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfOrganizationConfigRulesExceededException(MaxNumberOfOrganizationConfigRulesExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case resourceInUseException(ResourceInUseException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOrganizationConfigRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutOrganizationConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationConfigRuleArn = output.organizationConfigRuleArn
        } else {
            self.organizationConfigRuleArn = nil
        }
    }
}

public struct PutOrganizationConfigRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an organization Config rule.
    public var organizationConfigRuleArn: Swift.String?

    public init (
        organizationConfigRuleArn: Swift.String? = nil
    )
    {
        self.organizationConfigRuleArn = organizationConfigRuleArn
    }
}

struct PutOrganizationConfigRuleOutputResponseBody: Swift.Equatable {
    let organizationConfigRuleArn: Swift.String?
}

extension PutOrganizationConfigRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConfigRuleArn = "OrganizationConfigRuleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConfigRuleArn)
        organizationConfigRuleArn = organizationConfigRuleArnDecoded
    }
}

extension PutOrganizationConformancePackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameter0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameter0)
            }
        }
        if let deliveryS3Bucket = self.deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = self.deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for accountid0 in excludedAccounts {
                try excludedAccountsContainer.encode(accountid0)
            }
        }
        if let organizationConformancePackName = self.organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateS3Uri = self.templateS3Uri {
            try encodeContainer.encode(templateS3Uri, forKey: .templateS3Uri)
        }
    }
}

extension PutOrganizationConformancePackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutOrganizationConformancePackInput: Swift.Equatable {
    /// A list of ConformancePackInputParameter objects.
    public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional. If used, it must be prefixed with awsconfigconforms.
    public var deliveryS3Bucket: Swift.String?
    /// The prefix for the Amazon S3 bucket. This field is optional.
    public var deliveryS3KeyPrefix: Swift.String?
    /// A list of Amazon Web Services accounts to be excluded from an organization conformance pack while deploying a conformance pack.
    public var excludedAccounts: [Swift.String]?
    /// Name of the organization conformance pack you want to create.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?
    /// A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.
    public var templateBody: Swift.String?
    /// Location of file containing the template body. The uri must point to the conformance pack template (max size: 300 KB). You must have access to read Amazon S3 bucket.
    public var templateS3Uri: Swift.String?

    public init (
        conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
        deliveryS3Bucket: Swift.String? = nil,
        deliveryS3KeyPrefix: Swift.String? = nil,
        excludedAccounts: [Swift.String]? = nil,
        organizationConformancePackName: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateS3Uri: Swift.String? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.excludedAccounts = excludedAccounts
        self.organizationConformancePackName = organizationConformancePackName
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
    }
}

struct PutOrganizationConformancePackInputBody: Swift.Equatable {
    let organizationConformancePackName: Swift.String?
    let templateS3Uri: Swift.String?
    let templateBody: Swift.String?
    let deliveryS3Bucket: Swift.String?
    let deliveryS3KeyPrefix: Swift.String?
    let conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    let excludedAccounts: [Swift.String]?
}

extension PutOrganizationConformancePackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let templateS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateS3Uri)
        templateS3Uri = templateS3UriDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConfigClientTypes.ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConfigClientTypes.ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let excludedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[Swift.String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [Swift.String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
    }
}

extension PutOrganizationConformancePackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOrganizationConformancePackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfOrganizationConformancePacksExceededException" : self = .maxNumberOfOrganizationConformancePacksExceededException(try MaxNumberOfOrganizationConformancePacksExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationConformancePackTemplateValidationException" : self = .organizationConformancePackTemplateValidationException(try OrganizationConformancePackTemplateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutOrganizationConformancePackOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case maxNumberOfOrganizationConformancePacksExceededException(MaxNumberOfOrganizationConformancePacksExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case organizationConformancePackTemplateValidationException(OrganizationConformancePackTemplateValidationException)
    case resourceInUseException(ResourceInUseException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOrganizationConformancePackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutOrganizationConformancePackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationConformancePackArn = output.organizationConformancePackArn
        } else {
            self.organizationConformancePackArn = nil
        }
    }
}

public struct PutOrganizationConformancePackOutputResponse: Swift.Equatable {
    /// ARN of the organization conformance pack.
    public var organizationConformancePackArn: Swift.String?

    public init (
        organizationConformancePackArn: Swift.String? = nil
    )
    {
        self.organizationConformancePackArn = organizationConformancePackArn
    }
}

struct PutOrganizationConformancePackOutputResponseBody: Swift.Equatable {
    let organizationConformancePackArn: Swift.String?
}

extension PutOrganizationConformancePackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationConformancePackArn = "OrganizationConformancePackArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationConformancePackArn)
        organizationConformancePackArn = organizationConformancePackArnDecoded
    }
}

extension PutRemediationConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remediationConfigurations = remediationConfigurations {
            var remediationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remediationConfigurations)
            for remediationconfiguration0 in remediationConfigurations {
                try remediationConfigurationsContainer.encode(remediationconfiguration0)
            }
        }
    }
}

extension PutRemediationConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRemediationConfigurationsInput: Swift.Equatable {
    /// A list of remediation configuration objects.
    /// This member is required.
    public var remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?

    public init (
        remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

struct PutRemediationConfigurationsInputBody: Swift.Equatable {
    let remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?
}

extension PutRemediationConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationConfigurationsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationConfiguration?].self, forKey: .remediationConfigurations)
        var remediationConfigurationsDecoded0:[ConfigClientTypes.RemediationConfiguration]? = nil
        if let remediationConfigurationsContainer = remediationConfigurationsContainer {
            remediationConfigurationsDecoded0 = [ConfigClientTypes.RemediationConfiguration]()
            for structure0 in remediationConfigurationsContainer {
                if let structure0 = structure0 {
                    remediationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        remediationConfigurations = remediationConfigurationsDecoded0
    }
}

extension PutRemediationConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRemediationConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRemediationConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRemediationConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRemediationConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct PutRemediationConfigurationsOutputResponse: Swift.Equatable {
    /// Returns a list of failed remediation batch objects.
    public var failedBatches: [ConfigClientTypes.FailedRemediationBatch]?

    public init (
        failedBatches: [ConfigClientTypes.FailedRemediationBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct PutRemediationConfigurationsOutputResponseBody: Swift.Equatable {
    let failedBatches: [ConfigClientTypes.FailedRemediationBatch]?
}

extension PutRemediationConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.FailedRemediationBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[ConfigClientTypes.FailedRemediationBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [ConfigClientTypes.FailedRemediationBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

extension PutRemediationExceptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekey0)
            }
        }
    }
}

extension PutRemediationExceptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRemediationExceptionsInput: Swift.Equatable {
    /// The name of the Config rule for which you want to create remediation exception.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The exception is automatically deleted after the expiration date.
    public var expirationTime: ClientRuntime.Date?
    /// The message contains an explanation of the exception.
    public var message: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init (
        configRuleName: Swift.String? = nil,
        expirationTime: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.expirationTime = expirationTime
        self.message = message
        self.resourceKeys = resourceKeys
    }
}

struct PutRemediationExceptionsInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?
    let message: Swift.String?
    let expirationTime: ClientRuntime.Date?
}

extension PutRemediationExceptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension PutRemediationExceptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRemediationExceptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRemediationExceptionsOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRemediationExceptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct PutRemediationExceptionsOutputResponse: Swift.Equatable {
    /// Returns a list of failed remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
    public var failedBatches: [ConfigClientTypes.FailedRemediationExceptionBatch]?

    public init (
        failedBatches: [ConfigClientTypes.FailedRemediationExceptionBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct PutRemediationExceptionsOutputResponseBody: Swift.Equatable {
    let failedBatches: [ConfigClientTypes.FailedRemediationExceptionBatch]?
}

extension PutRemediationExceptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.FailedRemediationExceptionBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[ConfigClientTypes.FailedRemediationExceptionBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [ConfigClientTypes.FailedRemediationExceptionBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

extension PutResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case schemaVersionId = "SchemaVersionId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let schemaVersionId = self.schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourceConfigInput: Swift.Equatable {
    /// The configuration object of the resource in valid JSON format. It must match the schema registered with CloudFormation. The configuration JSON must not exceed 64 KB.
    /// This member is required.
    public var configuration: Swift.String?
    /// Unique identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?
    /// The type of the resource. The custom resource type must be registered with CloudFormation. You cannot use the organization names “amzn”, “amazon”, “alexa”, “custom” with custom resource types. It is the first part of the ResourceType up to the first ::.
    /// This member is required.
    public var resourceType: Swift.String?
    /// Version of the schema registered for the ResourceType in CloudFormation.
    /// This member is required.
    public var schemaVersionId: Swift.String?
    /// Tags associated with the resource. This field is not to be confused with the Amazon Web Services-wide tag feature for Amazon Web Services resources. Tags for PutResourceConfig are tags that you supply for the configuration items of your custom resources.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configuration: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.schemaVersionId = schemaVersionId
        self.tags = tags
    }
}

struct PutResourceConfigInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let schemaVersionId: Swift.String?
    let resourceId: Swift.String?
    let resourceName: Swift.String?
    let configuration: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension PutResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case schemaVersionId = "SchemaVersionId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuration)
        configuration = configurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in tagsContainer {
                if let value0 = value0 {
                    tagsDecoded0?[key0] = value0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxActiveResourcesExceededException" : self = .maxActiveResourcesExceededException(try MaxActiveResourcesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case maxActiveResourcesExceededException(MaxActiveResourcesExceededException)
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceConfigOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutRetentionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if retentionPeriodInDays != 0 {
            try encodeContainer.encode(retentionPeriodInDays, forKey: .retentionPeriodInDays)
        }
    }
}

extension PutRetentionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRetentionConfigurationInput: Swift.Equatable {
    /// Number of days Config stores your historical information. Currently, only applicable to the configuration item history.
    /// This member is required.
    public var retentionPeriodInDays: Swift.Int

    public init (
        retentionPeriodInDays: Swift.Int = 0
    )
    {
        self.retentionPeriodInDays = retentionPeriodInDays
    }
}

struct PutRetentionConfigurationInputBody: Swift.Equatable {
    let retentionPeriodInDays: Swift.Int
}

extension PutRetentionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodInDays) ?? 0
        retentionPeriodInDays = retentionPeriodInDaysDecoded
    }
}

extension PutRetentionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfRetentionConfigurationsExceededException" : self = .maxNumberOfRetentionConfigurationsExceededException(try MaxNumberOfRetentionConfigurationsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRetentionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfRetentionConfigurationsExceededException(MaxNumberOfRetentionConfigurationsExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRetentionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.retentionConfiguration = output.retentionConfiguration
        } else {
            self.retentionConfiguration = nil
        }
    }
}

public struct PutRetentionConfigurationOutputResponse: Swift.Equatable {
    /// Returns a retention configuration object.
    public var retentionConfiguration: ConfigClientTypes.RetentionConfiguration?

    public init (
        retentionConfiguration: ConfigClientTypes.RetentionConfiguration? = nil
    )
    {
        self.retentionConfiguration = retentionConfiguration
    }
}

struct PutRetentionConfigurationOutputResponseBody: Swift.Equatable {
    let retentionConfiguration: ConfigClientTypes.RetentionConfiguration?
}

extension PutRetentionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionConfiguration = "RetentionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RetentionConfiguration.self, forKey: .retentionConfiguration)
        retentionConfiguration = retentionConfigurationDecoded
    }
}

extension PutStoredQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storedQuery = "StoredQuery"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storedQuery = self.storedQuery {
            try encodeContainer.encode(storedQuery, forKey: .storedQuery)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutStoredQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutStoredQueryInput: Swift.Equatable {
    /// A list of StoredQuery objects. The mandatory fields are QueryName and Expression. When you are creating a query, you must provide a query name and an expression. When you are updating a query, you must provide a query name but updating the description is optional.
    /// This member is required.
    public var storedQuery: ConfigClientTypes.StoredQuery?
    /// A list of Tags object.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        storedQuery: ConfigClientTypes.StoredQuery? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.storedQuery = storedQuery
        self.tags = tags
    }
}

struct PutStoredQueryInputBody: Swift.Equatable {
    let storedQuery: ConfigClientTypes.StoredQuery?
    let tags: [ConfigClientTypes.Tag]?
}

extension PutStoredQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storedQuery = "StoredQuery"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.StoredQuery.self, forKey: .storedQuery)
        storedQuery = storedQueryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutStoredQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStoredQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceConcurrentModificationException" : self = .resourceConcurrentModificationException(try ResourceConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutStoredQueryOutputError: Swift.Error, Swift.Equatable {
    case resourceConcurrentModificationException(ResourceConcurrentModificationException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStoredQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutStoredQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryArn = output.queryArn
        } else {
            self.queryArn = nil
        }
    }
}

public struct PutStoredQueryOutputResponse: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
    public var queryArn: Swift.String?

    public init (
        queryArn: Swift.String? = nil
    )
    {
        self.queryArn = queryArn
    }
}

struct PutStoredQueryOutputResponseBody: Swift.Equatable {
    let queryArn: Swift.String?
}

extension PutStoredQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryArn = "QueryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
    }
}

extension ConfigClientTypes.QueryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectFields = "SelectFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectFields = selectFields {
            var selectFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectFields)
            for fieldinfo0 in selectFields {
                try selectFieldsContainer.encode(fieldinfo0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectFieldsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.FieldInfo?].self, forKey: .selectFields)
        var selectFieldsDecoded0:[ConfigClientTypes.FieldInfo]? = nil
        if let selectFieldsContainer = selectFieldsContainer {
            selectFieldsDecoded0 = [ConfigClientTypes.FieldInfo]()
            for structure0 in selectFieldsContainer {
                if let structure0 = structure0 {
                    selectFieldsDecoded0?.append(structure0)
                }
            }
        }
        selectFields = selectFieldsDecoded0
    }
}

extension ConfigClientTypes {
    /// Details about the query.
    public struct QueryInfo: Swift.Equatable {
        /// Returns a FieldInfo object.
        public var selectFields: [ConfigClientTypes.FieldInfo]?

        public init (
            selectFields: [ConfigClientTypes.FieldInfo]? = nil
        )
        {
            self.selectFields = selectFields
        }
    }

}

extension ConfigClientTypes {
    public enum RecorderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecorderStatus] {
            return [
                .failure,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "Failure"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecorderStatus(rawValue: rawValue) ?? RecorderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.RecordingGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allSupported
        case includeGlobalResourceTypes
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allSupported != false {
            try encodeContainer.encode(allSupported, forKey: .allSupported)
        }
        if includeGlobalResourceTypes != false {
            try encodeContainer.encode(includeGlobalResourceTypes, forKey: .includeGlobalResourceTypes)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetype0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allSupported) ?? false
        allSupported = allSupportedDecoded
        let includeGlobalResourceTypesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalResourceTypes) ?? false
        includeGlobalResourceTypes = includeGlobalResourceTypesDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ConfigClientTypes.ResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ConfigClientTypes.ResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension ConfigClientTypes {
    /// Specifies which Amazon Web Services resource types Config records for configuration changes. In the recording group, you specify whether you want to record all supported resource types or only specific types of resources. By default, Config records the configuration changes for all supported types of regional resources that Config discovers in the region in which it is running. Regional resources are tied to a region and can be used only in that region. Examples of regional resources are EC2 instances and EBS volumes. You can also have Config record supported types of global resources. Global resources are not tied to a specific region and can be used in all regions. The global resource types that Config supports include IAM users, groups, roles, and customer managed policies. Global resource types onboarded to Config recording after February 2022 will only be recorded in the service's home region for the commercial partition and Amazon Web Services GovCloud (US) West for the GovCloud partition. You can view the Configuration Items for these new global resource types only in their home region and Amazon Web Services GovCloud (US) West. Supported global resource types onboarded before February 2022 such as AWS::IAM::Group, AWS::IAM::Policy, AWS::IAM::Role, AWS::IAM::User remain unchanged, and they will continue to deliver Configuration Items in all supported regions in Config. The change will only affect new global resource types onboarded after February 2022. To record global resource types onboarded after February 2022, enable All Supported Resource Types in the home region of the global resource type you want to record. If you don't want Config to record all resources, you can specify which types of resources it will record with the resourceTypes parameter. For a list of supported resource types, see [Supported Resource Types](https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources). For more information and a table of the Home Regions for Global Resource Types Onboarded after February 2022, see [Selecting Which Resources Config Records](https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html).
    public struct RecordingGroup: Swift.Equatable {
        /// Specifies whether Config records configuration changes for every supported type of regional resource. If you set this option to true, when Config adds support for a new type of regional resource, it starts recording resources of that type automatically. If you set this option to true, you cannot enumerate a list of resourceTypes.
        public var allSupported: Swift.Bool
        /// Specifies whether Config includes all supported types of global resources (for example, IAM resources) with the resources that it records. Before you can set this option to true, you must set the allSupported option to true. If you set this option to true, when Config adds support for a new type of global resource, it starts recording resources of that type automatically. The configuration details for any global resource are the same in all regions. To prevent duplicate configuration items, you should consider customizing Config in only one region to record global resources.
        public var includeGlobalResourceTypes: Swift.Bool
        /// A comma-separated list that specifies the types of Amazon Web Services resources for which Config records configuration changes (for example, AWS::EC2::Instance or AWS::CloudTrail::Trail). To record all configuration changes, you must set the allSupported option to true. If you set this option to false, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group. For a list of valid resourceTypes values, see the resourceType Value column in [Supported Amazon Web Services resource Types](https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources).
        public var resourceTypes: [ConfigClientTypes.ResourceType]?

        public init (
            allSupported: Swift.Bool = false,
            includeGlobalResourceTypes: Swift.Bool = false,
            resourceTypes: [ConfigClientTypes.ResourceType]? = nil
        )
        {
            self.allSupported = allSupported
            self.includeGlobalResourceTypes = includeGlobalResourceTypes
            self.resourceTypes = resourceTypes
        }
    }

}

extension ConfigClientTypes.Relationship: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationshipName
        case resourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationshipName = self.relationshipName {
            try encodeContainer.encode(relationshipName, forKey: .relationshipName)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let relationshipNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipName)
        relationshipName = relationshipNameDecoded
    }
}

extension ConfigClientTypes {
    /// The relationship of the related resource to the main resource.
    public struct Relationship: Swift.Equatable {
        /// The type of relationship with the related resource.
        public var relationshipName: Swift.String?
        /// The ID of the related resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the related resource, if available.
        public var resourceName: Swift.String?
        /// The resource type of the related resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init (
            relationshipName: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.relationshipName = relationshipName
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.RemediationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case automatic = "Automatic"
        case configRuleName = "ConfigRuleName"
        case createdByService = "CreatedByService"
        case executionControls = "ExecutionControls"
        case maximumAutomaticAttempts = "MaximumAutomaticAttempts"
        case parameters = "Parameters"
        case resourceType = "ResourceType"
        case retryAttemptSeconds = "RetryAttemptSeconds"
        case targetId = "TargetId"
        case targetType = "TargetType"
        case targetVersion = "TargetVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if automatic != false {
            try encodeContainer.encode(automatic, forKey: .automatic)
        }
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let createdByService = self.createdByService {
            try encodeContainer.encode(createdByService, forKey: .createdByService)
        }
        if let executionControls = self.executionControls {
            try encodeContainer.encode(executionControls, forKey: .executionControls)
        }
        if let maximumAutomaticAttempts = self.maximumAutomaticAttempts {
            try encodeContainer.encode(maximumAutomaticAttempts, forKey: .maximumAutomaticAttempts)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, remediationParameters0) in parameters {
                try parametersContainer.encode(remediationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let retryAttemptSeconds = self.retryAttemptSeconds {
            try encodeContainer.encode(retryAttemptSeconds, forKey: .retryAttemptSeconds)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
        if let targetVersion = self.targetVersion {
            try encodeContainer.encode(targetVersion, forKey: .targetVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RemediationTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetVersion)
        targetVersion = targetVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: ConfigClientTypes.RemediationParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:ConfigClientTypes.RemediationParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:ConfigClientTypes.RemediationParameterValue]()
            for (key0, remediationparametervalue0) in parametersContainer {
                if let remediationparametervalue0 = remediationparametervalue0 {
                    parametersDecoded0?[key0] = remediationparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let automaticDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automatic) ?? false
        automatic = automaticDecoded
        let executionControlsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ExecutionControls.self, forKey: .executionControls)
        executionControls = executionControlsDecoded
        let maximumAutomaticAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumAutomaticAttempts)
        maximumAutomaticAttempts = maximumAutomaticAttemptsDecoded
        let retryAttemptSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAttemptSeconds)
        retryAttemptSeconds = retryAttemptSecondsDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByServiceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByService)
        createdByService = createdByServiceDecoded
    }
}

extension ConfigClientTypes {
    /// An object that represents the details about the remediation configuration that includes the remediation action, parameters, and data to execute the action.
    public struct RemediationConfiguration: Swift.Equatable {
        /// Amazon Resource Name (ARN) of remediation configuration.
        public var arn: Swift.String?
        /// The remediation is triggered automatically.
        public var automatic: Swift.Bool
        /// The name of the Config rule.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// Name of the service that owns the service-linked rule, if applicable.
        public var createdByService: Swift.String?
        /// An ExecutionControls object.
        public var executionControls: ConfigClientTypes.ExecutionControls?
        /// The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.
        public var maximumAutomaticAttempts: Swift.Int?
        /// An object of the RemediationParameterValue.
        public var parameters: [Swift.String:ConfigClientTypes.RemediationParameterValue]?
        /// The type of a resource.
        public var resourceType: Swift.String?
        /// Maximum time in seconds that Config runs auto-remediation. If you do not select a number, the default is 60 seconds. For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before throwing an exception.
        public var retryAttemptSeconds: Swift.Int?
        /// Target ID is the name of the public document.
        /// This member is required.
        public var targetId: Swift.String?
        /// The type of the target. Target executes remediation. For example, SSM document.
        /// This member is required.
        public var targetType: ConfigClientTypes.RemediationTargetType?
        /// Version of the target. For example, version of the SSM document. If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.
        public var targetVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            automatic: Swift.Bool = false,
            configRuleName: Swift.String? = nil,
            createdByService: Swift.String? = nil,
            executionControls: ConfigClientTypes.ExecutionControls? = nil,
            maximumAutomaticAttempts: Swift.Int? = nil,
            parameters: [Swift.String:ConfigClientTypes.RemediationParameterValue]? = nil,
            resourceType: Swift.String? = nil,
            retryAttemptSeconds: Swift.Int? = nil,
            targetId: Swift.String? = nil,
            targetType: ConfigClientTypes.RemediationTargetType? = nil,
            targetVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.automatic = automatic
            self.configRuleName = configRuleName
            self.createdByService = createdByService
            self.executionControls = executionControls
            self.maximumAutomaticAttempts = maximumAutomaticAttempts
            self.parameters = parameters
            self.resourceType = resourceType
            self.retryAttemptSeconds = retryAttemptSeconds
            self.targetId = targetId
            self.targetType = targetType
            self.targetVersion = targetVersion
        }
    }

}

extension ConfigClientTypes.RemediationException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension ConfigClientTypes {
    /// An object that represents the details about the remediation exception. The details include the rule name, an explanation of an exception, the time when the exception will be deleted, the resource ID, and resource type.
    public struct RemediationException: Swift.Equatable {
        /// The name of the Config rule.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// The time when the remediation exception will be deleted.
        public var expirationTime: ClientRuntime.Date?
        /// An explanation of an remediation exception.
        public var message: Swift.String?
        /// The ID of the resource (for example., sg-xxxxxx).
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of a resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            configRuleName: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.RemediationExceptionResourceKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ConfigClientTypes {
    /// The details that identify a resource within Config, including the resource type and resource ID.
    public struct RemediationExceptionResourceKey: Swift.Equatable {
        /// The ID of the resource (for example., sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The type of a resource.
        public var resourceType: Swift.String?

        public init (
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes {
    public enum RemediationExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case queued
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationExecutionState] {
            return [
                .failed,
                .inProgress,
                .queued,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemediationExecutionState(rawValue: rawValue) ?? RemediationExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.RemediationExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationTime = "InvocationTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case resourceKey = "ResourceKey"
        case state = "State"
        case stepDetails = "StepDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationTime = self.invocationTime {
            try encodeContainer.encodeTimestamp(invocationTime, format: .epochSeconds, forKey: .invocationTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceKey = self.resourceKey {
            try encodeContainer.encode(resourceKey, forKey: .resourceKey)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stepDetails = stepDetails {
            var stepDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepDetails)
            for remediationexecutionstep0 in stepDetails {
                try stepDetailsContainer.encode(remediationexecutionstep0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceKeyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceKey.self, forKey: .resourceKey)
        resourceKey = resourceKeyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RemediationExecutionState.self, forKey: .state)
        state = stateDecoded
        let stepDetailsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.RemediationExecutionStep?].self, forKey: .stepDetails)
        var stepDetailsDecoded0:[ConfigClientTypes.RemediationExecutionStep]? = nil
        if let stepDetailsContainer = stepDetailsContainer {
            stepDetailsDecoded0 = [ConfigClientTypes.RemediationExecutionStep]()
            for structure0 in stepDetailsContainer {
                if let structure0 = structure0 {
                    stepDetailsDecoded0?.append(structure0)
                }
            }
        }
        stepDetails = stepDetailsDecoded0
        let invocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .invocationTime)
        invocationTime = invocationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Provides details of the current status of the invoked remediation action for that resource.
    public struct RemediationExecutionStatus: Swift.Equatable {
        /// Start time when the remediation was executed.
        public var invocationTime: ClientRuntime.Date?
        /// The time when the remediation execution was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The details that identify a resource within Config, including the resource type and resource ID.
        public var resourceKey: ConfigClientTypes.ResourceKey?
        /// ENUM of the values.
        public var state: ConfigClientTypes.RemediationExecutionState?
        /// Details of every step.
        public var stepDetails: [ConfigClientTypes.RemediationExecutionStep]?

        public init (
            invocationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceKey: ConfigClientTypes.ResourceKey? = nil,
            state: ConfigClientTypes.RemediationExecutionState? = nil,
            stepDetails: [ConfigClientTypes.RemediationExecutionStep]? = nil
        )
        {
            self.invocationTime = invocationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceKey = resourceKey
            self.state = state
            self.stepDetails = stepDetails
        }
    }

}

extension ConfigClientTypes.RemediationExecutionStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case name = "Name"
        case startTime = "StartTime"
        case state = "State"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .epochSeconds, forKey: .stopTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.RemediationExecutionStepState.self, forKey: .state)
        state = stateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Name of the step from the SSM document.
    public struct RemediationExecutionStep: Swift.Equatable {
        /// An error message if the step was interrupted during execution.
        public var errorMessage: Swift.String?
        /// The details of the step.
        public var name: Swift.String?
        /// The time when the step started.
        public var startTime: ClientRuntime.Date?
        /// The valid status of the step.
        public var state: ConfigClientTypes.RemediationExecutionStepState?
        /// The time when the step stopped.
        public var stopTime: ClientRuntime.Date?

        public init (
            errorMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: ConfigClientTypes.RemediationExecutionStepState? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.errorMessage = errorMessage
            self.name = name
            self.startTime = startTime
            self.state = state
            self.stopTime = stopTime
        }
    }

}

extension ConfigClientTypes {
    public enum RemediationExecutionStepState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationExecutionStepState] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemediationExecutionStepState(rawValue: rawValue) ?? RemediationExecutionStepState.sdkUnknown(rawValue)
        }
    }
}

extension RemediationInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemediationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Remediation action is in progress. You can either cancel execution in Amazon Web Services Systems Manager or wait and try again later.
public struct RemediationInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RemediationInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RemediationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.RemediationParameterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceValue = "ResourceValue"
        case staticValue = "StaticValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceValue = self.resourceValue {
            try encodeContainer.encode(resourceValue, forKey: .resourceValue)
        }
        if let staticValue = self.staticValue {
            try encodeContainer.encode(staticValue, forKey: .staticValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceValueDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceValue.self, forKey: .resourceValue)
        resourceValue = resourceValueDecoded
        let staticValueDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.StaticValue.self, forKey: .staticValue)
        staticValue = staticValueDecoded
    }
}

extension ConfigClientTypes {
    /// The value is either a dynamic (resource) value or a static value. You must select either a dynamic value or a static value.
    public struct RemediationParameterValue: Swift.Equatable {
        /// The value is dynamic and changes at run-time.
        public var resourceValue: ConfigClientTypes.ResourceValue?
        /// The value is static and does not change at run-time.
        public var staticValue: ConfigClientTypes.StaticValue?

        public init (
            resourceValue: ConfigClientTypes.ResourceValue? = nil,
            staticValue: ConfigClientTypes.StaticValue? = nil
        )
        {
            self.resourceValue = resourceValue
            self.staticValue = staticValue
        }
    }

}

extension ConfigClientTypes {
    public enum RemediationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssmDocument
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationTargetType] {
            return [
                .ssmDocument,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssmDocument: return "SSM_DOCUMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemediationTargetType(rawValue: rawValue) ?? RemediationTargetType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Two users are trying to modify the same query at the same time. Wait for a moment and try again.
public struct ResourceConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes {
    public enum ResourceConfigurationSchemaType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnResourceSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceConfigurationSchemaType] {
            return [
                .cfnResourceSchema,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnResourceSchema: return "CFN_RESOURCE_SCHEMA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceConfigurationSchemaType(rawValue: rawValue) ?? ResourceConfigurationSchemaType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ResourceCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension ConfigClientTypes {
    /// An object that contains the resource type and the number of resources.
    public struct ResourceCount: Swift.Equatable {
        /// The number of resources.
        public var count: Swift.Int
        /// The resource type (for example, "AWS::EC2::Instance").
        public var resourceType: ConfigClientTypes.ResourceType?

        public init (
            count: Swift.Int = 0,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.count = count
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.ResourceCountFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case region = "Region"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the resource count based on account ID, region, and resource type.
    public struct ResourceCountFilters: Swift.Equatable {
        /// The 12-digit ID of the account.
        public var accountId: Swift.String?
        /// The region where the account is located.
        public var region: Swift.String?
        /// The type of the Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init (
            accountId: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.accountId = accountId
            self.region = region
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes {
    public enum ResourceCountGroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case awsRegion
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCountGroupKey] {
            return [
                .accountId,
                .awsRegion,
                .resourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case .resourceType: return "RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceCountGroupKey(rawValue: rawValue) ?? ResourceCountGroupKey.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfiguration = "ResourceConfiguration"
        case resourceConfigurationSchemaType = "ResourceConfigurationSchemaType"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfiguration = self.resourceConfiguration {
            try encodeContainer.encode(resourceConfiguration, forKey: .resourceConfiguration)
        }
        if let resourceConfigurationSchemaType = self.resourceConfigurationSchemaType {
            try encodeContainer.encode(resourceConfigurationSchemaType.rawValue, forKey: .resourceConfigurationSchemaType)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceConfiguration)
        resourceConfiguration = resourceConfigurationDecoded
        let resourceConfigurationSchemaTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceConfigurationSchemaType.self, forKey: .resourceConfigurationSchemaType)
        resourceConfigurationSchemaType = resourceConfigurationSchemaTypeDecoded
    }
}

extension ConfigClientTypes {
    /// Returns information about the resource being evaluated.
    public struct ResourceDetails: Swift.Equatable {
        /// The resource definition to be evaluated as per the resource configuration schema type.
        /// This member is required.
        public var resourceConfiguration: Swift.String?
        /// The schema type of the resource configuration.
        public var resourceConfigurationSchemaType: ConfigClientTypes.ResourceConfigurationSchemaType?
        /// A unique resource ID for an evaluation.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of resource being evaluated.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            resourceConfiguration: Swift.String? = nil,
            resourceConfigurationSchemaType: ConfigClientTypes.ResourceConfigurationSchemaType? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceConfiguration = resourceConfiguration
            self.resourceConfigurationSchemaType = resourceConfigurationSchemaType
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ConfigClientTypes.ResourceEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationMode = "EvaluationMode"
        case evaluationStartTimestamp = "EvaluationStartTimestamp"
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationMode = self.evaluationMode {
            try encodeContainer.encode(evaluationMode.rawValue, forKey: .evaluationMode)
        }
        if let evaluationStartTimestamp = self.evaluationStartTimestamp {
            try encodeContainer.encodeTimestamp(evaluationStartTimestamp, format: .epochSeconds, forKey: .evaluationStartTimestamp)
        }
        if let resourceEvaluationId = self.resourceEvaluationId {
            try encodeContainer.encode(resourceEvaluationId, forKey: .resourceEvaluationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
        let evaluationStartTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .evaluationStartTimestamp)
        evaluationStartTimestamp = evaluationStartTimestampDecoded
    }
}

extension ConfigClientTypes {
    /// Returns details of a resource evaluation.
    public struct ResourceEvaluation: Swift.Equatable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// The starting time of an execution.
        public var evaluationStartTimestamp: ClientRuntime.Date?
        /// The ResourceEvaluationId of a evaluation.
        public var resourceEvaluationId: Swift.String?

        public init (
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            evaluationStartTimestamp: ClientRuntime.Date? = nil,
            resourceEvaluationId: Swift.String? = nil
        )
        {
            self.evaluationMode = evaluationMode
            self.evaluationStartTimestamp = evaluationStartTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }
    }

}

extension ConfigClientTypes.ResourceEvaluationFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationContextIdentifier = "EvaluationContextIdentifier"
        case evaluationMode = "EvaluationMode"
        case timeWindow = "TimeWindow"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationContextIdentifier = self.evaluationContextIdentifier {
            try encodeContainer.encode(evaluationContextIdentifier, forKey: .evaluationContextIdentifier)
        }
        if let evaluationMode = self.evaluationMode {
            try encodeContainer.encode(evaluationMode.rawValue, forKey: .evaluationMode)
        }
        if let timeWindow = self.timeWindow {
            try encodeContainer.encode(timeWindow, forKey: .timeWindow)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
        let timeWindowDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.TimeWindow.self, forKey: .timeWindow)
        timeWindow = timeWindowDecoded
        let evaluationContextIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationContextIdentifier)
        evaluationContextIdentifier = evaluationContextIdentifierDecoded
    }
}

extension ConfigClientTypes {
    /// Returns details of a resource evaluation based on the selected filter.
    public struct ResourceEvaluationFilters: Swift.Equatable {
        /// Filters evaluations for a given infrastructure deployment. For example: CFN Stack.
        public var evaluationContextIdentifier: Swift.String?
        /// Filters all resource evaluations results based on an evaluation mode. the valid value for this API is Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// Returns a TimeWindow object.
        public var timeWindow: ConfigClientTypes.TimeWindow?

        public init (
            evaluationContextIdentifier: Swift.String? = nil,
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            timeWindow: ConfigClientTypes.TimeWindow? = nil
        )
        {
            self.evaluationContextIdentifier = evaluationContextIdentifier
            self.evaluationMode = evaluationMode
            self.timeWindow = timeWindow
        }
    }

}

extension ConfigClientTypes {
    public enum ResourceEvaluationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceEvaluationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceEvaluationStatus(rawValue: rawValue) ?? ResourceEvaluationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ResourceFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case region = "Region"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension ConfigClientTypes {
    /// Filters the results by resource account ID, region, resource ID, and resource name.
    public struct ResourceFilters: Swift.Equatable {
        /// The 12-digit source account ID.
        public var accountId: Swift.String?
        /// The source region.
        public var region: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.region = region
            self.resourceId = resourceId
            self.resourceName = resourceName
        }
    }

}

extension ConfigClientTypes.ResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceDeletionTime
        case resourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceDeletionTime = self.resourceDeletionTime {
            try encodeContainer.encodeTimestamp(resourceDeletionTime, format: .epochSeconds, forKey: .resourceDeletionTime)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceDeletionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resourceDeletionTime)
        resourceDeletionTime = resourceDeletionTimeDecoded
    }
}

extension ConfigClientTypes {
    /// The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the custom resource name.
    public struct ResourceIdentifier: Swift.Equatable {
        /// The time that the resource was deleted.
        public var resourceDeletionTime: ClientRuntime.Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource (if available).
        public var resourceName: Swift.String?
        /// The type of resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init (
            resourceDeletionTime: ClientRuntime.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.resourceDeletionTime = resourceDeletionTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You see this exception in the following cases:
///
/// * For DeleteConfigRule, Config is deleting this rule. Try your request again later.
///
/// * For DeleteConfigRule, the rule is deleting your evaluation results. Try your request again later.
///
/// * For DeleteConfigRule, a remediation action is associated with the rule and Config cannot delete this rule. Delete the remediation action associated with the rule before deleting the rule and try your request again later.
///
/// * For PutConfigOrganizationRule, organization Config rule deletion is in progress. Try your request again later.
///
/// * For DeleteOrganizationConfigRule, organization Config rule creation is in progress. Try your request again later.
///
/// * For PutConformancePack and PutOrganizationConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.
///
/// * For DeleteConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes.ResourceKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ConfigClientTypes {
    /// The details that identify a resource within Config, including the resource type and resource ID.
    public struct ResourceKey: Swift.Equatable {
        /// The ID of the resource (for example., sg-xxxxxx).
        /// This member is required.
        public var resourceId: Swift.String?
        /// The resource type.
        /// This member is required.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init (
            resourceId: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ResourceNotDiscoveredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotDiscoveredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a resource that is either unknown or has not been discovered.
public struct ResourceNotDiscoveredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotDiscoveredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotDiscoveredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessanalyzeranalyzer
        case accountpublicaccessblock
        case alarm
        case api
        case appconfigapplication
        case appsyncgraphqlapi
        case application
        case applicationversion
        case associationcompliance
        case athenadatacatalog
        case athenaworkgroup
        case autoscalinggroup
        case backupplan
        case backuprecoverypoint
        case backupselection
        case backupvault
        case batchcomputeenvironment
        case batchjobqueue
        case bucket
        case certificate
        case cloudformationproduct
        case cloudformationprovisionedproduct
        case cluster
        case clusterparametergroup
        case clustersecuritygroup
        case clustersnapshot
        case clustersubnetgroup
        case codedeployapplication
        case codedeploydeploymentconfig
        case codedeploydeploymentgroup
        case conformancepackcompliance
        case customergateway
        case dbcluster
        case dbclustersnapshot
        case dbinstance
        case dbsecuritygroup
        case dbsnapshot
        case dbsubnetgroup
        case dmscertificate
        case dmseventsubscription
        case dmsreplicationsubnetgroup
        case datasynclocationefs
        case datasynclocationfsxlustre
        case datasynclocationnfs
        case datasynclocations3
        case datasynclocationsmb
        case datasynctask
        case detectivegraph
        case distribution
        case domain
        case ecrpublicrepository
        case ecrrepository
        case ecscluster
        case ecsservice
        case ecstaskdefinition
        case efsaccesspoint
        case efsfilesystem
        case eip
        case ekscluster
        case eksfargateprofile
        case emrsecurityconfiguration
        case egressonlyinternetgateway
        case encryptionconfig
        case environment
        case eventsubscription
        case filedata
        case flowlog
        case function
        case globalacceleratoraccelerator
        case globalacceleratorendpointgroup
        case globalacceleratorlistener
        case gluejob
        case group
        case guarddutydetector
        case guarddutyipset
        case guarddutythreatintelset
        case host
        case ipsetv2
        case instance
        case internetgateway
        case key
        case kinesisstream
        case kinesisstreamconsumer
        case launchconfiguration
        case launchtemplate
        case listenerv2
        case loadbalancer
        case loadbalancerv2
        case mskcluster
        case managedinstanceinventory
        case managedrulesetv2
        case natgateway
        case networkacl
        case networkfirewallfirewall
        case networkfirewallfirewallpolicy
        case networkfirewallrulegroup
        case networkinsightsaccessscopeanalysis
        case networkinterface
        case opensearchdomain
        case patchcompliance
        case pipeline
        case policy
        case portfolio
        case project
        case protection
        case qldbledger
        case queue
        case ratebasedrule
        case redshifteventsubscription
        case regexpatternsetv2
        case regionalprotection
        case regionalratebasedrule
        case regionalrule
        case regionalrulegroup
        case regionalwebacl
        case registeredhainstance
        case resourcecompliance
        case restapi
        case role
        case route53hostedzone
        case route53resolverresolverendpoint
        case route53resolverresolverrule
        case route53resolverresolverruleassociation
        case routetable
        case rule
        case rulegroup
        case rulegroupv2
        case sesconfigurationset
        case sescontactlist
        case sagemakercoderepository
        case sagemakermodel
        case sagemakernotebookinstancelifecycleconfig
        case sagemakerworkteam
        case scalingpolicy
        case scheduledaction
        case secret
        case securitygroup
        case servicediscoverypublicdnsnamespace
        case servicediscoveryservice
        case stack
        case stage
        case stagev2
        case stepfunctionsactivity
        case stepfunctionsstatemachine
        case streamingdistribution
        case subnet
        case table
        case topic
        case trail
        case transitgateway
        case transitgatewayattachment
        case transitgatewayroutetable
        case user
        case vpc
        case vpcendpoint
        case vpcendpointservice
        case vpcpeeringconnection
        case vpnconnection
        case vpngateway
        case volume
        case webacl
        case webaclv2
        case workspacesconnectionalias
        case workspacesworkspace
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .accessanalyzeranalyzer,
                .accountpublicaccessblock,
                .alarm,
                .api,
                .appconfigapplication,
                .appsyncgraphqlapi,
                .application,
                .applicationversion,
                .associationcompliance,
                .athenadatacatalog,
                .athenaworkgroup,
                .autoscalinggroup,
                .backupplan,
                .backuprecoverypoint,
                .backupselection,
                .backupvault,
                .batchcomputeenvironment,
                .batchjobqueue,
                .bucket,
                .certificate,
                .cloudformationproduct,
                .cloudformationprovisionedproduct,
                .cluster,
                .clusterparametergroup,
                .clustersecuritygroup,
                .clustersnapshot,
                .clustersubnetgroup,
                .codedeployapplication,
                .codedeploydeploymentconfig,
                .codedeploydeploymentgroup,
                .conformancepackcompliance,
                .customergateway,
                .dbcluster,
                .dbclustersnapshot,
                .dbinstance,
                .dbsecuritygroup,
                .dbsnapshot,
                .dbsubnetgroup,
                .dmscertificate,
                .dmseventsubscription,
                .dmsreplicationsubnetgroup,
                .datasynclocationefs,
                .datasynclocationfsxlustre,
                .datasynclocationnfs,
                .datasynclocations3,
                .datasynclocationsmb,
                .datasynctask,
                .detectivegraph,
                .distribution,
                .domain,
                .ecrpublicrepository,
                .ecrrepository,
                .ecscluster,
                .ecsservice,
                .ecstaskdefinition,
                .efsaccesspoint,
                .efsfilesystem,
                .eip,
                .ekscluster,
                .eksfargateprofile,
                .emrsecurityconfiguration,
                .egressonlyinternetgateway,
                .encryptionconfig,
                .environment,
                .eventsubscription,
                .filedata,
                .flowlog,
                .function,
                .globalacceleratoraccelerator,
                .globalacceleratorendpointgroup,
                .globalacceleratorlistener,
                .gluejob,
                .group,
                .guarddutydetector,
                .guarddutyipset,
                .guarddutythreatintelset,
                .host,
                .ipsetv2,
                .instance,
                .internetgateway,
                .key,
                .kinesisstream,
                .kinesisstreamconsumer,
                .launchconfiguration,
                .launchtemplate,
                .listenerv2,
                .loadbalancer,
                .loadbalancerv2,
                .mskcluster,
                .managedinstanceinventory,
                .managedrulesetv2,
                .natgateway,
                .networkacl,
                .networkfirewallfirewall,
                .networkfirewallfirewallpolicy,
                .networkfirewallrulegroup,
                .networkinsightsaccessscopeanalysis,
                .networkinterface,
                .opensearchdomain,
                .patchcompliance,
                .pipeline,
                .policy,
                .portfolio,
                .project,
                .protection,
                .qldbledger,
                .queue,
                .ratebasedrule,
                .redshifteventsubscription,
                .regexpatternsetv2,
                .regionalprotection,
                .regionalratebasedrule,
                .regionalrule,
                .regionalrulegroup,
                .regionalwebacl,
                .registeredhainstance,
                .resourcecompliance,
                .restapi,
                .role,
                .route53hostedzone,
                .route53resolverresolverendpoint,
                .route53resolverresolverrule,
                .route53resolverresolverruleassociation,
                .routetable,
                .rule,
                .rulegroup,
                .rulegroupv2,
                .sesconfigurationset,
                .sescontactlist,
                .sagemakercoderepository,
                .sagemakermodel,
                .sagemakernotebookinstancelifecycleconfig,
                .sagemakerworkteam,
                .scalingpolicy,
                .scheduledaction,
                .secret,
                .securitygroup,
                .servicediscoverypublicdnsnamespace,
                .servicediscoveryservice,
                .stack,
                .stage,
                .stagev2,
                .stepfunctionsactivity,
                .stepfunctionsstatemachine,
                .streamingdistribution,
                .subnet,
                .table,
                .topic,
                .trail,
                .transitgateway,
                .transitgatewayattachment,
                .transitgatewayroutetable,
                .user,
                .vpc,
                .vpcendpoint,
                .vpcendpointservice,
                .vpcpeeringconnection,
                .vpnconnection,
                .vpngateway,
                .volume,
                .webacl,
                .webaclv2,
                .workspacesconnectionalias,
                .workspacesworkspace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessanalyzeranalyzer: return "AWS::AccessAnalyzer::Analyzer"
            case .accountpublicaccessblock: return "AWS::S3::AccountPublicAccessBlock"
            case .alarm: return "AWS::CloudWatch::Alarm"
            case .api: return "AWS::ApiGatewayV2::Api"
            case .appconfigapplication: return "AWS::AppConfig::Application"
            case .appsyncgraphqlapi: return "AWS::AppSync::GraphQLApi"
            case .application: return "AWS::ElasticBeanstalk::Application"
            case .applicationversion: return "AWS::ElasticBeanstalk::ApplicationVersion"
            case .associationcompliance: return "AWS::SSM::AssociationCompliance"
            case .athenadatacatalog: return "AWS::Athena::DataCatalog"
            case .athenaworkgroup: return "AWS::Athena::WorkGroup"
            case .autoscalinggroup: return "AWS::AutoScaling::AutoScalingGroup"
            case .backupplan: return "AWS::Backup::BackupPlan"
            case .backuprecoverypoint: return "AWS::Backup::RecoveryPoint"
            case .backupselection: return "AWS::Backup::BackupSelection"
            case .backupvault: return "AWS::Backup::BackupVault"
            case .batchcomputeenvironment: return "AWS::Batch::ComputeEnvironment"
            case .batchjobqueue: return "AWS::Batch::JobQueue"
            case .bucket: return "AWS::S3::Bucket"
            case .certificate: return "AWS::ACM::Certificate"
            case .cloudformationproduct: return "AWS::ServiceCatalog::CloudFormationProduct"
            case .cloudformationprovisionedproduct: return "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
            case .cluster: return "AWS::Redshift::Cluster"
            case .clusterparametergroup: return "AWS::Redshift::ClusterParameterGroup"
            case .clustersecuritygroup: return "AWS::Redshift::ClusterSecurityGroup"
            case .clustersnapshot: return "AWS::Redshift::ClusterSnapshot"
            case .clustersubnetgroup: return "AWS::Redshift::ClusterSubnetGroup"
            case .codedeployapplication: return "AWS::CodeDeploy::Application"
            case .codedeploydeploymentconfig: return "AWS::CodeDeploy::DeploymentConfig"
            case .codedeploydeploymentgroup: return "AWS::CodeDeploy::DeploymentGroup"
            case .conformancepackcompliance: return "AWS::Config::ConformancePackCompliance"
            case .customergateway: return "AWS::EC2::CustomerGateway"
            case .dbcluster: return "AWS::RDS::DBCluster"
            case .dbclustersnapshot: return "AWS::RDS::DBClusterSnapshot"
            case .dbinstance: return "AWS::RDS::DBInstance"
            case .dbsecuritygroup: return "AWS::RDS::DBSecurityGroup"
            case .dbsnapshot: return "AWS::RDS::DBSnapshot"
            case .dbsubnetgroup: return "AWS::RDS::DBSubnetGroup"
            case .dmscertificate: return "AWS::DMS::Certificate"
            case .dmseventsubscription: return "AWS::DMS::EventSubscription"
            case .dmsreplicationsubnetgroup: return "AWS::DMS::ReplicationSubnetGroup"
            case .datasynclocationefs: return "AWS::DataSync::LocationEFS"
            case .datasynclocationfsxlustre: return "AWS::DataSync::LocationFSxLustre"
            case .datasynclocationnfs: return "AWS::DataSync::LocationNFS"
            case .datasynclocations3: return "AWS::DataSync::LocationS3"
            case .datasynclocationsmb: return "AWS::DataSync::LocationSMB"
            case .datasynctask: return "AWS::DataSync::Task"
            case .detectivegraph: return "AWS::Detective::Graph"
            case .distribution: return "AWS::CloudFront::Distribution"
            case .domain: return "AWS::Elasticsearch::Domain"
            case .ecrpublicrepository: return "AWS::ECR::PublicRepository"
            case .ecrrepository: return "AWS::ECR::Repository"
            case .ecscluster: return "AWS::ECS::Cluster"
            case .ecsservice: return "AWS::ECS::Service"
            case .ecstaskdefinition: return "AWS::ECS::TaskDefinition"
            case .efsaccesspoint: return "AWS::EFS::AccessPoint"
            case .efsfilesystem: return "AWS::EFS::FileSystem"
            case .eip: return "AWS::EC2::EIP"
            case .ekscluster: return "AWS::EKS::Cluster"
            case .eksfargateprofile: return "AWS::EKS::FargateProfile"
            case .emrsecurityconfiguration: return "AWS::EMR::SecurityConfiguration"
            case .egressonlyinternetgateway: return "AWS::EC2::EgressOnlyInternetGateway"
            case .encryptionconfig: return "AWS::XRay::EncryptionConfig"
            case .environment: return "AWS::ElasticBeanstalk::Environment"
            case .eventsubscription: return "AWS::RDS::EventSubscription"
            case .filedata: return "AWS::SSM::FileData"
            case .flowlog: return "AWS::EC2::FlowLog"
            case .function: return "AWS::Lambda::Function"
            case .globalacceleratoraccelerator: return "AWS::GlobalAccelerator::Accelerator"
            case .globalacceleratorendpointgroup: return "AWS::GlobalAccelerator::EndpointGroup"
            case .globalacceleratorlistener: return "AWS::GlobalAccelerator::Listener"
            case .gluejob: return "AWS::Glue::Job"
            case .group: return "AWS::IAM::Group"
            case .guarddutydetector: return "AWS::GuardDuty::Detector"
            case .guarddutyipset: return "AWS::GuardDuty::IPSet"
            case .guarddutythreatintelset: return "AWS::GuardDuty::ThreatIntelSet"
            case .host: return "AWS::EC2::Host"
            case .ipsetv2: return "AWS::WAFv2::IPSet"
            case .instance: return "AWS::EC2::Instance"
            case .internetgateway: return "AWS::EC2::InternetGateway"
            case .key: return "AWS::KMS::Key"
            case .kinesisstream: return "AWS::Kinesis::Stream"
            case .kinesisstreamconsumer: return "AWS::Kinesis::StreamConsumer"
            case .launchconfiguration: return "AWS::AutoScaling::LaunchConfiguration"
            case .launchtemplate: return "AWS::EC2::LaunchTemplate"
            case .listenerv2: return "AWS::ElasticLoadBalancingV2::Listener"
            case .loadbalancer: return "AWS::ElasticLoadBalancing::LoadBalancer"
            case .loadbalancerv2: return "AWS::ElasticLoadBalancingV2::LoadBalancer"
            case .mskcluster: return "AWS::MSK::Cluster"
            case .managedinstanceinventory: return "AWS::SSM::ManagedInstanceInventory"
            case .managedrulesetv2: return "AWS::WAFv2::ManagedRuleSet"
            case .natgateway: return "AWS::EC2::NatGateway"
            case .networkacl: return "AWS::EC2::NetworkAcl"
            case .networkfirewallfirewall: return "AWS::NetworkFirewall::Firewall"
            case .networkfirewallfirewallpolicy: return "AWS::NetworkFirewall::FirewallPolicy"
            case .networkfirewallrulegroup: return "AWS::NetworkFirewall::RuleGroup"
            case .networkinsightsaccessscopeanalysis: return "AWS::EC2::NetworkInsightsAccessScopeAnalysis"
            case .networkinterface: return "AWS::EC2::NetworkInterface"
            case .opensearchdomain: return "AWS::OpenSearch::Domain"
            case .patchcompliance: return "AWS::SSM::PatchCompliance"
            case .pipeline: return "AWS::CodePipeline::Pipeline"
            case .policy: return "AWS::IAM::Policy"
            case .portfolio: return "AWS::ServiceCatalog::Portfolio"
            case .project: return "AWS::CodeBuild::Project"
            case .protection: return "AWS::Shield::Protection"
            case .qldbledger: return "AWS::QLDB::Ledger"
            case .queue: return "AWS::SQS::Queue"
            case .ratebasedrule: return "AWS::WAF::RateBasedRule"
            case .redshifteventsubscription: return "AWS::Redshift::EventSubscription"
            case .regexpatternsetv2: return "AWS::WAFv2::RegexPatternSet"
            case .regionalprotection: return "AWS::ShieldRegional::Protection"
            case .regionalratebasedrule: return "AWS::WAFRegional::RateBasedRule"
            case .regionalrule: return "AWS::WAFRegional::Rule"
            case .regionalrulegroup: return "AWS::WAFRegional::RuleGroup"
            case .regionalwebacl: return "AWS::WAFRegional::WebACL"
            case .registeredhainstance: return "AWS::EC2::RegisteredHAInstance"
            case .resourcecompliance: return "AWS::Config::ResourceCompliance"
            case .restapi: return "AWS::ApiGateway::RestApi"
            case .role: return "AWS::IAM::Role"
            case .route53hostedzone: return "AWS::Route53::HostedZone"
            case .route53resolverresolverendpoint: return "AWS::Route53Resolver::ResolverEndpoint"
            case .route53resolverresolverrule: return "AWS::Route53Resolver::ResolverRule"
            case .route53resolverresolverruleassociation: return "AWS::Route53Resolver::ResolverRuleAssociation"
            case .routetable: return "AWS::EC2::RouteTable"
            case .rule: return "AWS::WAF::Rule"
            case .rulegroup: return "AWS::WAF::RuleGroup"
            case .rulegroupv2: return "AWS::WAFv2::RuleGroup"
            case .sesconfigurationset: return "AWS::SES::ConfigurationSet"
            case .sescontactlist: return "AWS::SES::ContactList"
            case .sagemakercoderepository: return "AWS::SageMaker::CodeRepository"
            case .sagemakermodel: return "AWS::SageMaker::Model"
            case .sagemakernotebookinstancelifecycleconfig: return "AWS::SageMaker::NotebookInstanceLifecycleConfig"
            case .sagemakerworkteam: return "AWS::SageMaker::Workteam"
            case .scalingpolicy: return "AWS::AutoScaling::ScalingPolicy"
            case .scheduledaction: return "AWS::AutoScaling::ScheduledAction"
            case .secret: return "AWS::SecretsManager::Secret"
            case .securitygroup: return "AWS::EC2::SecurityGroup"
            case .servicediscoverypublicdnsnamespace: return "AWS::ServiceDiscovery::PublicDnsNamespace"
            case .servicediscoveryservice: return "AWS::ServiceDiscovery::Service"
            case .stack: return "AWS::CloudFormation::Stack"
            case .stage: return "AWS::ApiGateway::Stage"
            case .stagev2: return "AWS::ApiGatewayV2::Stage"
            case .stepfunctionsactivity: return "AWS::StepFunctions::Activity"
            case .stepfunctionsstatemachine: return "AWS::StepFunctions::StateMachine"
            case .streamingdistribution: return "AWS::CloudFront::StreamingDistribution"
            case .subnet: return "AWS::EC2::Subnet"
            case .table: return "AWS::DynamoDB::Table"
            case .topic: return "AWS::SNS::Topic"
            case .trail: return "AWS::CloudTrail::Trail"
            case .transitgateway: return "AWS::EC2::TransitGateway"
            case .transitgatewayattachment: return "AWS::EC2::TransitGatewayAttachment"
            case .transitgatewayroutetable: return "AWS::EC2::TransitGatewayRouteTable"
            case .user: return "AWS::IAM::User"
            case .vpc: return "AWS::EC2::VPC"
            case .vpcendpoint: return "AWS::EC2::VPCEndpoint"
            case .vpcendpointservice: return "AWS::EC2::VPCEndpointService"
            case .vpcpeeringconnection: return "AWS::EC2::VPCPeeringConnection"
            case .vpnconnection: return "AWS::EC2::VPNConnection"
            case .vpngateway: return "AWS::EC2::VPNGateway"
            case .volume: return "AWS::EC2::Volume"
            case .webacl: return "AWS::WAF::WebACL"
            case .webaclv2: return "AWS::WAFv2::WebACL"
            case .workspacesconnectionalias: return "AWS::WorkSpaces::ConnectionAlias"
            case .workspacesworkspace: return "AWS::WorkSpaces::Workspace"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.ResourceValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceValueType.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConfigClientTypes {
    /// The dynamic value of the resource.
    public struct ResourceValue: Swift.Equatable {
        /// The value is a resource ID.
        /// This member is required.
        public var value: ConfigClientTypes.ResourceValueType?

        public init (
            value: ConfigClientTypes.ResourceValueType? = nil
        )
        {
            self.value = value
        }
    }

}

extension ConfigClientTypes {
    public enum ResourceValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resourceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceValueType] {
            return [
                .resourceId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceId: return "RESOURCE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceValueType(rawValue: rawValue) ?? ResourceValueType.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.RetentionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if retentionPeriodInDays != 0 {
            try encodeContainer.encode(retentionPeriodInDays, forKey: .retentionPeriodInDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let retentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodInDays) ?? 0
        retentionPeriodInDays = retentionPeriodInDaysDecoded
    }
}

extension ConfigClientTypes {
    /// An object with the name of the retention configuration and the retention period in days. The object stores the configuration for data retention in Config.
    public struct RetentionConfiguration: Swift.Equatable {
        /// The name of the retention configuration object.
        /// This member is required.
        public var name: Swift.String?
        /// Number of days Config stores your historical information. Currently, only applicable to the configuration item history.
        /// This member is required.
        public var retentionPeriodInDays: Swift.Int

        public init (
            name: Swift.String? = nil,
            retentionPeriodInDays: Swift.Int = 0
        )
        {
            self.name = name
            self.retentionPeriodInDays = retentionPeriodInDays
        }
    }

}

extension ConfigClientTypes.Scope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceTypes = "ComplianceResourceTypes"
        case tagKey = "TagKey"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceResourceId = self.complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceTypes = complianceResourceTypes {
            var complianceResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceTypes)
            for stringwithcharlimit2560 in complianceResourceTypes {
                try complianceResourceTypesContainer.encode(stringwithcharlimit2560)
            }
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceTypes)
        var complianceResourceTypesDecoded0:[Swift.String]? = nil
        if let complianceResourceTypesContainer = complianceResourceTypesContainer {
            complianceResourceTypesDecoded0 = [Swift.String]()
            for string0 in complianceResourceTypesContainer {
                if let string0 = string0 {
                    complianceResourceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceResourceTypes = complianceResourceTypesDecoded0
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
    }
}

extension ConfigClientTypes {
    /// Defines which resources trigger an evaluation for an Config rule. The scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. Specify a scope to constrain which resources trigger an evaluation for a rule. Otherwise, evaluations for the rule are triggered when any resource in your recording group changes in configuration.
    public struct Scope: Swift.Equatable {
        /// The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for ComplianceResourceTypes.
        public var complianceResourceId: Swift.String?
        /// The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for ComplianceResourceId.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.
        public var tagKey: Swift.String?
        /// The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for TagValue, you must also specify a value for TagKey.
        public var tagValue: Swift.String?

        public init (
            complianceResourceId: Swift.String? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.complianceResourceId = complianceResourceId
            self.complianceResourceTypes = complianceResourceTypes
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }

}

extension SelectAggregateResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case expression = "Expression"
        case limit = "Limit"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = self.configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SelectAggregateResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SelectAggregateResourceConfigInput: Swift.Equatable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The SQL query SELECT command.
    /// This member is required.
    public var expression: Swift.String?
    /// The maximum number of query results returned on each page.
    public var limit: Swift.Int
    /// The maximum number of query results returned on each page. Config also allows the Limit request parameter.
    public var maxResults: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        configurationAggregatorName: Swift.String? = nil,
        expression: Swift.String? = nil,
        limit: Swift.Int = 0,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.expression = expression
        self.limit = limit
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SelectAggregateResourceConfigInputBody: Swift.Equatable {
    let expression: Swift.String?
    let configurationAggregatorName: Swift.String?
    let limit: Swift.Int
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension SelectAggregateResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case expression = "Expression"
        case limit = "Limit"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SelectAggregateResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SelectAggregateResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidExpressionException" : self = .invalidExpressionException(try InvalidExpressionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SelectAggregateResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidExpressionException(InvalidExpressionException)
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectAggregateResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SelectAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryInfo = output.queryInfo
            self.results = output.results
        } else {
            self.nextToken = nil
            self.queryInfo = nil
            self.results = nil
        }
    }
}

public struct SelectAggregateResourceConfigOutputResponse: Swift.Equatable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Details about the query.
    public var queryInfo: ConfigClientTypes.QueryInfo?
    /// Returns the results for the SQL query.
    public var results: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        queryInfo: ConfigClientTypes.QueryInfo? = nil,
        results: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

struct SelectAggregateResourceConfigOutputResponseBody: Swift.Equatable {
    let results: [Swift.String]?
    let queryInfo: ConfigClientTypes.QueryInfo?
    let nextToken: Swift.String?
}

extension SelectAggregateResourceConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryInfo = "QueryInfo"
        case results = "Results"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .results)
        var resultsDecoded0:[Swift.String]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [Swift.String]()
            for string0 in resultsContainer {
                if let string0 = string0 {
                    resultsDecoded0?.append(string0)
                }
            }
        }
        results = resultsDecoded0
        let queryInfoDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.QueryInfo.self, forKey: .queryInfo)
        queryInfo = queryInfoDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SelectResourceConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SelectResourceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SelectResourceConfigInput: Swift.Equatable {
    /// The SQL query SELECT command.
    /// This member is required.
    public var expression: Swift.String?
    /// The maximum number of query results returned on each page.
    public var limit: Swift.Int
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init (
        expression: Swift.String? = nil,
        limit: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.expression = expression
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct SelectResourceConfigInputBody: Swift.Equatable {
    let expression: Swift.String?
    let limit: Swift.Int
    let nextToken: Swift.String?
}

extension SelectResourceConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SelectResourceConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SelectResourceConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidExpressionException" : self = .invalidExpressionException(try InvalidExpressionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SelectResourceConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidExpressionException(InvalidExpressionException)
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectResourceConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SelectResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryInfo = output.queryInfo
            self.results = output.results
        } else {
            self.nextToken = nil
            self.queryInfo = nil
            self.results = nil
        }
    }
}

public struct SelectResourceConfigOutputResponse: Swift.Equatable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns the QueryInfo object.
    public var queryInfo: ConfigClientTypes.QueryInfo?
    /// Returns the results for the SQL query.
    public var results: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        queryInfo: ConfigClientTypes.QueryInfo? = nil,
        results: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

struct SelectResourceConfigOutputResponseBody: Swift.Equatable {
    let results: [Swift.String]?
    let queryInfo: ConfigClientTypes.QueryInfo?
    let nextToken: Swift.String?
}

extension SelectResourceConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryInfo = "QueryInfo"
        case results = "Results"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .results)
        var resultsDecoded0:[Swift.String]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [Swift.String]()
            for string0 in resultsContainer {
                if let string0 = string0 {
                    resultsDecoded0?.append(string0)
                }
            }
        }
        results = resultsDecoded0
        let queryInfoDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.QueryInfo.self, forKey: .queryInfo)
        queryInfo = queryInfoDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ConfigClientTypes {
    public enum SortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case score
        case sdkUnknown(Swift.String)

        public static var allCases: [SortBy] {
            return [
                .score,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .score: return "SCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortBy(rawValue: rawValue) ?? SortBy.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ConfigClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customPolicyDetails = "CustomPolicyDetails"
        case owner = "Owner"
        case sourceDetails = "SourceDetails"
        case sourceIdentifier = "SourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customPolicyDetails = self.customPolicyDetails {
            try encodeContainer.encode(customPolicyDetails, forKey: .customPolicyDetails)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let sourceDetails = sourceDetails {
            var sourceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDetails)
            for sourcedetail0 in sourceDetails {
                try sourceDetailsContainer.encode(sourcedetail0)
            }
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceDetailsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.SourceDetail?].self, forKey: .sourceDetails)
        var sourceDetailsDecoded0:[ConfigClientTypes.SourceDetail]? = nil
        if let sourceDetailsContainer = sourceDetailsContainer {
            sourceDetailsDecoded0 = [ConfigClientTypes.SourceDetail]()
            for structure0 in sourceDetailsContainer {
                if let structure0 = structure0 {
                    sourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        sourceDetails = sourceDetailsDecoded0
        let customPolicyDetailsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.CustomPolicyDetails.self, forKey: .customPolicyDetails)
        customPolicyDetails = customPolicyDetailsDecoded
    }
}

extension ConfigClientTypes {
    /// Provides the CustomPolicyDetails, the rule owner (Amazon Web Services for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier, and the events that cause the evaluation of your Amazon Web Services resources.
    public struct Source: Swift.Equatable {
        /// Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to CUSTOM_POLICY.
        public var customPolicyDetails: ConfigClientTypes.CustomPolicyDetails?
        /// Indicates whether Amazon Web Services or the customer owns and manages the Config rule. Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see [Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html) in the Config developer guide. Config Custom Rules are rules that you can develop either with Guard (CUSTOM_POLICY) or Lambda (CUSTOM_LAMBDA). For more information, see [Config Custom Rules ](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html) in the Config developer guide.
        /// This member is required.
        public var owner: ConfigClientTypes.Owner?
        /// Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. If the owner is set to CUSTOM_POLICY, the only acceptable values for the Config rule trigger message type are ConfigurationItemChangeNotification and OversizedConfigurationItemChangeNotification.
        public var sourceDetails: [ConfigClientTypes.SourceDetail]?
        /// For Config Managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see [List of Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name. For Config Custom Policy rules, this field will be ignored.
        public var sourceIdentifier: Swift.String?

        public init (
            customPolicyDetails: ConfigClientTypes.CustomPolicyDetails? = nil,
            owner: ConfigClientTypes.Owner? = nil,
            sourceDetails: [ConfigClientTypes.SourceDetail]? = nil,
            sourceIdentifier: Swift.String? = nil
        )
        {
            self.customPolicyDetails = customPolicyDetails
            self.owner = owner
            self.sourceDetails = sourceDetails
            self.sourceIdentifier = sourceIdentifier
        }
    }

}

extension ConfigClientTypes.SourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSource = "EventSource"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case messageType = "MessageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource.rawValue, forKey: .eventSource)
        }
        if let maximumExecutionFrequency = self.maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EventSource.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
    }
}

extension ConfigClientTypes {
    /// Provides the source and the message types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. You can specify the parameter values for SourceDetail only for custom rules.
    public struct SourceDetail: Swift.Equatable {
        /// The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.
        public var eventSource: ConfigClientTypes.EventSource?
        /// The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for MaximumExecutionFrequency, then MessageType must use the ScheduledNotification value. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter. Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose Three_Hours, Config runs evaluations once every three hours. In this case, Three_Hours is the frequency of this rule.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        ///
        /// * ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        ///
        /// * ConfigurationSnapshotDeliveryCompleted - Triggers a periodic evaluation when Config delivers a configuration snapshot.
        ///
        ///
        /// If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for ConfigurationItemChangeNotification and one for OversizedConfigurationItemChangeNotification.
        public var messageType: ConfigClientTypes.MessageType?

        public init (
            eventSource: ConfigClientTypes.EventSource? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            messageType: ConfigClientTypes.MessageType? = nil
        )
        {
            self.eventSource = eventSource
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.messageType = messageType
        }
    }

}

extension ConfigClientTypes.SsmControls: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case concurrentExecutionRatePercentage = "ConcurrentExecutionRatePercentage"
        case errorPercentage = "ErrorPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentExecutionRatePercentage = self.concurrentExecutionRatePercentage {
            try encodeContainer.encode(concurrentExecutionRatePercentage, forKey: .concurrentExecutionRatePercentage)
        }
        if let errorPercentage = self.errorPercentage {
            try encodeContainer.encode(errorPercentage, forKey: .errorPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentExecutionRatePercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .concurrentExecutionRatePercentage)
        concurrentExecutionRatePercentage = concurrentExecutionRatePercentageDecoded
        let errorPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorPercentage)
        errorPercentage = errorPercentageDecoded
    }
}

extension ConfigClientTypes {
    /// Amazon Web Services Systems Manager (SSM) specific remediation controls.
    public struct SsmControls: Swift.Equatable {
        /// The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10.
        public var concurrentExecutionRatePercentage: Swift.Int?
        /// The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received.
        public var errorPercentage: Swift.Int?

        public init (
            concurrentExecutionRatePercentage: Swift.Int? = nil,
            errorPercentage: Swift.Int? = nil
        )
        {
            self.concurrentExecutionRatePercentage = concurrentExecutionRatePercentage
            self.errorPercentage = errorPercentage
        }
    }

}

extension StartConfigRulesEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulename0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulename0)
            }
        }
    }
}

extension StartConfigRulesEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartConfigRulesEvaluationInput: Swift.Equatable {
    /// The list of names of Config rules that you want to run evaluations for.
    public var configRuleNames: [Swift.String]?

    public init (
        configRuleNames: [Swift.String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

struct StartConfigRulesEvaluationInputBody: Swift.Equatable {
    let configRuleNames: [Swift.String]?
}

extension StartConfigRulesEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[Swift.String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [Swift.String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
    }
}

extension StartConfigRulesEvaluationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConfigRulesEvaluationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartConfigRulesEvaluationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConfigRulesEvaluationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The output when you start the evaluation for the specified Config rule.
public struct StartConfigRulesEvaluationOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartConfigurationRecorderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = self.configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

extension StartConfigurationRecorderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [StartConfigurationRecorder] action.
public struct StartConfigurationRecorderInput: Swift.Equatable {
    /// The name of the recorder object that records each configuration change made to the resources.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init (
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct StartConfigurationRecorderInputBody: Swift.Equatable {
    let configurationRecorderName: Swift.String?
}

extension StartConfigurationRecorderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension StartConfigurationRecorderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConfigurationRecorderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoAvailableDeliveryChannelException" : self = .noAvailableDeliveryChannelException(try NoAvailableDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartConfigurationRecorderOutputError: Swift.Error, Swift.Equatable {
    case noAvailableDeliveryChannelException(NoAvailableDeliveryChannelException)
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConfigurationRecorderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartConfigurationRecorderOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartRemediationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = self.configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekey0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekey0)
            }
        }
    }
}

extension StartRemediationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRemediationExecutionInput: Swift.Equatable {
    /// The list of names of Config rules that you want to run remediation execution for.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init (
        configRuleName: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

struct StartRemediationExecutionInputBody: Swift.Equatable {
    let configRuleName: Swift.String?
    let resourceKeys: [ConfigClientTypes.ResourceKey]?
}

extension StartRemediationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ConfigClientTypes.ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ConfigClientTypes.ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension StartRemediationExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRemediationExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartRemediationExecutionOutputError: Swift.Error, Swift.Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRemediationExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartRemediationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedItems = output.failedItems
            self.failureMessage = output.failureMessage
        } else {
            self.failedItems = nil
            self.failureMessage = nil
        }
    }
}

public struct StartRemediationExecutionOutputResponse: Swift.Equatable {
    /// For resources that have failed to start execution, the API returns a resource key object.
    public var failedItems: [ConfigClientTypes.ResourceKey]?
    /// Returns a failure message. For example, the resource is already compliant.
    public var failureMessage: Swift.String?

    public init (
        failedItems: [ConfigClientTypes.ResourceKey]? = nil,
        failureMessage: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

struct StartRemediationExecutionOutputResponseBody: Swift.Equatable {
    let failureMessage: Swift.String?
    let failedItems: [ConfigClientTypes.ResourceKey]?
}

extension StartRemediationExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.ResourceKey?].self, forKey: .failedItems)
        var failedItemsDecoded0:[ConfigClientTypes.ResourceKey]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [ConfigClientTypes.ResourceKey]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension StartResourceEvaluationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case evaluationContext = "EvaluationContext"
        case evaluationMode = "EvaluationMode"
        case evaluationTimeout = "EvaluationTimeout"
        case resourceDetails = "ResourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let evaluationContext = self.evaluationContext {
            try encodeContainer.encode(evaluationContext, forKey: .evaluationContext)
        }
        if let evaluationMode = self.evaluationMode {
            try encodeContainer.encode(evaluationMode.rawValue, forKey: .evaluationMode)
        }
        if evaluationTimeout != 0 {
            try encodeContainer.encode(evaluationTimeout, forKey: .evaluationTimeout)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
    }
}

extension StartResourceEvaluationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartResourceEvaluationInput: Swift.Equatable {
    /// A client token is a unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request using one of these actions, specify a client token in the request. Avoid reusing the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, other than the Region or Availability Zone, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Returns an EvaluationContext object.
    public var evaluationContext: ConfigClientTypes.EvaluationContext?
    /// The mode of an evaluation. The valid value for this API is Proactive.
    /// This member is required.
    public var evaluationMode: ConfigClientTypes.EvaluationMode?
    /// The timeout for an evaluation. The default is 900 seconds. You cannot specify a number greater than 3600. If you specify 0, Config uses the default.
    public var evaluationTimeout: Swift.Int
    /// Returns a ResourceDetails object.
    /// This member is required.
    public var resourceDetails: ConfigClientTypes.ResourceDetails?

    public init (
        clientToken: Swift.String? = nil,
        evaluationContext: ConfigClientTypes.EvaluationContext? = nil,
        evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
        evaluationTimeout: Swift.Int = 0,
        resourceDetails: ConfigClientTypes.ResourceDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.evaluationContext = evaluationContext
        self.evaluationMode = evaluationMode
        self.evaluationTimeout = evaluationTimeout
        self.resourceDetails = resourceDetails
    }
}

struct StartResourceEvaluationInputBody: Swift.Equatable {
    let resourceDetails: ConfigClientTypes.ResourceDetails?
    let evaluationContext: ConfigClientTypes.EvaluationContext?
    let evaluationMode: ConfigClientTypes.EvaluationMode?
    let evaluationTimeout: Swift.Int
    let clientToken: Swift.String?
}

extension StartResourceEvaluationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case evaluationContext = "EvaluationContext"
        case evaluationMode = "EvaluationMode"
        case evaluationTimeout = "EvaluationTimeout"
        case resourceDetails = "ResourceDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let evaluationContextDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationContext.self, forKey: .evaluationContext)
        evaluationContext = evaluationContextDecoded
        let evaluationModeDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.EvaluationMode.self, forKey: .evaluationMode)
        evaluationMode = evaluationModeDecoded
        let evaluationTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationTimeout) ?? 0
        evaluationTimeout = evaluationTimeoutDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartResourceEvaluationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartResourceEvaluationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartResourceEvaluationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartResourceEvaluationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartResourceEvaluationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceEvaluationId = output.resourceEvaluationId
        } else {
            self.resourceEvaluationId = nil
        }
    }
}

public struct StartResourceEvaluationOutputResponse: Swift.Equatable {
    /// A unique ResourceEvaluationId that is associated with a single execution.
    public var resourceEvaluationId: Swift.String?

    public init (
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.resourceEvaluationId = resourceEvaluationId
    }
}

struct StartResourceEvaluationOutputResponseBody: Swift.Equatable {
    let resourceEvaluationId: Swift.String?
}

extension StartResourceEvaluationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEvaluationId = "ResourceEvaluationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEvaluationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEvaluationId)
        resourceEvaluationId = resourceEvaluationIdDecoded
    }
}

extension ConfigClientTypes.StaticValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringwithcharlimit2560 in values {
                try valuesContainer.encode(stringwithcharlimit2560)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ConfigClientTypes {
    /// The static value of the resource.
    public struct StaticValue: Swift.Equatable {
        /// A list of values. For example, the ARN of the assumed role.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension ConfigClientTypes.StatusDetailFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case memberAccountRuleStatus = "MemberAccountRuleStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let memberAccountRuleStatus = self.memberAccountRuleStatus {
            try encodeContainer.encode(memberAccountRuleStatus.rawValue, forKey: .memberAccountRuleStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let memberAccountRuleStatusDecoded = try containerValues.decodeIfPresent(ConfigClientTypes.MemberAccountRuleStatus.self, forKey: .memberAccountRuleStatus)
        memberAccountRuleStatus = memberAccountRuleStatusDecoded
    }
}

extension ConfigClientTypes {
    /// Status filter object to filter results based on specific member account ID or status type for an organization Config rule.
    public struct StatusDetailFilters: Swift.Equatable {
        /// The 12-digit account ID of the member account within an organization.
        public var accountId: Swift.String?
        /// Indicates deployment status for Config rule in the member account. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when Config rule has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when Config rule is being created in the member account.
        ///
        /// * CREATE_FAILED when Config rule creation has failed in the member account.
        ///
        /// * DELETE_FAILED when Config rule deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when Config rule is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when Config rule has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when Config rule has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when Config rule is being updated in the member account.
        ///
        /// * UPDATE_FAILED when Config rule deletion has failed in the member account.
        public var memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus?

        public init (
            accountId: Swift.String? = nil,
            memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus? = nil
        )
        {
            self.accountId = accountId
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }
    }

}

extension StopConfigurationRecorderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = self.configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

extension StopConfigurationRecorderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The input for the [StopConfigurationRecorder] action.
public struct StopConfigurationRecorderInput: Swift.Equatable {
    /// The name of the recorder object that records each configuration change made to the resources.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init (
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct StopConfigurationRecorderInputBody: Swift.Equatable {
    let configurationRecorderName: Swift.String?
}

extension StopConfigurationRecorderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension StopConfigurationRecorderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopConfigurationRecorderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopConfigurationRecorderOutputError: Swift.Error, Swift.Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopConfigurationRecorderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopConfigurationRecorderOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConfigClientTypes.StoredQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case queryArn = "QueryArn"
        case queryId = "QueryId"
        case queryName = "QueryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let queryArn = self.queryArn {
            try encodeContainer.encode(queryArn, forKey: .queryArn)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryName = self.queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
        let queryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryName)
        queryName = queryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension ConfigClientTypes {
    /// Provides the details of a stored query.
    public struct StoredQuery: Swift.Equatable {
        /// A unique description for the query.
        public var description: Swift.String?
        /// The expression of the query. For example, SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.
        public var expression: Swift.String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public var queryArn: Swift.String?
        /// The ID of the query.
        public var queryId: Swift.String?
        /// The name of the query.
        /// This member is required.
        public var queryName: Swift.String?

        public init (
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            queryArn: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryName: Swift.String? = nil
        )
        {
            self.description = description
            self.expression = expression
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }
    }

}

extension ConfigClientTypes.StoredQueryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryArn = "QueryArn"
        case queryId = "QueryId"
        case queryName = "QueryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryArn = self.queryArn {
            try encodeContainer.encode(queryArn, forKey: .queryArn)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryName = self.queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
        let queryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryName)
        queryName = queryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ConfigClientTypes {
    /// Returns details of a specific query.
    public struct StoredQueryMetadata: Swift.Equatable {
        /// A unique description for the query.
        public var description: Swift.String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        /// This member is required.
        public var queryArn: Swift.String?
        /// The ID of the query.
        /// This member is required.
        public var queryId: Swift.String?
        /// The name of the query.
        /// This member is required.
        public var queryName: Swift.String?

        public init (
            description: Swift.String? = nil,
            queryArn: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryName: Swift.String? = nil
        )
        {
            self.description = description
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }
    }

}

extension ConfigClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConfigClientTypes {
    /// The tags for the resource. The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag object.
    /// This member is required.
    public var tags: [ConfigClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ConfigClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ConfigClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConfigClientTypes.TemplateSSMDocumentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = self.documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
    }
}

extension ConfigClientTypes {
    /// This API allows you to create a conformance pack template with an Amazon Web Services Systems Manager document (SSM document). To deploy a conformance pack using an SSM document, first create an SSM document with conformance pack content, and then provide the DocumentName in the [PutConformancePack API](https://docs.aws.amazon.com/config/latest/APIReference/API_PutConformancePack.html). You can also provide the DocumentVersion. The TemplateSSMDocumentDetails object contains the name of the SSM document and the version of the SSM document.
    public struct TemplateSSMDocumentDetails: Swift.Equatable {
        /// The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document. If you want to use an SSM document from another Region or account, you must provide the ARN.
        /// This member is required.
        public var documentName: Swift.String?
        /// The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version. This field is optional.
        public var documentVersion: Swift.String?

        public init (
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
        }
    }

}

extension ConfigClientTypes.TimeWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ConfigClientTypes {
    /// Filters evaluation results based on start and end times.
    public struct TimeWindow: Swift.Equatable {
        /// The end time of an execution. The end time must be after the start date.
        public var endTime: ClientRuntime.Date?
        /// The start time of an execution.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the limit of the number of tags you can use. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested action is invalid. For PutStoredQuery, you will see this exception if there are missing required fields or if the input value fails the validation, or if you are trying to create more than 300 queries. For GetStoredQuery, ListStoredQuery, and DeleteStoredQuery you will see this exception if there are missing required fields or if the input value fails the validation.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Error executing the command
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
