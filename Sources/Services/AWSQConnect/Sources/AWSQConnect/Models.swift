//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The throttling limit has been exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by a service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ActivateMessageTemplateInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The version number of the message template version to activate.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
        self.versionNumber = versionNumber
    }
}

public struct ActivateMessageTemplateOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the message template.
    /// This member is required.
    public var messageTemplateArn: Swift.String?
    /// The identifier of the message template.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The version number of the message template version that is activated.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        messageTemplateArn: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.messageTemplateArn = messageTemplateArn
        self.messageTemplateId = messageTemplateId
        self.versionNumber = versionNumber
    }
}

extension QConnectClientTypes {

    /// Information about an agent.
    public struct AgentAttributes: Swift.Sendable {
        /// The agent’s first name as entered in their Amazon Connect user account.
        public var firstName: Swift.String?
        /// The agent’s last name as entered in their Amazon Connect user account.
        public var lastName: Swift.String?

        public init(
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        ) {
            self.firstName = firstName
            self.lastName = lastName
        }
    }
}

extension QConnectClientTypes.AgentAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentAttributes(firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

/// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension QConnectClientTypes {

    /// A leaf node condition which can be used to specify a tag condition.
    public struct TagCondition: Swift.Sendable {
        /// The tag key in the tag condition.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value in the tag condition.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension QConnectClientTypes {

    /// A list of conditions which would be applied together with an OR condition.
    public enum OrCondition: Swift.Sendable {
        /// A list of conditions which would be applied together with an AND condition.
        case andconditions([QConnectClientTypes.TagCondition])
        /// A leaf node condition which can be used to specify a tag condition.
        case tagcondition(QConnectClientTypes.TagCondition)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// An object that can be used to specify Tag conditions.
    public enum TagFilter: Swift.Sendable {
        /// A leaf node condition which can be used to specify a tag condition.
        case tagcondition(QConnectClientTypes.TagCondition)
        /// A list of conditions which would be applied together with an AND condition.
        case andconditions([QConnectClientTypes.TagCondition])
        /// A list of conditions which would be applied together with an OR condition.
        case orconditions([QConnectClientTypes.OrCondition])
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum KnowledgeBaseSearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseSearchType] {
            return [
                .hybrid,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The data of the configuration for a KNOWLEDGE_BASE type Amazon Q in Connect Assistant Association.
    public struct KnowledgeBaseAssociationConfigurationData: Swift.Sendable {
        /// An object that can be used to specify Tag conditions.
        public var contentTagFilter: QConnectClientTypes.TagFilter?
        /// The maximum number of results to return per page.
        public var maxResults: Swift.Int?
        /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text
        public var overrideKnowledgeBaseSearchType: QConnectClientTypes.KnowledgeBaseSearchType?

        public init(
            contentTagFilter: QConnectClientTypes.TagFilter? = nil,
            maxResults: Swift.Int? = nil,
            overrideKnowledgeBaseSearchType: QConnectClientTypes.KnowledgeBaseSearchType? = nil
        ) {
            self.contentTagFilter = contentTagFilter
            self.maxResults = maxResults
            self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
        }
    }
}

extension QConnectClientTypes {

    /// A typed union of the data of the configuration for an Amazon Q in Connect Assistant Association.
    public enum AssociationConfigurationData: Swift.Sendable {
        /// The data of the configuration for a KNOWLEDGE_BASE type Amazon Q in Connect Assistant Association.
        case knowledgebaseassociationconfigurationdata(QConnectClientTypes.KnowledgeBaseAssociationConfigurationData)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum AIAgentAssociationConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AIAgentAssociationConfigurationType] {
            return [
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The configuration for an Amazon Q in Connect Assistant Association.
    public struct AssociationConfiguration: Swift.Sendable {
        /// The data of the configuration for an Amazon Q in Connect Assistant Association.
        public var associationConfigurationData: QConnectClientTypes.AssociationConfigurationData?
        /// The identifier of the association for this Association Configuration.
        public var associationId: Swift.String?
        /// The type of the association for this Association Configuration.
        public var associationType: QConnectClientTypes.AIAgentAssociationConfigurationType?

        public init(
            associationConfigurationData: QConnectClientTypes.AssociationConfigurationData? = nil,
            associationId: Swift.String? = nil,
            associationType: QConnectClientTypes.AIAgentAssociationConfigurationType? = nil
        ) {
            self.associationConfigurationData = associationConfigurationData
            self.associationId = associationId
            self.associationType = associationType
        }
    }
}

extension QConnectClientTypes {

    /// The configuration for the ANSWER_RECOMMENDATION AI Agent type.
    public struct AnswerRecommendationAIAgentConfiguration: Swift.Sendable {
        /// The AI Guardrail identifier for the Answer Generation Guardrail used by the ANSWER_RECOMMENDATION AI Agent.
        public var answerGenerationAIGuardrailId: Swift.String?
        /// The AI Prompt identifier for the Answer Generation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public var answerGenerationAIPromptId: Swift.String?
        /// The association configurations for overriding behavior on this AI Agent.
        public var associationConfigurations: [QConnectClientTypes.AssociationConfiguration]?
        /// The AI Prompt identifier for the Intent Labeling prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public var intentLabelingGenerationAIPromptId: Swift.String?
        /// The locale to which specifies the language and region settings that determine the response language for [QueryAssistant](https://docs.aws.amazon.com/connect/latest/APIReference/API_amazon-q-connect_QueryAssistant.html). Changing this locale to anything other than en_US will turn off recommendations triggered by contact transcripts for agent assistance, as this feature is not supported in multiple languages.
        public var locale: Swift.String?
        /// The AI Prompt identifier for the Query Reformulation prompt used by the ANSWER_RECOMMENDATION AI Agent.
        public var queryReformulationAIPromptId: Swift.String?

        public init(
            answerGenerationAIGuardrailId: Swift.String? = nil,
            answerGenerationAIPromptId: Swift.String? = nil,
            associationConfigurations: [QConnectClientTypes.AssociationConfiguration]? = nil,
            intentLabelingGenerationAIPromptId: Swift.String? = nil,
            locale: Swift.String? = nil,
            queryReformulationAIPromptId: Swift.String? = nil
        ) {
            self.answerGenerationAIGuardrailId = answerGenerationAIGuardrailId
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
            self.intentLabelingGenerationAIPromptId = intentLabelingGenerationAIPromptId
            self.locale = locale
            self.queryReformulationAIPromptId = queryReformulationAIPromptId
        }
    }
}

extension QConnectClientTypes {

    /// The configuration for the MANUAL_SEARCH AI Agent type.
    public struct ManualSearchAIAgentConfiguration: Swift.Sendable {
        /// The AI Guardrail identifier for the Answer Generation guardrail used by the MANUAL_SEARCH AI Agent.
        public var answerGenerationAIGuardrailId: Swift.String?
        /// The AI Prompt identifier for the Answer Generation prompt used by the MANUAL_SEARCH AI Agent.
        public var answerGenerationAIPromptId: Swift.String?
        /// The association configurations for overriding behavior on this AI Agent.
        public var associationConfigurations: [QConnectClientTypes.AssociationConfiguration]?
        /// The locale to which specifies the language and region settings that determine the response language for [QueryAssistant](https://docs.aws.amazon.com/connect/latest/APIReference/API_amazon-q-connect_QueryAssistant.html).
        public var locale: Swift.String?

        public init(
            answerGenerationAIGuardrailId: Swift.String? = nil,
            answerGenerationAIPromptId: Swift.String? = nil,
            associationConfigurations: [QConnectClientTypes.AssociationConfiguration]? = nil,
            locale: Swift.String? = nil
        ) {
            self.answerGenerationAIGuardrailId = answerGenerationAIGuardrailId
            self.answerGenerationAIPromptId = answerGenerationAIPromptId
            self.associationConfigurations = associationConfigurations
            self.locale = locale
        }
    }
}

extension QConnectClientTypes {

    /// The configuration for AI Agents of type SELF_SERVICE.
    public struct SelfServiceAIAgentConfiguration: Swift.Sendable {
        /// The association configurations for overriding behavior on this AI Agent.
        public var associationConfigurations: [QConnectClientTypes.AssociationConfiguration]?
        /// The AI Guardrail identifier used by the SELF_SERVICE AI Agent.
        public var selfServiceAIGuardrailId: Swift.String?
        /// The AI Prompt identifier for the Self Service Answer Generation prompt used by the SELF_SERVICE AI Agent
        public var selfServiceAnswerGenerationAIPromptId: Swift.String?
        /// The AI Prompt identifier for the Self Service Pre-Processing prompt used by the SELF_SERVICE AI Agent
        public var selfServicePreProcessingAIPromptId: Swift.String?

        public init(
            associationConfigurations: [QConnectClientTypes.AssociationConfiguration]? = nil,
            selfServiceAIGuardrailId: Swift.String? = nil,
            selfServiceAnswerGenerationAIPromptId: Swift.String? = nil,
            selfServicePreProcessingAIPromptId: Swift.String? = nil
        ) {
            self.associationConfigurations = associationConfigurations
            self.selfServiceAIGuardrailId = selfServiceAIGuardrailId
            self.selfServiceAnswerGenerationAIPromptId = selfServiceAnswerGenerationAIPromptId
            self.selfServicePreProcessingAIPromptId = selfServicePreProcessingAIPromptId
        }
    }
}

extension QConnectClientTypes {

    /// A typed union that specifies the configuration based on the type of AI Agent.
    public enum AIAgentConfiguration: Swift.Sendable {
        /// The configuration for AI Agents of type MANUAL_SEARCH.
        case manualsearchaiagentconfiguration(QConnectClientTypes.ManualSearchAIAgentConfiguration)
        /// The configuration for AI Agents of type ANSWER_RECOMMENDATION.
        case answerrecommendationaiagentconfiguration(QConnectClientTypes.AnswerRecommendationAIAgentConfiguration)
        /// The configuration for AI Agents of type SELF_SERVICE.
        case selfserviceaiagentconfiguration(QConnectClientTypes.SelfServiceAIAgentConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum AIAgentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case answerRecommendation
        case manualSearch
        case selfService
        case sdkUnknown(Swift.String)

        public static var allCases: [AIAgentType] {
            return [
                .answerRecommendation,
                .manualSearch,
                .selfService
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .answerRecommendation: return "ANSWER_RECOMMENDATION"
            case .manualSearch: return "MANUAL_SEARCH"
            case .selfService: return "SELF_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum VisibilityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case published
        case saved
        case sdkUnknown(Swift.String)

        public static var allCases: [VisibilityStatus] {
            return [
                .published,
                .saved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .published: return "PUBLISHED"
            case .saved: return "SAVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAIAgentInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The configuration of the AI Agent.
    /// This member is required.
    public var configuration: QConnectClientTypes.AIAgentConfiguration?
    /// The description of the AI Agent.
    public var description: Swift.String?
    /// The name of the AI Agent.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the AI Agent.
    /// This member is required.
    public var type: QConnectClientTypes.AIAgentType?
    /// The visibility status of the AI Agent.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

    public init(
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: QConnectClientTypes.AIAgentConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: QConnectClientTypes.AIAgentType? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
    ) {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
        self.type = type
        self.visibilityStatus = visibilityStatus
    }
}

extension QConnectClientTypes {

    public enum Origin: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customer
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [Origin] {
            return [
                .customer,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customer: return "CUSTOMER"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The data for the AI Agent.
    public struct AIAgentData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI agent.
        /// This member is required.
        public var aiAgentArn: Swift.String?
        /// The identifier of the AI Agent.
        /// This member is required.
        public var aiAgentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// Configuration for the AI Agent.
        /// This member is required.
        public var configuration: QConnectClientTypes.AIAgentConfiguration?
        /// The description of the AI Agent.
        public var description: Swift.String?
        /// The time the AI Agent was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Agent.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public var origin: QConnectClientTypes.Origin?
        /// The status of the AI Agent.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the AI Agent.
        /// This member is required.
        public var type: QConnectClientTypes.AIAgentType?
        /// The visibility status of the AI Agent.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

        public init(
            aiAgentArn: Swift.String? = nil,
            aiAgentId: Swift.String? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            configuration: QConnectClientTypes.AIAgentConfiguration? = nil,
            description: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            origin: QConnectClientTypes.Origin? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: QConnectClientTypes.AIAgentType? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
        ) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }
    }
}

public struct CreateAIAgentOutput: Swift.Sendable {
    /// The data of the created AI Agent.
    public var aiAgent: QConnectClientTypes.AIAgentData?

    public init(
        aiAgent: QConnectClientTypes.AIAgentData? = nil
    ) {
        self.aiAgent = aiAgent
    }
}

public struct CreateAIAgentVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The modification time of the AI Agent should be tracked for version creation. This field should be specified to avoid version creation when simultaneous update to the underlying AI Agent are possible. The value should be the modifiedTime returned from the request to create or update an AI Agent so that version creation can fail if an update to the AI Agent post the specified modification time has been made.
    public var modifiedTime: Foundation.Date?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        modifiedTime: Foundation.Date? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.modifiedTime = modifiedTime
    }
}

public struct CreateAIAgentVersionOutput: Swift.Sendable {
    /// The data of the AI Agent version.
    public var aiAgent: QConnectClientTypes.AIAgentData?
    /// The version number of the AI Agent version.
    public var versionNumber: Swift.Int?

    public init(
        aiAgent: QConnectClientTypes.AIAgentData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiAgent = aiAgent
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIAgentInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
    }
}

public struct DeleteAIAgentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAIAgentVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The version number of the AI Agent version.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIAgentVersionOutput: Swift.Sendable {

    public init() { }
}

public struct GetAIAgentInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent (with or without a version qualifier). Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
    }
}

public struct GetAIAgentOutput: Swift.Sendable {
    /// The data of the AI Agent.
    public var aiAgent: QConnectClientTypes.AIAgentData?
    /// The version number of the AI Agent version (returned if an AI Agent version was specified via use of a qualifier for the aiAgentId on the request).
    public var versionNumber: Swift.Int?

    public init(
        aiAgent: QConnectClientTypes.AIAgentData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiAgent = aiAgent
        self.versionNumber = versionNumber
    }
}

public struct ListAIAgentsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The origin of the AI Agents to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
    public var origin: QConnectClientTypes.Origin?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: QConnectClientTypes.Origin? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Agent.
    public struct AIAgentSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI agent.
        /// This member is required.
        public var aiAgentArn: Swift.String?
        /// The identifier of the AI Agent.
        /// This member is required.
        public var aiAgentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The configuration for the AI Agent.
        public var configuration: QConnectClientTypes.AIAgentConfiguration?
        /// The description of the AI Agent.
        public var description: Swift.String?
        /// The time the AI Agent was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Agent.
        /// This member is required.
        public var name: Swift.String?
        /// The origin of the AI Agent. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
        public var origin: QConnectClientTypes.Origin?
        /// The status of the AI Agent.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the AI Agent.
        /// This member is required.
        public var type: QConnectClientTypes.AIAgentType?
        /// The visibility status of the AI Agent.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

        public init(
            aiAgentArn: Swift.String? = nil,
            aiAgentId: Swift.String? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            configuration: QConnectClientTypes.AIAgentConfiguration? = nil,
            description: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            origin: QConnectClientTypes.Origin? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: QConnectClientTypes.AIAgentType? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
        ) {
            self.aiAgentArn = aiAgentArn
            self.aiAgentId = aiAgentId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.configuration = configuration
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.type = type
            self.visibilityStatus = visibilityStatus
        }
    }
}

public struct ListAIAgentsOutput: Swift.Sendable {
    /// The summaries of AI Agents.
    /// This member is required.
    public var aiAgentSummaries: [QConnectClientTypes.AIAgentSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiAgentSummaries: [QConnectClientTypes.AIAgentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiAgentSummaries = aiAgentSummaries
        self.nextToken = nextToken
    }
}

public struct ListAIAgentVersionsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent for which versions are to be listed.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The origin of the AI Agent versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
    public var origin: QConnectClientTypes.Origin?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: QConnectClientTypes.Origin? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Agent version.
    public struct AIAgentVersionSummary: Swift.Sendable {
        /// The data for the summary of the AI Agent version.
        public var aiAgentSummary: QConnectClientTypes.AIAgentSummary?
        /// The version number for this AI Agent version.
        public var versionNumber: Swift.Int?

        public init(
            aiAgentSummary: QConnectClientTypes.AIAgentSummary? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.aiAgentSummary = aiAgentSummary
            self.versionNumber = versionNumber
        }
    }
}

public struct ListAIAgentVersionsOutput: Swift.Sendable {
    /// The summaries of AI Agent versions.
    /// This member is required.
    public var aiAgentVersionSummaries: [QConnectClientTypes.AIAgentVersionSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiAgentVersionSummaries: [QConnectClientTypes.AIAgentVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiAgentVersionSummaries = aiAgentVersionSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAIAgentInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Agent.
    /// This member is required.
    public var aiAgentId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The configuration of the Amazon Q in Connect AI Agent.
    public var configuration: QConnectClientTypes.AIAgentConfiguration?
    /// The description of the Amazon Q in Connect AI Agent.
    public var description: Swift.String?
    /// The visbility status of the Amazon Q in Connect AI Agent.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

    public init(
        aiAgentId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configuration: QConnectClientTypes.AIAgentConfiguration? = nil,
        description: Swift.String? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
    ) {
        self.aiAgentId = aiAgentId
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.visibilityStatus = visibilityStatus
    }
}

public struct UpdateAIAgentOutput: Swift.Sendable {
    /// The data of the updated Amazon Q in Connect AI Agent.
    public var aiAgent: QConnectClientTypes.AIAgentData?

    public init(
        aiAgent: QConnectClientTypes.AIAgentData? = nil
    ) {
        self.aiAgent = aiAgent
    }
}

extension QConnectClientTypes {

    /// A type that specifies the AI Agent ID configuration data when mapping an AI Agents to be used for an AI Agent type on a session or assistant.
    public struct AIAgentConfigurationData: Swift.Sendable {
        /// The ID of the AI Agent to be configured.
        /// This member is required.
        public var aiAgentId: Swift.String?

        public init(
            aiAgentId: Swift.String? = nil
        ) {
            self.aiAgentId = aiAgentId
        }
    }
}

extension QConnectClientTypes {

    /// Strength for filters
    public enum GuardrailFilterStrength: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Type of text to text filter in content policy
    public enum GuardrailContentFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Contains filter strengths for harmful content. AI Guardrail's support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate: Describes input prompts and model responses that discriminate, criticize, insult, denounce, or dehumanize a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults: Describes input prompts and model responses that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual: Describes input prompts and model responses that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence: Describes input prompts and model responses that includes glorification of, or threats to inflict physical pain, hurt, or injury toward a person, group, or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence.
    public struct GuardrailContentFilterConfig: Swift.Sendable {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: QConnectClientTypes.GuardrailFilterStrength?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: QConnectClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: QConnectClientTypes.GuardrailContentFilterType?

        public init(
            inputStrength: QConnectClientTypes.GuardrailFilterStrength? = nil,
            outputStrength: QConnectClientTypes.GuardrailFilterStrength? = nil,
            type: QConnectClientTypes.GuardrailContentFilterType? = nil
        ) {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }
    }
}

extension QConnectClientTypes.GuardrailContentFilterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFilterConfig(inputStrength: \"CONTENT_REDACTED\", outputStrength: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Contains details about how to handle harmful content.
    public struct AIGuardrailContentPolicyConfig: Swift.Sendable {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        /// This member is required.
        public var filtersConfig: [QConnectClientTypes.GuardrailContentFilterConfig]?

        public init(
            filtersConfig: [QConnectClientTypes.GuardrailContentFilterConfig]? = nil
        ) {
            self.filtersConfig = filtersConfig
        }
    }
}

extension QConnectClientTypes {

    /// Type of contextual grounding filter
    public enum GuardrailContextualGroundingFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grounding
        case relevance
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingFilterType] {
            return [
                .grounding,
                .relevance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grounding: return "GROUNDING"
            case .relevance: return "RELEVANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The filter configuration details for the AI Guardrail's contextual grounding filter.
    public struct GuardrailContextualGroundingFilterConfig: Swift.Sendable {
        /// The threshold details for the AI Guardrail's contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double
        /// The filter type for the AI Guardrail's contextual grounding filter.
        /// This member is required.
        public var type: QConnectClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            threshold: Swift.Double = 0.0,
            type: QConnectClientTypes.GuardrailContextualGroundingFilterType? = nil
        ) {
            self.threshold = threshold
            self.type = type
        }
    }
}

extension QConnectClientTypes.GuardrailContextualGroundingFilterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContextualGroundingFilterConfig(threshold: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The policy configuration details for the AI Guardrail's contextual grounding policy.
    public struct AIGuardrailContextualGroundingPolicyConfig: Swift.Sendable {
        /// The filter configuration details for the AI Guardrails contextual grounding policy.
        /// This member is required.
        public var filtersConfig: [QConnectClientTypes.GuardrailContextualGroundingFilterConfig]?

        public init(
            filtersConfig: [QConnectClientTypes.GuardrailContextualGroundingFilterConfig]? = nil
        ) {
            self.filtersConfig = filtersConfig
        }
    }
}

extension QConnectClientTypes {

    /// Options for sensitive information action.
    public enum GuardrailSensitiveInformationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymize
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationAction] {
            return [
                .anonymize,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymize: return "ANONYMIZE"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The currently supported PII entities
    public enum GuardrailPiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The PII entity to configure for the AI Guardrail.
    public struct GuardrailPiiEntityConfig: Swift.Sendable {
        /// Configure AI Guardrail's action when the PII entity is detected.
        /// This member is required.
        public var action: QConnectClientTypes.GuardrailSensitiveInformationAction?
        /// Configure AI Guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:
        ///
        /// * General
        ///
        /// * ADDRESS A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        ///
        /// * AGE An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age.
        ///
        /// * NAME An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. AI Guardrail doesn't apply this entity type to names that are part of organizations or addresses. For example, AI Guardrail recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        ///
        /// * EMAIL An email address, such as marymajor@email.com.
        ///
        /// * PHONE A phone number. This entity type also includes fax and pager numbers.
        ///
        /// * USERNAME A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        ///
        /// * PASSWORD An alphanumeric string that is used as a password, such as "* very20special#pass*".
        ///
        /// * DRIVER_ID The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        ///
        /// * LICENSE_PLATE A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        ///
        /// * VEHICLE_IDENTIFICATION_NUMBER A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the ISO 3779 specification. Each country has specific codes and formats for VINs.
        ///
        ///
        ///
        ///
        /// * Finance
        ///
        /// * CREDIT_DEBIT_CARD_CVV A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        ///
        /// * CREDIT_DEBIT_CARD_EXPIRY The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as month/year or MM/YY. AI Guardrail recognizes expiration dates such as 01/21, 01/2021, and Jan 2021.
        ///
        /// * CREDIT_DEBIT_CARD_NUMBER The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        ///
        /// * PIN A four-digit personal identification number (PIN) with which you can access your bank account.
        ///
        /// * INTERNATIONAL_BANK_ACCOUNT_NUMBER An International Bank Account Number has specific formats in each country. For more information, see [ www.iban.com/structure](https://www.iban.com/structure).
        ///
        /// * SWIFT_CODE A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        ///
        ///
        ///
        ///
        /// * IT
        ///
        /// * IP_ADDRESS An IPv4 address, such as 198.51.100.0.
        ///
        /// * MAC_ADDRESS A media access control (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        ///
        /// * URL A web address, such as www.example.com.
        ///
        /// * AWS_ACCESS_KEY A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        /// * AWS_SECRET_KEY A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        ///
        ///
        ///
        /// * USA specific
        ///
        /// * US_BANK_ACCOUNT_NUMBER A US bank account number, which is typically 10 to 12 digits long.
        ///
        /// * US_BANK_ROUTING_NUMBER A US bank account routing number. These are typically nine digits long,
        ///
        /// * US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        ///
        /// * US_PASSPORT_NUMBER A US passport number. Passport numbers range from six to nine alphanumeric characters.
        ///
        /// * US_SOCIAL_SECURITY_NUMBER A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        ///
        ///
        ///
        ///
        /// * Canada specific
        ///
        /// * CA_HEALTH_NUMBER A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        ///
        /// * CA_SOCIAL_INSURANCE_NUMBER A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as 123-456-789. A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://www.wikipedia.org/wiki/Luhn_algorithm) .
        ///
        ///
        ///
        ///
        /// * UK Specific
        ///
        /// * UK_NATIONAL_HEALTH_SERVICE_NUMBER A UK National Health Service Number is a 10-17 digit number, such as 485 555 3456. The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        ///
        /// * UK_NATIONAL_INSURANCE_NUMBER A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        ///
        /// * UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        ///
        ///
        ///
        ///
        /// * Custom
        ///
        /// * Regex filter - You can use a regular expressions to define patterns for an AI Guardrail to recognize and act upon such as serial number, booking ID etc..
        /// This member is required.
        public var type: QConnectClientTypes.GuardrailPiiEntityType?

        public init(
            action: QConnectClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: QConnectClientTypes.GuardrailPiiEntityType? = nil
        ) {
            self.action = action
            self.type = type
        }
    }
}

extension QConnectClientTypes.GuardrailPiiEntityConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailPiiEntityConfig(action: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The regular expression to configure for the AI Guardrail.
    public struct GuardrailRegexConfig: Swift.Sendable {
        /// The AI Guardrail action to configure when matching regular expression is detected.
        /// This member is required.
        public var action: QConnectClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression to configure for the AI Guardrail.
        public var description: Swift.String?
        /// The name of the regular expression to configure for the AI Guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The regular expression pattern to configure for the AI Guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: QConnectClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        ) {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }
}

extension QConnectClientTypes.GuardrailRegexConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailRegexConfig(action: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", pattern: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Contains details about PII entities and regular expressions to configure for the AI Guardrail.
    public struct AIGuardrailSensitiveInformationPolicyConfig: Swift.Sendable {
        /// A list of PII entities to configure to the AI Guardrail.
        public var piiEntitiesConfig: [QConnectClientTypes.GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the AI Guardrail.
        public var regexesConfig: [QConnectClientTypes.GuardrailRegexConfig]?

        public init(
            piiEntitiesConfig: [QConnectClientTypes.GuardrailPiiEntityConfig]? = nil,
            regexesConfig: [QConnectClientTypes.GuardrailRegexConfig]? = nil
        ) {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }
    }
}

extension QConnectClientTypes {

    /// Type of topic in a policy
    public enum GuardrailTopicType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Details about topics for the AI Guardrail to identify and deny.
    public struct GuardrailTopicConfig: Swift.Sendable {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        /// This member is required.
        public var type: QConnectClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: QConnectClientTypes.GuardrailTopicType? = nil
        ) {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }
}

extension QConnectClientTypes.GuardrailTopicConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicConfig(definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Contains details about topics that the AI Guardrail should identify and deny.
    public struct AIGuardrailTopicPolicyConfig: Swift.Sendable {
        /// A list of policies related to topics that the AI Guardrail should deny.
        /// This member is required.
        public var topicsConfig: [QConnectClientTypes.GuardrailTopicConfig]?

        public init(
            topicsConfig: [QConnectClientTypes.GuardrailTopicConfig]? = nil
        ) {
            self.topicsConfig = topicsConfig
        }
    }
}

extension QConnectClientTypes {

    /// Options for managed words.
    public enum GuardrailManagedWordsType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordsType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The managed word list to configure for the AI Guardrail.
    public struct GuardrailManagedWordsConfig: Swift.Sendable {
        /// The managed word type to configure for the AI Guardrail.
        /// This member is required.
        public var type: QConnectClientTypes.GuardrailManagedWordsType?

        public init(
            type: QConnectClientTypes.GuardrailManagedWordsType? = nil
        ) {
            self.type = type
        }
    }
}

extension QConnectClientTypes.GuardrailManagedWordsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailManagedWordsConfig(type: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// A word to configure for the AI Guardrail.
    public struct GuardrailWordConfig: Swift.Sendable {
        /// Text of the word configured for the AI Guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension QConnectClientTypes.GuardrailWordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailWordConfig(text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Contains details about the word policy to configured for the AI Guardrail.
    public struct AIGuardrailWordPolicyConfig: Swift.Sendable {
        /// A list of managed words to configure for the AI Guardrail.
        public var managedWordListsConfig: [QConnectClientTypes.GuardrailManagedWordsConfig]?
        /// A list of words to configure for the AI Guardrail.
        public var wordsConfig: [QConnectClientTypes.GuardrailWordConfig]?

        public init(
            managedWordListsConfig: [QConnectClientTypes.GuardrailManagedWordsConfig]? = nil,
            wordsConfig: [QConnectClientTypes.GuardrailWordConfig]? = nil
        ) {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }
    }
}

public struct CreateAIGuardrailInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The message to return when the AI Guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the AI Guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The content filter policies to configure for the AI Guardrail.
    public var contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to create an AI Guardrail.
    public var contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig?
    /// A description of the AI Guardrail.
    public var description: Swift.String?
    /// The name of the AI Guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the AI Guardrail.
    public var sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The topic policies to configure for the AI Guardrail.
    public var topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig?
    /// The visibility status of the AI Guardrail.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?
    /// The word policy you configure for the AI Guardrail.
    public var wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig?

    public init(
        assistantId: Swift.String? = nil,
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil,
        wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig? = nil
    ) {
        self.assistantId = assistantId
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientToken = clientToken
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.tags = tags
        self.topicPolicyConfig = topicPolicyConfig
        self.visibilityStatus = visibilityStatus
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension CreateAIGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAIGuardrailInput(assistantId: \(Swift.String(describing: assistantId)), clientToken: \(Swift.String(describing: clientToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), name: \(Swift.String(describing: name)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), visibilityStatus: \(Swift.String(describing: visibilityStatus)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The data for the AI Guardrail
    public struct AIGuardrailData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI Guardrail.
        /// This member is required.
        public var aiGuardrailArn: Swift.String?
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        /// This member is required.
        public var aiGuardrailId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The message to return when the AI Guardrail blocks a prompt.
        /// This member is required.
        public var blockedInputMessaging: Swift.String?
        /// The message to return when the AI Guardrail blocks a model response.
        /// This member is required.
        public var blockedOutputsMessaging: Swift.String?
        /// Contains details about how to handle harmful content.
        public var contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig?
        /// The policy configuration details for the AI Guardrail's contextual grounding policy.
        public var contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig?
        /// A description of the AI Guardrail.
        public var description: Swift.String?
        /// The time the AI Guardrail was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// Contains details about PII entities and regular expressions to configure for the AI Guardrail.
        public var sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig?
        /// The status of the AI Guardrail.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// Contains details about topics that the AI Guardrail should identify and deny.
        public var topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig?
        /// The visibility status of the AI Guardrail.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?
        /// Contains details about the word policy to configured for the AI Guardrail.
        public var wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig?

        public init(
            aiGuardrailArn: Swift.String? = nil,
            aiGuardrailId: Swift.String? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            blockedInputMessaging: Swift.String? = nil,
            blockedOutputsMessaging: Swift.String? = nil,
            contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig? = nil,
            contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig? = nil,
            description: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil,
            wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig? = nil
        ) {
            self.aiGuardrailArn = aiGuardrailArn
            self.aiGuardrailId = aiGuardrailId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.status = status
            self.tags = tags
            self.topicPolicyConfig = topicPolicyConfig
            self.visibilityStatus = visibilityStatus
            self.wordPolicyConfig = wordPolicyConfig
        }
    }
}

extension QConnectClientTypes.AIGuardrailData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AIGuardrailData(aiGuardrailArn: \(Swift.String(describing: aiGuardrailArn)), aiGuardrailId: \(Swift.String(describing: aiGuardrailId)), assistantArn: \(Swift.String(describing: assistantArn)), assistantId: \(Swift.String(describing: assistantId)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), modifiedTime: \(Swift.String(describing: modifiedTime)), name: \(Swift.String(describing: name)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), visibilityStatus: \(Swift.String(describing: visibilityStatus)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

public struct CreateAIGuardrailOutput: Swift.Sendable {
    /// The data of the AI Guardrail.
    public var aiGuardrail: QConnectClientTypes.AIGuardrailData?

    public init(
        aiGuardrail: QConnectClientTypes.AIGuardrailData? = nil
    ) {
        self.aiGuardrail = aiGuardrail
    }
}

public struct CreateAIGuardrailVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The time the AI Guardrail was last modified.
    public var modifiedTime: Foundation.Date?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        modifiedTime: Foundation.Date? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.modifiedTime = modifiedTime
    }
}

public struct CreateAIGuardrailVersionOutput: Swift.Sendable {
    /// The data of the AI Guardrail version.
    public var aiGuardrail: QConnectClientTypes.AIGuardrailData?
    /// The version number of the AI Guardrail version.
    public var versionNumber: Swift.Int?

    public init(
        aiGuardrail: QConnectClientTypes.AIGuardrailData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiGuardrail = aiGuardrail
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIGuardrailInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
    }
}

public struct DeleteAIGuardrailOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAIGuardrailVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The version number of the AI Guardrail version to be deleted.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIGuardrailVersionOutput: Swift.Sendable {

    public init() { }
}

public struct GetAIGuardrailInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
    }
}

public struct GetAIGuardrailOutput: Swift.Sendable {
    /// The data of the AI Guardrail.
    public var aiGuardrail: QConnectClientTypes.AIGuardrailData?
    /// The version number of the AI Guardrail version (returned if an AI Guardrail version was specified via use of a qualifier for the aiGuardrailId on the request).
    public var versionNumber: Swift.Int?

    public init(
        aiGuardrail: QConnectClientTypes.AIGuardrailData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiGuardrail = aiGuardrail
        self.versionNumber = versionNumber
    }
}

public struct ListAIGuardrailsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Guardrail.
    public struct AIGuardrailSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI Guardrail.
        /// This member is required.
        public var aiGuardrailArn: Swift.String?
        /// The identifier of the Amazon Q in Connect AI Guardrail.
        /// This member is required.
        public var aiGuardrailId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A description of the AI Guardrail.
        public var description: Swift.String?
        /// The time the AI Guardrail was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the AI Guardrail.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The visibility status of the AI Guardrail.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

        public init(
            aiGuardrailArn: Swift.String? = nil,
            aiGuardrailId: Swift.String? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
        ) {
            self.aiGuardrailArn = aiGuardrailArn
            self.aiGuardrailId = aiGuardrailId
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modifiedTime = modifiedTime
            self.name = name
            self.status = status
            self.tags = tags
            self.visibilityStatus = visibilityStatus
        }
    }
}

extension QConnectClientTypes.AIGuardrailSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AIGuardrailSummary(aiGuardrailArn: \(Swift.String(describing: aiGuardrailArn)), aiGuardrailId: \(Swift.String(describing: aiGuardrailId)), assistantArn: \(Swift.String(describing: assistantArn)), assistantId: \(Swift.String(describing: assistantId)), modifiedTime: \(Swift.String(describing: modifiedTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), visibilityStatus: \(Swift.String(describing: visibilityStatus)), description: \"CONTENT_REDACTED\")"}
}

public struct ListAIGuardrailsOutput: Swift.Sendable {
    /// The summaries of the AI Guardrails.
    /// This member is required.
    public var aiGuardrailSummaries: [QConnectClientTypes.AIGuardrailSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiGuardrailSummaries: [QConnectClientTypes.AIGuardrailSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiGuardrailSummaries = aiGuardrailSummaries
        self.nextToken = nextToken
    }
}

public struct ListAIGuardrailVersionsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail for which versions are to be listed.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Guardrail version.
    public struct AIGuardrailVersionSummary: Swift.Sendable {
        /// The data for the summary of the AI Guardrail version.
        public var aiGuardrailSummary: QConnectClientTypes.AIGuardrailSummary?
        /// The version number for this AI Guardrail version.
        public var versionNumber: Swift.Int?

        public init(
            aiGuardrailSummary: QConnectClientTypes.AIGuardrailSummary? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.aiGuardrailSummary = aiGuardrailSummary
            self.versionNumber = versionNumber
        }
    }
}

public struct ListAIGuardrailVersionsOutput: Swift.Sendable {
    /// The summaries of the AI Guardrail versions.
    /// This member is required.
    public var aiGuardrailVersionSummaries: [QConnectClientTypes.AIGuardrailVersionSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiGuardrailVersionSummaries: [QConnectClientTypes.AIGuardrailVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiGuardrailVersionSummaries = aiGuardrailVersionSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAIGuardrailInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Guardrail.
    /// This member is required.
    public var aiGuardrailId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The message to return when the AI Guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the AI Guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The content filter policies to configure for the AI Guardrail.
    public var contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to create an AI Guardrail.
    public var contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig?
    /// A description of the AI Guardrail.
    public var description: Swift.String?
    /// The sensitive information policy to configure for the AI Guardrail.
    public var sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig?
    /// The topic policies to configure for the AI Guardrail.
    public var topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig?
    /// The visibility status of the Amazon Q in Connect AI Guardrail.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?
    /// The word policy you configure for the AI Guardrail.
    public var wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig?

    public init(
        aiGuardrailId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contentPolicyConfig: QConnectClientTypes.AIGuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        sensitiveInformationPolicyConfig: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig? = nil,
        topicPolicyConfig: QConnectClientTypes.AIGuardrailTopicPolicyConfig? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil,
        wordPolicyConfig: QConnectClientTypes.AIGuardrailWordPolicyConfig? = nil
    ) {
        self.aiGuardrailId = aiGuardrailId
        self.assistantId = assistantId
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientToken = clientToken
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.topicPolicyConfig = topicPolicyConfig
        self.visibilityStatus = visibilityStatus
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension UpdateAIGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAIGuardrailInput(aiGuardrailId: \(Swift.String(describing: aiGuardrailId)), assistantId: \(Swift.String(describing: assistantId)), clientToken: \(Swift.String(describing: clientToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), visibilityStatus: \(Swift.String(describing: visibilityStatus)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

public struct UpdateAIGuardrailOutput: Swift.Sendable {
    /// The data of the updated Amazon Q in Connect AI Guardrail.
    public var aiGuardrail: QConnectClientTypes.AIGuardrailData?

    public init(
        aiGuardrail: QConnectClientTypes.AIGuardrailData? = nil
    ) {
        self.aiGuardrail = aiGuardrail
    }
}

extension QConnectClientTypes {

    public enum AIPromptAPIFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anthropicClaudeMessages
        case anthropicClaudeTextCompletions
        case sdkUnknown(Swift.String)

        public static var allCases: [AIPromptAPIFormat] {
            return [
                .anthropicClaudeMessages,
                .anthropicClaudeTextCompletions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anthropicClaudeMessages: return "ANTHROPIC_CLAUDE_MESSAGES"
            case .anthropicClaudeTextCompletions: return "ANTHROPIC_CLAUDE_TEXT_COMPLETIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The configuration for a prompt template that supports full textual prompt configuration using a YAML prompt.
    public struct TextFullAIPromptEditTemplateConfiguration: Swift.Sendable {
        /// The YAML text for the AI Prompt template.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextFullAIPromptEditTemplateConfiguration(text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// A typed union that specifies the configuration for a prompt template based on its type.
    public enum AIPromptTemplateConfiguration: Swift.Sendable {
        /// The configuration for a prompt template that supports full textual prompt configuration using a YAML prompt.
        case textfullaipromptedittemplateconfiguration(QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum AIPromptTemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [AIPromptTemplateType] {
            return [
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum AIPromptType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case answerGeneration
        case intentLabelingGeneration
        case queryReformulation
        case selfServiceAnswerGeneration
        case selfServicePreProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [AIPromptType] {
            return [
                .answerGeneration,
                .intentLabelingGeneration,
                .queryReformulation,
                .selfServiceAnswerGeneration,
                .selfServicePreProcessing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .answerGeneration: return "ANSWER_GENERATION"
            case .intentLabelingGeneration: return "INTENT_LABELING_GENERATION"
            case .queryReformulation: return "QUERY_REFORMULATION"
            case .selfServiceAnswerGeneration: return "SELF_SERVICE_ANSWER_GENERATION"
            case .selfServicePreProcessing: return "SELF_SERVICE_PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAIPromptInput: Swift.Sendable {
    /// The API Format of the AI Prompt.
    /// This member is required.
    public var apiFormat: QConnectClientTypes.AIPromptAPIFormat?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The description of the AI Prompt.
    public var description: Swift.String?
    /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the AI Prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The configuration of the prompt template for this AI Prompt.
    /// This member is required.
    public var templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration?
    /// The type of the prompt template for this AI Prompt.
    /// This member is required.
    public var templateType: QConnectClientTypes.AIPromptTemplateType?
    /// The type of this AI Prompt.
    /// This member is required.
    public var type: QConnectClientTypes.AIPromptType?
    /// The visibility status of the AI Prompt.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

    public init(
        apiFormat: QConnectClientTypes.AIPromptAPIFormat? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration? = nil,
        templateType: QConnectClientTypes.AIPromptTemplateType? = nil,
        type: QConnectClientTypes.AIPromptType? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
    ) {
        self.apiFormat = apiFormat
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.modelId = modelId
        self.name = name
        self.tags = tags
        self.templateConfiguration = templateConfiguration
        self.templateType = templateType
        self.type = type
        self.visibilityStatus = visibilityStatus
    }
}

extension QConnectClientTypes {

    /// The data for the AI Prompt
    public struct AIPromptData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        /// This member is required.
        public var aiPromptArn: Swift.String?
        /// The identifier of the Amazon Q in Connect AI prompt.
        /// This member is required.
        public var aiPromptId: Swift.String?
        /// The API format used for this AI Prompt.
        /// This member is required.
        public var apiFormat: QConnectClientTypes.AIPromptAPIFormat?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description of the AI Prompt.
        public var description: Swift.String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1.
        /// This member is required.
        public var modelId: Swift.String?
        /// The time the AI Prompt was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Prompt
        /// This member is required.
        public var name: Swift.String?
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public var origin: QConnectClientTypes.Origin?
        /// The status of the AI Prompt.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The configuration of the prompt template for this AI Prompt.
        /// This member is required.
        public var templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration?
        /// The type of the prompt template for this AI Prompt.
        /// This member is required.
        public var templateType: QConnectClientTypes.AIPromptTemplateType?
        /// The type of this AI Prompt.
        /// This member is required.
        public var type: QConnectClientTypes.AIPromptType?
        /// The visibility status of the AI Prompt.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

        public init(
            aiPromptArn: Swift.String? = nil,
            aiPromptId: Swift.String? = nil,
            apiFormat: QConnectClientTypes.AIPromptAPIFormat? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            origin: QConnectClientTypes.Origin? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration? = nil,
            templateType: QConnectClientTypes.AIPromptTemplateType? = nil,
            type: QConnectClientTypes.AIPromptType? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
        ) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }
    }
}

public struct CreateAIPromptOutput: Swift.Sendable {
    /// The data of the AI Prompt.
    public var aiPrompt: QConnectClientTypes.AIPromptData?

    public init(
        aiPrompt: QConnectClientTypes.AIPromptData? = nil
    ) {
        self.aiPrompt = aiPrompt
    }
}

public struct CreateAIPromptVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI prompt.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The time the AI Prompt was last modified.
    public var modifiedTime: Foundation.Date?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        modifiedTime: Foundation.Date? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.modifiedTime = modifiedTime
    }
}

public struct CreateAIPromptVersionOutput: Swift.Sendable {
    /// The data of the AI Prompt version.
    public var aiPrompt: QConnectClientTypes.AIPromptData?
    /// The version number of the AI Prompt version.
    public var versionNumber: Swift.Int?

    public init(
        aiPrompt: QConnectClientTypes.AIPromptData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiPrompt = aiPrompt
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIPromptInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI prompt. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
    }
}

public struct DeleteAIPromptOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAIPromptVersionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI prompt.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The version number of the AI Prompt version to be deleted.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
        self.versionNumber = versionNumber
    }
}

public struct DeleteAIPromptVersionOutput: Swift.Sendable {

    public init() { }
}

public struct GetAIPromptInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI prompt.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
    }
}

public struct GetAIPromptOutput: Swift.Sendable {
    /// The data of the AI Prompt.
    public var aiPrompt: QConnectClientTypes.AIPromptData?
    /// The version number of the AI Prompt version (returned if an AI Prompt version was specified via use of a qualifier for the aiPromptId on the request).
    public var versionNumber: Swift.Int?

    public init(
        aiPrompt: QConnectClientTypes.AIPromptData? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.aiPrompt = aiPrompt
        self.versionNumber = versionNumber
    }
}

public struct ListAIPromptsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The origin of the AI Prompts to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
    public var origin: QConnectClientTypes.Origin?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: QConnectClientTypes.Origin? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Prompt.
    public struct AIPromptSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AI Prompt.
        /// This member is required.
        public var aiPromptArn: Swift.String?
        /// The identifier of the Amazon Q in Connect AI prompt.
        /// This member is required.
        public var aiPromptId: Swift.String?
        /// The API format used for this AI Prompt.
        /// This member is required.
        public var apiFormat: QConnectClientTypes.AIPromptAPIFormat?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description of the AI Prompt.
        public var description: Swift.String?
        /// The identifier of the model used for this AI Prompt. Model Ids supported are: CLAUDE_3_HAIKU_20240307_V1.
        /// This member is required.
        public var modelId: Swift.String?
        /// The time the AI Prompt was last modified.
        public var modifiedTime: Foundation.Date?
        /// The name of the AI Prompt.
        /// This member is required.
        public var name: Swift.String?
        /// The origin of the AI Prompt. SYSTEM for a default AI Prompt created by Q in Connect or CUSTOMER for an AI Prompt created by calling AI Prompt creation APIs.
        public var origin: QConnectClientTypes.Origin?
        /// The status of the AI Prompt.
        public var status: QConnectClientTypes.Status?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the prompt template for this AI Prompt.
        /// This member is required.
        public var templateType: QConnectClientTypes.AIPromptTemplateType?
        /// The type of this AI Prompt.
        /// This member is required.
        public var type: QConnectClientTypes.AIPromptType?
        /// The visibility status of the AI Prompt.
        /// This member is required.
        public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

        public init(
            aiPromptArn: Swift.String? = nil,
            aiPromptId: Swift.String? = nil,
            apiFormat: QConnectClientTypes.AIPromptAPIFormat? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            origin: QConnectClientTypes.Origin? = nil,
            status: QConnectClientTypes.Status? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateType: QConnectClientTypes.AIPromptTemplateType? = nil,
            type: QConnectClientTypes.AIPromptType? = nil,
            visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
        ) {
            self.aiPromptArn = aiPromptArn
            self.aiPromptId = aiPromptId
            self.apiFormat = apiFormat
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.modelId = modelId
            self.modifiedTime = modifiedTime
            self.name = name
            self.origin = origin
            self.status = status
            self.tags = tags
            self.templateType = templateType
            self.type = type
            self.visibilityStatus = visibilityStatus
        }
    }
}

public struct ListAIPromptsOutput: Swift.Sendable {
    /// The summaries of the AI Prompts.
    /// This member is required.
    public var aiPromptSummaries: [QConnectClientTypes.AIPromptSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiPromptSummaries: [QConnectClientTypes.AIPromptSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiPromptSummaries = aiPromptSummaries
        self.nextToken = nextToken
    }
}

public struct ListAIPromptVersionsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI prompt for which versions are to be listed.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The origin of the AI Prompt versions to be listed. SYSTEM for a default AI Agent created by Q in Connect or CUSTOMER for an AI Agent created by calling AI Agent creation APIs.
    public var origin: QConnectClientTypes.Origin?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: QConnectClientTypes.Origin? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

extension QConnectClientTypes {

    /// The summary of the AI Prompt version.
    public struct AIPromptVersionSummary: Swift.Sendable {
        /// The date for the summary of the AI Prompt version.
        public var aiPromptSummary: QConnectClientTypes.AIPromptSummary?
        /// The version number for this AI Prompt version.
        public var versionNumber: Swift.Int?

        public init(
            aiPromptSummary: QConnectClientTypes.AIPromptSummary? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.aiPromptSummary = aiPromptSummary
            self.versionNumber = versionNumber
        }
    }
}

public struct ListAIPromptVersionsOutput: Swift.Sendable {
    /// The summaries of the AI Prompt versions.
    /// This member is required.
    public var aiPromptVersionSummaries: [QConnectClientTypes.AIPromptVersionSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        aiPromptVersionSummaries: [QConnectClientTypes.AIPromptVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.aiPromptVersionSummaries = aiPromptVersionSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAIPromptInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect AI Prompt.
    /// This member is required.
    public var aiPromptId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)..
    public var clientToken: Swift.String?
    /// The description of the Amazon Q in Connect AI Prompt.
    public var description: Swift.String?
    /// The configuration of the prompt template for this AI Prompt.
    public var templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration?
    /// The visibility status of the Amazon Q in Connect AI prompt.
    /// This member is required.
    public var visibilityStatus: QConnectClientTypes.VisibilityStatus?

    public init(
        aiPromptId: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        templateConfiguration: QConnectClientTypes.AIPromptTemplateConfiguration? = nil,
        visibilityStatus: QConnectClientTypes.VisibilityStatus? = nil
    ) {
        self.aiPromptId = aiPromptId
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.templateConfiguration = templateConfiguration
        self.visibilityStatus = visibilityStatus
    }
}

public struct UpdateAIPromptOutput: Swift.Sendable {
    /// The data of the updated Amazon Q in Connect AI Prompt.
    public var aiPrompt: QConnectClientTypes.AIPromptData?

    public init(
        aiPrompt: QConnectClientTypes.AIPromptData? = nil
    ) {
        self.aiPrompt = aiPrompt
    }
}

extension QConnectClientTypes {

    /// Content association data for a [step-by-step guide](https://docs.aws.amazon.com/connect/latest/adminguide/step-by-step-guided-experiences.html).
    public struct AmazonConnectGuideAssociationData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon Connect flow. Step-by-step guides are a type of flow.
        public var flowId: Swift.String?

        public init(
            flowId: Swift.String? = nil
        ) {
            self.flowId = flowId
        }
    }
}

extension QConnectClientTypes {

    /// Configuration information for Amazon AppIntegrations to automatically ingest content.
    public struct AppIntegrationsConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.
        ///
        /// * For [SharePoint](https://learn.microsoft.com/en-us/sharepoint/dev/sp-add-ins/sharepoint-net-server-csom-jsom-and-rest-api-index), your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.
        ///
        /// * For [Amazon S3](http://aws.amazon.com/s3/), the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name. The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        /// This member is required.
        public var appIntegrationArn: Swift.String?
        /// The fields from the source that are made available to your agents in Amazon Q in Connect. Optional if ObjectConfiguration is included in the provided DataIntegration.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), you must include at least number, short_description, sys_mod_count, workflow_state, and active.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), you must include at least id, title, updated_at, and draft.
        ///
        ///
        /// Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public var objectFields: [Swift.String]?

        public init(
            appIntegrationArn: Swift.String? = nil,
            objectFields: [Swift.String]? = nil
        ) {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }
    }
}

extension QConnectClientTypes {

    /// The data that is input into Amazon Q in Connect as a result of the assistant association.
    public enum AssistantAssociationInputData: Swift.Sendable {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        case knowledgebaseid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum AssociationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAssistantAssociationInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: QConnectClientTypes.AssistantAssociationInputData?
    /// The type of association.
    /// This member is required.
    public var associationType: QConnectClientTypes.AssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assistantId: Swift.String? = nil,
        association: QConnectClientTypes.AssistantAssociationInputData? = nil,
        associationType: QConnectClientTypes.AssociationType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.assistantId = assistantId
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.tags = tags
    }
}

extension QConnectClientTypes {

    /// Association information about the knowledge base.
    public struct KnowledgeBaseAssociationData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        public var knowledgeBaseId: Swift.String?

        public init(
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        ) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }
}

extension QConnectClientTypes {

    /// The data that is output as a result of the assistant association.
    public enum AssistantAssociationOutputData: Swift.Sendable {
        /// The knowledge base where output data is sent.
        case knowledgebaseassociation(QConnectClientTypes.KnowledgeBaseAssociationData)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// Information about the assistant association.
    public struct AssistantAssociationData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A union type that currently has a single argument, the knowledge base ID.
        /// This member is required.
        public var associationData: QConnectClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: QConnectClientTypes.AssistantAssociationOutputData? = nil,
            associationType: QConnectClientTypes.AssociationType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }
}

public struct CreateAssistantAssociationOutput: Swift.Sendable {
    /// The assistant association.
    public var assistantAssociation: QConnectClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: QConnectClientTypes.AssistantAssociationData? = nil
    ) {
        self.assistantAssociation = assistantAssociation
    }
}

public struct DeleteAssistantAssociationInput: Swift.Sendable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

public struct DeleteAssistantAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct GetAssistantAssociationInput: Swift.Sendable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

public struct GetAssistantAssociationOutput: Swift.Sendable {
    /// The assistant association.
    public var assistantAssociation: QConnectClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: QConnectClientTypes.AssistantAssociationData? = nil
    ) {
        self.assistantAssociation = assistantAssociation
    }
}

public struct ListAssistantAssociationsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// Summary information about the assistant association.
    public struct AssistantAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The association data.
        /// This member is required.
        public var associationData: QConnectClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: QConnectClientTypes.AssistantAssociationOutputData? = nil,
            associationType: QConnectClientTypes.AssociationType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }
}

public struct ListAssistantAssociationsOutput: Swift.Sendable {
    /// Summary information about assistant associations.
    /// This member is required.
    public var assistantAssociationSummaries: [QConnectClientTypes.AssistantAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantAssociationSummaries: [QConnectClientTypes.AssistantAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.assistantAssociationSummaries = assistantAssociationSummaries
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The configuration information for the customer managed key used for encryption.
    public struct ServerSideEncryptionConfiguration: Swift.Sendable {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html). For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id).
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        ) {
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension QConnectClientTypes {

    public enum AssistantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantType] {
            return [
                .agent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAssistantInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the assistant.
    public var description: Swift.String?
    /// The name of the assistant.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration information for the customer managed key used for encryption. The customer managed key must have a policy that allows kms:CreateGrant,  kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
    public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of assistant.
    /// This member is required.
    public var type: QConnectClientTypes.AssistantType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: QConnectClientTypes.AssistantType? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.type = type
    }
}

extension QConnectClientTypes {

    public enum AssistantCapabilityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantCapabilityType] {
            return [
                .v1,
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The capability configuration for an Amazon Q in Connect assistant.
    public struct AssistantCapabilityConfiguration: Swift.Sendable {
        /// The type of Amazon Q in Connect assistant capability.
        public var type: QConnectClientTypes.AssistantCapabilityType?

        public init(
            type: QConnectClientTypes.AssistantCapabilityType? = nil
        ) {
            self.type = type
        }
    }
}

extension QConnectClientTypes {

    /// The configuration information for the Amazon Q in Connect assistant integration.
    public struct AssistantIntegrationConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        ) {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }
}

extension QConnectClientTypes {

    public enum AssistantStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The assistant data.
    public struct AssistantData: Swift.Sendable {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public var aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public var capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration?
        /// The description.
        public var description: Swift.String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public var integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration?
        /// The name.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: QConnectClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of assistant.
        /// This member is required.
        public var type: QConnectClientTypes.AssistantType?

        public init(
            aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: QConnectClientTypes.AssistantStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: QConnectClientTypes.AssistantType? = nil
        ) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }
}

public struct CreateAssistantOutput: Swift.Sendable {
    /// Information about the assistant.
    public var assistant: QConnectClientTypes.AssistantData?

    public init(
        assistant: QConnectClientTypes.AssistantData? = nil
    ) {
        self.assistant = assistant
    }
}

public struct DeleteAssistantInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
    }
}

public struct DeleteAssistantOutput: Swift.Sendable {

    public init() { }
}

public struct GetAssistantInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
    }
}

public struct GetAssistantOutput: Swift.Sendable {
    /// Information about the assistant.
    public var assistant: QConnectClientTypes.AssistantData?

    public init(
        assistant: QConnectClientTypes.AssistantData? = nil
    ) {
        self.assistant = assistant
    }
}

public struct GetRecommendationsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
    public var waitTimeSeconds: Swift.Int

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        waitTimeSeconds: Swift.Int = 0
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.sessionId = sessionId
        self.waitTimeSeconds = waitTimeSeconds
    }
}

extension QConnectClientTypes {

    public enum RelevanceLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceLevel] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Details about the source content ranking data.
    public struct RankingData: Swift.Sendable {
        /// The relevance score of the content.
        public var relevanceLevel: QConnectClientTypes.RelevanceLevel?
        /// The relevance level of the recommendation.
        public var relevanceScore: Swift.Double

        public init(
            relevanceLevel: QConnectClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0
        ) {
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
        }
    }
}

extension QConnectClientTypes {

    /// Offset specification to describe highlighting of document excerpts for rendering search results and recommendations.
    public struct Highlight: Swift.Sendable {
        /// The offset for the start of the highlight.
        public var beginOffsetInclusive: Swift.Int
        /// The offset for the end of the highlight.
        public var endOffsetExclusive: Swift.Int

        public init(
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        ) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }
}

extension QConnectClientTypes {

    /// The text of the document.
    public struct DocumentText: Swift.Sendable {
        /// Highlights in the document text.
        public var highlights: [QConnectClientTypes.Highlight]?
        /// Text in the document.
        public var text: Swift.String?

        public init(
            highlights: [QConnectClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        ) {
            self.highlights = highlights
            self.text = text
        }
    }
}

extension QConnectClientTypes.DocumentText: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentText(highlights: \(Swift.String(describing: highlights)), text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Details about the source content text data.
    public struct TextData: Swift.Sendable {
        /// The text of the document.
        public var excerpt: QConnectClientTypes.DocumentText?
        /// The text of the document.
        public var title: QConnectClientTypes.DocumentText?

        public init(
            excerpt: QConnectClientTypes.DocumentText? = nil,
            title: QConnectClientTypes.DocumentText? = nil
        ) {
            self.excerpt = excerpt
            self.title = title
        }
    }
}

extension QConnectClientTypes {

    /// Details about the content data.
    public struct ContentDataDetails: Swift.Sendable {
        /// Details about the content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// Details about the content text data.
        /// This member is required.
        public var textData: QConnectClientTypes.TextData?

        public init(
            rankingData: QConnectClientTypes.RankingData? = nil,
            textData: QConnectClientTypes.TextData? = nil
        ) {
            self.rankingData = rankingData
            self.textData = textData
        }
    }
}

extension QConnectClientTypes {

    /// Details about the detected intent.
    public struct IntentDetectedDataDetails: Swift.Sendable {
        /// The detected intent.
        /// This member is required.
        public var intent: Swift.String?
        /// The identifier of the detected intent.
        /// This member is required.
        public var intentId: Swift.String?

        public init(
            intent: Swift.String? = nil,
            intentId: Swift.String? = nil
        ) {
            self.intent = intent
            self.intentId = intentId
        }
    }
}

extension QConnectClientTypes.IntentDetectedDataDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntentDetectedDataDetails(intentId: \(Swift.String(describing: intentId)), intent: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Contains information about where the text with a citation begins and ends in the generated output.
    public struct CitationSpan: Swift.Sendable {
        /// Where the text with a citation starts in the generated output.
        public var beginOffsetInclusive: Swift.Int
        /// Where the text with a citation ends in the generated output.
        public var endOffsetExclusive: Swift.Int

        public init(
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        ) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }
}

extension QConnectClientTypes {

    public enum SourceContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceContentType] {
            return [
                .knowledgeContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Details about the source content data.
    public struct SourceContentDataDetails: Swift.Sendable {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public var citationSpan: QConnectClientTypes.CitationSpan?
        /// The identifier of the source content.
        /// This member is required.
        public var id: Swift.String?
        /// Details about the source content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// Details about the source content text data.
        /// This member is required.
        public var textData: QConnectClientTypes.TextData?
        /// The type of the source content.
        /// This member is required.
        public var type: QConnectClientTypes.SourceContentType?

        public init(
            citationSpan: QConnectClientTypes.CitationSpan? = nil,
            id: Swift.String? = nil,
            rankingData: QConnectClientTypes.RankingData? = nil,
            textData: QConnectClientTypes.TextData? = nil,
            type: QConnectClientTypes.SourceContentType? = nil
        ) {
            self.citationSpan = citationSpan
            self.id = id
            self.rankingData = rankingData
            self.textData = textData
            self.type = type
        }
    }
}

extension QConnectClientTypes {

    public enum ReferenceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBase
        case webCrawler
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceType] {
            return [
                .knowledgeBase,
                .webCrawler
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .webCrawler: return "WEB_CRAWLER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Reference information about the content.
    public struct ContentReference: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the content.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        public var knowledgeBaseId: Swift.String?
        /// The type of reference content.
        public var referenceType: QConnectClientTypes.ReferenceType?
        /// The web URL of the source content.
        public var sourceURL: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            referenceType: QConnectClientTypes.ReferenceType? = nil,
            sourceURL: Swift.String? = nil
        ) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.referenceType = referenceType
            self.sourceURL = sourceURL
        }
    }
}

extension QConnectClientTypes {

    /// Reference information about generative content.
    public struct GenerativeReference: Swift.Sendable {
        /// The identifier of the LLM model.
        public var generationId: Swift.String?
        /// The identifier of the LLM model.
        public var modelId: Swift.String?

        public init(
            generationId: Swift.String? = nil,
            modelId: Swift.String? = nil
        ) {
            self.generationId = generationId
            self.modelId = modelId
        }
    }
}

extension QConnectClientTypes {

    /// Reference data.
    public enum DataReference: Swift.Sendable {
        /// Reference information about the content.
        case contentreference(QConnectClientTypes.ContentReference)
        /// Reference information about the generative content.
        case generativereference(QConnectClientTypes.GenerativeReference)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The document.
    public struct Document: Swift.Sendable {
        /// A reference to the content resource.
        /// This member is required.
        public var contentReference: QConnectClientTypes.ContentReference?
        /// The excerpt from the document.
        public var excerpt: QConnectClientTypes.DocumentText?
        /// The title of the document.
        public var title: QConnectClientTypes.DocumentText?

        public init(
            contentReference: QConnectClientTypes.ContentReference? = nil,
            excerpt: QConnectClientTypes.DocumentText? = nil,
            title: QConnectClientTypes.DocumentText? = nil
        ) {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }
    }
}

extension QConnectClientTypes {

    public enum RecommendationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case detectedIntent
        case generativeAnswer
        case generativeResponse
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .detectedIntent,
                .generativeAnswer,
                .generativeResponse,
                .knowledgeContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .detectedIntent: return "DETECTED_INTENT"
            case .generativeAnswer: return "GENERATIVE_ANSWER"
            case .generativeResponse: return "GENERATIVE_RESPONSE"
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Data associated with the QUERY RecommendationTriggerType.
    public struct QueryRecommendationTriggerData: Swift.Sendable {
        /// The text associated with the recommendation trigger.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension QConnectClientTypes.QueryRecommendationTriggerData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryRecommendationTriggerData(text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// A union type containing information related to the trigger.
    public enum RecommendationTriggerData: Swift.Sendable {
        /// Data associated with the QUERY RecommendationTriggerType.
        case query(QConnectClientTypes.QueryRecommendationTriggerData)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum RecommendationSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case issueDetection
        case other
        case ruleEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSourceType] {
            return [
                .issueDetection,
                .other,
                .ruleEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .issueDetection: return "ISSUE_DETECTION"
            case .other: return "OTHER"
            case .ruleEvaluation: return "RULE_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum RecommendationTriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generative
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTriggerType] {
            return [
                .generative,
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generative: return "GENERATIVE"
            case .query: return "QUERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// A recommendation trigger provides context on the event that produced the referenced recommendations. Recommendations are only referenced in recommendationIds by a single RecommendationTrigger.
    public struct RecommendationTrigger: Swift.Sendable {
        /// A union type containing information related to the trigger.
        /// This member is required.
        public var data: QConnectClientTypes.RecommendationTriggerData?
        /// The identifier of the recommendation trigger.
        /// This member is required.
        public var id: Swift.String?
        /// The identifiers of the recommendations.
        /// This member is required.
        public var recommendationIds: [Swift.String]?
        /// The source of the recommendation trigger.
        ///
        /// * ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.
        ///
        /// * RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        /// This member is required.
        public var source: QConnectClientTypes.RecommendationSourceType?
        /// The type of recommendation trigger.
        /// This member is required.
        public var type: QConnectClientTypes.RecommendationTriggerType?

        public init(
            data: QConnectClientTypes.RecommendationTriggerData? = nil,
            id: Swift.String? = nil,
            recommendationIds: [Swift.String]? = nil,
            source: QConnectClientTypes.RecommendationSourceType? = nil,
            type: QConnectClientTypes.RecommendationTriggerType? = nil
        ) {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }
    }
}

public struct ListAssistantsInput: Swift.Sendable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// Summary information about the assistant.
    public struct AssistantSummary: Swift.Sendable {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that is set on the Amazon Q in Connect Assistant.
        public var aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]?
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The configuration information for the Amazon Q in Connect assistant capability.
        public var capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration?
        /// The description of the assistant.
        public var description: Swift.String?
        /// The configuration information for the Amazon Q in Connect assistant integration.
        public var integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration?
        /// The name of the assistant.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. To use Amazon Q in Connect with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: QConnectClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the assistant.
        /// This member is required.
        public var type: QConnectClientTypes.AssistantType?

        public init(
            aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]? = nil,
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: QConnectClientTypes.AssistantStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: QConnectClientTypes.AssistantType? = nil
        ) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }
}

public struct ListAssistantsOutput: Swift.Sendable {
    /// Information about the assistants.
    /// This member is required.
    public var assistantSummaries: [QConnectClientTypes.AssistantSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantSummaries: [QConnectClientTypes.AssistantSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.assistantSummaries = assistantSummaries
        self.nextToken = nextToken
    }
}

public struct NotifyRecommendationsReceivedInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifiers of the recommendations.
    /// This member is required.
    public var recommendationIds: [Swift.String]?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.recommendationIds = recommendationIds
        self.sessionId = sessionId
    }
}

extension QConnectClientTypes {

    /// An error occurred when creating a recommendation.
    public struct NotifyRecommendationsReceivedError: Swift.Sendable {
        /// A recommendation is causing an error.
        public var message: Swift.String?
        /// The identifier of the recommendation that is in error.
        public var recommendationId: Swift.String?

        public init(
            message: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        ) {
            self.message = message
            self.recommendationId = recommendationId
        }
    }
}

public struct NotifyRecommendationsReceivedOutput: Swift.Sendable {
    /// The identifiers of recommendations that are causing errors.
    public var errors: [QConnectClientTypes.NotifyRecommendationsReceivedError]?
    /// The identifiers of the recommendations.
    public var recommendationIds: [Swift.String]?

    public init(
        errors: [QConnectClientTypes.NotifyRecommendationsReceivedError]? = nil,
        recommendationIds: [Swift.String]? = nil
    ) {
        self.errors = errors
        self.recommendationIds = recommendationIds
    }
}

extension QConnectClientTypes {

    public enum Relevance: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case helpful
        case notHelpful
        case sdkUnknown(Swift.String)

        public static var allCases: [Relevance] {
            return [
                .helpful,
                .notHelpful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .helpful: return "HELPFUL"
            case .notHelpful: return "NOT_HELPFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The feedback information for a generative target type.
    public struct GenerativeContentFeedbackData: Swift.Sendable {
        /// The relevance of the feedback.
        /// This member is required.
        public var relevance: QConnectClientTypes.Relevance?

        public init(
            relevance: QConnectClientTypes.Relevance? = nil
        ) {
            self.relevance = relevance
        }
    }
}

extension QConnectClientTypes {

    /// Information about the feedback.
    public enum ContentFeedbackData: Swift.Sendable {
        /// Information about the feedback for a generative target type.
        case generativecontentfeedbackdata(QConnectClientTypes.GenerativeContentFeedbackData)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum TargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case recommendation
        case result
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .recommendation,
                .result
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .recommendation: return "RECOMMENDATION"
            case .result: return "RESULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct PutFeedbackInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// Information about the feedback provided.
    /// This member is required.
    public var contentFeedback: QConnectClientTypes.ContentFeedbackData?
    /// The identifier of the feedback target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The type of the feedback target.
    /// This member is required.
    public var targetType: QConnectClientTypes.TargetType?

    public init(
        assistantId: Swift.String? = nil,
        contentFeedback: QConnectClientTypes.ContentFeedbackData? = nil,
        targetId: Swift.String? = nil,
        targetType: QConnectClientTypes.TargetType? = nil
    ) {
        self.assistantId = assistantId
        self.contentFeedback = contentFeedback
        self.targetId = targetId
        self.targetType = targetType
    }
}

public struct PutFeedbackOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantArn: Swift.String?
    /// The identifier of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// Information about the feedback provided.
    /// This member is required.
    public var contentFeedback: QConnectClientTypes.ContentFeedbackData?
    /// The identifier of the feedback target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The type of the feedback target.
    /// This member is required.
    public var targetType: QConnectClientTypes.TargetType?

    public init(
        assistantArn: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        contentFeedback: QConnectClientTypes.ContentFeedbackData? = nil,
        targetId: Swift.String? = nil,
        targetType: QConnectClientTypes.TargetType? = nil
    ) {
        self.assistantArn = assistantArn
        self.assistantId = assistantId
        self.contentFeedback = contentFeedback
        self.targetId = targetId
        self.targetType = targetType
    }
}

/// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension QConnectClientTypes {

    public enum QueryConditionComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryConditionComparisonOperator] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum QueryConditionFieldName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resultType
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryConditionFieldName] {
            return [
                .resultType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resultType: return "RESULT_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The condition for the query.
    public struct QueryConditionItem: Swift.Sendable {
        /// The comparison operator for query condition to query on.
        /// This member is required.
        public var comparator: QConnectClientTypes.QueryConditionComparisonOperator?
        /// The name of the field for query condition to query on.
        /// This member is required.
        public var field: QConnectClientTypes.QueryConditionFieldName?
        /// The value for the query condition to query on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparator: QConnectClientTypes.QueryConditionComparisonOperator? = nil,
            field: QConnectClientTypes.QueryConditionFieldName? = nil,
            value: Swift.String? = nil
        ) {
            self.comparator = comparator
            self.field = field
            self.value = value
        }
    }
}

extension QConnectClientTypes {

    /// Information about how to query content.
    public enum QueryCondition: Swift.Sendable {
        /// The condition for the query.
        case single(QConnectClientTypes.QueryConditionItem)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// Information about the Amazon Q intent.
    public struct IntentInputData: Swift.Sendable {
        /// The identifier of the Amazon Q intent.
        /// This member is required.
        public var intentId: Swift.String?

        public init(
            intentId: Swift.String? = nil
        ) {
            self.intentId = intentId
        }
    }
}

extension QConnectClientTypes {

    /// Information about the text to search for.
    public struct QueryTextInputData: Swift.Sendable {
        /// The text to search for.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension QConnectClientTypes.QueryTextInputData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryTextInputData(text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Input information for the query.
    public enum QueryInputData: Swift.Sendable {
        /// Input information for the query.
        case querytextinputdata(QConnectClientTypes.QueryTextInputData)
        /// Input information for the intent.
        case intentinputdata(QConnectClientTypes.IntentInputData)
        case sdkUnknown(Swift.String)
    }
}

public struct QueryAssistantInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search type to be used against the Knowledge Base for this request. The values can be SEMANTIC which uses vector embeddings or HYBRID which use vector embeddings and raw text.
    public var overrideKnowledgeBaseSearchType: QConnectClientTypes.KnowledgeBaseSearchType?
    /// Information about how to query content.
    public var queryCondition: [QConnectClientTypes.QueryCondition]?
    /// Information about the query.
    public var queryInputData: QConnectClientTypes.QueryInputData?
    /// The text to search for.
    public var queryText: Swift.String?
    /// The identifier of the Amazon Q in Connect session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        overrideKnowledgeBaseSearchType: QConnectClientTypes.KnowledgeBaseSearchType? = nil,
        queryCondition: [QConnectClientTypes.QueryCondition]? = nil,
        queryInputData: QConnectClientTypes.QueryInputData? = nil,
        queryText: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.overrideKnowledgeBaseSearchType = overrideKnowledgeBaseSearchType
        self.queryCondition = queryCondition
        self.queryInputData = queryInputData
        self.queryText = queryText
        self.sessionId = sessionId
    }
}

extension QueryAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), overrideKnowledgeBaseSearchType: \(Swift.String(describing: overrideKnowledgeBaseSearchType)), queryCondition: \(Swift.String(describing: queryCondition)), queryInputData: \(Swift.String(describing: queryInputData)), sessionId: \(Swift.String(describing: sessionId)), queryText: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    public enum QueryResultType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generativeAnswer
        case intentAnswer
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryResultType] {
            return [
                .generativeAnswer,
                .intentAnswer,
                .knowledgeContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generativeAnswer: return "GENERATIVE_ANSWER"
            case .intentAnswer: return "INTENT_ANSWER"
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct RemoveAssistantAIAgentInput: Swift.Sendable {
    /// The type of the AI Agent being removed for use by default from the Amazon Q in Connect Assistant.
    /// This member is required.
    public var aiAgentType: QConnectClientTypes.AIAgentType?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        aiAgentType: QConnectClientTypes.AIAgentType? = nil,
        assistantId: Swift.String? = nil
    ) {
        self.aiAgentType = aiAgentType
        self.assistantId = assistantId
    }
}

public struct RemoveAssistantAIAgentOutput: Swift.Sendable {

    public init() { }
}

extension QConnectClientTypes {

    public enum FilterField: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum FilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// A search filter.
    public struct Filter: Swift.Sendable {
        /// The field on which to filter.
        /// This member is required.
        public var field: QConnectClientTypes.FilterField?
        /// The operator to use for comparing the field’s value with the provided value.
        /// This member is required.
        public var `operator`: QConnectClientTypes.FilterOperator?
        /// The desired field value on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            field: QConnectClientTypes.FilterField? = nil,
            `operator`: QConnectClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        ) {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QConnectClientTypes {

    /// The search expression.
    public struct SearchExpression: Swift.Sendable {
        /// The search expression filters.
        /// This member is required.
        public var filters: [QConnectClientTypes.Filter]?

        public init(
            filters: [QConnectClientTypes.Filter]? = nil
        ) {
            self.filters = filters
        }
    }
}

public struct SearchSessionsInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.SearchExpression?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.SearchExpression? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

extension QConnectClientTypes {

    /// Summary information about the session.
    public struct SessionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q in Connect assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }
    }
}

public struct SearchSessionsOutput: Swift.Sendable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the sessions.
    /// This member is required.
    public var sessionSummaries: [QConnectClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [QConnectClientTypes.SessionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

public struct CreateSessionInput: Swift.Sendable {
    /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
    public var aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the session.
    /// This member is required.
    public var name: Swift.String?
    /// An object that can be used to specify Tag conditions.
    public var tagFilter: QConnectClientTypes.TagFilter?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]? = nil,
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tagFilter: QConnectClientTypes.TagFilter? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.aiAgentConfiguration = aiAgentConfiguration
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tagFilter = tagFilter
        self.tags = tags
    }
}

extension QConnectClientTypes {

    /// The configuration information for the session integration.
    public struct SessionIntegrationConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        ) {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }
}

extension QConnectClientTypes {

    /// Information about the session.
    public struct SessionData: Swift.Sendable {
        /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
        public var aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]?
        /// The description of the session.
        public var description: Swift.String?
        /// The configuration information for the session integration.
        public var integrationConfiguration: QConnectClientTypes.SessionIntegrationConfiguration?
        /// The name of the session.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// An object that can be used to specify Tag conditions.
        public var tagFilter: QConnectClientTypes.TagFilter?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.SessionIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            tagFilter: QConnectClientTypes.TagFilter? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.aiAgentConfiguration = aiAgentConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tagFilter = tagFilter
            self.tags = tags
        }
    }
}

public struct CreateSessionOutput: Swift.Sendable {
    /// The session.
    public var session: QConnectClientTypes.SessionData?

    public init(
        session: QConnectClientTypes.SessionData? = nil
    ) {
        self.session = session
    }
}

public struct GetNextMessageInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The token for the next message. Use the value returned in the SendMessage or previous response in the next request to retrieve the next message.
    /// This member is required.
    public var nextMessageToken: Swift.String?
    /// The identifier of the Amazon Q in Connect session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        nextMessageToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.nextMessageToken = nextMessageToken
        self.sessionId = sessionId
    }
}

extension QConnectClientTypes {

    /// A union type that specifies the data stored on the session.
    public enum RuntimeSessionDataValue: Swift.Sendable {
        /// The string value of the data stored on the session.
        case stringvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The list of key-value pairs that are stored on the session.
    public struct RuntimeSessionData: Swift.Sendable {
        /// The key of the data stored on the session.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the data stored on the session.
        /// This member is required.
        public var value: QConnectClientTypes.RuntimeSessionDataValue?

        public init(
            key: Swift.String? = nil,
            value: QConnectClientTypes.RuntimeSessionDataValue? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension QConnectClientTypes.RuntimeSessionData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuntimeSessionData(value: \(Swift.String(describing: value)), key: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    public enum ConversationStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case rejected
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationStatusReason] {
            return [
                .failed,
                .rejected,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum ConversationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case processing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationStatus] {
            return [
                .closed,
                .processing,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .processing: return "PROCESSING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The conversation state associated to a message.
    public struct ConversationState: Swift.Sendable {
        /// The reason of the conversation state.
        public var reason: QConnectClientTypes.ConversationStatusReason?
        /// The status of the conversation state.
        /// This member is required.
        public var status: QConnectClientTypes.ConversationStatus?

        public init(
            reason: QConnectClientTypes.ConversationStatusReason? = nil,
            status: QConnectClientTypes.ConversationStatus? = nil
        ) {
            self.reason = reason
            self.status = status
        }
    }
}

extension QConnectClientTypes {

    public enum Participant: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case bot
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [Participant] {
            return [
                .agent,
                .bot,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .bot: return "BOT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The message data in text type.
    public struct TextMessage: Swift.Sendable {
        /// The value of the message data in text type.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        ) {
            self.value = value
        }
    }
}

extension QConnectClientTypes.TextMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextMessage(value: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The message data.
    public enum MessageData: Swift.Sendable {
        /// The message data in text type.
        case text(QConnectClientTypes.TextMessage)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The message output.
    public struct MessageOutput: Swift.Sendable {
        /// The identifier of a message.
        /// This member is required.
        public var messageId: Swift.String?
        /// The participant of a message.
        /// This member is required.
        public var participant: QConnectClientTypes.Participant?
        /// The timestamp of a message.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The value of a message data.
        /// This member is required.
        public var value: QConnectClientTypes.MessageData?

        public init(
            messageId: Swift.String? = nil,
            participant: QConnectClientTypes.Participant? = nil,
            timestamp: Foundation.Date? = nil,
            value: QConnectClientTypes.MessageData? = nil
        ) {
            self.messageId = messageId
            self.participant = participant
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension QConnectClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNextMessageOutput: Swift.Sendable {
    /// The conversation data stored on an Amazon Q in Connect Session.
    public var conversationSessionData: [QConnectClientTypes.RuntimeSessionData]?
    /// The state of current conversation.
    /// This member is required.
    public var conversationState: QConnectClientTypes.ConversationState?
    /// The token for the next message.
    public var nextMessageToken: Swift.String?
    /// The identifier of the submitted message.
    /// This member is required.
    public var requestMessageId: Swift.String?
    /// The message response to the requested message.
    /// This member is required.
    public var response: QConnectClientTypes.MessageOutput?
    /// The type of message response.
    /// This member is required.
    public var type: QConnectClientTypes.MessageType?

    public init(
        conversationSessionData: [QConnectClientTypes.RuntimeSessionData]? = nil,
        conversationState: QConnectClientTypes.ConversationState? = nil,
        nextMessageToken: Swift.String? = nil,
        requestMessageId: Swift.String? = nil,
        response: QConnectClientTypes.MessageOutput? = nil,
        type: QConnectClientTypes.MessageType? = nil
    ) {
        self.conversationSessionData = conversationSessionData
        self.conversationState = conversationState
        self.nextMessageToken = nextMessageToken
        self.requestMessageId = requestMessageId
        self.response = response
        self.type = type
    }
}

public struct GetSessionInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.sessionId = sessionId
    }
}

public struct GetSessionOutput: Swift.Sendable {
    /// The session.
    public var session: QConnectClientTypes.SessionData?

    public init(
        session: QConnectClientTypes.SessionData? = nil
    ) {
        self.session = session
    }
}

public struct ListMessagesInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the Amazon Q in Connect session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

public struct ListMessagesOutput: Swift.Sendable {
    /// The message information.
    /// This member is required.
    public var messages: [QConnectClientTypes.MessageOutput]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        messages: [QConnectClientTypes.MessageOutput]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.messages = messages
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The conversation history data to included in conversation context data before the the Amazon Q in Connect session..
    public struct SelfServiceConversationHistory: Swift.Sendable {
        /// The bot response of the conversation history data.
        public var botResponse: Swift.String?
        /// The input transcript of the conversation history data.
        public var inputTranscript: Swift.String?
        /// The number of turn of the conversation history data.
        /// This member is required.
        public var turnNumber: Swift.Int?

        public init(
            botResponse: Swift.String? = nil,
            inputTranscript: Swift.String? = nil,
            turnNumber: Swift.Int? = nil
        ) {
            self.botResponse = botResponse
            self.inputTranscript = inputTranscript
            self.turnNumber = turnNumber
        }
    }
}

extension QConnectClientTypes.SelfServiceConversationHistory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfServiceConversationHistory(turnNumber: \(Swift.String(describing: turnNumber)), botResponse: \"CONTENT_REDACTED\", inputTranscript: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The conversation context to include in SendMessage.
    public struct ConversationContext: Swift.Sendable {
        /// The self service conversation history before the Amazon Q in Connect session.
        /// This member is required.
        public var selfServiceConversationHistory: [QConnectClientTypes.SelfServiceConversationHistory]?

        public init(
            selfServiceConversationHistory: [QConnectClientTypes.SelfServiceConversationHistory]? = nil
        ) {
            self.selfServiceConversationHistory = selfServiceConversationHistory
        }
    }
}

extension QConnectClientTypes {

    /// The message input.
    public struct MessageInput: Swift.Sendable {
        /// The message input value.
        /// This member is required.
        public var value: QConnectClientTypes.MessageData?

        public init(
            value: QConnectClientTypes.MessageData? = nil
        ) {
            self.value = value
        }
    }
}

public struct SendMessageInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field.For more information about idempotency, see Making retries safe with idempotent APIs.
    public var clientToken: Swift.String?
    /// The conversation context before the Amazon Q in Connect session.
    public var conversationContext: QConnectClientTypes.ConversationContext?
    /// The message data to submit to the Amazon Q in Connect session.
    /// This member is required.
    public var message: QConnectClientTypes.MessageInput?
    /// The identifier of the Amazon Q in Connect session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The message type.
    /// This member is required.
    public var type: QConnectClientTypes.MessageType?

    public init(
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        conversationContext: QConnectClientTypes.ConversationContext? = nil,
        message: QConnectClientTypes.MessageInput? = nil,
        sessionId: Swift.String? = nil,
        type: QConnectClientTypes.MessageType? = nil
    ) {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.conversationContext = conversationContext
        self.message = message
        self.sessionId = sessionId
        self.type = type
    }
}

public struct SendMessageOutput: Swift.Sendable {
    /// The token for the next message, used by GetNextMessage.
    /// This member is required.
    public var nextMessageToken: Swift.String?
    /// The identifier of the submitted message.
    /// This member is required.
    public var requestMessageId: Swift.String?

    public init(
        nextMessageToken: Swift.String? = nil,
        requestMessageId: Swift.String? = nil
    ) {
        self.nextMessageToken = nextMessageToken
        self.requestMessageId = requestMessageId
    }
}

public struct UpdateSessionInput: Swift.Sendable {
    /// The configuration of the AI Agents (mapped by AI Agent Type to AI Agent version) that should be used by Amazon Q in Connect for this Session.
    public var aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// An object that can be used to specify Tag conditions.
    public var tagFilter: QConnectClientTypes.TagFilter?

    public init(
        aiAgentConfiguration: [Swift.String: QConnectClientTypes.AIAgentConfigurationData]? = nil,
        assistantId: Swift.String? = nil,
        description: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        tagFilter: QConnectClientTypes.TagFilter? = nil
    ) {
        self.aiAgentConfiguration = aiAgentConfiguration
        self.assistantId = assistantId
        self.description = description
        self.sessionId = sessionId
        self.tagFilter = tagFilter
    }
}

public struct UpdateSessionOutput: Swift.Sendable {
    /// Information about the session.
    public var session: QConnectClientTypes.SessionData?

    public init(
        session: QConnectClientTypes.SessionData? = nil
    ) {
        self.session = session
    }
}

extension QConnectClientTypes {

    public enum SessionDataNamespace: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionDataNamespace] {
            return [
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateSessionDataInput: Swift.Sendable {
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The data stored on the Amazon Q in Connect Session.
    /// This member is required.
    public var data: [QConnectClientTypes.RuntimeSessionData]?
    /// The namespace into which the session data is stored. Supported namespaces are: Custom
    public var namespace: QConnectClientTypes.SessionDataNamespace?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        data: [QConnectClientTypes.RuntimeSessionData]? = nil,
        namespace: QConnectClientTypes.SessionDataNamespace? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.assistantId = assistantId
        self.data = data
        self.namespace = namespace
        self.sessionId = sessionId
    }
}

public struct UpdateSessionDataOutput: Swift.Sendable {
    /// Data stored in the session.
    /// This member is required.
    public var data: [QConnectClientTypes.RuntimeSessionData]?
    /// The namespace into which the session data is stored. Supported namespaces are: Custom
    /// This member is required.
    public var namespace: QConnectClientTypes.SessionDataNamespace?
    /// The Amazon Resource Name (ARN) of the session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The identifier of the session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        data: [QConnectClientTypes.RuntimeSessionData]? = nil,
        namespace: QConnectClientTypes.SessionDataNamespace? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.data = data
        self.namespace = namespace
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

public struct UpdateAssistantAIAgentInput: Swift.Sendable {
    /// The type of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
    /// This member is required.
    public var aiAgentType: QConnectClientTypes.AIAgentType?
    /// The identifier of the Amazon Q in Connect assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The configuration of the AI Agent being updated for use by default on the Amazon Q in Connect Assistant.
    /// This member is required.
    public var configuration: QConnectClientTypes.AIAgentConfigurationData?

    public init(
        aiAgentType: QConnectClientTypes.AIAgentType? = nil,
        assistantId: Swift.String? = nil,
        configuration: QConnectClientTypes.AIAgentConfigurationData? = nil
    ) {
        self.aiAgentType = aiAgentType
        self.assistantId = assistantId
        self.configuration = configuration
    }
}

public struct UpdateAssistantAIAgentOutput: Swift.Sendable {
    /// The assistant data.
    public var assistant: QConnectClientTypes.AssistantData?

    public init(
        assistant: QConnectClientTypes.AssistantData? = nil
    ) {
        self.assistant = assistant
    }
}

extension QConnectClientTypes {

    /// Instructions for interpreting the contents of a document.
    public struct ParsingPrompt: Swift.Sendable {
        /// Instructions for interpreting the contents of a document.
        /// This member is required.
        public var parsingPromptText: Swift.String?

        public init(
            parsingPromptText: Swift.String? = nil
        ) {
            self.parsingPromptText = parsingPromptText
        }
    }
}

extension QConnectClientTypes {

    /// Settings for a foundation model used to parse documents for a data source.
    public struct BedrockFoundationModelConfigurationForParsing: Swift.Sendable {
        /// The ARN of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Instructions for interpreting the contents of a document.
        public var parsingPrompt: QConnectClientTypes.ParsingPrompt?

        public init(
            modelArn: Swift.String? = nil,
            parsingPrompt: QConnectClientTypes.ParsingPrompt? = nil
        ) {
            self.modelArn = modelArn
            self.parsingPrompt = parsingPrompt
        }
    }
}

extension QConnectClientTypes {

    public enum ChannelSubtype: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case sms
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelSubtype] {
            return [
                .email,
                .sms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum ChunkingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixedSize
        case hierarchical
        case `none`
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [ChunkingStrategy] {
            return [
                .fixedSize,
                .hierarchical,
                .none,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixedSize: return "FIXED_SIZE"
            case .hierarchical: return "HIERARCHICAL"
            case .none: return "NONE"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
    public struct FixedSizeChunkingConfiguration: Swift.Sendable {
        /// The maximum number of tokens to include in a chunk.
        /// This member is required.
        public var maxTokens: Swift.Int?
        /// The percentage of overlap between adjacent chunks of a data source.
        /// This member is required.
        public var overlapPercentage: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil,
            overlapPercentage: Swift.Int? = nil
        ) {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }
    }
}

extension QConnectClientTypes {

    /// Token settings for each layer.
    public struct HierarchicalChunkingLevelConfiguration: Swift.Sendable {
        /// The maximum number of tokens that a chunk can contain in this layer.
        /// This member is required.
        public var maxTokens: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil
        ) {
            self.maxTokens = maxTokens
        }
    }
}

extension QConnectClientTypes {

    /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
    public struct HierarchicalChunkingConfiguration: Swift.Sendable {
        /// Token settings for each layer.
        /// This member is required.
        public var levelConfigurations: [QConnectClientTypes.HierarchicalChunkingLevelConfiguration]?
        /// The number of tokens to repeat across chunks in the same layer.
        /// This member is required.
        public var overlapTokens: Swift.Int?

        public init(
            levelConfigurations: [QConnectClientTypes.HierarchicalChunkingLevelConfiguration]? = nil,
            overlapTokens: Swift.Int? = nil
        ) {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }
    }
}

extension QConnectClientTypes {

    /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into smaller documents based on groups of similar content derived from the text with natural language processing.
    public struct SemanticChunkingConfiguration: Swift.Sendable {
        /// The dissimilarity threshold for splitting chunks.
        /// This member is required.
        public var breakpointPercentileThreshold: Swift.Int?
        /// The buffer size.
        /// This member is required.
        public var bufferSize: Swift.Int?
        /// The maximum number of tokens that a chunk can contain.
        /// This member is required.
        public var maxTokens: Swift.Int?

        public init(
            breakpointPercentileThreshold: Swift.Int? = nil,
            bufferSize: Swift.Int? = nil,
            maxTokens: Swift.Int? = nil
        ) {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }
    }
}

extension QConnectClientTypes {

    /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    public struct ChunkingConfiguration: Swift.Sendable {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        /// This member is required.
        public var chunkingStrategy: QConnectClientTypes.ChunkingStrategy?
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public var fixedSizeChunkingConfiguration: QConnectClientTypes.FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public var hierarchicalChunkingConfiguration: QConnectClientTypes.HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into smaller documents based on groups of similar content derived from the text with natural language processing.
        public var semanticChunkingConfiguration: QConnectClientTypes.SemanticChunkingConfiguration?

        public init(
            chunkingStrategy: QConnectClientTypes.ChunkingStrategy? = nil,
            fixedSizeChunkingConfiguration: QConnectClientTypes.FixedSizeChunkingConfiguration? = nil,
            hierarchicalChunkingConfiguration: QConnectClientTypes.HierarchicalChunkingConfiguration? = nil,
            semanticChunkingConfiguration: QConnectClientTypes.SemanticChunkingConfiguration? = nil
        ) {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }
    }
}

extension QConnectClientTypes {

    /// The configuration information of the Amazon Connect data source.
    public struct ConnectConfiguration: Swift.Sendable {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        ) {
            self.instanceId = instanceId
        }
    }
}

extension QConnectClientTypes {

    /// The configuration information of the external data source.
    public enum Configuration: Swift.Sendable {
        /// The configuration information of the Amazon Connect data source.
        case connectconfiguration(QConnectClientTypes.ConnectConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The contents of a content association.
    public enum ContentAssociationContents: Swift.Sendable {
        /// The data of the step-by-step guide association.
        case amazonconnectguideassociation(QConnectClientTypes.AmazonConnectGuideAssociationData)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum ContentAssociationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonConnectGuide
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentAssociationType] {
            return [
                .amazonConnectGuide
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonConnectGuide: return "AMAZON_CONNECT_GUIDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateContentAssociationInput: Swift.Sendable {
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: QConnectClientTypes.ContentAssociationContents?
    /// The type of association.
    /// This member is required.
    public var associationType: QConnectClientTypes.ContentAssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the content.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        association: QConnectClientTypes.ContentAssociationContents? = nil,
        associationType: QConnectClientTypes.ContentAssociationType? = nil,
        clientToken: Swift.String? = nil,
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.tags = tags
    }
}

extension QConnectClientTypes {

    /// Information about the content association.
    public struct ContentAssociationData: Swift.Sendable {
        /// The content association.
        /// This member is required.
        public var associationData: QConnectClientTypes.ContentAssociationContents?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.ContentAssociationType?
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the content association.
        /// This member is required.
        public var contentAssociationArn: Swift.String?
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var contentAssociationId: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            associationData: QConnectClientTypes.ContentAssociationContents? = nil,
            associationType: QConnectClientTypes.ContentAssociationType? = nil,
            contentArn: Swift.String? = nil,
            contentAssociationArn: Swift.String? = nil,
            contentAssociationId: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }
    }
}

public struct CreateContentAssociationOutput: Swift.Sendable {
    /// The association between Amazon Q in Connect content and another resource.
    public var contentAssociation: QConnectClientTypes.ContentAssociationData?

    public init(
        contentAssociation: QConnectClientTypes.ContentAssociationData? = nil
    ) {
        self.contentAssociation = contentAssociation
    }
}

public struct DeleteContentAssociationInput: Swift.Sendable {
    /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentAssociationId: Swift.String?
    /// The identifier of the content.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentAssociationId: Swift.String? = nil,
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.contentAssociationId = contentAssociationId
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteContentAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct GetContentAssociationInput: Swift.Sendable {
    /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentAssociationId: Swift.String?
    /// The identifier of the content.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentAssociationId: Swift.String? = nil,
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.contentAssociationId = contentAssociationId
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetContentAssociationOutput: Swift.Sendable {
    /// The association between Amazon Q in Connect content and another resource.
    public var contentAssociation: QConnectClientTypes.ContentAssociationData?

    public init(
        contentAssociation: QConnectClientTypes.ContentAssociationData? = nil
    ) {
        self.contentAssociation = contentAssociation
    }
}

public struct ListContentAssociationsInput: Swift.Sendable {
    /// The identifier of the content.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// Summary information about a content association.
    public struct ContentAssociationSummary: Swift.Sendable {
        /// The content association.
        /// This member is required.
        public var associationData: QConnectClientTypes.ContentAssociationContents?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.ContentAssociationType?
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the content association.
        /// This member is required.
        public var contentAssociationArn: Swift.String?
        /// The identifier of the content association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var contentAssociationId: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            associationData: QConnectClientTypes.ContentAssociationContents? = nil,
            associationType: QConnectClientTypes.ContentAssociationType? = nil,
            contentArn: Swift.String? = nil,
            contentAssociationArn: Swift.String? = nil,
            contentAssociationId: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.associationData = associationData
            self.associationType = associationType
            self.contentArn = contentArn
            self.contentAssociationArn = contentAssociationArn
            self.contentAssociationId = contentAssociationId
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.tags = tags
        }
    }
}

public struct ListContentAssociationsOutput: Swift.Sendable {
    /// Summary information about content associations.
    /// This member is required.
    public var contentAssociationSummaries: [QConnectClientTypes.ContentAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentAssociationSummaries: [QConnectClientTypes.ContentAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.contentAssociationSummaries = contentAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct CreateContentInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String: Swift.String]?
    /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the [SearchContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_SearchContent.html) API.
    /// This member is required.
    public var name: Swift.String?
    /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
    public var overrideLinkOutUri: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The title of the content. If not set, the title is equal to the name.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        name: Swift.String? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.name = name
        self.overrideLinkOutUri = overrideLinkOutUri
        self.tags = tags
        self.title = title
        self.uploadId = uploadId
    }
}

extension QConnectClientTypes {

    public enum ContentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Information about the content.
    public struct ContentData: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The URI of the content.
        public var linkOutUri: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String: Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the content revision.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: QConnectClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?
        /// The URL of the content.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: Foundation.Date?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            linkOutUri: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: QConnectClientTypes.ContentStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: Foundation.Date? = nil
        ) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }
}

extension QConnectClientTypes.ContentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentData(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), linkOutUri: \(Swift.String(describing: linkOutUri)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

public struct CreateContentOutput: Swift.Sendable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    ) {
        self.content = content
    }
}

public struct DeleteContentInput: Swift.Sendable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteContentOutput: Swift.Sendable {

    public init() { }
}

public struct GetContentInput: Swift.Sendable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetContentOutput: Swift.Sendable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    ) {
        self.content = content
    }
}

public struct GetContentSummaryInput: Swift.Sendable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension QConnectClientTypes {

    /// Summary information about the content.
    public struct ContentSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String: Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the revision of the content.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: QConnectClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: QConnectClientTypes.ContentStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            title: Swift.String? = nil
        ) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }
    }
}

public struct GetContentSummaryOutput: Swift.Sendable {
    /// The content summary.
    public var contentSummary: QConnectClientTypes.ContentSummary?

    public init(
        contentSummary: QConnectClientTypes.ContentSummary? = nil
    ) {
        self.contentSummary = contentSummary
    }
}

public struct ListContentsInput: Swift.Sendable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListContentsOutput: Swift.Sendable {
    /// Information about the content.
    /// This member is required.
    public var contentSummaries: [QConnectClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [QConnectClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

/// The provided revisionId does not match, indicating the content has been modified since it was last read.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct UpdateContentInput: Swift.Sendable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q in Connect, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String: Swift.String]?
    /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
    public var overrideLinkOutUri: Swift.String?
    /// Unset the existing overrideLinkOutUri if it exists.
    public var removeOverrideLinkOutUri: Swift.Bool?
    /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
    public var revisionId: Swift.String?
    /// The title of the content.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_StartContentUpload.html).
    public var uploadId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        removeOverrideLinkOutUri: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    ) {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.overrideLinkOutUri = overrideLinkOutUri
        self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
        self.revisionId = revisionId
        self.title = title
        self.uploadId = uploadId
    }
}

public struct UpdateContentOutput: Swift.Sendable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    ) {
        self.content = content
    }
}

extension QConnectClientTypes {

    public enum ContentDisposition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachment
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentDisposition] {
            return [
                .attachment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum KnowledgeBaseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case external
        case managed
        case messageTemplates
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .custom,
                .external,
                .managed,
                .messageTemplates,
                .quickResponses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .external: return "EXTERNAL"
            case .managed: return "MANAGED"
            case .messageTemplates: return "MESSAGE_TEMPLATES"
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Information about how to render the content.
    public struct RenderingConfiguration: Swift.Sendable {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:
        ///
        /// * Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted
        ///
        /// * ServiceNow: number, short_description, sys_mod_count, workflow_state, or active
        ///
        /// * Zendesk: id, title, updated_at, or draft
        ///
        ///
        /// The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_GetContent.html).
        public var templateUri: Swift.String?

        public init(
            templateUri: Swift.String? = nil
        ) {
            self.templateUri = templateUri
        }
    }
}

extension QConnectClientTypes {

    /// The configuration of crawl limits for the web URLs.
    public struct WebCrawlerLimits: Swift.Sendable {
        /// Rate of web URLs retrieved per minute.
        public var rateLimit: Swift.Int?

        public init(
            rateLimit: Swift.Int? = nil
        ) {
            self.rateLimit = rateLimit
        }
    }
}

extension QConnectClientTypes {

    public enum WebScopeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hostOnly
        case subdomains
        case sdkUnknown(Swift.String)

        public static var allCases: [WebScopeType] {
            return [
                .hostOnly,
                .subdomains
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hostOnly: return "HOST_ONLY"
            case .subdomains: return "SUBDOMAINS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// A URL for crawling.
    public struct SeedUrl: Swift.Sendable {
        /// URL for crawling
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension QConnectClientTypes {

    /// The configuration of the URL/URLs for the web content that you want to crawl. You should be authorized to crawl the URLs.
    public struct UrlConfiguration: Swift.Sendable {
        /// List of URLs for crawling.
        public var seedUrls: [QConnectClientTypes.SeedUrl]?

        public init(
            seedUrls: [QConnectClientTypes.SeedUrl]? = nil
        ) {
            self.seedUrls = seedUrls
        }
    }
}

extension QConnectClientTypes {

    /// The configuration details for the web data source.
    public struct WebCrawlerConfiguration: Swift.Sendable {
        /// The configuration of crawl limits for the web URLs.
        public var crawlerLimits: QConnectClientTypes.WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        public var exclusionFilters: [Swift.String]?
        /// A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        public var inclusionFilters: [Swift.String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL https://docs.aws.amazon.com/bedrock/latest/userguide/ and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain aws.amazon.com can also include sub domain docs.aws.amazon.com.
        public var scope: QConnectClientTypes.WebScopeType?
        /// The configuration of the URL/URLs for the web content that you want to crawl. You should be authorized to crawl the URLs.
        /// This member is required.
        public var urlConfiguration: QConnectClientTypes.UrlConfiguration?

        public init(
            crawlerLimits: QConnectClientTypes.WebCrawlerLimits? = nil,
            exclusionFilters: [Swift.String]? = nil,
            inclusionFilters: [Swift.String]? = nil,
            scope: QConnectClientTypes.WebScopeType? = nil,
            urlConfiguration: QConnectClientTypes.UrlConfiguration? = nil
        ) {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
            self.urlConfiguration = urlConfiguration
        }
    }
}

extension QConnectClientTypes.WebCrawlerConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebCrawlerConfiguration(crawlerLimits: \(Swift.String(describing: crawlerLimits)), scope: \(Swift.String(describing: scope)), urlConfiguration: \(Swift.String(describing: urlConfiguration)), exclusionFilters: \"CONTENT_REDACTED\", inclusionFilters: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Source configuration for managed resources.
    public enum ManagedSourceConfiguration: Swift.Sendable {
        /// Configuration data for web crawler data source.
        case webcrawlerconfiguration(QConnectClientTypes.WebCrawlerConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// Configuration information about the external data source.
    public enum SourceConfiguration: Swift.Sendable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appintegrations(QConnectClientTypes.AppIntegrationsConfiguration)
        /// Source configuration for managed resources.
        case managedsourceconfiguration(QConnectClientTypes.ManagedSourceConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    public enum ParsingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bedrockFoundationModel
        case sdkUnknown(Swift.String)

        public static var allCases: [ParsingStrategy] {
            return [
                .bedrockFoundationModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bedrockFoundationModel: return "BEDROCK_FOUNDATION_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Settings for parsing document contents. By default, the service converts the contents of each document into text before splitting it into chunks. To improve processing of PDF files with tables and images, you can configure the data source to convert the pages of text into images and use a model to describe the contents of each page.
    public struct ParsingConfiguration: Swift.Sendable {
        /// Settings for a foundation model used to parse documents for a data source.
        public var bedrockFoundationModelConfiguration: QConnectClientTypes.BedrockFoundationModelConfigurationForParsing?
        /// The parsing strategy for the data source.
        /// This member is required.
        public var parsingStrategy: QConnectClientTypes.ParsingStrategy?

        public init(
            bedrockFoundationModelConfiguration: QConnectClientTypes.BedrockFoundationModelConfigurationForParsing? = nil,
            parsingStrategy: QConnectClientTypes.ParsingStrategy? = nil
        ) {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }
    }
}

extension QConnectClientTypes {

    /// Contains details about how to ingest the documents in a data source.
    public struct VectorIngestionConfiguration: Swift.Sendable {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public var chunkingConfiguration: QConnectClientTypes.ChunkingConfiguration?
        /// A custom parser for data source documents.
        public var parsingConfiguration: QConnectClientTypes.ParsingConfiguration?

        public init(
            chunkingConfiguration: QConnectClientTypes.ChunkingConfiguration? = nil,
            parsingConfiguration: QConnectClientTypes.ParsingConfiguration? = nil
        ) {
            self.chunkingConfiguration = chunkingConfiguration
            self.parsingConfiguration = parsingConfiguration
        }
    }
}

public struct CreateKnowledgeBaseInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
    /// This member is required.
    public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
    /// The name of the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Information about how to render the content.
    public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
    /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
    public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
    /// The source of the knowledge base content. Only set this argument for EXTERNAL or Managed knowledge bases.
    public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// Contains details about how to ingest the documents in a data source.
    public var vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
        name: Swift.String? = nil,
        renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
        serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
        sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseType = knowledgeBaseType
        self.name = name
        self.renderingConfiguration = renderingConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

extension QConnectClientTypes {

    public enum SyncStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createInProgress
        case syncingInProgress
        case syncFailed
        case syncSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncStatus] {
            return [
                .createInProgress,
                .syncingInProgress,
                .syncFailed,
                .syncSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .syncingInProgress: return "SYNCING_IN_PROGRESS"
            case .syncFailed: return "SYNC_FAILED"
            case .syncSuccess: return "SYNC_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum KnowledgeBaseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Information about the knowledge base.
    public struct KnowledgeBaseData: Swift.Sendable {
        /// The description.
        public var description: Swift.String?
        /// List of failure reasons on ingestion per file.
        public var ingestionFailureReasons: [Swift.String]?
        /// Status of ingestion on data source.
        public var ingestionStatus: QConnectClientTypes.SyncStatus?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public var lastContentModificationTime: Foundation.Date?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: QConnectClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// Contains details about how to ingest the documents in a data source.
        public var vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration?

        public init(
            description: Swift.String? = nil,
            ingestionFailureReasons: [Swift.String]? = nil,
            ingestionStatus: QConnectClientTypes.SyncStatus? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
            lastContentModificationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
            status: QConnectClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration? = nil
        ) {
            self.description = description
            self.ingestionFailureReasons = ingestionFailureReasons
            self.ingestionStatus = ingestionStatus
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }
}

public struct CreateKnowledgeBaseOutput: Swift.Sendable {
    /// The knowledge base.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    ) {
        self.knowledgeBase = knowledgeBase
    }
}

extension QConnectClientTypes {

    /// The container of the message template body.
    public enum MessageTemplateBodyContentProvider: Swift.Sendable {
        /// The content of the message template.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The body to use in email messages.
    public struct EmailMessageTemplateContentBody: Swift.Sendable {
        /// The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        public var html: QConnectClientTypes.MessageTemplateBodyContentProvider?
        /// The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        public var plainText: QConnectClientTypes.MessageTemplateBodyContentProvider?

        public init(
            html: QConnectClientTypes.MessageTemplateBodyContentProvider? = nil,
            plainText: QConnectClientTypes.MessageTemplateBodyContentProvider? = nil
        ) {
            self.html = html
            self.plainText = plainText
        }
    }
}

extension QConnectClientTypes {

    /// The email header to include in email messages.
    public struct EmailHeader: Swift.Sendable {
        /// The name of the email header.
        public var name: Swift.String?
        /// The value of the email header.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.name = name
            self.value = value
        }
    }
}

extension QConnectClientTypes.EmailHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailHeader(name: \(Swift.String(describing: name)), value: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The content of the message template that applies to the email channel subtype.
    public struct EmailMessageTemplateContent: Swift.Sendable {
        /// The body to use in email messages.
        public var body: QConnectClientTypes.EmailMessageTemplateContentBody?
        /// The email headers to include in email messages.
        public var headers: [QConnectClientTypes.EmailHeader]?
        /// The subject line, or title, to use in email messages.
        public var subject: Swift.String?

        public init(
            body: QConnectClientTypes.EmailMessageTemplateContentBody? = nil,
            headers: [QConnectClientTypes.EmailHeader]? = nil,
            subject: Swift.String? = nil
        ) {
            self.body = body
            self.headers = headers
            self.subject = subject
        }
    }
}

extension QConnectClientTypes.EmailMessageTemplateContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailMessageTemplateContent(body: \(Swift.String(describing: body)), headers: \(Swift.String(describing: headers)), subject: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The body to use in SMS messages.
    public struct SMSMessageTemplateContentBody: Swift.Sendable {
        /// The message body to use in SMS messages.
        public var plainText: QConnectClientTypes.MessageTemplateBodyContentProvider?

        public init(
            plainText: QConnectClientTypes.MessageTemplateBodyContentProvider? = nil
        ) {
            self.plainText = plainText
        }
    }
}

extension QConnectClientTypes {

    /// The content of the message template that applies to the SMS channel subtype.
    public struct SMSMessageTemplateContent: Swift.Sendable {
        /// The body to use in SMS messages.
        public var body: QConnectClientTypes.SMSMessageTemplateContentBody?

        public init(
            body: QConnectClientTypes.SMSMessageTemplateContentBody? = nil
        ) {
            self.body = body
        }
    }
}

extension QConnectClientTypes {

    /// The container of message template content.
    public enum MessageTemplateContentProvider: Swift.Sendable {
        /// The content of the message template that applies to the email channel subtype.
        case email(QConnectClientTypes.EmailMessageTemplateContent)
        /// The content of the message template that applies to the SMS channel subtype.
        case sms(QConnectClientTypes.SMSMessageTemplateContent)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The customer profile attributes that are used with the message template.
    public struct CustomerProfileAttributes: Swift.Sendable {
        /// A unique account number that you have given to the customer.
        public var accountNumber: Swift.String?
        /// Any additional information relevant to the customer's profile.
        public var additionalInformation: Swift.String?
        /// The first line of a customer address.
        public var address1: Swift.String?
        /// The second line of a customer address.
        public var address2: Swift.String?
        /// The third line of a customer address.
        public var address3: Swift.String?
        /// The fourth line of a customer address.
        public var address4: Swift.String?
        /// The first line of a customer’s billing address.
        public var billingAddress1: Swift.String?
        /// The second line of a customer’s billing address.
        public var billingAddress2: Swift.String?
        /// The third line of a customer’s billing address.
        public var billingAddress3: Swift.String?
        /// The fourth line of a customer’s billing address.
        public var billingAddress4: Swift.String?
        /// The city of a customer’s billing address.
        public var billingCity: Swift.String?
        /// The country of a customer’s billing address.
        public var billingCountry: Swift.String?
        /// The county of a customer’s billing address.
        public var billingCounty: Swift.String?
        /// The postal code of a customer’s billing address.
        public var billingPostalCode: Swift.String?
        /// The province of a customer’s billing address.
        public var billingProvince: Swift.String?
        /// The state of a customer’s billing address.
        public var billingState: Swift.String?
        /// The customer's birth date.
        public var birthDate: Swift.String?
        /// The customer's business email address.
        public var businessEmailAddress: Swift.String?
        /// The name of the customer's business.
        public var businessName: Swift.String?
        /// The customer's business phone number.
        public var businessPhoneNumber: Swift.String?
        /// The city in which a customer lives.
        public var city: Swift.String?
        /// The country in which a customer lives.
        public var country: Swift.String?
        /// The county in which a customer lives.
        public var county: Swift.String?
        /// The custom attributes in customer profile attributes.
        public var custom: [Swift.String: Swift.String]?
        /// The customer's email address, which has not been specified as a personal or business address.
        public var emailAddress: Swift.String?
        /// The customer's first name.
        public var firstName: Swift.String?
        /// The customer's gender.
        public var gender: Swift.String?
        /// The customer's mobile phone number.
        public var homePhoneNumber: Swift.String?
        /// The customer's last name.
        public var lastName: Swift.String?
        /// The first line of a customer’s mailing address.
        public var mailingAddress1: Swift.String?
        /// The second line of a customer’s mailing address.
        public var mailingAddress2: Swift.String?
        /// The third line of a customer’s mailing address.
        public var mailingAddress3: Swift.String?
        /// The fourth line of a customer’s mailing address.
        public var mailingAddress4: Swift.String?
        /// The city of a customer’s mailing address.
        public var mailingCity: Swift.String?
        /// The country of a customer’s mailing address.
        public var mailingCountry: Swift.String?
        /// The county of a customer’s mailing address.
        public var mailingCounty: Swift.String?
        /// The postal code of a customer’s mailing address.
        public var mailingPostalCode: Swift.String?
        /// The province of a customer’s mailing address.
        public var mailingProvince: Swift.String?
        /// The state of a customer’s mailing address.
        public var mailingState: Swift.String?
        /// The customer's middle name.
        public var middleName: Swift.String?
        /// The customer's mobile phone number.
        public var mobilePhoneNumber: Swift.String?
        /// The customer's party type.
        public var partyType: Swift.String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public var phoneNumber: Swift.String?
        /// The postal code of a customer address.
        public var postalCode: Swift.String?
        /// The ARN of a customer profile.
        public var profileARN: Swift.String?
        /// The unique identifier of a customer profile.
        public var profileId: Swift.String?
        /// The province in which a customer lives.
        public var province: Swift.String?
        /// The first line of a customer’s shipping address.
        public var shippingAddress1: Swift.String?
        /// The second line of a customer’s shipping address.
        public var shippingAddress2: Swift.String?
        /// The third line of a customer’s shipping address.
        public var shippingAddress3: Swift.String?
        /// The fourth line of a customer’s shipping address.
        public var shippingAddress4: Swift.String?
        /// The city of a customer’s shipping address.
        public var shippingCity: Swift.String?
        /// The country of a customer’s shipping address.
        public var shippingCountry: Swift.String?
        /// The county of a customer’s shipping address.
        public var shippingCounty: Swift.String?
        /// The postal code of a customer’s shipping address.
        public var shippingPostalCode: Swift.String?
        /// The province of a customer’s shipping address.
        public var shippingProvince: Swift.String?
        /// The state of a customer’s shipping address.
        public var shippingState: Swift.String?
        /// The state in which a customer lives.
        public var state: Swift.String?

        public init(
            accountNumber: Swift.String? = nil,
            additionalInformation: Swift.String? = nil,
            address1: Swift.String? = nil,
            address2: Swift.String? = nil,
            address3: Swift.String? = nil,
            address4: Swift.String? = nil,
            billingAddress1: Swift.String? = nil,
            billingAddress2: Swift.String? = nil,
            billingAddress3: Swift.String? = nil,
            billingAddress4: Swift.String? = nil,
            billingCity: Swift.String? = nil,
            billingCountry: Swift.String? = nil,
            billingCounty: Swift.String? = nil,
            billingPostalCode: Swift.String? = nil,
            billingProvince: Swift.String? = nil,
            billingState: Swift.String? = nil,
            birthDate: Swift.String? = nil,
            businessEmailAddress: Swift.String? = nil,
            businessName: Swift.String? = nil,
            businessPhoneNumber: Swift.String? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            county: Swift.String? = nil,
            custom: [Swift.String: Swift.String]? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            gender: Swift.String? = nil,
            homePhoneNumber: Swift.String? = nil,
            lastName: Swift.String? = nil,
            mailingAddress1: Swift.String? = nil,
            mailingAddress2: Swift.String? = nil,
            mailingAddress3: Swift.String? = nil,
            mailingAddress4: Swift.String? = nil,
            mailingCity: Swift.String? = nil,
            mailingCountry: Swift.String? = nil,
            mailingCounty: Swift.String? = nil,
            mailingPostalCode: Swift.String? = nil,
            mailingProvince: Swift.String? = nil,
            mailingState: Swift.String? = nil,
            middleName: Swift.String? = nil,
            mobilePhoneNumber: Swift.String? = nil,
            partyType: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            profileARN: Swift.String? = nil,
            profileId: Swift.String? = nil,
            province: Swift.String? = nil,
            shippingAddress1: Swift.String? = nil,
            shippingAddress2: Swift.String? = nil,
            shippingAddress3: Swift.String? = nil,
            shippingAddress4: Swift.String? = nil,
            shippingCity: Swift.String? = nil,
            shippingCountry: Swift.String? = nil,
            shippingCounty: Swift.String? = nil,
            shippingPostalCode: Swift.String? = nil,
            shippingProvince: Swift.String? = nil,
            shippingState: Swift.String? = nil,
            state: Swift.String? = nil
        ) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.billingAddress1 = billingAddress1
            self.billingAddress2 = billingAddress2
            self.billingAddress3 = billingAddress3
            self.billingAddress4 = billingAddress4
            self.billingCity = billingCity
            self.billingCountry = billingCountry
            self.billingCounty = billingCounty
            self.billingPostalCode = billingPostalCode
            self.billingProvince = billingProvince
            self.billingState = billingState
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.city = city
            self.country = country
            self.county = county
            self.custom = custom
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress1 = mailingAddress1
            self.mailingAddress2 = mailingAddress2
            self.mailingAddress3 = mailingAddress3
            self.mailingAddress4 = mailingAddress4
            self.mailingCity = mailingCity
            self.mailingCountry = mailingCountry
            self.mailingCounty = mailingCounty
            self.mailingPostalCode = mailingPostalCode
            self.mailingProvince = mailingProvince
            self.mailingState = mailingState
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.profileARN = profileARN
            self.profileId = profileId
            self.province = province
            self.shippingAddress1 = shippingAddress1
            self.shippingAddress2 = shippingAddress2
            self.shippingAddress3 = shippingAddress3
            self.shippingAddress4 = shippingAddress4
            self.shippingCity = shippingCity
            self.shippingCountry = shippingCountry
            self.shippingCounty = shippingCounty
            self.shippingPostalCode = shippingPostalCode
            self.shippingProvince = shippingProvince
            self.shippingState = shippingState
            self.state = state
        }
    }
}

extension QConnectClientTypes.CustomerProfileAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerProfileAttributes(accountNumber: \"CONTENT_REDACTED\", additionalInformation: \"CONTENT_REDACTED\", address1: \"CONTENT_REDACTED\", address2: \"CONTENT_REDACTED\", address3: \"CONTENT_REDACTED\", address4: \"CONTENT_REDACTED\", billingAddress1: \"CONTENT_REDACTED\", billingAddress2: \"CONTENT_REDACTED\", billingAddress3: \"CONTENT_REDACTED\", billingAddress4: \"CONTENT_REDACTED\", billingCity: \"CONTENT_REDACTED\", billingCountry: \"CONTENT_REDACTED\", billingCounty: \"CONTENT_REDACTED\", billingPostalCode: \"CONTENT_REDACTED\", billingProvince: \"CONTENT_REDACTED\", billingState: \"CONTENT_REDACTED\", birthDate: \"CONTENT_REDACTED\", businessEmailAddress: \"CONTENT_REDACTED\", businessName: \"CONTENT_REDACTED\", businessPhoneNumber: \"CONTENT_REDACTED\", city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", county: \"CONTENT_REDACTED\", custom: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", gender: \"CONTENT_REDACTED\", homePhoneNumber: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", mailingAddress1: \"CONTENT_REDACTED\", mailingAddress2: \"CONTENT_REDACTED\", mailingAddress3: \"CONTENT_REDACTED\", mailingAddress4: \"CONTENT_REDACTED\", mailingCity: \"CONTENT_REDACTED\", mailingCountry: \"CONTENT_REDACTED\", mailingCounty: \"CONTENT_REDACTED\", mailingPostalCode: \"CONTENT_REDACTED\", mailingProvince: \"CONTENT_REDACTED\", mailingState: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\", mobilePhoneNumber: \"CONTENT_REDACTED\", partyType: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", profileARN: \"CONTENT_REDACTED\", profileId: \"CONTENT_REDACTED\", province: \"CONTENT_REDACTED\", shippingAddress1: \"CONTENT_REDACTED\", shippingAddress2: \"CONTENT_REDACTED\", shippingAddress3: \"CONTENT_REDACTED\", shippingAddress4: \"CONTENT_REDACTED\", shippingCity: \"CONTENT_REDACTED\", shippingCountry: \"CONTENT_REDACTED\", shippingCounty: \"CONTENT_REDACTED\", shippingPostalCode: \"CONTENT_REDACTED\", shippingProvince: \"CONTENT_REDACTED\", shippingState: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The system endpoint attributes that are used with the message template.
    public struct SystemEndpointAttributes: Swift.Sendable {
        /// The customer's phone number if used with customerEndpoint, or the number the customer dialed to call your contact center if used with systemEndpoint.
        public var address: Swift.String?

        public init(
            address: Swift.String? = nil
        ) {
            self.address = address
        }
    }
}

extension QConnectClientTypes.SystemEndpointAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SystemEndpointAttributes(address: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The system attributes that are used with the message template.
    public struct SystemAttributes: Swift.Sendable {
        /// The CustomerEndpoint attribute.
        public var customerEndpoint: QConnectClientTypes.SystemEndpointAttributes?
        /// The name of the task.
        public var name: Swift.String?
        /// The SystemEndpoint attribute.
        public var systemEndpoint: QConnectClientTypes.SystemEndpointAttributes?

        public init(
            customerEndpoint: QConnectClientTypes.SystemEndpointAttributes? = nil,
            name: Swift.String? = nil,
            systemEndpoint: QConnectClientTypes.SystemEndpointAttributes? = nil
        ) {
            self.customerEndpoint = customerEndpoint
            self.name = name
            self.systemEndpoint = systemEndpoint
        }
    }
}

extension QConnectClientTypes.SystemAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SystemAttributes(customerEndpoint: \(Swift.String(describing: customerEndpoint)), systemEndpoint: \(Swift.String(describing: systemEndpoint)), name: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The attributes that are used with the message template.
    public struct MessageTemplateAttributes: Swift.Sendable {
        /// The agent attributes that are used with the message template.
        public var agentAttributes: QConnectClientTypes.AgentAttributes?
        /// The custom attributes that are used with the message template.
        public var customAttributes: [Swift.String: Swift.String]?
        /// The customer profile attributes that are used with the message template.
        public var customerProfileAttributes: QConnectClientTypes.CustomerProfileAttributes?
        /// The system attributes that are used with the message template.
        public var systemAttributes: QConnectClientTypes.SystemAttributes?

        public init(
            agentAttributes: QConnectClientTypes.AgentAttributes? = nil,
            customAttributes: [Swift.String: Swift.String]? = nil,
            customerProfileAttributes: QConnectClientTypes.CustomerProfileAttributes? = nil,
            systemAttributes: QConnectClientTypes.SystemAttributes? = nil
        ) {
            self.agentAttributes = agentAttributes
            self.customAttributes = customAttributes
            self.customerProfileAttributes = customerProfileAttributes
            self.systemAttributes = systemAttributes
        }
    }
}

extension QConnectClientTypes.MessageTemplateAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageTemplateAttributes(agentAttributes: \(Swift.String(describing: agentAttributes)), customerProfileAttributes: \(Swift.String(describing: customerProfileAttributes)), systemAttributes: \(Swift.String(describing: systemAttributes)), customAttributes: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The configuration information of the grouping of Amazon Q in Connect users.
    public struct GroupingConfiguration: Swift.Sendable {
        /// The criteria used for grouping Amazon Q in Connect users. The following is the list of supported criteria values.
        ///
        /// * RoutingProfileArn: Grouping the users by their [Amazon Connect routing profile ARN](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html). User should have [SearchRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_SearchRoutingProfiles.html) and [DescribeRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribeRoutingProfile.html) permissions when setting criteria to this value.
        public var criteria: Swift.String?
        /// The list of values that define different groups of Amazon Q in Connect users.
        ///
        /// * When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of [Amazon Connect routing profiles](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html) as values of this parameter.
        public var values: [Swift.String]?

        public init(
            criteria: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.criteria = criteria
            self.values = values
        }
    }
}

extension QConnectClientTypes.GroupingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupingConfiguration(criteria: \"CONTENT_REDACTED\", values: \"CONTENT_REDACTED\")"}
}

public struct CreateMessageTemplateInput: Swift.Sendable {
    /// The channel subtype this message template applies to.
    /// This member is required.
    public var channelSubtype: QConnectClientTypes.ChannelSubtype?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The content of the message template.
    /// This member is required.
    public var content: QConnectClientTypes.MessageTemplateContentProvider?
    /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
    public var defaultAttributes: QConnectClientTypes.MessageTemplateAttributes?
    /// The description of the message template.
    public var description: Swift.String?
    /// The configuration information of the grouping of Amazon Q in Connect users.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the message template.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
        clientToken: Swift.String? = nil,
        content: QConnectClientTypes.MessageTemplateContentProvider? = nil,
        defaultAttributes: QConnectClientTypes.MessageTemplateAttributes? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.channelSubtype = channelSubtype
        self.clientToken = clientToken
        self.content = content
        self.defaultAttributes = defaultAttributes
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.tags = tags
    }
}

extension QConnectClientTypes {

    public enum MessageTemplateAttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case custom
        case customerProfile
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageTemplateAttributeType] {
            return [
                .agent,
                .custom,
                .customerProfile,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .custom: return "CUSTOM"
            case .customerProfile: return "CUSTOMER_PROFILE"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The data of a message template.
    public struct MessageTemplateData: Swift.Sendable {
        /// The types of attributes that the message template contains.
        public var attributeTypes: [QConnectClientTypes.MessageTemplateAttributeType]?
        /// The channel subtype this message template applies to.
        /// This member is required.
        public var channelSubtype: QConnectClientTypes.ChannelSubtype?
        /// The content of the message template.
        /// This member is required.
        public var content: QConnectClientTypes.MessageTemplateContentProvider?
        /// The timestamp when the message template was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public var defaultAttributes: QConnectClientTypes.MessageTemplateAttributes?
        /// The description of the message template.
        public var description: Swift.String?
        /// The configuration information of the grouping of Amazon Q in Connect users.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the message template data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the message template.
        /// This member is required.
        public var messageTemplateArn: Swift.String?
        /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. It’s calculated by content, language, defaultAttributes and Attachments of the message template.
        /// This member is required.
        public var messageTemplateContentSha256: Swift.String?
        /// The identifier of the message template.
        /// This member is required.
        public var messageTemplateId: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            attributeTypes: [QConnectClientTypes.MessageTemplateAttributeType]? = nil,
            channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
            content: QConnectClientTypes.MessageTemplateContentProvider? = nil,
            createdTime: Foundation.Date? = nil,
            defaultAttributes: QConnectClientTypes.MessageTemplateAttributes? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            messageTemplateArn: Swift.String? = nil,
            messageTemplateContentSha256: Swift.String? = nil,
            messageTemplateId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.attributeTypes = attributeTypes
            self.channelSubtype = channelSubtype
            self.content = content
            self.createdTime = createdTime
            self.defaultAttributes = defaultAttributes
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateContentSha256 = messageTemplateContentSha256
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
        }
    }
}

public struct CreateMessageTemplateOutput: Swift.Sendable {
    /// The message template.
    public var messageTemplate: QConnectClientTypes.MessageTemplateData?

    public init(
        messageTemplate: QConnectClientTypes.MessageTemplateData? = nil
    ) {
        self.messageTemplate = messageTemplate
    }
}

public struct CreateMessageTemplateAttachmentInput: Swift.Sendable {
    /// The body of the attachment file being uploaded. It should be encoded using base64 encoding.
    /// This member is required.
    public var body: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The presentation information for the attachment file.
    /// This member is required.
    public var contentDisposition: QConnectClientTypes.ContentDisposition?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The name of the attachment file being uploaded. The name should include the file extension.
    /// This member is required.
    public var name: Swift.String?

    public init(
        body: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contentDisposition: QConnectClientTypes.ContentDisposition? = nil,
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.body = body
        self.clientToken = clientToken
        self.contentDisposition = contentDisposition
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
        self.name = name
    }
}

extension CreateMessageTemplateAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMessageTemplateAttachmentInput(clientToken: \(Swift.String(describing: clientToken)), contentDisposition: \(Swift.String(describing: contentDisposition)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), messageTemplateId: \(Swift.String(describing: messageTemplateId)), body: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Information about the message template attachment.
    public struct MessageTemplateAttachment: Swift.Sendable {
        /// The identifier of the attachment file.
        /// This member is required.
        public var attachmentId: Swift.String?
        /// The presentation information for the attachment file.
        /// This member is required.
        public var contentDisposition: QConnectClientTypes.ContentDisposition?
        /// The name of the attachment file being uploaded. The name should include the file extension.
        /// This member is required.
        public var name: Swift.String?
        /// The timestamp when the attachment file was uploaded.
        /// This member is required.
        public var uploadedTime: Foundation.Date?
        /// A pre-signed Amazon S3 URL that can be used to download the attachment file.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the pre-signed Amazon S3 URL.
        /// This member is required.
        public var urlExpiry: Foundation.Date?

        public init(
            attachmentId: Swift.String? = nil,
            contentDisposition: QConnectClientTypes.ContentDisposition? = nil,
            name: Swift.String? = nil,
            uploadedTime: Foundation.Date? = nil,
            url: Swift.String? = nil,
            urlExpiry: Foundation.Date? = nil
        ) {
            self.attachmentId = attachmentId
            self.contentDisposition = contentDisposition
            self.name = name
            self.uploadedTime = uploadedTime
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }
}

extension QConnectClientTypes.MessageTemplateAttachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageTemplateAttachment(attachmentId: \(Swift.String(describing: attachmentId)), contentDisposition: \(Swift.String(describing: contentDisposition)), uploadedTime: \(Swift.String(describing: uploadedTime)), urlExpiry: \(Swift.String(describing: urlExpiry)), name: \"CONTENT_REDACTED\", url: \"CONTENT_REDACTED\")"}
}

public struct CreateMessageTemplateAttachmentOutput: Swift.Sendable {
    /// The message template attachment.
    public var attachment: QConnectClientTypes.MessageTemplateAttachment?

    public init(
        attachment: QConnectClientTypes.MessageTemplateAttachment? = nil
    ) {
        self.attachment = attachment
    }
}

public struct CreateMessageTemplateVersionInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. It’s calculated by content, language, defaultAttributes and Attachments of the message template. If not supplied, the message template version will be created based on the message template content that is referenced by the $LATEST qualifier by default.
    public var messageTemplateContentSha256: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateContentSha256: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateContentSha256 = messageTemplateContentSha256
        self.messageTemplateId = messageTemplateId
    }
}

extension QConnectClientTypes {

    /// The extended data of a message template.
    public struct ExtendedMessageTemplateData: Swift.Sendable {
        /// The message template attachments.
        public var attachments: [QConnectClientTypes.MessageTemplateAttachment]?
        /// The types of attributes contain the message template.
        public var attributeTypes: [QConnectClientTypes.MessageTemplateAttributeType]?
        /// The channel subtype this message template applies to.
        /// This member is required.
        public var channelSubtype: QConnectClientTypes.ChannelSubtype?
        /// The content of the message template.
        /// This member is required.
        public var content: QConnectClientTypes.MessageTemplateContentProvider?
        /// The timestamp when the message template was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        public var defaultAttributes: QConnectClientTypes.MessageTemplateAttributes?
        /// The description of the message template.
        public var description: Swift.String?
        /// The configuration information of the grouping of Amazon Q in Connect users.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the version of the message template is activated.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the message template data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the message template.
        /// This member is required.
        public var messageTemplateArn: Swift.String?
        /// The checksum value of the message template content that is referenced by the $LATEST qualifier. It can be returned in MessageTemplateData or ExtendedMessageTemplateData. It’s calculated by content, language, defaultAttributes and Attachments of the message template.
        /// This member is required.
        public var messageTemplateContentSha256: Swift.String?
        /// The identifier of the message template.
        /// This member is required.
        public var messageTemplateId: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The version number of the message template version.
        public var versionNumber: Swift.Int?

        public init(
            attachments: [QConnectClientTypes.MessageTemplateAttachment]? = nil,
            attributeTypes: [QConnectClientTypes.MessageTemplateAttributeType]? = nil,
            channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
            content: QConnectClientTypes.MessageTemplateContentProvider? = nil,
            createdTime: Foundation.Date? = nil,
            defaultAttributes: QConnectClientTypes.MessageTemplateAttributes? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            messageTemplateArn: Swift.String? = nil,
            messageTemplateContentSha256: Swift.String? = nil,
            messageTemplateId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.attachments = attachments
            self.attributeTypes = attributeTypes
            self.channelSubtype = channelSubtype
            self.content = content
            self.createdTime = createdTime
            self.defaultAttributes = defaultAttributes
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateContentSha256 = messageTemplateContentSha256
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
            self.versionNumber = versionNumber
        }
    }
}

public struct CreateMessageTemplateVersionOutput: Swift.Sendable {
    /// The message template.
    public var messageTemplate: QConnectClientTypes.ExtendedMessageTemplateData?

    public init(
        messageTemplate: QConnectClientTypes.ExtendedMessageTemplateData? = nil
    ) {
        self.messageTemplate = messageTemplate
    }
}

extension QConnectClientTypes {

    /// The container of quick response data.
    public enum QuickResponseDataProvider: Swift.Sendable {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateQuickResponseInput: Swift.Sendable {
    /// The Amazon Connect channels this quick response applies to.
    public var channels: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](http://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The content of the quick response.
    /// This member is required.
    public var content: QConnectClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for a quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for a quick response written in richtext.
    public var contentType: Swift.String?
    /// The description of the quick response.
    public var description: Swift.String?
    /// The configuration information of the user groups that the quick response is accessible to.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    /// This member is required.
    public var name: Swift.String?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        channels: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        content: QConnectClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        shortcutKey: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.channels = channels
        self.clientToken = clientToken
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.shortcutKey = shortcutKey
        self.tags = tags
    }
}

extension CreateQuickResponseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQuickResponseInput(clientToken: \(Swift.String(describing: clientToken)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), name: \(Swift.String(describing: name)), shortcutKey: \(Swift.String(describing: shortcutKey)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The container quick response content.
    public enum QuickResponseContentProvider: Swift.Sendable {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// The content of the quick response stored in different media types.
    public struct QuickResponseContents: Swift.Sendable {
        /// The container quick response content.
        public var markdown: QConnectClientTypes.QuickResponseContentProvider?
        /// The container quick response content.
        public var plainText: QConnectClientTypes.QuickResponseContentProvider?

        public init(
            markdown: QConnectClientTypes.QuickResponseContentProvider? = nil,
            plainText: QConnectClientTypes.QuickResponseContentProvider? = nil
        ) {
            self.markdown = markdown
            self.plainText = plainText
        }
    }
}

extension QConnectClientTypes {

    public enum QuickResponseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseStatus] {
            return [
                .created,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Information about the quick response.
    public struct QuickResponseData: Swift.Sendable {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        public var contents: QConnectClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The status of the quick response data.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: QConnectClientTypes.QuickResponseContents? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }
}

extension QConnectClientTypes.QuickResponseData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseData(contentType: \(Swift.String(describing: contentType)), contents: \(Swift.String(describing: contents)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), shortcutKey: \(Swift.String(describing: shortcutKey)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

public struct CreateQuickResponseOutput: Swift.Sendable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    ) {
        self.quickResponse = quickResponse
    }
}

public struct DeactivateMessageTemplateInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The version number of the message template version to deactivate.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
        self.versionNumber = versionNumber
    }
}

public struct DeactivateMessageTemplateOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the message template.
    /// This member is required.
    public var messageTemplateArn: Swift.String?
    /// The identifier of the message template.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The version number of the message template version that has been deactivated.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        messageTemplateArn: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    ) {
        self.messageTemplateArn = messageTemplateArn
        self.messageTemplateId = messageTemplateId
        self.versionNumber = versionNumber
    }
}

public struct DeleteImportJobInput: Swift.Sendable {
    /// The identifier of the import job to be deleted.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteImportJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteKnowledgeBaseInput: Swift.Sendable {
    /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteKnowledgeBaseOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMessageTemplateInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
    }
}

public struct DeleteMessageTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMessageTemplateAttachmentInput: Swift.Sendable {
    /// The identifier of the attachment file.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.attachmentId = attachmentId
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
    }
}

public struct DeleteMessageTemplateAttachmentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteQuickResponseInput: Swift.Sendable {
    /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response to delete.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

public struct DeleteQuickResponseOutput: Swift.Sendable {

    public init() { }
}

extension QConnectClientTypes {

    public enum ExternalSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSource] {
            return [
                .amazonConnect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonConnect: return "AMAZON_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The configuration information of the external data source.
    public struct ExternalSourceConfiguration: Swift.Sendable {
        /// The configuration information of the external data source.
        /// This member is required.
        public var configuration: QConnectClientTypes.Configuration?
        /// The type of the external data source.
        /// This member is required.
        public var source: QConnectClientTypes.ExternalSource?

        public init(
            configuration: QConnectClientTypes.Configuration? = nil,
            source: QConnectClientTypes.ExternalSource? = nil
        ) {
            self.configuration = configuration
            self.source = source
        }
    }
}

public struct GetImportJobInput: Swift.Sendable {
    /// The identifier of the import job to retrieve.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base that the import job belongs to.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension QConnectClientTypes {

    public enum ImportJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobType] {
            return [
                .quickResponses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum ImportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleted
        case deleteFailed
        case deleteInProgress
        case failed
        case startInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobStatus] {
            return [
                .complete,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .failed,
                .startInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// Summary information about the import job.
    public struct ImportJobData: Swift.Sendable {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The configuration information of the external data source.
        public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
        /// The link to download the information of resource data that failed to be imported.
        public var failedRecordReport: Swift.String?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of the import job.
        /// This member is required.
        public var importJobType: QConnectClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public var metadata: [Swift.String: Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: QConnectClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?
        /// The download link to the resource file that is uploaded to the import job.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: Foundation.Date?

        public init(
            createdTime: Foundation.Date? = nil,
            externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
            failedRecordReport: Swift.String? = nil,
            importJobId: Swift.String? = nil,
            importJobType: QConnectClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            status: QConnectClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: Foundation.Date? = nil
        ) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }
}

extension QConnectClientTypes.ImportJobData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobData(createdTime: \(Swift.String(describing: createdTime)), externalSourceConfiguration: \(Swift.String(describing: externalSourceConfiguration)), importJobId: \(Swift.String(describing: importJobId)), importJobType: \(Swift.String(describing: importJobType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), failedRecordReport: \"CONTENT_REDACTED\", url: \"CONTENT_REDACTED\")"}
}

public struct GetImportJobOutput: Swift.Sendable {
    /// The import job.
    public var importJob: QConnectClientTypes.ImportJobData?

    public init(
        importJob: QConnectClientTypes.ImportJobData? = nil
    ) {
        self.importJob = importJob
    }
}

public struct GetKnowledgeBaseInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetKnowledgeBaseOutput: Swift.Sendable {
    /// The knowledge base.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    ) {
        self.knowledgeBase = knowledgeBase
    }
}

public struct GetMessageTemplateInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
    }
}

public struct GetMessageTemplateOutput: Swift.Sendable {
    /// The message template.
    public var messageTemplate: QConnectClientTypes.ExtendedMessageTemplateData?

    public init(
        messageTemplate: QConnectClientTypes.ExtendedMessageTemplateData? = nil
    ) {
        self.messageTemplate = messageTemplate
    }
}

public struct GetQuickResponseInput: Swift.Sendable {
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

public struct GetQuickResponseOutput: Swift.Sendable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    ) {
        self.quickResponse = quickResponse
    }
}

extension QConnectClientTypes {

    /// Summary information about the import job.
    public struct ImportJobSummary: Swift.Sendable {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The configuration information of the external source that the resource data are imported from.
        public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of import job.
        /// This member is required.
        public var importJobType: QConnectClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The metadata fields of the imported Amazon Q in Connect resources.
        public var metadata: [Swift.String: Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: QConnectClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
            importJobId: Swift.String? = nil,
            importJobType: QConnectClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            status: QConnectClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil
        ) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }
    }
}

public struct ListImportJobsInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListImportJobsOutput: Swift.Sendable {
    /// Summary information about the import jobs.
    /// This member is required.
    public var importJobSummaries: [QConnectClientTypes.ImportJobSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        importJobSummaries: [QConnectClientTypes.ImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.importJobSummaries = importJobSummaries
        self.nextToken = nextToken
    }
}

public struct ListKnowledgeBasesInput: Swift.Sendable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// Summary information about the knowledge base.
    public struct KnowledgeBaseSummary: Swift.Sendable {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q in Connect. For more information about setting up a customer managed key for Amazon Q in Connect, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
        /// The status of the knowledge base summary.
        /// This member is required.
        public var status: QConnectClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// Contains details about how to ingest the documents in a data source.
        public var vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
            status: QConnectClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vectorIngestionConfiguration: QConnectClientTypes.VectorIngestionConfiguration? = nil
        ) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }
}

public struct ListKnowledgeBasesOutput: Swift.Sendable {
    /// Information about the knowledge bases.
    /// This member is required.
    public var knowledgeBaseSummaries: [QConnectClientTypes.KnowledgeBaseSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [QConnectClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

public struct ListMessageTemplatesInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The summary of the message template.
    public struct MessageTemplateSummary: Swift.Sendable {
        /// The version number of the message template version that is activated.
        public var activeVersionNumber: Swift.Int?
        /// The channel subtype this message template applies to.
        /// This member is required.
        public var channelSubtype: QConnectClientTypes.ChannelSubtype?
        /// The timestamp when the message template was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the message template.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the message template data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the message template.
        /// This member is required.
        public var messageTemplateArn: Swift.String?
        /// The identifier of the message template.
        /// This member is required.
        public var messageTemplateId: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            activeVersionNumber: Swift.Int? = nil,
            channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            messageTemplateArn: Swift.String? = nil,
            messageTemplateId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.activeVersionNumber = activeVersionNumber
            self.channelSubtype = channelSubtype
            self.createdTime = createdTime
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListMessageTemplatesOutput: Swift.Sendable {
    /// Summary information about the message template.
    /// This member is required.
    public var messageTemplateSummaries: [QConnectClientTypes.MessageTemplateSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        messageTemplateSummaries: [QConnectClientTypes.MessageTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.messageTemplateSummaries = messageTemplateSummaries
        self.nextToken = nextToken
    }
}

public struct ListMessageTemplateVersionsInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        messageTemplateId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.messageTemplateId = messageTemplateId
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The summary of the message template version.
    public struct MessageTemplateVersionSummary: Swift.Sendable {
        /// The channel subtype this message template applies to.
        /// This member is required.
        public var channelSubtype: QConnectClientTypes.ChannelSubtype?
        /// Whether the version of the message template is activated.
        /// This member is required.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the message template.
        /// This member is required.
        public var messageTemplateArn: Swift.String?
        /// The identifier of the message template.
        /// This member is required.
        public var messageTemplateId: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The version number of the message template version.
        /// This member is required.
        public var versionNumber: Swift.Int?

        public init(
            channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            messageTemplateArn: Swift.String? = nil,
            messageTemplateId: Swift.String? = nil,
            name: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.channelSubtype = channelSubtype
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.versionNumber = versionNumber
        }
    }
}

public struct ListMessageTemplateVersionsOutput: Swift.Sendable {
    /// Summary information about the versions of a message template.
    /// This member is required.
    public var messageTemplateVersionSummaries: [QConnectClientTypes.MessageTemplateVersionSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        messageTemplateVersionSummaries: [QConnectClientTypes.MessageTemplateVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.messageTemplateVersionSummaries = messageTemplateVersionSummaries
        self.nextToken = nextToken
    }
}

public struct RenderMessageTemplateInput: Swift.Sendable {
    /// An object that specifies the values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the value for that variable.
    /// This member is required.
    public var attributes: QConnectClientTypes.MessageTemplateAttributes?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        attributes: QConnectClientTypes.MessageTemplateAttributes? = nil,
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.attributes = attributes
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
    }
}

public struct RenderMessageTemplateOutput: Swift.Sendable {
    /// The message template attachments.
    public var attachments: [QConnectClientTypes.MessageTemplateAttachment]?
    /// The attribute keys that are not resolved.
    public var attributesNotInterpolated: [Swift.String]?
    /// The content of the message template.
    /// This member is required.
    public var content: QConnectClientTypes.MessageTemplateContentProvider?

    public init(
        attachments: [QConnectClientTypes.MessageTemplateAttachment]? = nil,
        attributesNotInterpolated: [Swift.String]? = nil,
        content: QConnectClientTypes.MessageTemplateContentProvider? = nil
    ) {
        self.attachments = attachments
        self.attributesNotInterpolated = attributesNotInterpolated
        self.content = content
    }
}

extension RenderMessageTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RenderMessageTemplateOutput(attachments: \(Swift.String(describing: attachments)), content: \(Swift.String(describing: content)), attributesNotInterpolated: \"CONTENT_REDACTED\")"}
}

public struct UpdateMessageTemplateInput: Swift.Sendable {
    /// The content of the message template.
    public var content: QConnectClientTypes.MessageTemplateContentProvider?
    /// An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
    public var defaultAttributes: QConnectClientTypes.MessageTemplateAttributes?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?

    public init(
        content: QConnectClientTypes.MessageTemplateContentProvider? = nil,
        defaultAttributes: QConnectClientTypes.MessageTemplateAttributes? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil
    ) {
        self.content = content
        self.defaultAttributes = defaultAttributes
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.messageTemplateId = messageTemplateId
    }
}

public struct UpdateMessageTemplateOutput: Swift.Sendable {
    /// The message template.
    public var messageTemplate: QConnectClientTypes.MessageTemplateData?

    public init(
        messageTemplate: QConnectClientTypes.MessageTemplateData? = nil
    ) {
        self.messageTemplate = messageTemplate
    }
}

public struct UpdateMessageTemplateMetadataInput: Swift.Sendable {
    /// The description of the message template.
    public var description: Swift.String?
    /// The configuration information of the grouping of Amazon Q in Connect users.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the message template. Can be either the ID or the ARN. It cannot contain any qualifier.
    /// This member is required.
    public var messageTemplateId: Swift.String?
    /// The name of the message template.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        messageTemplateId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.messageTemplateId = messageTemplateId
        self.name = name
    }
}

public struct UpdateMessageTemplateMetadataOutput: Swift.Sendable {
    /// The message template.
    public var messageTemplate: QConnectClientTypes.MessageTemplateData?

    public init(
        messageTemplate: QConnectClientTypes.MessageTemplateData? = nil
    ) {
        self.messageTemplate = messageTemplate
    }
}

public struct ListQuickResponsesInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    /// The summary information about the quick response.
    public struct QuickResponseSummary: Swift.Sendable {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response summary was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }
    }
}

extension QConnectClientTypes.QuickResponseSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseSummary(contentType: \(Swift.String(describing: contentType)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

public struct ListQuickResponsesOutput: Swift.Sendable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the quick responses.
    /// This member is required.
    public var quickResponseSummaries: [QConnectClientTypes.QuickResponseSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quickResponseSummaries: [QConnectClientTypes.QuickResponseSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.quickResponseSummaries = quickResponseSummaries
    }
}

public struct UpdateQuickResponseInput: Swift.Sendable {
    /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
    public var channels: [Swift.String]?
    /// The updated content of the quick response.
    public var content: QConnectClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
    public var contentType: Swift.String?
    /// The updated description of the quick response.
    public var description: Swift.String?
    /// The updated grouping configuration of the quick response.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    public var name: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?
    /// Whether to remove the description from the quick response.
    public var removeDescription: Swift.Bool?
    /// Whether to remove the grouping configuration of the quick response.
    public var removeGroupingConfiguration: Swift.Bool?
    /// Whether to remove the shortcut key of the quick response.
    public var removeShortcutKey: Swift.Bool?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?

    public init(
        channels: [Swift.String]? = nil,
        content: QConnectClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        quickResponseId: Swift.String? = nil,
        removeDescription: Swift.Bool? = nil,
        removeGroupingConfiguration: Swift.Bool? = nil,
        removeShortcutKey: Swift.Bool? = nil,
        shortcutKey: Swift.String? = nil
    ) {
        self.channels = channels
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.quickResponseId = quickResponseId
        self.removeDescription = removeDescription
        self.removeGroupingConfiguration = removeGroupingConfiguration
        self.removeShortcutKey = removeShortcutKey
        self.shortcutKey = shortcutKey
    }
}

extension UpdateQuickResponseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuickResponseInput(content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), name: \(Swift.String(describing: name)), quickResponseId: \(Swift.String(describing: quickResponseId)), removeDescription: \(Swift.String(describing: removeDescription)), removeGroupingConfiguration: \(Swift.String(describing: removeGroupingConfiguration)), removeShortcutKey: \(Swift.String(describing: removeShortcutKey)), shortcutKey: \(Swift.String(describing: shortcutKey)), channels: \"CONTENT_REDACTED\")"}
}

public struct UpdateQuickResponseOutput: Swift.Sendable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    ) {
        self.quickResponse = quickResponse
    }
}

public struct RemoveKnowledgeBaseTemplateUriInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct RemoveKnowledgeBaseTemplateUriOutput: Swift.Sendable {

    public init() { }
}

public struct SearchContentInput: Swift.Sendable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.SearchExpression?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.SearchExpression? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

public struct SearchContentOutput: Swift.Sendable {
    /// Summary information about the content.
    /// This member is required.
    public var contentSummaries: [QConnectClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [QConnectClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

extension QConnectClientTypes {

    public enum MessageTemplateFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageTemplateFilterOperator] {
            return [
                .equals,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The message template fields to filter the message template query results by. The following is the list of supported field names:
    ///
    /// * name
    ///
    /// * description
    ///
    /// * channel
    ///
    /// * channelSubtype
    ///
    /// * language
    ///
    /// * qualifier
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct MessageTemplateFilterField: Swift.Sendable {
        /// Whether to treat null value as a match for the attribute field.
        public var includeNoExistence: Swift.Bool?
        /// The name of the attribute field to filter the message templates by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for filtering.
        /// This member is required.
        public var `operator`: QConnectClientTypes.MessageTemplateFilterOperator?
        /// The values of attribute field to filter the message template by.
        public var values: [Swift.String]?

        public init(
            includeNoExistence: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.MessageTemplateFilterOperator? = nil,
            values: [Swift.String]? = nil
        ) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

extension QConnectClientTypes {

    public enum Order: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The message template fields to order the message template query results by. The following is the list of supported field names:
    ///
    /// * name
    ///
    /// * description
    ///
    /// * channel
    ///
    /// * channelSubtype
    ///
    /// * language
    ///
    /// * qualifier
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct MessageTemplateOrderField: Swift.Sendable {
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The order at which the message templates are sorted by.
        public var order: QConnectClientTypes.Order?

        public init(
            name: Swift.String? = nil,
            order: QConnectClientTypes.Order? = nil
        ) {
            self.name = name
            self.order = order
        }
    }
}

extension QConnectClientTypes {

    public enum MessageTemplateQueryOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case containsAndPrefix
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageTemplateQueryOperator] {
            return [
                .contains,
                .containsAndPrefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .containsAndPrefix: return "CONTAINS_AND_PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    public enum Priority: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Priority] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The message template fields to query message templates by. The following is the list of supported field names:
    ///
    /// * name
    ///
    /// * description
    public struct MessageTemplateQueryField: Swift.Sendable {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public var allowFuzziness: Swift.Bool?
        /// The name of the attribute to query the message templates by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for matching attribute field values in the query.
        /// This member is required.
        public var `operator`: QConnectClientTypes.MessageTemplateQueryOperator?
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public var priority: QConnectClientTypes.Priority?
        /// The values of the attribute to query the message templates by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            allowFuzziness: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.MessageTemplateQueryOperator? = nil,
            priority: QConnectClientTypes.Priority? = nil,
            values: [Swift.String]? = nil
        ) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }
    }
}

extension QConnectClientTypes {

    /// The search expression of the message template.
    public struct MessageTemplateSearchExpression: Swift.Sendable {
        /// The configuration of filtering rules applied to message template query results.
        public var filters: [QConnectClientTypes.MessageTemplateFilterField]?
        /// The message template attribute fields on which the query results are ordered.
        public var orderOnField: QConnectClientTypes.MessageTemplateOrderField?
        /// The message template query expressions.
        public var queries: [QConnectClientTypes.MessageTemplateQueryField]?

        public init(
            filters: [QConnectClientTypes.MessageTemplateFilterField]? = nil,
            orderOnField: QConnectClientTypes.MessageTemplateOrderField? = nil,
            queries: [QConnectClientTypes.MessageTemplateQueryField]? = nil
        ) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }
    }
}

public struct SearchMessageTemplatesInput: Swift.Sendable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression for querying the message template.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.MessageTemplateSearchExpression?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.MessageTemplateSearchExpression? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

extension QConnectClientTypes {

    /// The result of message template search.
    public struct MessageTemplateSearchResultData: Swift.Sendable {
        /// The channel subtype this message template applies to.
        /// This member is required.
        public var channelSubtype: QConnectClientTypes.ChannelSubtype?
        /// The timestamp when the message template was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the message template.
        public var description: Swift.String?
        /// The configuration information of the grouping of Amazon Q in Connect users.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the version of the message template is activated.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the message template data.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the message template data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the message template.
        /// This member is required.
        public var messageTemplateArn: Swift.String?
        /// The identifier of the message template.
        /// This member is required.
        public var messageTemplateId: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var name: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The version number of the message template version.
        public var versionNumber: Swift.Int?

        public init(
            channelSubtype: QConnectClientTypes.ChannelSubtype? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            messageTemplateArn: Swift.String? = nil,
            messageTemplateId: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            versionNumber: Swift.Int? = nil
        ) {
            self.channelSubtype = channelSubtype
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.messageTemplateArn = messageTemplateArn
            self.messageTemplateId = messageTemplateId
            self.name = name
            self.tags = tags
            self.versionNumber = versionNumber
        }
    }
}

public struct SearchMessageTemplatesOutput: Swift.Sendable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the message template search.
    /// This member is required.
    public var results: [QConnectClientTypes.MessageTemplateSearchResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [QConnectClientTypes.MessageTemplateSearchResultData]? = nil
    ) {
        self.nextToken = nextToken
        self.results = results
    }
}

extension QConnectClientTypes {

    public enum QuickResponseFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseFilterOperator] {
            return [
                .equals,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The quick response fields to filter the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseFilterField: Swift.Sendable {
        /// Whether to treat null value as a match for the attribute field.
        public var includeNoExistence: Swift.Bool?
        /// The name of the attribute field to filter the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for filtering.
        /// This member is required.
        public var `operator`: QConnectClientTypes.QuickResponseFilterOperator?
        /// The values of attribute field to filter the quick response by.
        public var values: [Swift.String]?

        public init(
            includeNoExistence: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.QuickResponseFilterOperator? = nil,
            values: [Swift.String]? = nil
        ) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

extension QConnectClientTypes {

    /// The quick response fields to order the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseOrderField: Swift.Sendable {
        /// The name of the attribute to order the quick response query results by.
        /// This member is required.
        public var name: Swift.String?
        /// The order at which the quick responses are sorted by.
        public var order: QConnectClientTypes.Order?

        public init(
            name: Swift.String? = nil,
            order: QConnectClientTypes.Order? = nil
        ) {
            self.name = name
            self.order = order
        }
    }
}

extension QConnectClientTypes {

    public enum QuickResponseQueryOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case containsAndPrefix
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseQueryOperator] {
            return [
                .contains,
                .containsAndPrefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .containsAndPrefix: return "CONTAINS_AND_PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QConnectClientTypes {

    /// The quick response fields to query quick responses by. The following is the list of supported field names.
    ///
    /// * content
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    public struct QuickResponseQueryField: Swift.Sendable {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public var allowFuzziness: Swift.Bool?
        /// The name of the attribute to query the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for matching attribute field values in the query.
        /// This member is required.
        public var `operator`: QConnectClientTypes.QuickResponseQueryOperator?
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public var priority: QConnectClientTypes.Priority?
        /// The values of the attribute to query the quick responses by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            allowFuzziness: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.QuickResponseQueryOperator? = nil,
            priority: QConnectClientTypes.Priority? = nil,
            values: [Swift.String]? = nil
        ) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }
    }
}

extension QConnectClientTypes {

    /// Information about the import job.
    public struct QuickResponseSearchExpression: Swift.Sendable {
        /// The configuration of filtering rules applied to quick response query results.
        public var filters: [QConnectClientTypes.QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public var orderOnField: QConnectClientTypes.QuickResponseOrderField?
        /// The quick response query expressions.
        public var queries: [QConnectClientTypes.QuickResponseQueryField]?

        public init(
            filters: [QConnectClientTypes.QuickResponseFilterField]? = nil,
            orderOnField: QConnectClientTypes.QuickResponseOrderField? = nil,
            queries: [QConnectClientTypes.QuickResponseQueryField]? = nil
        ) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }
    }
}

public struct SearchQuickResponsesInput: Swift.Sendable {
    /// The [user-defined Amazon Connect contact attributes](https://docs.aws.amazon.com/connect/latest/adminguide/connect-attrib-list.html#user-defined-attributes) to be resolved when search results are returned.
    public var attributes: [Swift.String: Swift.String]?
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression for querying the quick response.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.QuickResponseSearchExpression?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.QuickResponseSearchExpression? = nil
    ) {
        self.attributes = attributes
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

extension SearchQuickResponsesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchQuickResponsesInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchExpression: \(Swift.String(describing: searchExpression)), attributes: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// The result of quick response search.
    public struct QuickResponseSearchResultData: Swift.Sendable {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public var attributesInterpolated: [Swift.String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public var attributesNotInterpolated: [Swift.String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        /// This member is required.
        public var contents: QConnectClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        /// This member is required.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written.
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response search result data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            attributesInterpolated: [Swift.String]? = nil,
            attributesNotInterpolated: [Swift.String]? = nil,
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: QConnectClientTypes.QuickResponseContents? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }
}

extension QConnectClientTypes.QuickResponseSearchResultData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseSearchResultData(contentType: \(Swift.String(describing: contentType)), contents: \(Swift.String(describing: contents)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), shortcutKey: \(Swift.String(describing: shortcutKey)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), attributesInterpolated: \"CONTENT_REDACTED\", attributesNotInterpolated: \"CONTENT_REDACTED\", channels: \"CONTENT_REDACTED\")"}
}

public struct SearchQuickResponsesOutput: Swift.Sendable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The results of the quick response search.
    /// This member is required.
    public var results: [QConnectClientTypes.QuickResponseSearchResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [QConnectClientTypes.QuickResponseSearchResultData]? = nil
    ) {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct StartContentUploadInput: Swift.Sendable {
    /// The type of content to upload.
    /// This member is required.
    public var contentType: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The expected expiration time of the generated presigned URL, specified in minutes.
    public var presignedUrlTimeToLive: Swift.Int?

    public init(
        contentType: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        presignedUrlTimeToLive: Swift.Int? = nil
    ) {
        self.contentType = contentType
        self.knowledgeBaseId = knowledgeBaseId
        self.presignedUrlTimeToLive = presignedUrlTimeToLive
    }
}

public struct StartContentUploadOutput: Swift.Sendable {
    /// The headers to include in the upload.
    /// This member is required.
    public var headersToInclude: [Swift.String: Swift.String]?
    /// The identifier of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The URL of the upload.
    /// This member is required.
    public var url: Swift.String?
    /// The expiration time of the URL as an epoch timestamp.
    /// This member is required.
    public var urlExpiry: Foundation.Date?

    public init(
        headersToInclude: [Swift.String: Swift.String]? = nil,
        uploadId: Swift.String? = nil,
        url: Swift.String? = nil,
        urlExpiry: Foundation.Date? = nil
    ) {
        self.headersToInclude = headersToInclude
        self.uploadId = uploadId
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

extension StartContentUploadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadOutput(headersToInclude: \(Swift.String(describing: headersToInclude)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

public struct StartImportJobInput: Swift.Sendable {
    /// The tags used to organize, track, or control access for this resource.
    public var clientToken: Swift.String?
    /// The configuration information of the external source that the resource data are imported from.
    public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
    /// The type of the import job.
    ///
    /// * For importing quick response resource, set the value to QUICK_RESPONSES.
    /// This member is required.
    public var importJobType: QConnectClientTypes.ImportJobType?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    ///
    /// * For importing Amazon Q in Connect quick responses, this should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The metadata fields of the imported Amazon Q in Connect resources.
    public var metadata: [Swift.String: Swift.String]?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
        importJobType: QConnectClientTypes.ImportJobType? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        uploadId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.externalSourceConfiguration = externalSourceConfiguration
        self.importJobType = importJobType
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.uploadId = uploadId
    }
}

public struct StartImportJobOutput: Swift.Sendable {
    /// The import job.
    public var importJob: QConnectClientTypes.ImportJobData?

    public init(
        importJob: QConnectClientTypes.ImportJobData? = nil
    ) {
        self.importJob = importJob
    }
}

public struct UpdateKnowledgeBaseTemplateUriInput: Swift.Sendable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The template URI to update.
    /// This member is required.
    public var templateUri: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        templateUri: Swift.String? = nil
    ) {
        self.knowledgeBaseId = knowledgeBaseId
        self.templateUri = templateUri
    }
}

public struct UpdateKnowledgeBaseTemplateUriOutput: Swift.Sendable {
    /// The knowledge base to update.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    ) {
        self.knowledgeBase = knowledgeBase
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

/// Amazon Q in Connect throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension QConnectClientTypes {

    /// Details about the data.
    public indirect enum DataDetails: Swift.Sendable {
        /// Details about the content data.
        case contentdata(QConnectClientTypes.ContentDataDetails)
        /// Details about the generative data.
        case generativedata(QConnectClientTypes.GenerativeDataDetails)
        /// Details about the intent data.
        case intentdetecteddata(QConnectClientTypes.IntentDetectedDataDetails)
        /// Details about the content data.
        case sourcecontentdata(QConnectClientTypes.SourceContentDataDetails)
        case sdkUnknown(Swift.String)
    }
}

extension QConnectClientTypes {

    /// Summary of the data.
    public struct DataSummary: Swift.Sendable {
        /// Details about the data.
        /// This member is required.
        public var details: QConnectClientTypes.DataDetails?
        /// Reference information about the content.
        /// This member is required.
        public var reference: QConnectClientTypes.DataReference?

        public init(
            details: QConnectClientTypes.DataDetails? = nil,
            reference: QConnectClientTypes.DataReference? = nil
        ) {
            self.details = details
            self.reference = reference
        }
    }
}

extension QConnectClientTypes {

    /// Details about generative data.
    public struct GenerativeDataDetails: Swift.Sendable {
        /// The LLM response.
        /// This member is required.
        public var completion: Swift.String?
        /// Details about the generative content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// The references used to generative the LLM response.
        /// This member is required.
        public var references: [QConnectClientTypes.DataSummary]?

        public init(
            completion: Swift.String? = nil,
            rankingData: QConnectClientTypes.RankingData? = nil,
            references: [QConnectClientTypes.DataSummary]? = nil
        ) {
            self.completion = completion
            self.rankingData = rankingData
            self.references = references
        }
    }
}

extension QConnectClientTypes.GenerativeDataDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerativeDataDetails(rankingData: \(Swift.String(describing: rankingData)), references: \(Swift.String(describing: references)), completion: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {

    /// Information about the recommendation.
    public struct RecommendationData: Swift.Sendable {
        /// Summary of the recommended content.
        public var data: QConnectClientTypes.DataSummary?
        /// The recommended document.
        public var document: QConnectClientTypes.Document?
        /// The identifier of the recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The relevance level of the recommendation.
        public var relevanceLevel: QConnectClientTypes.RelevanceLevel?
        /// The relevance score of the recommendation.
        public var relevanceScore: Swift.Double
        /// The type of recommendation.
        public var type: QConnectClientTypes.RecommendationType?

        public init(
            data: QConnectClientTypes.DataSummary? = nil,
            document: QConnectClientTypes.Document? = nil,
            recommendationId: Swift.String? = nil,
            relevanceLevel: QConnectClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0,
            type: QConnectClientTypes.RecommendationType? = nil
        ) {
            self.data = data
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }
    }
}

extension QConnectClientTypes {

    /// Information about the result.
    public struct ResultData: Swift.Sendable {
        /// Summary of the recommended content.
        public var data: QConnectClientTypes.DataSummary?
        /// The document.
        public var document: QConnectClientTypes.Document?
        /// The relevance score of the results.
        public var relevanceScore: Swift.Double
        /// The identifier of the result data.
        /// This member is required.
        public var resultId: Swift.String?
        /// The type of the query result.
        public var type: QConnectClientTypes.QueryResultType?

        public init(
            data: QConnectClientTypes.DataSummary? = nil,
            document: QConnectClientTypes.Document? = nil,
            relevanceScore: Swift.Double = 0.0,
            resultId: Swift.String? = nil,
            type: QConnectClientTypes.QueryResultType? = nil
        ) {
            self.data = data
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
            self.type = type
        }
    }
}

public struct GetRecommendationsOutput: Swift.Sendable {
    /// The recommendations.
    /// This member is required.
    public var recommendations: [QConnectClientTypes.RecommendationData]?
    /// The triggers corresponding to recommendations.
    public var triggers: [QConnectClientTypes.RecommendationTrigger]?

    public init(
        recommendations: [QConnectClientTypes.RecommendationData]? = nil,
        triggers: [QConnectClientTypes.RecommendationTrigger]? = nil
    ) {
        self.recommendations = recommendations
        self.triggers = triggers
    }
}

public struct QueryAssistantOutput: Swift.Sendable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the query.
    /// This member is required.
    public var results: [QConnectClientTypes.ResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [QConnectClientTypes.ResultData]? = nil
    ) {
        self.nextToken = nextToken
        self.results = results
    }
}

extension ActivateMessageTemplateInput {

    static func urlPathProvider(_ value: ActivateMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/activate"
    }
}

extension CreateAIAgentInput {

    static func urlPathProvider(_ value: CreateAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents"
    }
}

extension CreateAIAgentVersionInput {

    static func urlPathProvider(_ value: CreateAIAgentVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())/versions"
    }
}

extension CreateAIGuardrailInput {

    static func urlPathProvider(_ value: CreateAIGuardrailInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails"
    }
}

extension CreateAIGuardrailVersionInput {

    static func urlPathProvider(_ value: CreateAIGuardrailVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())/versions"
    }
}

extension CreateAIPromptInput {

    static func urlPathProvider(_ value: CreateAIPromptInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts"
    }
}

extension CreateAIPromptVersionInput {

    static func urlPathProvider(_ value: CreateAIPromptVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())/versions"
    }
}

extension CreateAssistantInput {

    static func urlPathProvider(_ value: CreateAssistantInput) -> Swift.String? {
        return "/assistants"
    }
}

extension CreateAssistantAssociationInput {

    static func urlPathProvider(_ value: CreateAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

extension CreateContentInput {

    static func urlPathProvider(_ value: CreateContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

extension CreateContentAssociationInput {

    static func urlPathProvider(_ value: CreateContentAssociationInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/associations"
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgeBases"
    }
}

extension CreateMessageTemplateInput {

    static func urlPathProvider(_ value: CreateMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates"
    }
}

extension CreateMessageTemplateAttachmentInput {

    static func urlPathProvider(_ value: CreateMessageTemplateAttachmentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/attachments"
    }
}

extension CreateMessageTemplateVersionInput {

    static func urlPathProvider(_ value: CreateMessageTemplateVersionInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/versions"
    }
}

extension CreateQuickResponseInput {

    static func urlPathProvider(_ value: CreateQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

extension CreateSessionInput {

    static func urlPathProvider(_ value: CreateSessionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions"
    }
}

extension DeactivateMessageTemplateInput {

    static func urlPathProvider(_ value: DeactivateMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/deactivate"
    }
}

extension DeleteAIAgentInput {

    static func urlPathProvider(_ value: DeleteAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())"
    }
}

extension DeleteAIAgentVersionInput {

    static func urlPathProvider(_ value: DeleteAIAgentVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension DeleteAIGuardrailInput {

    static func urlPathProvider(_ value: DeleteAIGuardrailInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())"
    }
}

extension DeleteAIGuardrailVersionInput {

    static func urlPathProvider(_ value: DeleteAIGuardrailVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension DeleteAIPromptInput {

    static func urlPathProvider(_ value: DeleteAIPromptInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())"
    }
}

extension DeleteAIPromptVersionInput {

    static func urlPathProvider(_ value: DeleteAIPromptVersionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension DeleteAssistantInput {

    static func urlPathProvider(_ value: DeleteAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

extension DeleteAssistantAssociationInput {

    static func urlPathProvider(_ value: DeleteAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let assistantAssociationId = value.assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

extension DeleteContentInput {

    static func urlPathProvider(_ value: DeleteContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension DeleteContentAssociationInput {

    static func urlPathProvider(_ value: DeleteContentAssociationInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        guard let contentAssociationId = value.contentAssociationId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/associations/\(contentAssociationId.urlPercentEncoding())"
    }
}

extension DeleteImportJobInput {

    static func urlPathProvider(_ value: DeleteImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let importJobId = value.importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension DeleteMessageTemplateInput {

    static func urlPathProvider(_ value: DeleteMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())"
    }
}

extension DeleteMessageTemplateAttachmentInput {

    static func urlPathProvider(_ value: DeleteMessageTemplateAttachmentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension DeleteQuickResponseInput {

    static func urlPathProvider(_ value: DeleteQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension GetAIAgentInput {

    static func urlPathProvider(_ value: GetAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())"
    }
}

extension GetAIGuardrailInput {

    static func urlPathProvider(_ value: GetAIGuardrailInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())"
    }
}

extension GetAIPromptInput {

    static func urlPathProvider(_ value: GetAIPromptInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())"
    }
}

extension GetAssistantInput {

    static func urlPathProvider(_ value: GetAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

extension GetAssistantAssociationInput {

    static func urlPathProvider(_ value: GetAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let assistantAssociationId = value.assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

extension GetContentInput {

    static func urlPathProvider(_ value: GetContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension GetContentAssociationInput {

    static func urlPathProvider(_ value: GetContentAssociationInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        guard let contentAssociationId = value.contentAssociationId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/associations/\(contentAssociationId.urlPercentEncoding())"
    }
}

extension GetContentSummaryInput {

    static func urlPathProvider(_ value: GetContentSummaryInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/summary"
    }
}

extension GetImportJobInput {

    static func urlPathProvider(_ value: GetImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let importJobId = value.importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension GetMessageTemplateInput {

    static func urlPathProvider(_ value: GetMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())"
    }
}

extension GetNextMessageInput {

    static func urlPathProvider(_ value: GetNextMessageInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/messages/next"
    }
}

extension GetNextMessageInput {

    static func queryItemProvider(_ value: GetNextMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let nextMessageToken = value.nextMessageToken else {
            let message = "Creating a URL Query Item failed. nextMessageToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let nextMessageTokenQueryItem = Smithy.URIQueryItem(name: "nextMessageToken".urlPercentEncoding(), value: Swift.String(nextMessageToken).urlPercentEncoding())
        items.append(nextMessageTokenQueryItem)
        return items
    }
}

extension GetQuickResponseInput {

    static func urlPathProvider(_ value: GetQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension GetRecommendationsInput {

    static func urlPathProvider(_ value: GetRecommendationsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations"
    }
}

extension GetRecommendationsInput {

    static func queryItemProvider(_ value: GetRecommendationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.waitTimeSeconds != 0 {
            let waitTimeSecondsQueryItem = Smithy.URIQueryItem(name: "waitTimeSeconds".urlPercentEncoding(), value: Swift.String(value.waitTimeSeconds).urlPercentEncoding())
            items.append(waitTimeSecondsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension ListAIAgentsInput {

    static func urlPathProvider(_ value: ListAIAgentsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents"
    }
}

extension ListAIAgentsInput {

    static func queryItemProvider(_ value: ListAIAgentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let origin = value.origin {
            let originQueryItem = Smithy.URIQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin.rawValue).urlPercentEncoding())
            items.append(originQueryItem)
        }
        return items
    }
}

extension ListAIAgentVersionsInput {

    static func urlPathProvider(_ value: ListAIAgentVersionsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())/versions"
    }
}

extension ListAIAgentVersionsInput {

    static func queryItemProvider(_ value: ListAIAgentVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let origin = value.origin {
            let originQueryItem = Smithy.URIQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin.rawValue).urlPercentEncoding())
            items.append(originQueryItem)
        }
        return items
    }
}

extension ListAIGuardrailsInput {

    static func urlPathProvider(_ value: ListAIGuardrailsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails"
    }
}

extension ListAIGuardrailsInput {

    static func queryItemProvider(_ value: ListAIGuardrailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAIGuardrailVersionsInput {

    static func urlPathProvider(_ value: ListAIGuardrailVersionsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())/versions"
    }
}

extension ListAIGuardrailVersionsInput {

    static func queryItemProvider(_ value: ListAIGuardrailVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAIPromptsInput {

    static func urlPathProvider(_ value: ListAIPromptsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts"
    }
}

extension ListAIPromptsInput {

    static func queryItemProvider(_ value: ListAIPromptsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let origin = value.origin {
            let originQueryItem = Smithy.URIQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin.rawValue).urlPercentEncoding())
            items.append(originQueryItem)
        }
        return items
    }
}

extension ListAIPromptVersionsInput {

    static func urlPathProvider(_ value: ListAIPromptVersionsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())/versions"
    }
}

extension ListAIPromptVersionsInput {

    static func queryItemProvider(_ value: ListAIPromptVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let origin = value.origin {
            let originQueryItem = Smithy.URIQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin.rawValue).urlPercentEncoding())
            items.append(originQueryItem)
        }
        return items
    }
}

extension ListAssistantAssociationsInput {

    static func urlPathProvider(_ value: ListAssistantAssociationsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

extension ListAssistantAssociationsInput {

    static func queryItemProvider(_ value: ListAssistantAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssistantsInput {

    static func urlPathProvider(_ value: ListAssistantsInput) -> Swift.String? {
        return "/assistants"
    }
}

extension ListAssistantsInput {

    static func queryItemProvider(_ value: ListAssistantsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListContentAssociationsInput {

    static func urlPathProvider(_ value: ListContentAssociationsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/associations"
    }
}

extension ListContentAssociationsInput {

    static func queryItemProvider(_ value: ListContentAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListContentsInput {

    static func urlPathProvider(_ value: ListContentsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

extension ListContentsInput {

    static func queryItemProvider(_ value: ListContentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImportJobsInput {

    static func urlPathProvider(_ value: ListImportJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

extension ListImportJobsInput {

    static func queryItemProvider(_ value: ListImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgeBases"
    }
}

extension ListKnowledgeBasesInput {

    static func queryItemProvider(_ value: ListKnowledgeBasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMessagesInput {

    static func urlPathProvider(_ value: ListMessagesInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/messages"
    }
}

extension ListMessagesInput {

    static func queryItemProvider(_ value: ListMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMessageTemplatesInput {

    static func urlPathProvider(_ value: ListMessageTemplatesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates"
    }
}

extension ListMessageTemplatesInput {

    static func queryItemProvider(_ value: ListMessageTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMessageTemplateVersionsInput {

    static func urlPathProvider(_ value: ListMessageTemplateVersionsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/versions"
    }
}

extension ListMessageTemplateVersionsInput {

    static func queryItemProvider(_ value: ListMessageTemplateVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQuickResponsesInput {

    static func urlPathProvider(_ value: ListQuickResponsesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

extension ListQuickResponsesInput {

    static func queryItemProvider(_ value: ListQuickResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension NotifyRecommendationsReceivedInput {

    static func urlPathProvider(_ value: NotifyRecommendationsReceivedInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations/notify"
    }
}

extension PutFeedbackInput {

    static func urlPathProvider(_ value: PutFeedbackInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/feedback"
    }
}

extension QueryAssistantInput {

    static func urlPathProvider(_ value: QueryAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/query"
    }
}

extension RemoveAssistantAIAgentInput {

    static func urlPathProvider(_ value: RemoveAssistantAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagentConfiguration"
    }
}

extension RemoveAssistantAIAgentInput {

    static func queryItemProvider(_ value: RemoveAssistantAIAgentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let aiAgentType = value.aiAgentType else {
            let message = "Creating a URL Query Item failed. aiAgentType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aiAgentTypeQueryItem = Smithy.URIQueryItem(name: "aiAgentType".urlPercentEncoding(), value: Swift.String(aiAgentType.rawValue).urlPercentEncoding())
        items.append(aiAgentTypeQueryItem)
        return items
    }
}

extension RemoveKnowledgeBaseTemplateUriInput {

    static func urlPathProvider(_ value: RemoveKnowledgeBaseTemplateUriInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

extension RenderMessageTemplateInput {

    static func urlPathProvider(_ value: RenderMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/render"
    }
}

extension SearchContentInput {

    static func urlPathProvider(_ value: SearchContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search"
    }
}

extension SearchContentInput {

    static func queryItemProvider(_ value: SearchContentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SearchMessageTemplatesInput {

    static func urlPathProvider(_ value: SearchMessageTemplatesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search/messageTemplates"
    }
}

extension SearchMessageTemplatesInput {

    static func queryItemProvider(_ value: SearchMessageTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SearchQuickResponsesInput {

    static func urlPathProvider(_ value: SearchQuickResponsesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search/quickResponses"
    }
}

extension SearchQuickResponsesInput {

    static func queryItemProvider(_ value: SearchQuickResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SearchSessionsInput {

    static func urlPathProvider(_ value: SearchSessionsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/searchSessions"
    }
}

extension SearchSessionsInput {

    static func queryItemProvider(_ value: SearchSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SendMessageInput {

    static func urlPathProvider(_ value: SendMessageInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/message"
    }
}

extension StartContentUploadInput {

    static func urlPathProvider(_ value: StartContentUploadInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/upload"
    }
}

extension StartImportJobInput {

    static func urlPathProvider(_ value: StartImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAIAgentInput {

    static func urlPathProvider(_ value: UpdateAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiAgentId = value.aiAgentId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagents/\(aiAgentId.urlPercentEncoding())"
    }
}

extension UpdateAIGuardrailInput {

    static func urlPathProvider(_ value: UpdateAIGuardrailInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiGuardrailId = value.aiGuardrailId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiguardrails/\(aiGuardrailId.urlPercentEncoding())"
    }
}

extension UpdateAIPromptInput {

    static func urlPathProvider(_ value: UpdateAIPromptInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let aiPromptId = value.aiPromptId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiprompts/\(aiPromptId.urlPercentEncoding())"
    }
}

extension UpdateAssistantAIAgentInput {

    static func urlPathProvider(_ value: UpdateAssistantAIAgentInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/aiagentConfiguration"
    }
}

extension UpdateContentInput {

    static func urlPathProvider(_ value: UpdateContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension UpdateKnowledgeBaseTemplateUriInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseTemplateUriInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

extension UpdateMessageTemplateInput {

    static func urlPathProvider(_ value: UpdateMessageTemplateInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())"
    }
}

extension UpdateMessageTemplateMetadataInput {

    static func urlPathProvider(_ value: UpdateMessageTemplateMetadataInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let messageTemplateId = value.messageTemplateId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/messageTemplates/\(messageTemplateId.urlPercentEncoding())/metadata"
    }
}

extension UpdateQuickResponseInput {

    static func urlPathProvider(_ value: UpdateQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension UpdateSessionInput {

    static func urlPathProvider(_ value: UpdateSessionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension UpdateSessionDataInput {

    static func urlPathProvider(_ value: UpdateSessionDataInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/data"
    }
}

extension ActivateMessageTemplateInput {

    static func write(value: ActivateMessageTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["versionNumber"].write(value.versionNumber)
    }
}

extension CreateAIAgentInput {

    static func write(value: CreateAIAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: QConnectClientTypes.AIAgentConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
        try writer["visibilityStatus"].write(value.visibilityStatus)
    }
}

extension CreateAIAgentVersionInput {

    static func write(value: CreateAIAgentVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["modifiedTime"].writeTimestamp(value.modifiedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CreateAIGuardrailInput {

    static func write(value: CreateAIGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientToken"].write(value.clientToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: QConnectClientTypes.AIGuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: QConnectClientTypes.AIGuardrailTopicPolicyConfig.write(value:to:))
        try writer["visibilityStatus"].write(value.visibilityStatus)
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: QConnectClientTypes.AIGuardrailWordPolicyConfig.write(value:to:))
    }
}

extension CreateAIGuardrailVersionInput {

    static func write(value: CreateAIGuardrailVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["modifiedTime"].writeTimestamp(value.modifiedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CreateAIPromptInput {

    static func write(value: CreateAIPromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiFormat"].write(value.apiFormat)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["modelId"].write(value.modelId)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateConfiguration"].write(value.templateConfiguration, with: QConnectClientTypes.AIPromptTemplateConfiguration.write(value:to:))
        try writer["templateType"].write(value.templateType)
        try writer["type"].write(value.type)
        try writer["visibilityStatus"].write(value.visibilityStatus)
    }
}

extension CreateAIPromptVersionInput {

    static func write(value: CreateAIPromptVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["modifiedTime"].writeTimestamp(value.modifiedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CreateAssistantInput {

    static func write(value: CreateAssistantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: QConnectClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateAssistantAssociationInput {

    static func write(value: CreateAssistantAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["association"].write(value.association, with: QConnectClientTypes.AssistantAssociationInputData.write(value:to:))
        try writer["associationType"].write(value.associationType)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateContentInput {

    static func write(value: CreateContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["overrideLinkOutUri"].write(value.overrideLinkOutUri)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["title"].write(value.title)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension CreateContentAssociationInput {

    static func write(value: CreateContentAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["association"].write(value.association, with: QConnectClientTypes.ContentAssociationContents.write(value:to:))
        try writer["associationType"].write(value.associationType)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateKnowledgeBaseInput {

    static func write(value: CreateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["knowledgeBaseType"].write(value.knowledgeBaseType)
        try writer["name"].write(value.name)
        try writer["renderingConfiguration"].write(value.renderingConfiguration, with: QConnectClientTypes.RenderingConfiguration.write(value:to:))
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: QConnectClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: QConnectClientTypes.SourceConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vectorIngestionConfiguration"].write(value.vectorIngestionConfiguration, with: QConnectClientTypes.VectorIngestionConfiguration.write(value:to:))
    }
}

extension CreateMessageTemplateInput {

    static func write(value: CreateMessageTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelSubtype"].write(value.channelSubtype)
        try writer["clientToken"].write(value.clientToken)
        try writer["content"].write(value.content, with: QConnectClientTypes.MessageTemplateContentProvider.write(value:to:))
        try writer["defaultAttributes"].write(value.defaultAttributes, with: QConnectClientTypes.MessageTemplateAttributes.write(value:to:))
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: QConnectClientTypes.GroupingConfiguration.write(value:to:))
        try writer["language"].write(value.language)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateMessageTemplateAttachmentInput {

    static func write(value: CreateMessageTemplateAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["clientToken"].write(value.clientToken)
        try writer["contentDisposition"].write(value.contentDisposition)
        try writer["name"].write(value.name)
    }
}

extension CreateMessageTemplateVersionInput {

    static func write(value: CreateMessageTemplateVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messageTemplateContentSha256"].write(value.messageTemplateContentSha256)
    }
}

extension CreateQuickResponseInput {

    static func write(value: CreateQuickResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["content"].write(value.content, with: QConnectClientTypes.QuickResponseDataProvider.write(value:to:))
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: QConnectClientTypes.GroupingConfiguration.write(value:to:))
        try writer["isActive"].write(value.isActive)
        try writer["language"].write(value.language)
        try writer["name"].write(value.name)
        try writer["shortcutKey"].write(value.shortcutKey)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSessionInput {

    static func write(value: CreateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aiAgentConfiguration"].writeMap(value.aiAgentConfiguration, valueWritingClosure: QConnectClientTypes.AIAgentConfigurationData.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tagFilter"].write(value.tagFilter, with: QConnectClientTypes.TagFilter.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeactivateMessageTemplateInput {

    static func write(value: DeactivateMessageTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["versionNumber"].write(value.versionNumber)
    }
}

extension NotifyRecommendationsReceivedInput {

    static func write(value: NotifyRecommendationsReceivedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommendationIds"].writeList(value.recommendationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutFeedbackInput {

    static func write(value: PutFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentFeedback"].write(value.contentFeedback, with: QConnectClientTypes.ContentFeedbackData.write(value:to:))
        try writer["targetId"].write(value.targetId)
        try writer["targetType"].write(value.targetType)
    }
}

extension QueryAssistantInput {

    static func write(value: QueryAssistantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["overrideKnowledgeBaseSearchType"].write(value.overrideKnowledgeBaseSearchType)
        try writer["queryCondition"].writeList(value.queryCondition, memberWritingClosure: QConnectClientTypes.QueryCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["queryInputData"].write(value.queryInputData, with: QConnectClientTypes.QueryInputData.write(value:to:))
        try writer["queryText"].write(value.queryText)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension RenderMessageTemplateInput {

    static func write(value: RenderMessageTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: QConnectClientTypes.MessageTemplateAttributes.write(value:to:))
    }
}

extension SearchContentInput {

    static func write(value: SearchContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchExpression"].write(value.searchExpression, with: QConnectClientTypes.SearchExpression.write(value:to:))
    }
}

extension SearchMessageTemplatesInput {

    static func write(value: SearchMessageTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchExpression"].write(value.searchExpression, with: QConnectClientTypes.MessageTemplateSearchExpression.write(value:to:))
    }
}

extension SearchQuickResponsesInput {

    static func write(value: SearchQuickResponsesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["searchExpression"].write(value.searchExpression, with: QConnectClientTypes.QuickResponseSearchExpression.write(value:to:))
    }
}

extension SearchSessionsInput {

    static func write(value: SearchSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchExpression"].write(value.searchExpression, with: QConnectClientTypes.SearchExpression.write(value:to:))
    }
}

extension SendMessageInput {

    static func write(value: SendMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["conversationContext"].write(value.conversationContext, with: QConnectClientTypes.ConversationContext.write(value:to:))
        try writer["message"].write(value.message, with: QConnectClientTypes.MessageInput.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension StartContentUploadInput {

    static func write(value: StartContentUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["presignedUrlTimeToLive"].write(value.presignedUrlTimeToLive)
    }
}

extension StartImportJobInput {

    static func write(value: StartImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["externalSourceConfiguration"].write(value.externalSourceConfiguration, with: QConnectClientTypes.ExternalSourceConfiguration.write(value:to:))
        try writer["importJobType"].write(value.importJobType)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAIAgentInput {

    static func write(value: UpdateAIAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: QConnectClientTypes.AIAgentConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["visibilityStatus"].write(value.visibilityStatus)
    }
}

extension UpdateAIGuardrailInput {

    static func write(value: UpdateAIGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientToken"].write(value.clientToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: QConnectClientTypes.AIGuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: QConnectClientTypes.AIGuardrailTopicPolicyConfig.write(value:to:))
        try writer["visibilityStatus"].write(value.visibilityStatus)
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: QConnectClientTypes.AIGuardrailWordPolicyConfig.write(value:to:))
    }
}

extension UpdateAIPromptInput {

    static func write(value: UpdateAIPromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["templateConfiguration"].write(value.templateConfiguration, with: QConnectClientTypes.AIPromptTemplateConfiguration.write(value:to:))
        try writer["visibilityStatus"].write(value.visibilityStatus)
    }
}

extension UpdateAssistantAIAgentInput {

    static func write(value: UpdateAssistantAIAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aiAgentType"].write(value.aiAgentType)
        try writer["configuration"].write(value.configuration, with: QConnectClientTypes.AIAgentConfigurationData.write(value:to:))
    }
}

extension UpdateContentInput {

    static func write(value: UpdateContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["overrideLinkOutUri"].write(value.overrideLinkOutUri)
        try writer["removeOverrideLinkOutUri"].write(value.removeOverrideLinkOutUri)
        try writer["revisionId"].write(value.revisionId)
        try writer["title"].write(value.title)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension UpdateKnowledgeBaseTemplateUriInput {

    static func write(value: UpdateKnowledgeBaseTemplateUriInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateUri"].write(value.templateUri)
    }
}

extension UpdateMessageTemplateInput {

    static func write(value: UpdateMessageTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: QConnectClientTypes.MessageTemplateContentProvider.write(value:to:))
        try writer["defaultAttributes"].write(value.defaultAttributes, with: QConnectClientTypes.MessageTemplateAttributes.write(value:to:))
        try writer["language"].write(value.language)
    }
}

extension UpdateMessageTemplateMetadataInput {

    static func write(value: UpdateMessageTemplateMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: QConnectClientTypes.GroupingConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateQuickResponseInput {

    static func write(value: UpdateQuickResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["content"].write(value.content, with: QConnectClientTypes.QuickResponseDataProvider.write(value:to:))
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: QConnectClientTypes.GroupingConfiguration.write(value:to:))
        try writer["isActive"].write(value.isActive)
        try writer["language"].write(value.language)
        try writer["name"].write(value.name)
        try writer["removeDescription"].write(value.removeDescription)
        try writer["removeGroupingConfiguration"].write(value.removeGroupingConfiguration)
        try writer["removeShortcutKey"].write(value.removeShortcutKey)
        try writer["shortcutKey"].write(value.shortcutKey)
    }
}

extension UpdateSessionInput {

    static func write(value: UpdateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aiAgentConfiguration"].writeMap(value.aiAgentConfiguration, valueWritingClosure: QConnectClientTypes.AIAgentConfigurationData.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["tagFilter"].write(value.tagFilter, with: QConnectClientTypes.TagFilter.write(value:to:))
    }
}

extension UpdateSessionDataInput {

    static func write(value: UpdateSessionDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].writeList(value.data, memberWritingClosure: QConnectClientTypes.RuntimeSessionData.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["namespace"].write(value.namespace)
    }
}

extension ActivateMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateMessageTemplateOutput()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.versionNumber = try reader["versionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension CreateAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIAgentOutput()
        value.aiAgent = try reader["aiAgent"].readIfPresent(with: QConnectClientTypes.AIAgentData.read(from:))
        return value
    }
}

extension CreateAIAgentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIAgentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIAgentVersionOutput()
        value.aiAgent = try reader["aiAgent"].readIfPresent(with: QConnectClientTypes.AIAgentData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension CreateAIGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIGuardrailOutput()
        value.aiGuardrail = try reader["aiGuardrail"].readIfPresent(with: QConnectClientTypes.AIGuardrailData.read(from:))
        return value
    }
}

extension CreateAIGuardrailVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIGuardrailVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIGuardrailVersionOutput()
        value.aiGuardrail = try reader["aiGuardrail"].readIfPresent(with: QConnectClientTypes.AIGuardrailData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension CreateAIPromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIPromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIPromptOutput()
        value.aiPrompt = try reader["aiPrompt"].readIfPresent(with: QConnectClientTypes.AIPromptData.read(from:))
        return value
    }
}

extension CreateAIPromptVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAIPromptVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAIPromptVersionOutput()
        value.aiPrompt = try reader["aiPrompt"].readIfPresent(with: QConnectClientTypes.AIPromptData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension CreateAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssistantOutput()
        value.assistant = try reader["assistant"].readIfPresent(with: QConnectClientTypes.AssistantData.read(from:))
        return value
    }
}

extension CreateAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssistantAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssistantAssociationOutput()
        value.assistantAssociation = try reader["assistantAssociation"].readIfPresent(with: QConnectClientTypes.AssistantAssociationData.read(from:))
        return value
    }
}

extension CreateContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContentOutput()
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.ContentData.read(from:))
        return value
    }
}

extension CreateContentAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContentAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContentAssociationOutput()
        value.contentAssociation = try reader["contentAssociation"].readIfPresent(with: QConnectClientTypes.ContentAssociationData.read(from:))
        return value
    }
}

extension CreateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: QConnectClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension CreateMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMessageTemplateOutput()
        value.messageTemplate = try reader["messageTemplate"].readIfPresent(with: QConnectClientTypes.MessageTemplateData.read(from:))
        return value
    }
}

extension CreateMessageTemplateAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMessageTemplateAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMessageTemplateAttachmentOutput()
        value.attachment = try reader["attachment"].readIfPresent(with: QConnectClientTypes.MessageTemplateAttachment.read(from:))
        return value
    }
}

extension CreateMessageTemplateVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMessageTemplateVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMessageTemplateVersionOutput()
        value.messageTemplate = try reader["messageTemplate"].readIfPresent(with: QConnectClientTypes.ExtendedMessageTemplateData.read(from:))
        return value
    }
}

extension CreateQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: QConnectClientTypes.QuickResponseData.read(from:))
        return value
    }
}

extension CreateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSessionOutput()
        value.session = try reader["session"].readIfPresent(with: QConnectClientTypes.SessionData.read(from:))
        return value
    }
}

extension DeactivateMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeactivateMessageTemplateOutput()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.versionNumber = try reader["versionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIAgentOutput {
        return DeleteAIAgentOutput()
    }
}

extension DeleteAIAgentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIAgentVersionOutput {
        return DeleteAIAgentVersionOutput()
    }
}

extension DeleteAIGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIGuardrailOutput {
        return DeleteAIGuardrailOutput()
    }
}

extension DeleteAIGuardrailVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIGuardrailVersionOutput {
        return DeleteAIGuardrailVersionOutput()
    }
}

extension DeleteAIPromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIPromptOutput {
        return DeleteAIPromptOutput()
    }
}

extension DeleteAIPromptVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAIPromptVersionOutput {
        return DeleteAIPromptVersionOutput()
    }
}

extension DeleteAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssistantOutput {
        return DeleteAssistantOutput()
    }
}

extension DeleteAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssistantAssociationOutput {
        return DeleteAssistantAssociationOutput()
    }
}

extension DeleteContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContentOutput {
        return DeleteContentOutput()
    }
}

extension DeleteContentAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContentAssociationOutput {
        return DeleteContentAssociationOutput()
    }
}

extension DeleteImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImportJobOutput {
        return DeleteImportJobOutput()
    }
}

extension DeleteKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKnowledgeBaseOutput {
        return DeleteKnowledgeBaseOutput()
    }
}

extension DeleteMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMessageTemplateOutput {
        return DeleteMessageTemplateOutput()
    }
}

extension DeleteMessageTemplateAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMessageTemplateAttachmentOutput {
        return DeleteMessageTemplateAttachmentOutput()
    }
}

extension DeleteQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQuickResponseOutput {
        return DeleteQuickResponseOutput()
    }
}

extension GetAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAIAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAIAgentOutput()
        value.aiAgent = try reader["aiAgent"].readIfPresent(with: QConnectClientTypes.AIAgentData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension GetAIGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAIGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAIGuardrailOutput()
        value.aiGuardrail = try reader["aiGuardrail"].readIfPresent(with: QConnectClientTypes.AIGuardrailData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension GetAIPromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAIPromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAIPromptOutput()
        value.aiPrompt = try reader["aiPrompt"].readIfPresent(with: QConnectClientTypes.AIPromptData.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension GetAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssistantOutput()
        value.assistant = try reader["assistant"].readIfPresent(with: QConnectClientTypes.AssistantData.read(from:))
        return value
    }
}

extension GetAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssistantAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssistantAssociationOutput()
        value.assistantAssociation = try reader["assistantAssociation"].readIfPresent(with: QConnectClientTypes.AssistantAssociationData.read(from:))
        return value
    }
}

extension GetContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContentOutput()
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.ContentData.read(from:))
        return value
    }
}

extension GetContentAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContentAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContentAssociationOutput()
        value.contentAssociation = try reader["contentAssociation"].readIfPresent(with: QConnectClientTypes.ContentAssociationData.read(from:))
        return value
    }
}

extension GetContentSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContentSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContentSummaryOutput()
        value.contentSummary = try reader["contentSummary"].readIfPresent(with: QConnectClientTypes.ContentSummary.read(from:))
        return value
    }
}

extension GetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportJobOutput()
        value.importJob = try reader["importJob"].readIfPresent(with: QConnectClientTypes.ImportJobData.read(from:))
        return value
    }
}

extension GetKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: QConnectClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension GetMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMessageTemplateOutput()
        value.messageTemplate = try reader["messageTemplate"].readIfPresent(with: QConnectClientTypes.ExtendedMessageTemplateData.read(from:))
        return value
    }
}

extension GetNextMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNextMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNextMessageOutput()
        value.conversationSessionData = try reader["conversationSessionData"].readListIfPresent(memberReadingClosure: QConnectClientTypes.RuntimeSessionData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conversationState = try reader["conversationState"].readIfPresent(with: QConnectClientTypes.ConversationState.read(from:))
        value.nextMessageToken = try reader["nextMessageToken"].readIfPresent()
        value.requestMessageId = try reader["requestMessageId"].readIfPresent() ?? ""
        value.response = try reader["response"].readIfPresent(with: QConnectClientTypes.MessageOutput.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: QConnectClientTypes.QuickResponseData.read(from:))
        return value
    }
}

extension GetRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommendationsOutput()
        value.recommendations = try reader["recommendations"].readListIfPresent(memberReadingClosure: QConnectClientTypes.RecommendationData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.triggers = try reader["triggers"].readListIfPresent(memberReadingClosure: QConnectClientTypes.RecommendationTrigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.session = try reader["session"].readIfPresent(with: QConnectClientTypes.SessionData.read(from:))
        return value
    }
}

extension ListAIAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIAgentsOutput()
        value.aiAgentSummaries = try reader["aiAgentSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIAgentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAIAgentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIAgentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIAgentVersionsOutput()
        value.aiAgentVersionSummaries = try reader["aiAgentVersionSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIAgentVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAIGuardrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIGuardrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIGuardrailsOutput()
        value.aiGuardrailSummaries = try reader["aiGuardrailSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIGuardrailSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAIGuardrailVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIGuardrailVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIGuardrailVersionsOutput()
        value.aiGuardrailVersionSummaries = try reader["aiGuardrailVersionSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIGuardrailVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAIPromptsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIPromptsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIPromptsOutput()
        value.aiPromptSummaries = try reader["aiPromptSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIPromptSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAIPromptVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAIPromptVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAIPromptVersionsOutput()
        value.aiPromptVersionSummaries = try reader["aiPromptVersionSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AIPromptVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssistantAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssistantAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssistantAssociationsOutput()
        value.assistantAssociationSummaries = try reader["assistantAssociationSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AssistantAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssistantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssistantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssistantsOutput()
        value.assistantSummaries = try reader["assistantSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AssistantSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListContentAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContentAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContentAssociationsOutput()
        value.contentAssociationSummaries = try reader["contentAssociationSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.ContentAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListContentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContentsOutput()
        value.contentSummaries = try reader["contentSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.ContentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportJobsOutput()
        value.importJobSummaries = try reader["importJobSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.ImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKnowledgeBasesOutput()
        value.knowledgeBaseSummaries = try reader["knowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.KnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMessagesOutput()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageOutput.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMessageTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMessageTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMessageTemplatesOutput()
        value.messageTemplateSummaries = try reader["messageTemplateSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMessageTemplateVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMessageTemplateVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMessageTemplateVersionsOutput()
        value.messageTemplateVersionSummaries = try reader["messageTemplateVersionSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageTemplateVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQuickResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQuickResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQuickResponsesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.quickResponseSummaries = try reader["quickResponseSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.QuickResponseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NotifyRecommendationsReceivedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyRecommendationsReceivedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = NotifyRecommendationsReceivedOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: QConnectClientTypes.NotifyRecommendationsReceivedError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendationIds = try reader["recommendationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFeedbackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFeedbackOutput()
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.contentFeedback = try reader["contentFeedback"].readIfPresent(with: QConnectClientTypes.ContentFeedbackData.read(from:))
        value.targetId = try reader["targetId"].readIfPresent() ?? ""
        value.targetType = try reader["targetType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QueryAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> QueryAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = QueryAssistantOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: QConnectClientTypes.ResultData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RemoveAssistantAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveAssistantAIAgentOutput {
        return RemoveAssistantAIAgentOutput()
    }
}

extension RemoveKnowledgeBaseTemplateUriOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveKnowledgeBaseTemplateUriOutput {
        return RemoveKnowledgeBaseTemplateUriOutput()
    }
}

extension RenderMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RenderMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RenderMessageTemplateOutput()
        value.attachments = try reader["attachments"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageTemplateAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributesNotInterpolated = try reader["attributesNotInterpolated"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.MessageTemplateContentProvider.read(from:))
        return value
    }
}

extension SearchContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContentOutput()
        value.contentSummaries = try reader["contentSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.ContentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchMessageTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchMessageTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchMessageTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageTemplateSearchResultData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SearchQuickResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQuickResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQuickResponsesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: QConnectClientTypes.QuickResponseSearchResultData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SearchSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: QConnectClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SendMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendMessageOutput()
        value.nextMessageToken = try reader["nextMessageToken"].readIfPresent() ?? ""
        value.requestMessageId = try reader["requestMessageId"].readIfPresent() ?? ""
        return value
    }
}

extension StartContentUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContentUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartContentUploadOutput()
        value.headersToInclude = try reader["headersToInclude"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.url = try reader["url"].readIfPresent() ?? ""
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension StartImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportJobOutput()
        value.importJob = try reader["importJob"].readIfPresent(with: QConnectClientTypes.ImportJobData.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAIAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAIAgentOutput()
        value.aiAgent = try reader["aiAgent"].readIfPresent(with: QConnectClientTypes.AIAgentData.read(from:))
        return value
    }
}

extension UpdateAIGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAIGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAIGuardrailOutput()
        value.aiGuardrail = try reader["aiGuardrail"].readIfPresent(with: QConnectClientTypes.AIGuardrailData.read(from:))
        return value
    }
}

extension UpdateAIPromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAIPromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAIPromptOutput()
        value.aiPrompt = try reader["aiPrompt"].readIfPresent(with: QConnectClientTypes.AIPromptData.read(from:))
        return value
    }
}

extension UpdateAssistantAIAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssistantAIAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssistantAIAgentOutput()
        value.assistant = try reader["assistant"].readIfPresent(with: QConnectClientTypes.AssistantData.read(from:))
        return value
    }
}

extension UpdateContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateContentOutput()
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.ContentData.read(from:))
        return value
    }
}

extension UpdateKnowledgeBaseTemplateUriOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKnowledgeBaseTemplateUriOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKnowledgeBaseTemplateUriOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: QConnectClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension UpdateMessageTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMessageTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMessageTemplateOutput()
        value.messageTemplate = try reader["messageTemplate"].readIfPresent(with: QConnectClientTypes.MessageTemplateData.read(from:))
        return value
    }
}

extension UpdateMessageTemplateMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMessageTemplateMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMessageTemplateMetadataOutput()
        value.messageTemplate = try reader["messageTemplate"].readIfPresent(with: QConnectClientTypes.MessageTemplateData.read(from:))
        return value
    }
}

extension UpdateQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: QConnectClientTypes.QuickResponseData.read(from:))
        return value
    }
}

extension UpdateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSessionOutput()
        value.session = try reader["session"].readIfPresent(with: QConnectClientTypes.SessionData.read(from:))
        return value
    }
}

extension UpdateSessionDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSessionDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSessionDataOutput()
        value.data = try reader["data"].readListIfPresent(memberReadingClosure: QConnectClientTypes.RuntimeSessionData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.namespace = try reader["namespace"].readIfPresent() ?? .sdkUnknown("")
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

enum ActivateMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIAgentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIGuardrailVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIPromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAIPromptVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContentAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMessageTemplateAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMessageTemplateVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIAgentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIGuardrailVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIPromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAIPromptVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContentAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMessageTemplateAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAIGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAIPromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContentAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContentSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNextMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIAgentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIGuardrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIGuardrailVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIPromptsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAIPromptVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssistantAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssistantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContentAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKnowledgeBasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMessageTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMessageTemplateVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQuickResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyRecommendationsReceivedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum QueryAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveAssistantAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveKnowledgeBaseTemplateUriOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RenderMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchMessageTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQuickResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContentUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAIGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAIPromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssistantAIAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKnowledgeBaseTemplateUriOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMessageTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMessageTemplateMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSessionDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTimeoutException {
        let reader = baseError.errorBodyReader
        var value = RequestTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QConnectClientTypes.AIAgentData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIAgentData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIAgentData()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiAgentId = try reader["aiAgentId"].readIfPresent() ?? ""
        value.aiAgentArn = try reader["aiAgentArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: QConnectClientTypes.AIAgentConfiguration.read(from:))
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.origin = try reader["origin"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIAgentConfiguration {

    static func write(value: QConnectClientTypes.AIAgentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .answerrecommendationaiagentconfiguration(answerrecommendationaiagentconfiguration):
                try writer["answerRecommendationAIAgentConfiguration"].write(answerrecommendationaiagentconfiguration, with: QConnectClientTypes.AnswerRecommendationAIAgentConfiguration.write(value:to:))
            case let .manualsearchaiagentconfiguration(manualsearchaiagentconfiguration):
                try writer["manualSearchAIAgentConfiguration"].write(manualsearchaiagentconfiguration, with: QConnectClientTypes.ManualSearchAIAgentConfiguration.write(value:to:))
            case let .selfserviceaiagentconfiguration(selfserviceaiagentconfiguration):
                try writer["selfServiceAIAgentConfiguration"].write(selfserviceaiagentconfiguration, with: QConnectClientTypes.SelfServiceAIAgentConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIAgentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "manualSearchAIAgentConfiguration":
                return .manualsearchaiagentconfiguration(try reader["manualSearchAIAgentConfiguration"].read(with: QConnectClientTypes.ManualSearchAIAgentConfiguration.read(from:)))
            case "answerRecommendationAIAgentConfiguration":
                return .answerrecommendationaiagentconfiguration(try reader["answerRecommendationAIAgentConfiguration"].read(with: QConnectClientTypes.AnswerRecommendationAIAgentConfiguration.read(from:)))
            case "selfServiceAIAgentConfiguration":
                return .selfserviceaiagentconfiguration(try reader["selfServiceAIAgentConfiguration"].read(with: QConnectClientTypes.SelfServiceAIAgentConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.SelfServiceAIAgentConfiguration {

    static func write(value: QConnectClientTypes.SelfServiceAIAgentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationConfigurations"].writeList(value.associationConfigurations, memberWritingClosure: QConnectClientTypes.AssociationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["selfServiceAIGuardrailId"].write(value.selfServiceAIGuardrailId)
        try writer["selfServiceAnswerGenerationAIPromptId"].write(value.selfServiceAnswerGenerationAIPromptId)
        try writer["selfServicePreProcessingAIPromptId"].write(value.selfServicePreProcessingAIPromptId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SelfServiceAIAgentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SelfServiceAIAgentConfiguration()
        value.selfServicePreProcessingAIPromptId = try reader["selfServicePreProcessingAIPromptId"].readIfPresent()
        value.selfServiceAnswerGenerationAIPromptId = try reader["selfServiceAnswerGenerationAIPromptId"].readIfPresent()
        value.selfServiceAIGuardrailId = try reader["selfServiceAIGuardrailId"].readIfPresent()
        value.associationConfigurations = try reader["associationConfigurations"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AssociationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AssociationConfiguration {

    static func write(value: QConnectClientTypes.AssociationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationConfigurationData"].write(value.associationConfigurationData, with: QConnectClientTypes.AssociationConfigurationData.write(value:to:))
        try writer["associationId"].write(value.associationId)
        try writer["associationType"].write(value.associationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssociationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssociationConfiguration()
        value.associationId = try reader["associationId"].readIfPresent()
        value.associationType = try reader["associationType"].readIfPresent()
        value.associationConfigurationData = try reader["associationConfigurationData"].readIfPresent(with: QConnectClientTypes.AssociationConfigurationData.read(from:))
        return value
    }
}

extension QConnectClientTypes.AssociationConfigurationData {

    static func write(value: QConnectClientTypes.AssociationConfigurationData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .knowledgebaseassociationconfigurationdata(knowledgebaseassociationconfigurationdata):
                try writer["knowledgeBaseAssociationConfigurationData"].write(knowledgebaseassociationconfigurationdata, with: QConnectClientTypes.KnowledgeBaseAssociationConfigurationData.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssociationConfigurationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "knowledgeBaseAssociationConfigurationData":
                return .knowledgebaseassociationconfigurationdata(try reader["knowledgeBaseAssociationConfigurationData"].read(with: QConnectClientTypes.KnowledgeBaseAssociationConfigurationData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.KnowledgeBaseAssociationConfigurationData {

    static func write(value: QConnectClientTypes.KnowledgeBaseAssociationConfigurationData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentTagFilter"].write(value.contentTagFilter, with: QConnectClientTypes.TagFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["overrideKnowledgeBaseSearchType"].write(value.overrideKnowledgeBaseSearchType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.KnowledgeBaseAssociationConfigurationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.KnowledgeBaseAssociationConfigurationData()
        value.contentTagFilter = try reader["contentTagFilter"].readIfPresent(with: QConnectClientTypes.TagFilter.read(from:))
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.overrideKnowledgeBaseSearchType = try reader["overrideKnowledgeBaseSearchType"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.TagFilter {

    static func write(value: QConnectClientTypes.TagFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andconditions(andconditions):
                try writer["andConditions"].writeList(andconditions, memberWritingClosure: QConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .orconditions(orconditions):
                try writer["orConditions"].writeList(orconditions, memberWritingClosure: QConnectClientTypes.OrCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .tagcondition(tagcondition):
                try writer["tagCondition"].write(tagcondition, with: QConnectClientTypes.TagCondition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.TagFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tagCondition":
                return .tagcondition(try reader["tagCondition"].read(with: QConnectClientTypes.TagCondition.read(from:)))
            case "andConditions":
                return .andconditions(try reader["andConditions"].readList(memberReadingClosure: QConnectClientTypes.TagCondition.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "orConditions":
                return .orconditions(try reader["orConditions"].readList(memberReadingClosure: QConnectClientTypes.OrCondition.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.OrCondition {

    static func write(value: QConnectClientTypes.OrCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andconditions(andconditions):
                try writer["andConditions"].writeList(andconditions, memberWritingClosure: QConnectClientTypes.TagCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .tagcondition(tagcondition):
                try writer["tagCondition"].write(tagcondition, with: QConnectClientTypes.TagCondition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.OrCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "andConditions":
                return .andconditions(try reader["andConditions"].readList(memberReadingClosure: QConnectClientTypes.TagCondition.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "tagCondition":
                return .tagcondition(try reader["tagCondition"].read(with: QConnectClientTypes.TagCondition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.TagCondition {

    static func write(value: QConnectClientTypes.TagCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.TagCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.TagCondition()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AnswerRecommendationAIAgentConfiguration {

    static func write(value: QConnectClientTypes.AnswerRecommendationAIAgentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["answerGenerationAIGuardrailId"].write(value.answerGenerationAIGuardrailId)
        try writer["answerGenerationAIPromptId"].write(value.answerGenerationAIPromptId)
        try writer["associationConfigurations"].writeList(value.associationConfigurations, memberWritingClosure: QConnectClientTypes.AssociationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["intentLabelingGenerationAIPromptId"].write(value.intentLabelingGenerationAIPromptId)
        try writer["locale"].write(value.locale)
        try writer["queryReformulationAIPromptId"].write(value.queryReformulationAIPromptId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AnswerRecommendationAIAgentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AnswerRecommendationAIAgentConfiguration()
        value.intentLabelingGenerationAIPromptId = try reader["intentLabelingGenerationAIPromptId"].readIfPresent()
        value.queryReformulationAIPromptId = try reader["queryReformulationAIPromptId"].readIfPresent()
        value.answerGenerationAIPromptId = try reader["answerGenerationAIPromptId"].readIfPresent()
        value.answerGenerationAIGuardrailId = try reader["answerGenerationAIGuardrailId"].readIfPresent()
        value.associationConfigurations = try reader["associationConfigurations"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AssociationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.locale = try reader["locale"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ManualSearchAIAgentConfiguration {

    static func write(value: QConnectClientTypes.ManualSearchAIAgentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["answerGenerationAIGuardrailId"].write(value.answerGenerationAIGuardrailId)
        try writer["answerGenerationAIPromptId"].write(value.answerGenerationAIPromptId)
        try writer["associationConfigurations"].writeList(value.associationConfigurations, memberWritingClosure: QConnectClientTypes.AssociationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["locale"].write(value.locale)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ManualSearchAIAgentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ManualSearchAIAgentConfiguration()
        value.answerGenerationAIPromptId = try reader["answerGenerationAIPromptId"].readIfPresent()
        value.answerGenerationAIGuardrailId = try reader["answerGenerationAIGuardrailId"].readIfPresent()
        value.associationConfigurations = try reader["associationConfigurations"].readListIfPresent(memberReadingClosure: QConnectClientTypes.AssociationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.locale = try reader["locale"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIGuardrailData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailData()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiGuardrailArn = try reader["aiGuardrailArn"].readIfPresent() ?? ""
        value.aiGuardrailId = try reader["aiGuardrailId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.blockedInputMessaging = try reader["blockedInputMessaging"].readIfPresent() ?? ""
        value.blockedOutputsMessaging = try reader["blockedOutputsMessaging"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.topicPolicyConfig = try reader["topicPolicyConfig"].readIfPresent(with: QConnectClientTypes.AIGuardrailTopicPolicyConfig.read(from:))
        value.contentPolicyConfig = try reader["contentPolicyConfig"].readIfPresent(with: QConnectClientTypes.AIGuardrailContentPolicyConfig.read(from:))
        value.wordPolicyConfig = try reader["wordPolicyConfig"].readIfPresent(with: QConnectClientTypes.AIGuardrailWordPolicyConfig.read(from:))
        value.sensitiveInformationPolicyConfig = try reader["sensitiveInformationPolicyConfig"].readIfPresent(with: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig.read(from:))
        value.contextualGroundingPolicyConfig = try reader["contextualGroundingPolicyConfig"].readIfPresent(with: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig {

    static func write(value: QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: QConnectClientTypes.GuardrailContextualGroundingFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailContextualGroundingPolicyConfig()
        value.filtersConfig = try reader["filtersConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailContextualGroundingFilterConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QConnectClientTypes.GuardrailContextualGroundingFilterConfig {

    static func write(value: QConnectClientTypes.GuardrailContextualGroundingFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["threshold"].write(value.threshold)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailContextualGroundingFilterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailContextualGroundingFilterConfig()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig {

    static func write(value: QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntitiesConfig"].writeList(value.piiEntitiesConfig, memberWritingClosure: QConnectClientTypes.GuardrailPiiEntityConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regexesConfig"].writeList(value.regexesConfig, memberWritingClosure: QConnectClientTypes.GuardrailRegexConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailSensitiveInformationPolicyConfig()
        value.piiEntitiesConfig = try reader["piiEntitiesConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailPiiEntityConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexesConfig = try reader["regexesConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailRegexConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.GuardrailRegexConfig {

    static func write(value: QConnectClientTypes.GuardrailRegexConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["pattern"].write(value.pattern)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailRegexConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailRegexConfig()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.pattern = try reader["pattern"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.GuardrailPiiEntityConfig {

    static func write(value: QConnectClientTypes.GuardrailPiiEntityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailPiiEntityConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailPiiEntityConfig()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.AIGuardrailWordPolicyConfig {

    static func write(value: QConnectClientTypes.AIGuardrailWordPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managedWordListsConfig"].writeList(value.managedWordListsConfig, memberWritingClosure: QConnectClientTypes.GuardrailManagedWordsConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["wordsConfig"].writeList(value.wordsConfig, memberWritingClosure: QConnectClientTypes.GuardrailWordConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailWordPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailWordPolicyConfig()
        value.wordsConfig = try reader["wordsConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailWordConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordListsConfig = try reader["managedWordListsConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailManagedWordsConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.GuardrailManagedWordsConfig {

    static func write(value: QConnectClientTypes.GuardrailManagedWordsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailManagedWordsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailManagedWordsConfig()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.GuardrailWordConfig {

    static func write(value: QConnectClientTypes.GuardrailWordConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailWordConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailWordConfig()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.AIGuardrailContentPolicyConfig {

    static func write(value: QConnectClientTypes.AIGuardrailContentPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: QConnectClientTypes.GuardrailContentFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailContentPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailContentPolicyConfig()
        value.filtersConfig = try reader["filtersConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailContentFilterConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QConnectClientTypes.GuardrailContentFilterConfig {

    static func write(value: QConnectClientTypes.GuardrailContentFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputStrength"].write(value.inputStrength)
        try writer["outputStrength"].write(value.outputStrength)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailContentFilterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailContentFilterConfig()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.inputStrength = try reader["inputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.outputStrength = try reader["outputStrength"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.AIGuardrailTopicPolicyConfig {

    static func write(value: QConnectClientTypes.AIGuardrailTopicPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicsConfig"].writeList(value.topicsConfig, memberWritingClosure: QConnectClientTypes.GuardrailTopicConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailTopicPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailTopicPolicyConfig()
        value.topicsConfig = try reader["topicsConfig"].readListIfPresent(memberReadingClosure: QConnectClientTypes.GuardrailTopicConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QConnectClientTypes.GuardrailTopicConfig {

    static func write(value: QConnectClientTypes.GuardrailTopicConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["examples"].writeList(value.examples, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GuardrailTopicConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GuardrailTopicConfig()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.examples = try reader["examples"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.AIPromptData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIPromptData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIPromptData()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiPromptId = try reader["aiPromptId"].readIfPresent() ?? ""
        value.aiPromptArn = try reader["aiPromptArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.apiFormat = try reader["apiFormat"].readIfPresent() ?? .sdkUnknown("")
        value.templateConfiguration = try reader["templateConfiguration"].readIfPresent(with: QConnectClientTypes.AIPromptTemplateConfiguration.read(from:))
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.origin = try reader["origin"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIPromptTemplateConfiguration {

    static func write(value: QConnectClientTypes.AIPromptTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .textfullaipromptedittemplateconfiguration(textfullaipromptedittemplateconfiguration):
                try writer["textFullAIPromptEditTemplateConfiguration"].write(textfullaipromptedittemplateconfiguration, with: QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIPromptTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textFullAIPromptEditTemplateConfiguration":
                return .textfullaipromptedittemplateconfiguration(try reader["textFullAIPromptEditTemplateConfiguration"].read(with: QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration {

    static func write(value: QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.TextFullAIPromptEditTemplateConfiguration()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.AssistantData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantData()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: QConnectClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: QConnectClientTypes.AssistantIntegrationConfiguration.read(from:))
        value.capabilityConfiguration = try reader["capabilityConfiguration"].readIfPresent(with: QConnectClientTypes.AssistantCapabilityConfiguration.read(from:))
        value.aiAgentConfiguration = try reader["aiAgentConfiguration"].readMapIfPresent(valueReadingClosure: QConnectClientTypes.AIAgentConfigurationData.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AIAgentConfigurationData {

    static func write(value: QConnectClientTypes.AIAgentConfigurationData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aiAgentId"].write(value.aiAgentId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIAgentConfigurationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIAgentConfigurationData()
        value.aiAgentId = try reader["aiAgentId"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.AssistantCapabilityConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantCapabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantCapabilityConfiguration()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AssistantIntegrationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantIntegrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantIntegrationConfiguration()
        value.topicIntegrationArn = try reader["topicIntegrationArn"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ServerSideEncryptionConfiguration {

    static func write(value: QConnectClientTypes.ServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ServerSideEncryptionConfiguration()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AssistantAssociationData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantAssociationData()
        value.assistantAssociationId = try reader["assistantAssociationId"].readIfPresent() ?? ""
        value.assistantAssociationArn = try reader["assistantAssociationArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: QConnectClientTypes.AssistantAssociationOutputData.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AssistantAssociationOutputData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantAssociationOutputData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "knowledgeBaseAssociation":
                return .knowledgebaseassociation(try reader["knowledgeBaseAssociation"].read(with: QConnectClientTypes.KnowledgeBaseAssociationData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.KnowledgeBaseAssociationData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.KnowledgeBaseAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.KnowledgeBaseAssociationData()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ContentData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentData()
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.linkOutUri = try reader["linkOutUri"].readIfPresent()
        value.url = try reader["url"].readIfPresent() ?? ""
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension QConnectClientTypes.ContentAssociationData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentAssociationData()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentAssociationId = try reader["contentAssociationId"].readIfPresent() ?? ""
        value.contentAssociationArn = try reader["contentAssociationArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: QConnectClientTypes.ContentAssociationContents.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.ContentAssociationContents {

    static func write(value: QConnectClientTypes.ContentAssociationContents?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amazonconnectguideassociation(amazonconnectguideassociation):
                try writer["amazonConnectGuideAssociation"].write(amazonconnectguideassociation, with: QConnectClientTypes.AmazonConnectGuideAssociationData.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentAssociationContents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "amazonConnectGuideAssociation":
                return .amazonconnectguideassociation(try reader["amazonConnectGuideAssociation"].read(with: QConnectClientTypes.AmazonConnectGuideAssociationData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.AmazonConnectGuideAssociationData {

    static func write(value: QConnectClientTypes.AmazonConnectGuideAssociationData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowId"].write(value.flowId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AmazonConnectGuideAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AmazonConnectGuideAssociationData()
        value.flowId = try reader["flowId"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.KnowledgeBaseData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.KnowledgeBaseData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.KnowledgeBaseData()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.knowledgeBaseType = try reader["knowledgeBaseType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastContentModificationTime = try reader["lastContentModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vectorIngestionConfiguration = try reader["vectorIngestionConfiguration"].readIfPresent(with: QConnectClientTypes.VectorIngestionConfiguration.read(from:))
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: QConnectClientTypes.SourceConfiguration.read(from:))
        value.renderingConfiguration = try reader["renderingConfiguration"].readIfPresent(with: QConnectClientTypes.RenderingConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: QConnectClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.ingestionStatus = try reader["ingestionStatus"].readIfPresent()
        value.ingestionFailureReasons = try reader["ingestionFailureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.RenderingConfiguration {

    static func write(value: QConnectClientTypes.RenderingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateUri"].write(value.templateUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RenderingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.RenderingConfiguration()
        value.templateUri = try reader["templateUri"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.SourceConfiguration {

    static func write(value: QConnectClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .appintegrations(appintegrations):
                try writer["appIntegrations"].write(appintegrations, with: QConnectClientTypes.AppIntegrationsConfiguration.write(value:to:))
            case let .managedsourceconfiguration(managedsourceconfiguration):
                try writer["managedSourceConfiguration"].write(managedsourceconfiguration, with: QConnectClientTypes.ManagedSourceConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "appIntegrations":
                return .appintegrations(try reader["appIntegrations"].read(with: QConnectClientTypes.AppIntegrationsConfiguration.read(from:)))
            case "managedSourceConfiguration":
                return .managedsourceconfiguration(try reader["managedSourceConfiguration"].read(with: QConnectClientTypes.ManagedSourceConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.ManagedSourceConfiguration {

    static func write(value: QConnectClientTypes.ManagedSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .webcrawlerconfiguration(webcrawlerconfiguration):
                try writer["webCrawlerConfiguration"].write(webcrawlerconfiguration, with: QConnectClientTypes.WebCrawlerConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ManagedSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "webCrawlerConfiguration":
                return .webcrawlerconfiguration(try reader["webCrawlerConfiguration"].read(with: QConnectClientTypes.WebCrawlerConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.WebCrawlerConfiguration {

    static func write(value: QConnectClientTypes.WebCrawlerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerLimits"].write(value.crawlerLimits, with: QConnectClientTypes.WebCrawlerLimits.write(value:to:))
        try writer["exclusionFilters"].writeList(value.exclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inclusionFilters"].writeList(value.inclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scope"].write(value.scope)
        try writer["urlConfiguration"].write(value.urlConfiguration, with: QConnectClientTypes.UrlConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.WebCrawlerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.WebCrawlerConfiguration()
        value.urlConfiguration = try reader["urlConfiguration"].readIfPresent(with: QConnectClientTypes.UrlConfiguration.read(from:))
        value.crawlerLimits = try reader["crawlerLimits"].readIfPresent(with: QConnectClientTypes.WebCrawlerLimits.read(from:))
        value.inclusionFilters = try reader["inclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exclusionFilters = try reader["exclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scope = try reader["scope"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.WebCrawlerLimits {

    static func write(value: QConnectClientTypes.WebCrawlerLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rateLimit"].write(value.rateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.WebCrawlerLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.WebCrawlerLimits()
        value.rateLimit = try reader["rateLimit"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.UrlConfiguration {

    static func write(value: QConnectClientTypes.UrlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["seedUrls"].writeList(value.seedUrls, memberWritingClosure: QConnectClientTypes.SeedUrl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.UrlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.UrlConfiguration()
        value.seedUrls = try reader["seedUrls"].readListIfPresent(memberReadingClosure: QConnectClientTypes.SeedUrl.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.SeedUrl {

    static func write(value: QConnectClientTypes.SeedUrl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SeedUrl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SeedUrl()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AppIntegrationsConfiguration {

    static func write(value: QConnectClientTypes.AppIntegrationsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIntegrationArn"].write(value.appIntegrationArn)
        try writer["objectFields"].writeList(value.objectFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AppIntegrationsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AppIntegrationsConfiguration()
        value.appIntegrationArn = try reader["appIntegrationArn"].readIfPresent() ?? ""
        value.objectFields = try reader["objectFields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.VectorIngestionConfiguration {

    static func write(value: QConnectClientTypes.VectorIngestionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingConfiguration"].write(value.chunkingConfiguration, with: QConnectClientTypes.ChunkingConfiguration.write(value:to:))
        try writer["parsingConfiguration"].write(value.parsingConfiguration, with: QConnectClientTypes.ParsingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.VectorIngestionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.VectorIngestionConfiguration()
        value.chunkingConfiguration = try reader["chunkingConfiguration"].readIfPresent(with: QConnectClientTypes.ChunkingConfiguration.read(from:))
        value.parsingConfiguration = try reader["parsingConfiguration"].readIfPresent(with: QConnectClientTypes.ParsingConfiguration.read(from:))
        return value
    }
}

extension QConnectClientTypes.ParsingConfiguration {

    static func write(value: QConnectClientTypes.ParsingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockFoundationModelConfiguration"].write(value.bedrockFoundationModelConfiguration, with: QConnectClientTypes.BedrockFoundationModelConfigurationForParsing.write(value:to:))
        try writer["parsingStrategy"].write(value.parsingStrategy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ParsingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ParsingConfiguration()
        value.parsingStrategy = try reader["parsingStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.bedrockFoundationModelConfiguration = try reader["bedrockFoundationModelConfiguration"].readIfPresent(with: QConnectClientTypes.BedrockFoundationModelConfigurationForParsing.read(from:))
        return value
    }
}

extension QConnectClientTypes.BedrockFoundationModelConfigurationForParsing {

    static func write(value: QConnectClientTypes.BedrockFoundationModelConfigurationForParsing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelArn"].write(value.modelArn)
        try writer["parsingPrompt"].write(value.parsingPrompt, with: QConnectClientTypes.ParsingPrompt.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.BedrockFoundationModelConfigurationForParsing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.BedrockFoundationModelConfigurationForParsing()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.parsingPrompt = try reader["parsingPrompt"].readIfPresent(with: QConnectClientTypes.ParsingPrompt.read(from:))
        return value
    }
}

extension QConnectClientTypes.ParsingPrompt {

    static func write(value: QConnectClientTypes.ParsingPrompt?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parsingPromptText"].write(value.parsingPromptText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ParsingPrompt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ParsingPrompt()
        value.parsingPromptText = try reader["parsingPromptText"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.ChunkingConfiguration {

    static func write(value: QConnectClientTypes.ChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingStrategy"].write(value.chunkingStrategy)
        try writer["fixedSizeChunkingConfiguration"].write(value.fixedSizeChunkingConfiguration, with: QConnectClientTypes.FixedSizeChunkingConfiguration.write(value:to:))
        try writer["hierarchicalChunkingConfiguration"].write(value.hierarchicalChunkingConfiguration, with: QConnectClientTypes.HierarchicalChunkingConfiguration.write(value:to:))
        try writer["semanticChunkingConfiguration"].write(value.semanticChunkingConfiguration, with: QConnectClientTypes.SemanticChunkingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ChunkingConfiguration()
        value.chunkingStrategy = try reader["chunkingStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.fixedSizeChunkingConfiguration = try reader["fixedSizeChunkingConfiguration"].readIfPresent(with: QConnectClientTypes.FixedSizeChunkingConfiguration.read(from:))
        value.hierarchicalChunkingConfiguration = try reader["hierarchicalChunkingConfiguration"].readIfPresent(with: QConnectClientTypes.HierarchicalChunkingConfiguration.read(from:))
        value.semanticChunkingConfiguration = try reader["semanticChunkingConfiguration"].readIfPresent(with: QConnectClientTypes.SemanticChunkingConfiguration.read(from:))
        return value
    }
}

extension QConnectClientTypes.SemanticChunkingConfiguration {

    static func write(value: QConnectClientTypes.SemanticChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["breakpointPercentileThreshold"].write(value.breakpointPercentileThreshold)
        try writer["bufferSize"].write(value.bufferSize)
        try writer["maxTokens"].write(value.maxTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SemanticChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SemanticChunkingConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        value.bufferSize = try reader["bufferSize"].readIfPresent() ?? 0
        value.breakpointPercentileThreshold = try reader["breakpointPercentileThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.HierarchicalChunkingConfiguration {

    static func write(value: QConnectClientTypes.HierarchicalChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["levelConfigurations"].writeList(value.levelConfigurations, memberWritingClosure: QConnectClientTypes.HierarchicalChunkingLevelConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["overlapTokens"].write(value.overlapTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.HierarchicalChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.HierarchicalChunkingConfiguration()
        value.levelConfigurations = try reader["levelConfigurations"].readListIfPresent(memberReadingClosure: QConnectClientTypes.HierarchicalChunkingLevelConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.overlapTokens = try reader["overlapTokens"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.HierarchicalChunkingLevelConfiguration {

    static func write(value: QConnectClientTypes.HierarchicalChunkingLevelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.HierarchicalChunkingLevelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.HierarchicalChunkingLevelConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.FixedSizeChunkingConfiguration {

    static func write(value: QConnectClientTypes.FixedSizeChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["overlapPercentage"].write(value.overlapPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.FixedSizeChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.FixedSizeChunkingConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        value.overlapPercentage = try reader["overlapPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.MessageTemplateData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateData()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.channelSubtype = try reader["channelSubtype"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.MessageTemplateContentProvider.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.language = try reader["language"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: QConnectClientTypes.GroupingConfiguration.read(from:))
        value.defaultAttributes = try reader["defaultAttributes"].readIfPresent(with: QConnectClientTypes.MessageTemplateAttributes.read(from:))
        value.attributeTypes = try reader["attributeTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QConnectClientTypes.MessageTemplateAttributeType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.messageTemplateContentSha256 = try reader["messageTemplateContentSha256"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.MessageTemplateAttributes {

    static func write(value: QConnectClientTypes.MessageTemplateAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAttributes"].write(value.agentAttributes, with: QConnectClientTypes.AgentAttributes.write(value:to:))
        try writer["customAttributes"].writeMap(value.customAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["customerProfileAttributes"].write(value.customerProfileAttributes, with: QConnectClientTypes.CustomerProfileAttributes.write(value:to:))
        try writer["systemAttributes"].write(value.systemAttributes, with: QConnectClientTypes.SystemAttributes.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateAttributes()
        value.systemAttributes = try reader["systemAttributes"].readIfPresent(with: QConnectClientTypes.SystemAttributes.read(from:))
        value.agentAttributes = try reader["agentAttributes"].readIfPresent(with: QConnectClientTypes.AgentAttributes.read(from:))
        value.customerProfileAttributes = try reader["customerProfileAttributes"].readIfPresent(with: QConnectClientTypes.CustomerProfileAttributes.read(from:))
        value.customAttributes = try reader["customAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.CustomerProfileAttributes {

    static func write(value: QConnectClientTypes.CustomerProfileAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountNumber"].write(value.accountNumber)
        try writer["additionalInformation"].write(value.additionalInformation)
        try writer["address1"].write(value.address1)
        try writer["address2"].write(value.address2)
        try writer["address3"].write(value.address3)
        try writer["address4"].write(value.address4)
        try writer["billingAddress1"].write(value.billingAddress1)
        try writer["billingAddress2"].write(value.billingAddress2)
        try writer["billingAddress3"].write(value.billingAddress3)
        try writer["billingAddress4"].write(value.billingAddress4)
        try writer["billingCity"].write(value.billingCity)
        try writer["billingCountry"].write(value.billingCountry)
        try writer["billingCounty"].write(value.billingCounty)
        try writer["billingPostalCode"].write(value.billingPostalCode)
        try writer["billingProvince"].write(value.billingProvince)
        try writer["billingState"].write(value.billingState)
        try writer["birthDate"].write(value.birthDate)
        try writer["businessEmailAddress"].write(value.businessEmailAddress)
        try writer["businessName"].write(value.businessName)
        try writer["businessPhoneNumber"].write(value.businessPhoneNumber)
        try writer["city"].write(value.city)
        try writer["country"].write(value.country)
        try writer["county"].write(value.county)
        try writer["custom"].writeMap(value.custom, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["emailAddress"].write(value.emailAddress)
        try writer["firstName"].write(value.firstName)
        try writer["gender"].write(value.gender)
        try writer["homePhoneNumber"].write(value.homePhoneNumber)
        try writer["lastName"].write(value.lastName)
        try writer["mailingAddress1"].write(value.mailingAddress1)
        try writer["mailingAddress2"].write(value.mailingAddress2)
        try writer["mailingAddress3"].write(value.mailingAddress3)
        try writer["mailingAddress4"].write(value.mailingAddress4)
        try writer["mailingCity"].write(value.mailingCity)
        try writer["mailingCountry"].write(value.mailingCountry)
        try writer["mailingCounty"].write(value.mailingCounty)
        try writer["mailingPostalCode"].write(value.mailingPostalCode)
        try writer["mailingProvince"].write(value.mailingProvince)
        try writer["mailingState"].write(value.mailingState)
        try writer["middleName"].write(value.middleName)
        try writer["mobilePhoneNumber"].write(value.mobilePhoneNumber)
        try writer["partyType"].write(value.partyType)
        try writer["phoneNumber"].write(value.phoneNumber)
        try writer["postalCode"].write(value.postalCode)
        try writer["profileARN"].write(value.profileARN)
        try writer["profileId"].write(value.profileId)
        try writer["province"].write(value.province)
        try writer["shippingAddress1"].write(value.shippingAddress1)
        try writer["shippingAddress2"].write(value.shippingAddress2)
        try writer["shippingAddress3"].write(value.shippingAddress3)
        try writer["shippingAddress4"].write(value.shippingAddress4)
        try writer["shippingCity"].write(value.shippingCity)
        try writer["shippingCountry"].write(value.shippingCountry)
        try writer["shippingCounty"].write(value.shippingCounty)
        try writer["shippingPostalCode"].write(value.shippingPostalCode)
        try writer["shippingProvince"].write(value.shippingProvince)
        try writer["shippingState"].write(value.shippingState)
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.CustomerProfileAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.CustomerProfileAttributes()
        value.profileId = try reader["profileId"].readIfPresent()
        value.profileARN = try reader["profileARN"].readIfPresent()
        value.firstName = try reader["firstName"].readIfPresent()
        value.middleName = try reader["middleName"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        value.accountNumber = try reader["accountNumber"].readIfPresent()
        value.emailAddress = try reader["emailAddress"].readIfPresent()
        value.phoneNumber = try reader["phoneNumber"].readIfPresent()
        value.additionalInformation = try reader["additionalInformation"].readIfPresent()
        value.partyType = try reader["partyType"].readIfPresent()
        value.businessName = try reader["businessName"].readIfPresent()
        value.birthDate = try reader["birthDate"].readIfPresent()
        value.gender = try reader["gender"].readIfPresent()
        value.mobilePhoneNumber = try reader["mobilePhoneNumber"].readIfPresent()
        value.homePhoneNumber = try reader["homePhoneNumber"].readIfPresent()
        value.businessPhoneNumber = try reader["businessPhoneNumber"].readIfPresent()
        value.businessEmailAddress = try reader["businessEmailAddress"].readIfPresent()
        value.address1 = try reader["address1"].readIfPresent()
        value.address2 = try reader["address2"].readIfPresent()
        value.address3 = try reader["address3"].readIfPresent()
        value.address4 = try reader["address4"].readIfPresent()
        value.city = try reader["city"].readIfPresent()
        value.county = try reader["county"].readIfPresent()
        value.country = try reader["country"].readIfPresent()
        value.postalCode = try reader["postalCode"].readIfPresent()
        value.province = try reader["province"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.shippingAddress1 = try reader["shippingAddress1"].readIfPresent()
        value.shippingAddress2 = try reader["shippingAddress2"].readIfPresent()
        value.shippingAddress3 = try reader["shippingAddress3"].readIfPresent()
        value.shippingAddress4 = try reader["shippingAddress4"].readIfPresent()
        value.shippingCity = try reader["shippingCity"].readIfPresent()
        value.shippingCounty = try reader["shippingCounty"].readIfPresent()
        value.shippingCountry = try reader["shippingCountry"].readIfPresent()
        value.shippingPostalCode = try reader["shippingPostalCode"].readIfPresent()
        value.shippingProvince = try reader["shippingProvince"].readIfPresent()
        value.shippingState = try reader["shippingState"].readIfPresent()
        value.mailingAddress1 = try reader["mailingAddress1"].readIfPresent()
        value.mailingAddress2 = try reader["mailingAddress2"].readIfPresent()
        value.mailingAddress3 = try reader["mailingAddress3"].readIfPresent()
        value.mailingAddress4 = try reader["mailingAddress4"].readIfPresent()
        value.mailingCity = try reader["mailingCity"].readIfPresent()
        value.mailingCounty = try reader["mailingCounty"].readIfPresent()
        value.mailingCountry = try reader["mailingCountry"].readIfPresent()
        value.mailingPostalCode = try reader["mailingPostalCode"].readIfPresent()
        value.mailingProvince = try reader["mailingProvince"].readIfPresent()
        value.mailingState = try reader["mailingState"].readIfPresent()
        value.billingAddress1 = try reader["billingAddress1"].readIfPresent()
        value.billingAddress2 = try reader["billingAddress2"].readIfPresent()
        value.billingAddress3 = try reader["billingAddress3"].readIfPresent()
        value.billingAddress4 = try reader["billingAddress4"].readIfPresent()
        value.billingCity = try reader["billingCity"].readIfPresent()
        value.billingCounty = try reader["billingCounty"].readIfPresent()
        value.billingCountry = try reader["billingCountry"].readIfPresent()
        value.billingPostalCode = try reader["billingPostalCode"].readIfPresent()
        value.billingProvince = try reader["billingProvince"].readIfPresent()
        value.billingState = try reader["billingState"].readIfPresent()
        value.custom = try reader["custom"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AgentAttributes {

    static func write(value: QConnectClientTypes.AgentAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["firstName"].write(value.firstName)
        try writer["lastName"].write(value.lastName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AgentAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AgentAttributes()
        value.firstName = try reader["firstName"].readIfPresent()
        value.lastName = try reader["lastName"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.SystemAttributes {

    static func write(value: QConnectClientTypes.SystemAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerEndpoint"].write(value.customerEndpoint, with: QConnectClientTypes.SystemEndpointAttributes.write(value:to:))
        try writer["name"].write(value.name)
        try writer["systemEndpoint"].write(value.systemEndpoint, with: QConnectClientTypes.SystemEndpointAttributes.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SystemAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SystemAttributes()
        value.name = try reader["name"].readIfPresent()
        value.customerEndpoint = try reader["customerEndpoint"].readIfPresent(with: QConnectClientTypes.SystemEndpointAttributes.read(from:))
        value.systemEndpoint = try reader["systemEndpoint"].readIfPresent(with: QConnectClientTypes.SystemEndpointAttributes.read(from:))
        return value
    }
}

extension QConnectClientTypes.SystemEndpointAttributes {

    static func write(value: QConnectClientTypes.SystemEndpointAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SystemEndpointAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SystemEndpointAttributes()
        value.address = try reader["address"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.GroupingConfiguration {

    static func write(value: QConnectClientTypes.GroupingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].write(value.criteria)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GroupingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GroupingConfiguration()
        value.criteria = try reader["criteria"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.MessageTemplateContentProvider {

    static func write(value: QConnectClientTypes.MessageTemplateContentProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .email(email):
                try writer["email"].write(email, with: QConnectClientTypes.EmailMessageTemplateContent.write(value:to:))
            case let .sms(sms):
                try writer["sms"].write(sms, with: QConnectClientTypes.SMSMessageTemplateContent.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateContentProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "email":
                return .email(try reader["email"].read(with: QConnectClientTypes.EmailMessageTemplateContent.read(from:)))
            case "sms":
                return .sms(try reader["sms"].read(with: QConnectClientTypes.SMSMessageTemplateContent.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.SMSMessageTemplateContent {

    static func write(value: QConnectClientTypes.SMSMessageTemplateContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body, with: QConnectClientTypes.SMSMessageTemplateContentBody.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SMSMessageTemplateContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SMSMessageTemplateContent()
        value.body = try reader["body"].readIfPresent(with: QConnectClientTypes.SMSMessageTemplateContentBody.read(from:))
        return value
    }
}

extension QConnectClientTypes.SMSMessageTemplateContentBody {

    static func write(value: QConnectClientTypes.SMSMessageTemplateContentBody?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["plainText"].write(value.plainText, with: QConnectClientTypes.MessageTemplateBodyContentProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SMSMessageTemplateContentBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SMSMessageTemplateContentBody()
        value.plainText = try reader["plainText"].readIfPresent(with: QConnectClientTypes.MessageTemplateBodyContentProvider.read(from:))
        return value
    }
}

extension QConnectClientTypes.MessageTemplateBodyContentProvider {

    static func write(value: QConnectClientTypes.MessageTemplateBodyContentProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .content(content):
                try writer["content"].write(content)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateBodyContentProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "content":
                return .content(try reader["content"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.EmailMessageTemplateContent {

    static func write(value: QConnectClientTypes.EmailMessageTemplateContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body, with: QConnectClientTypes.EmailMessageTemplateContentBody.write(value:to:))
        try writer["headers"].writeList(value.headers, memberWritingClosure: QConnectClientTypes.EmailHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subject"].write(value.subject)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.EmailMessageTemplateContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.EmailMessageTemplateContent()
        value.subject = try reader["subject"].readIfPresent()
        value.body = try reader["body"].readIfPresent(with: QConnectClientTypes.EmailMessageTemplateContentBody.read(from:))
        value.headers = try reader["headers"].readListIfPresent(memberReadingClosure: QConnectClientTypes.EmailHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.EmailHeader {

    static func write(value: QConnectClientTypes.EmailHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.EmailHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.EmailHeader()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.EmailMessageTemplateContentBody {

    static func write(value: QConnectClientTypes.EmailMessageTemplateContentBody?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["html"].write(value.html, with: QConnectClientTypes.MessageTemplateBodyContentProvider.write(value:to:))
        try writer["plainText"].write(value.plainText, with: QConnectClientTypes.MessageTemplateBodyContentProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.EmailMessageTemplateContentBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.EmailMessageTemplateContentBody()
        value.plainText = try reader["plainText"].readIfPresent(with: QConnectClientTypes.MessageTemplateBodyContentProvider.read(from:))
        value.html = try reader["html"].readIfPresent(with: QConnectClientTypes.MessageTemplateBodyContentProvider.read(from:))
        return value
    }
}

extension QConnectClientTypes.MessageTemplateAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateAttachment()
        value.contentDisposition = try reader["contentDisposition"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.uploadedTime = try reader["uploadedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.url = try reader["url"].readIfPresent() ?? ""
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.attachmentId = try reader["attachmentId"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.ExtendedMessageTemplateData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ExtendedMessageTemplateData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ExtendedMessageTemplateData()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.channelSubtype = try reader["channelSubtype"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: QConnectClientTypes.MessageTemplateContentProvider.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.language = try reader["language"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: QConnectClientTypes.GroupingConfiguration.read(from:))
        value.defaultAttributes = try reader["defaultAttributes"].readIfPresent(with: QConnectClientTypes.MessageTemplateAttributes.read(from:))
        value.attributeTypes = try reader["attributeTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QConnectClientTypes.MessageTemplateAttributeType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachments = try reader["attachments"].readListIfPresent(memberReadingClosure: QConnectClientTypes.MessageTemplateAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isActive = try reader["isActive"].readIfPresent()
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        value.messageTemplateContentSha256 = try reader["messageTemplateContentSha256"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.QuickResponseData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QuickResponseData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.QuickResponseData()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.contents = try reader["contents"].readIfPresent(with: QConnectClientTypes.QuickResponseContents.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: QConnectClientTypes.GroupingConfiguration.read(from:))
        value.shortcutKey = try reader["shortcutKey"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.isActive = try reader["isActive"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.language = try reader["language"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.QuickResponseContents {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QuickResponseContents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.QuickResponseContents()
        value.plainText = try reader["plainText"].readIfPresent(with: QConnectClientTypes.QuickResponseContentProvider.read(from:))
        value.markdown = try reader["markdown"].readIfPresent(with: QConnectClientTypes.QuickResponseContentProvider.read(from:))
        return value
    }
}

extension QConnectClientTypes.QuickResponseContentProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QuickResponseContentProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "content":
                return .content(try reader["content"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.SessionData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SessionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SessionData()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: QConnectClientTypes.SessionIntegrationConfiguration.read(from:))
        value.tagFilter = try reader["tagFilter"].readIfPresent(with: QConnectClientTypes.TagFilter.read(from:))
        value.aiAgentConfiguration = try reader["aiAgentConfiguration"].readMapIfPresent(valueReadingClosure: QConnectClientTypes.AIAgentConfigurationData.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.SessionIntegrationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SessionIntegrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SessionIntegrationConfiguration()
        value.topicIntegrationArn = try reader["topicIntegrationArn"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ContentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentSummary()
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.ImportJobData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ImportJobData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ImportJobData()
        value.importJobId = try reader["importJobId"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.importJobType = try reader["importJobType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.url = try reader["url"].readIfPresent() ?? ""
        value.failedRecordReport = try reader["failedRecordReport"].readIfPresent()
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalSourceConfiguration = try reader["externalSourceConfiguration"].readIfPresent(with: QConnectClientTypes.ExternalSourceConfiguration.read(from:))
        return value
    }
}

extension QConnectClientTypes.ExternalSourceConfiguration {

    static func write(value: QConnectClientTypes.ExternalSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: QConnectClientTypes.Configuration.write(value:to:))
        try writer["source"].write(value.source)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ExternalSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ExternalSourceConfiguration()
        value.source = try reader["source"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: QConnectClientTypes.Configuration.read(from:))
        return value
    }
}

extension QConnectClientTypes.Configuration {

    static func write(value: QConnectClientTypes.Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .connectconfiguration(connectconfiguration):
                try writer["connectConfiguration"].write(connectconfiguration, with: QConnectClientTypes.ConnectConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "connectConfiguration":
                return .connectconfiguration(try reader["connectConfiguration"].read(with: QConnectClientTypes.ConnectConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.ConnectConfiguration {

    static func write(value: QConnectClientTypes.ConnectConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceId"].write(value.instanceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ConnectConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ConnectConfiguration()
        value.instanceId = try reader["instanceId"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.MessageOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageOutput()
        value.value = try reader["value"].readIfPresent(with: QConnectClientTypes.MessageData.read(from:))
        value.messageId = try reader["messageId"].readIfPresent() ?? ""
        value.participant = try reader["participant"].readIfPresent() ?? .sdkUnknown("")
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension QConnectClientTypes.MessageData {

    static func write(value: QConnectClientTypes.MessageData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text, with: QConnectClientTypes.TextMessage.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read(with: QConnectClientTypes.TextMessage.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.TextMessage {

    static func write(value: QConnectClientTypes.TextMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.TextMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.TextMessage()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ConversationState {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ConversationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ConversationState()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.RuntimeSessionData {

    static func write(value: QConnectClientTypes.RuntimeSessionData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value, with: QConnectClientTypes.RuntimeSessionDataValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RuntimeSessionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.RuntimeSessionData()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: QConnectClientTypes.RuntimeSessionDataValue.read(from:))
        return value
    }
}

extension QConnectClientTypes.RuntimeSessionDataValue {

    static func write(value: QConnectClientTypes.RuntimeSessionDataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RuntimeSessionDataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.RecommendationData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RecommendationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.RecommendationData()
        value.recommendationId = try reader["recommendationId"].readIfPresent() ?? ""
        value.document = try reader["document"].readIfPresent(with: QConnectClientTypes.Document.read(from:))
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0
        value.relevanceLevel = try reader["relevanceLevel"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.data = try reader["data"].readIfPresent(with: QConnectClientTypes.DataSummary.read(from:))
        return value
    }
}

extension QConnectClientTypes.DataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.DataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.DataSummary()
        value.reference = try reader["reference"].readIfPresent(with: QConnectClientTypes.DataReference.read(from:))
        value.details = try reader["details"].readIfPresent(with: QConnectClientTypes.DataDetails.read(from:))
        return value
    }
}

extension QConnectClientTypes.DataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.DataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contentData":
                return .contentdata(try reader["contentData"].read(with: QConnectClientTypes.ContentDataDetails.read(from:)))
            case "generativeData":
                return .generativedata(try reader["generativeData"].read(with: QConnectClientTypes.GenerativeDataDetails.read(from:)))
            case "intentDetectedData":
                return .intentdetecteddata(try reader["intentDetectedData"].read(with: QConnectClientTypes.IntentDetectedDataDetails.read(from:)))
            case "sourceContentData":
                return .sourcecontentdata(try reader["sourceContentData"].read(with: QConnectClientTypes.SourceContentDataDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.SourceContentDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SourceContentDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SourceContentDataDetails()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.textData = try reader["textData"].readIfPresent(with: QConnectClientTypes.TextData.read(from:))
        value.rankingData = try reader["rankingData"].readIfPresent(with: QConnectClientTypes.RankingData.read(from:))
        value.citationSpan = try reader["citationSpan"].readIfPresent(with: QConnectClientTypes.CitationSpan.read(from:))
        return value
    }
}

extension QConnectClientTypes.CitationSpan {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.CitationSpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.CitationSpan()
        value.beginOffsetInclusive = try reader["beginOffsetInclusive"].readIfPresent() ?? 0
        value.endOffsetExclusive = try reader["endOffsetExclusive"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.RankingData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RankingData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.RankingData()
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0
        value.relevanceLevel = try reader["relevanceLevel"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.TextData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.TextData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.TextData()
        value.title = try reader["title"].readIfPresent(with: QConnectClientTypes.DocumentText.read(from:))
        value.excerpt = try reader["excerpt"].readIfPresent(with: QConnectClientTypes.DocumentText.read(from:))
        return value
    }
}

extension QConnectClientTypes.DocumentText {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.DocumentText {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.DocumentText()
        value.text = try reader["text"].readIfPresent()
        value.highlights = try reader["highlights"].readListIfPresent(memberReadingClosure: QConnectClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.Highlight {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.Highlight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.Highlight()
        value.beginOffsetInclusive = try reader["beginOffsetInclusive"].readIfPresent() ?? 0
        value.endOffsetExclusive = try reader["endOffsetExclusive"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.IntentDetectedDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.IntentDetectedDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.IntentDetectedDataDetails()
        value.intent = try reader["intent"].readIfPresent() ?? ""
        value.intentId = try reader["intentId"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.GenerativeDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GenerativeDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GenerativeDataDetails()
        value.completion = try reader["completion"].readIfPresent() ?? ""
        value.references = try reader["references"].readListIfPresent(memberReadingClosure: QConnectClientTypes.DataSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.rankingData = try reader["rankingData"].readIfPresent(with: QConnectClientTypes.RankingData.read(from:))
        return value
    }
}

extension QConnectClientTypes.ContentDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentDataDetails()
        value.textData = try reader["textData"].readIfPresent(with: QConnectClientTypes.TextData.read(from:))
        value.rankingData = try reader["rankingData"].readIfPresent(with: QConnectClientTypes.RankingData.read(from:))
        return value
    }
}

extension QConnectClientTypes.DataReference {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.DataReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contentReference":
                return .contentreference(try reader["contentReference"].read(with: QConnectClientTypes.ContentReference.read(from:)))
            case "generativeReference":
                return .generativereference(try reader["generativeReference"].read(with: QConnectClientTypes.GenerativeReference.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.GenerativeReference {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GenerativeReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GenerativeReference()
        value.modelId = try reader["modelId"].readIfPresent()
        value.generationId = try reader["generationId"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ContentReference {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentReference()
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.contentArn = try reader["contentArn"].readIfPresent()
        value.contentId = try reader["contentId"].readIfPresent()
        value.sourceURL = try reader["sourceURL"].readIfPresent()
        value.referenceType = try reader["referenceType"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.Document {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.Document {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.Document()
        value.contentReference = try reader["contentReference"].readIfPresent(with: QConnectClientTypes.ContentReference.read(from:))
        value.title = try reader["title"].readIfPresent(with: QConnectClientTypes.DocumentText.read(from:))
        value.excerpt = try reader["excerpt"].readIfPresent(with: QConnectClientTypes.DocumentText.read(from:))
        return value
    }
}

extension QConnectClientTypes.RecommendationTrigger {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RecommendationTrigger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.RecommendationTrigger()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent() ?? .sdkUnknown("")
        value.data = try reader["data"].readIfPresent(with: QConnectClientTypes.RecommendationTriggerData.read(from:))
        value.recommendationIds = try reader["recommendationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QConnectClientTypes.RecommendationTriggerData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.RecommendationTriggerData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "query":
                return .query(try reader["query"].read(with: QConnectClientTypes.QueryRecommendationTriggerData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.QueryRecommendationTriggerData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QueryRecommendationTriggerData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.QueryRecommendationTriggerData()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIAgentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIAgentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIAgentSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiAgentId = try reader["aiAgentId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.aiAgentArn = try reader["aiAgentArn"].readIfPresent() ?? ""
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: QConnectClientTypes.AIAgentConfiguration.read(from:))
        value.origin = try reader["origin"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AIAgentVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIAgentVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIAgentVersionSummary()
        value.aiAgentSummary = try reader["aiAgentSummary"].readIfPresent(with: QConnectClientTypes.AIAgentSummary.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIGuardrailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiGuardrailId = try reader["aiGuardrailId"].readIfPresent() ?? ""
        value.aiGuardrailArn = try reader["aiGuardrailArn"].readIfPresent() ?? ""
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AIGuardrailVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIGuardrailVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIGuardrailVersionSummary()
        value.aiGuardrailSummary = try reader["aiGuardrailSummary"].readIfPresent(with: QConnectClientTypes.AIGuardrailSummary.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AIPromptSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIPromptSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIPromptSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.aiPromptId = try reader["aiPromptId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.aiPromptArn = try reader["aiPromptArn"].readIfPresent() ?? ""
        value.modifiedTime = try reader["modifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.apiFormat = try reader["apiFormat"].readIfPresent() ?? .sdkUnknown("")
        value.visibilityStatus = try reader["visibilityStatus"].readIfPresent() ?? .sdkUnknown("")
        value.origin = try reader["origin"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AIPromptVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AIPromptVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AIPromptVersionSummary()
        value.aiPromptSummary = try reader["aiPromptSummary"].readIfPresent(with: QConnectClientTypes.AIPromptSummary.read(from:))
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.AssistantAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantAssociationSummary()
        value.assistantAssociationId = try reader["assistantAssociationId"].readIfPresent() ?? ""
        value.assistantAssociationArn = try reader["assistantAssociationArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: QConnectClientTypes.AssistantAssociationOutputData.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.AssistantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.AssistantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.AssistantSummary()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: QConnectClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: QConnectClientTypes.AssistantIntegrationConfiguration.read(from:))
        value.capabilityConfiguration = try reader["capabilityConfiguration"].readIfPresent(with: QConnectClientTypes.AssistantCapabilityConfiguration.read(from:))
        value.aiAgentConfiguration = try reader["aiAgentConfiguration"].readMapIfPresent(valueReadingClosure: QConnectClientTypes.AIAgentConfigurationData.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.ContentAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ContentAssociationSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentAssociationId = try reader["contentAssociationId"].readIfPresent() ?? ""
        value.contentAssociationArn = try reader["contentAssociationArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: QConnectClientTypes.ContentAssociationContents.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.ImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ImportJobSummary()
        value.importJobId = try reader["importJobId"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.importJobType = try reader["importJobType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalSourceConfiguration = try reader["externalSourceConfiguration"].readIfPresent(with: QConnectClientTypes.ExternalSourceConfiguration.read(from:))
        return value
    }
}

extension QConnectClientTypes.KnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.KnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.KnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.knowledgeBaseType = try reader["knowledgeBaseType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: QConnectClientTypes.SourceConfiguration.read(from:))
        value.vectorIngestionConfiguration = try reader["vectorIngestionConfiguration"].readIfPresent(with: QConnectClientTypes.VectorIngestionConfiguration.read(from:))
        value.renderingConfiguration = try reader["renderingConfiguration"].readIfPresent(with: QConnectClientTypes.RenderingConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: QConnectClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.MessageTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateSummary()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.channelSubtype = try reader["channelSubtype"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        value.activeVersionNumber = try reader["activeVersionNumber"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.MessageTemplateVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateVersionSummary()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.channelSubtype = try reader["channelSubtype"].readIfPresent() ?? .sdkUnknown("")
        value.isActive = try reader["isActive"].readIfPresent() ?? false
        value.versionNumber = try reader["versionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension QConnectClientTypes.QuickResponseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QuickResponseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.QuickResponseSummary()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.isActive = try reader["isActive"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.NotifyRecommendationsReceivedError {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.NotifyRecommendationsReceivedError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.NotifyRecommendationsReceivedError()
        value.recommendationId = try reader["recommendationId"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.ContentFeedbackData {

    static func write(value: QConnectClientTypes.ContentFeedbackData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .generativecontentfeedbackdata(generativecontentfeedbackdata):
                try writer["generativeContentFeedbackData"].write(generativecontentfeedbackdata, with: QConnectClientTypes.GenerativeContentFeedbackData.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ContentFeedbackData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "generativeContentFeedbackData":
                return .generativecontentfeedbackdata(try reader["generativeContentFeedbackData"].read(with: QConnectClientTypes.GenerativeContentFeedbackData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QConnectClientTypes.GenerativeContentFeedbackData {

    static func write(value: QConnectClientTypes.GenerativeContentFeedbackData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["relevance"].write(value.relevance)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.GenerativeContentFeedbackData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.GenerativeContentFeedbackData()
        value.relevance = try reader["relevance"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QConnectClientTypes.ResultData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.ResultData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.ResultData()
        value.resultId = try reader["resultId"].readIfPresent() ?? ""
        value.document = try reader["document"].readIfPresent(with: QConnectClientTypes.Document.read(from:))
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0
        value.data = try reader["data"].readIfPresent(with: QConnectClientTypes.DataSummary.read(from:))
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension QConnectClientTypes.MessageTemplateSearchResultData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.MessageTemplateSearchResultData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.MessageTemplateSearchResultData()
        value.messageTemplateArn = try reader["messageTemplateArn"].readIfPresent() ?? ""
        value.messageTemplateId = try reader["messageTemplateId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.channelSubtype = try reader["channelSubtype"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent() ?? ""
        value.isActive = try reader["isActive"].readIfPresent()
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: QConnectClientTypes.GroupingConfiguration.read(from:))
        value.language = try reader["language"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.QuickResponseSearchResultData {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.QuickResponseSearchResultData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.QuickResponseSearchResultData()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.contents = try reader["contents"].readIfPresent(with: QConnectClientTypes.QuickResponseContents.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.isActive = try reader["isActive"].readIfPresent() ?? false
        value.description = try reader["description"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: QConnectClientTypes.GroupingConfiguration.read(from:))
        value.shortcutKey = try reader["shortcutKey"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.language = try reader["language"].readIfPresent()
        value.attributesNotInterpolated = try reader["attributesNotInterpolated"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributesInterpolated = try reader["attributesInterpolated"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QConnectClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QConnectClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QConnectClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        return value
    }
}

extension QConnectClientTypes.AssistantAssociationInputData {

    static func write(value: QConnectClientTypes.AssistantAssociationInputData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .knowledgebaseid(knowledgebaseid):
                try writer["knowledgeBaseId"].write(knowledgebaseid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QConnectClientTypes.QuickResponseDataProvider {

    static func write(value: QConnectClientTypes.QuickResponseDataProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .content(content):
                try writer["content"].write(content)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QConnectClientTypes.QueryCondition {

    static func write(value: QConnectClientTypes.QueryCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .single(single):
                try writer["single"].write(single, with: QConnectClientTypes.QueryConditionItem.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QConnectClientTypes.QueryConditionItem {

    static func write(value: QConnectClientTypes.QueryConditionItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparator"].write(value.comparator)
        try writer["field"].write(value.field)
        try writer["value"].write(value.value)
    }
}

extension QConnectClientTypes.QueryInputData {

    static func write(value: QConnectClientTypes.QueryInputData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .intentinputdata(intentinputdata):
                try writer["intentInputData"].write(intentinputdata, with: QConnectClientTypes.IntentInputData.write(value:to:))
            case let .querytextinputdata(querytextinputdata):
                try writer["queryTextInputData"].write(querytextinputdata, with: QConnectClientTypes.QueryTextInputData.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension QConnectClientTypes.IntentInputData {

    static func write(value: QConnectClientTypes.IntentInputData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["intentId"].write(value.intentId)
    }
}

extension QConnectClientTypes.QueryTextInputData {

    static func write(value: QConnectClientTypes.QueryTextInputData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension QConnectClientTypes.SearchExpression {

    static func write(value: QConnectClientTypes.SearchExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: QConnectClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.Filter {

    static func write(value: QConnectClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["field"].write(value.field)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value)
    }
}

extension QConnectClientTypes.MessageTemplateSearchExpression {

    static func write(value: QConnectClientTypes.MessageTemplateSearchExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: QConnectClientTypes.MessageTemplateFilterField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["orderOnField"].write(value.orderOnField, with: QConnectClientTypes.MessageTemplateOrderField.write(value:to:))
        try writer["queries"].writeList(value.queries, memberWritingClosure: QConnectClientTypes.MessageTemplateQueryField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.MessageTemplateOrderField {

    static func write(value: QConnectClientTypes.MessageTemplateOrderField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["order"].write(value.order)
    }
}

extension QConnectClientTypes.MessageTemplateFilterField {

    static func write(value: QConnectClientTypes.MessageTemplateFilterField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeNoExistence"].write(value.includeNoExistence)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.MessageTemplateQueryField {

    static func write(value: QConnectClientTypes.MessageTemplateQueryField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowFuzziness"].write(value.allowFuzziness)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["priority"].write(value.priority)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.QuickResponseSearchExpression {

    static func write(value: QConnectClientTypes.QuickResponseSearchExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: QConnectClientTypes.QuickResponseFilterField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["orderOnField"].write(value.orderOnField, with: QConnectClientTypes.QuickResponseOrderField.write(value:to:))
        try writer["queries"].writeList(value.queries, memberWritingClosure: QConnectClientTypes.QuickResponseQueryField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.QuickResponseOrderField {

    static func write(value: QConnectClientTypes.QuickResponseOrderField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["order"].write(value.order)
    }
}

extension QConnectClientTypes.QuickResponseFilterField {

    static func write(value: QConnectClientTypes.QuickResponseFilterField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeNoExistence"].write(value.includeNoExistence)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.QuickResponseQueryField {

    static func write(value: QConnectClientTypes.QuickResponseQueryField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowFuzziness"].write(value.allowFuzziness)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["priority"].write(value.priority)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.MessageInput {

    static func write(value: QConnectClientTypes.MessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value, with: QConnectClientTypes.MessageData.write(value:to:))
    }
}

extension QConnectClientTypes.ConversationContext {

    static func write(value: QConnectClientTypes.ConversationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["selfServiceConversationHistory"].writeList(value.selfServiceConversationHistory, memberWritingClosure: QConnectClientTypes.SelfServiceConversationHistory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QConnectClientTypes.SelfServiceConversationHistory {

    static func write(value: QConnectClientTypes.SelfServiceConversationHistory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["botResponse"].write(value.botResponse)
        try writer["inputTranscript"].write(value.inputTranscript)
        try writer["turnNumber"].write(value.turnNumber)
    }
}

public enum QConnectClientTypes {}
