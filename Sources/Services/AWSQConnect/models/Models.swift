// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QConnectClientTypes.AppIntegrationsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIntegrationArn
        case objectFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIntegrationArn = self.appIntegrationArn {
            try encodeContainer.encode(appIntegrationArn, forKey: .appIntegrationArn)
        }
        if let objectFields = objectFields {
            var objectFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectFields)
            for nonemptystring0 in objectFields {
                try objectFieldsContainer.encode(nonemptystring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIntegrationArn)
        appIntegrationArn = appIntegrationArnDecoded
        let objectFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectFields)
        var objectFieldsDecoded0:[Swift.String]? = nil
        if let objectFieldsContainer = objectFieldsContainer {
            objectFieldsDecoded0 = [Swift.String]()
            for string0 in objectFieldsContainer {
                if let string0 = string0 {
                    objectFieldsDecoded0?.append(string0)
                }
            }
        }
        objectFields = objectFieldsDecoded0
    }
}

extension QConnectClientTypes {
    /// Configuration information for Amazon AppIntegrations to automatically ingest content.
    public struct AppIntegrationsConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.
        ///
        /// * For [SharePoint](https://learn.microsoft.com/en-us/sharepoint/dev/sp-add-ins/sharepoint-net-server-csom-jsom-and-rest-api-index), your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.
        ///
        /// * For [Amazon S3](https://aws.amazon.com/s3/), the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name. The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        /// This member is required.
        public var appIntegrationArn: Swift.String?
        /// The fields from the source that are made available to your agents in Amazon Q. Optional if ObjectConfiguration is included in the provided DataIntegration.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), you must include at least number, short_description, sys_mod_count, workflow_state, and active.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), you must include at least id, title, updated_at, and draft.
        ///
        ///
        /// Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public var objectFields: [Swift.String]?

        public init(
            appIntegrationArn: Swift.String? = nil,
            objectFields: [Swift.String]? = nil
        )
        {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }
    }

}

extension QConnectClientTypes.AssistantAssociationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = self.assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = self.assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = self.associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Information about the assistant association.
    public struct AssistantAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Amazon Q assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A union type that currently has a single argument, the knowledge base ID.
        /// This member is required.
        public var associationData: QConnectClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: QConnectClientTypes.AssistantAssociationOutputData? = nil,
            associationType: QConnectClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension QConnectClientTypes.AssistantAssociationInputData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseid = "knowledgeBaseId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseid(knowledgebaseid):
                try container.encode(knowledgebaseid, forKey: .knowledgebaseid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .knowledgebaseid)
        if let knowledgebaseid = knowledgebaseidDecoded {
            self = .knowledgebaseid(knowledgebaseid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// The data that is input into Amazon Q as a result of the assistant association.
    public enum AssistantAssociationInputData: Swift.Equatable {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        case knowledgebaseid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.AssistantAssociationOutputData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseassociation = "knowledgeBaseAssociation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseassociation(knowledgebaseassociation):
                try container.encode(knowledgebaseassociation, forKey: .knowledgebaseassociation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseassociationDecoded = try values.decodeIfPresent(QConnectClientTypes.KnowledgeBaseAssociationData.self, forKey: .knowledgebaseassociation)
        if let knowledgebaseassociation = knowledgebaseassociationDecoded {
            self = .knowledgebaseassociation(knowledgebaseassociation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// The data that is output as a result of the assistant association.
    public enum AssistantAssociationOutputData: Swift.Equatable {
        /// The knowledge base where output data is sent.
        case knowledgebaseassociation(QConnectClientTypes.KnowledgeBaseAssociationData)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.AssistantAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = self.assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = self.assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = self.associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Summary information about the assistant association.
    public struct AssistantAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Amazon Q assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The association data.
        /// This member is required.
        public var associationData: QConnectClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: QConnectClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: QConnectClientTypes.AssistantAssociationOutputData? = nil,
            associationType: QConnectClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension QConnectClientTypes.AssistantCapabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantCapabilityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QConnectClientTypes {
    /// The capability configuration for an Amazon Q assistant.
    public struct AssistantCapabilityConfiguration: Swift.Equatable {
        /// The type of Amazon Q assistant capability.
        public var type: QConnectClientTypes.AssistantCapabilityType?

        public init(
            type: QConnectClientTypes.AssistantCapabilityType? = nil
        )
        {
            self.type = type
        }
    }

}

extension QConnectClientTypes {
    public enum AssistantCapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantCapabilityType] {
            return [
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantCapabilityType(rawValue: rawValue) ?? AssistantCapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.AssistantData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case capabilityConfiguration
        case description
        case integrationConfiguration
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let capabilityConfiguration = self.capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationConfiguration = self.integrationConfiguration {
            try encodeContainer.encode(integrationConfiguration, forKey: .integrationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let integrationConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantIntegrationConfiguration.self, forKey: .integrationConfiguration)
        integrationConfiguration = integrationConfigurationDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantCapabilityConfiguration.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension QConnectClientTypes {
    /// The assistant data.
    public struct AssistantData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The configuration information for the Amazon Q assistant capability.
        public var capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration?
        /// The description.
        public var description: Swift.String?
        /// The configuration information for the Amazon Q assistant integration.
        public var integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration?
        /// The name.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. To use Amazon Q with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: QConnectClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of assistant.
        /// This member is required.
        public var type: QConnectClientTypes.AssistantType?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: QConnectClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: QConnectClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension QConnectClientTypes.AssistantIntegrationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicIntegrationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicIntegrationArn = self.topicIntegrationArn {
            try encodeContainer.encode(topicIntegrationArn, forKey: .topicIntegrationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicIntegrationArn)
        topicIntegrationArn = topicIntegrationArnDecoded
    }
}

extension QConnectClientTypes {
    /// The configuration information for the Amazon Q assistant integration.
    public struct AssistantIntegrationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        )
        {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }

}

extension QConnectClientTypes {
    public enum AssistantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantStatus(rawValue: rawValue) ?? AssistantStatus.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.AssistantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case capabilityConfiguration
        case description
        case integrationConfiguration
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let capabilityConfiguration = self.capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationConfiguration = self.integrationConfiguration {
            try encodeContainer.encode(integrationConfiguration, forKey: .integrationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let integrationConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantIntegrationConfiguration.self, forKey: .integrationConfiguration)
        integrationConfiguration = integrationConfigurationDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantCapabilityConfiguration.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension QConnectClientTypes {
    /// Summary information about the assistant.
    public struct AssistantSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The configuration information for the Amazon Q assistant capability.
        public var capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration?
        /// The description of the assistant.
        public var description: Swift.String?
        /// The configuration information for the Amazon Q assistant integration.
        public var integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration?
        /// The name of the assistant.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. To use Amazon Q with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: QConnectClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the assistant.
        /// This member is required.
        public var type: QConnectClientTypes.AssistantType?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            capabilityConfiguration: QConnectClientTypes.AssistantCapabilityConfiguration? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: QConnectClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: QConnectClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.capabilityConfiguration = capabilityConfiguration
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension QConnectClientTypes {
    public enum AssistantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantType] {
            return [
                .agent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantType(rawValue: rawValue) ?? AssistantType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationType(rawValue: rawValue) ?? AssociationType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectconfiguration = "connectConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .connectconfiguration(connectconfiguration):
                try container.encode(connectconfiguration, forKey: .connectconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let connectconfigurationDecoded = try values.decodeIfPresent(QConnectClientTypes.ConnectConfiguration.self, forKey: .connectconfiguration)
        if let connectconfiguration = connectconfigurationDecoded {
            self = .connectconfiguration(connectconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// The configuration information of the external data source.
    public enum Configuration: Swift.Equatable {
        /// The configuration information of the Amazon Connect data source.
        case connectconfiguration(QConnectClientTypes.ConnectConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QConnectClientTypes.ConnectConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension QConnectClientTypes {
    /// The configuration information of the Amazon Connect data source.
    public struct ConnectConfiguration: Swift.Equatable {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension QConnectClientTypes.ContentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case linkOutUri
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
        case url
        case urlExpiry
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let linkOutUri = self.linkOutUri {
            try encodeContainer.encode(linkOutUri, forKey: .linkOutUri)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = self.urlExpiry {
            try encodeContainer.encodeTimestamp(urlExpiry, format: .epochSeconds, forKey: .urlExpiry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let linkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkOutUri)
        linkOutUri = linkOutUriDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

extension QConnectClientTypes.ContentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentData(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), linkOutUri: \(Swift.String(describing: linkOutUri)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// Information about the content.
    public struct ContentData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The URI of the content.
        public var linkOutUri: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the content revision.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: QConnectClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?
        /// The URL of the content.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: ClientRuntime.Date?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            linkOutUri: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: QConnectClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: ClientRuntime.Date? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension QConnectClientTypes.ContentDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rankingData
        case textData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rankingData = self.rankingData {
            try encodeContainer.encode(rankingData, forKey: .rankingData)
        }
        if let textData = self.textData {
            try encodeContainer.encode(textData, forKey: .textData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.TextData.self, forKey: .textData)
        textData = textDataDecoded
        let rankingDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RankingData.self, forKey: .rankingData)
        rankingData = rankingDataDecoded
    }
}

extension QConnectClientTypes {
    /// Details about the content data.
    public struct ContentDataDetails: Swift.Equatable {
        /// Details about the content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// Details about the content text data.
        /// This member is required.
        public var textData: QConnectClientTypes.TextData?

        public init(
            rankingData: QConnectClientTypes.RankingData? = nil,
            textData: QConnectClientTypes.TextData? = nil
        )
        {
            self.rankingData = rankingData
            self.textData = textData
        }
    }

}

extension QConnectClientTypes.ContentFeedbackData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generativecontentfeedbackdata = "generativeContentFeedbackData"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .generativecontentfeedbackdata(generativecontentfeedbackdata):
                try container.encode(generativecontentfeedbackdata, forKey: .generativecontentfeedbackdata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let generativecontentfeedbackdataDecoded = try values.decodeIfPresent(QConnectClientTypes.GenerativeContentFeedbackData.self, forKey: .generativecontentfeedbackdata)
        if let generativecontentfeedbackdata = generativecontentfeedbackdataDecoded {
            self = .generativecontentfeedbackdata(generativecontentfeedbackdata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// Information about the feedback.
    public enum ContentFeedbackData: Swift.Equatable {
        /// Information about the feedback for a generative target type.
        case generativecontentfeedbackdata(QConnectClientTypes.GenerativeContentFeedbackData)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.ContentReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
    }
}

extension QConnectClientTypes {
    /// Reference information about the content.
    public struct ContentReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        public var knowledgeBaseId: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension QConnectClientTypes {
    public enum ContentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentStatus(rawValue: rawValue) ?? ContentStatus.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.ContentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Summary information about the content.
    public struct ContentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the revision of the content.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: QConnectClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: QConnectClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

extension CreateAssistantAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let association = self.association {
            try encodeContainer.encode(association, forKey: .association)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

public struct CreateAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: QConnectClientTypes.AssistantAssociationInputData?
    /// The type of association.
    /// This member is required.
    public var associationType: QConnectClientTypes.AssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assistantId: Swift.String? = nil,
        association: QConnectClientTypes.AssistantAssociationInputData? = nil,
        associationType: QConnectClientTypes.AssociationType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssistantAssociationInputBody: Swift.Equatable {
    let associationType: QConnectClientTypes.AssociationType?
    let association: QConnectClientTypes.AssistantAssociationInputData?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssistantAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantAssociationInputData.self, forKey: .association)
        association = associationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssistantAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssistantAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct CreateAssistantAssociationOutput: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: QConnectClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: QConnectClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct CreateAssistantAssociationOutputBody: Swift.Equatable {
    let assistantAssociation: QConnectClientTypes.AssistantAssociationData?
}

extension CreateAssistantAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

enum CreateAssistantAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssistantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assistants"
    }
}

public struct CreateAssistantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the assistant.
    public var description: Swift.String?
    /// The name of the assistant.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration information for the customer managed key used for encryption. The customer managed key must have a policy that allows kms:CreateGrant,  kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. To use Amazon Q with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
    public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of assistant.
    /// This member is required.
    public var type: QConnectClientTypes.AssistantType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: QConnectClientTypes.AssistantType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.type = type
    }
}

struct CreateAssistantInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let type: QConnectClientTypes.AssistantType?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
}

extension CreateAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension CreateAssistantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssistantOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct CreateAssistantOutput: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: QConnectClientTypes.AssistantData?

    public init(
        assistant: QConnectClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct CreateAssistantOutputBody: Swift.Equatable {
    let assistant: QConnectClientTypes.AssistantData?
}

extension CreateAssistantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

enum CreateAssistantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideLinkOutUri = self.overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension CreateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

public struct CreateContentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the [SearchContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_SearchContent.html) API.
    /// This member is required.
    public var name: Swift.String?
    /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
    public var overrideLinkOutUri: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The title of the content. If not set, the title is equal to the name.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.name = name
        self.overrideLinkOutUri = overrideLinkOutUri
        self.tags = tags
        self.title = title
        self.uploadId = uploadId
    }
}

struct CreateContentInputBody: Swift.Equatable {
    let name: Swift.String?
    let title: Swift.String?
    let overrideLinkOutUri: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let uploadId: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct CreateContentOutput: Swift.Equatable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct CreateContentOutputBody: Swift.Equatable {
    let content: QConnectClientTypes.ContentData?
}

extension CreateContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

enum CreateContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/knowledgeBases"
    }
}

public struct CreateKnowledgeBaseInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
    /// This member is required.
    public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
    /// The name of the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Information about how to render the content.
    public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
    /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
    public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
    /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
    public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
        name: Swift.String? = nil,
        renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
        serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
        sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseType = knowledgeBaseType
        self.name = name
        self.renderingConfiguration = renderingConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateKnowledgeBaseInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
    let sourceConfiguration: QConnectClientTypes.SourceConfiguration?
    let renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
    let serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct CreateKnowledgeBaseOutput: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct CreateKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBase: QConnectClientTypes.KnowledgeBaseData?
}

extension CreateKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum CreateKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateQuickResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case clientToken
        case content
        case contentType
        case description
        case groupingConfiguration
        case isActive
        case language
        case name
        case shortcutKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupingConfiguration = self.groupingConfiguration {
            try encodeContainer.encode(groupingConfiguration, forKey: .groupingConfiguration)
        }
        if let isActive = self.isActive {
            try encodeContainer.encode(isActive, forKey: .isActive)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortcutKey = self.shortcutKey {
            try encodeContainer.encode(shortcutKey, forKey: .shortcutKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateQuickResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

public struct CreateQuickResponseInput: Swift.Equatable {
    /// The Amazon Connect channels this quick response applies to.
    public var channels: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The content of the quick response.
    /// This member is required.
    public var content: QConnectClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for a quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for a quick response written in richtext.
    public var contentType: Swift.String?
    /// The description of the quick response.
    public var description: Swift.String?
    /// The configuration information of the user groups that the quick response is accessible to.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    /// This member is required.
    public var name: Swift.String?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        channels: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        content: QConnectClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        shortcutKey: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channels = channels
        self.clientToken = clientToken
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.shortcutKey = shortcutKey
        self.tags = tags
    }
}

struct CreateQuickResponseInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: QConnectClientTypes.QuickResponseDataProvider?
    let contentType: Swift.String?
    let groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    let description: Swift.String?
    let shortcutKey: Swift.String?
    let isActive: Swift.Bool?
    let channels: [Swift.String]?
    let language: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateQuickResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case clientToken
        case content
        case contentType
        case description
        case groupingConfiguration
        case isActive
        case language
        case name
        case shortcutKey
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseDataProvider.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let groupingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.GroupingConfiguration.self, forKey: .groupingConfiguration)
        groupingConfiguration = groupingConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let shortcutKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortcutKey)
        shortcutKey = shortcutKeyDecoded
        let isActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isActive)
        isActive = isActiveDecoded
        let channelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channels)
        var channelsDecoded0:[Swift.String]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Swift.String]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateQuickResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateQuickResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.quickResponse = output.quickResponse
        } else {
            self.quickResponse = nil
        }
    }
}

public struct CreateQuickResponseOutput: Swift.Equatable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

struct CreateQuickResponseOutputBody: Swift.Equatable {
    let quickResponse: QConnectClientTypes.QuickResponseData?
}

extension CreateQuickResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickResponse
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseData.self, forKey: .quickResponse)
        quickResponse = quickResponseDecoded
    }
}

enum CreateQuickResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions"
    }
}

public struct CreateSessionInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the session.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateSessionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateSessionOutput: Swift.Equatable {
    /// The session.
    public var session: QConnectClientTypes.SessionData?

    public init(
        session: QConnectClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct CreateSessionOutputBody: Swift.Equatable {
    let session: QConnectClientTypes.SessionData?
}

extension CreateSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

enum CreateSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.DataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentdata = "contentData"
        case generativedata = "generativeData"
        case sdkUnknown
        case sourcecontentdata = "sourceContentData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contentdata(contentdata):
                try container.encode(contentdata, forKey: .contentdata)
            case let .generativedata(generativedata):
                try container.encode(generativedata, forKey: .generativedata)
            case let .sourcecontentdata(sourcecontentdata):
                try container.encode(sourcecontentdata, forKey: .sourcecontentdata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contentdataDecoded = try values.decodeIfPresent(QConnectClientTypes.ContentDataDetails.self, forKey: .contentdata)
        if let contentdata = contentdataDecoded {
            self = .contentdata(contentdata)
            return
        }
        let generativedataDecoded = try values.decodeIfPresent(QConnectClientTypes.GenerativeDataDetails.self, forKey: .generativedata)
        if let generativedata = generativedataDecoded {
            self = .generativedata(generativedata)
            return
        }
        let sourcecontentdataDecoded = try values.decodeIfPresent(QConnectClientTypes.SourceContentDataDetails.self, forKey: .sourcecontentdata)
        if let sourcecontentdata = sourcecontentdataDecoded {
            self = .sourcecontentdata(sourcecontentdata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// Details about the data.
    public indirect enum DataDetails: Swift.Equatable {
        /// Details about the content data.
        case contentdata(QConnectClientTypes.ContentDataDetails)
        /// Details about the generative data.
        case generativedata(QConnectClientTypes.GenerativeDataDetails)
        /// Details about the content data.
        case sourcecontentdata(QConnectClientTypes.SourceContentDataDetails)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.DataReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentreference = "contentReference"
        case generativereference = "generativeReference"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contentreference(contentreference):
                try container.encode(contentreference, forKey: .contentreference)
            case let .generativereference(generativereference):
                try container.encode(generativereference, forKey: .generativereference)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contentreferenceDecoded = try values.decodeIfPresent(QConnectClientTypes.ContentReference.self, forKey: .contentreference)
        if let contentreference = contentreferenceDecoded {
            self = .contentreference(contentreference)
            return
        }
        let generativereferenceDecoded = try values.decodeIfPresent(QConnectClientTypes.GenerativeReference.self, forKey: .generativereference)
        if let generativereference = generativereferenceDecoded {
            self = .generativereference(generativereference)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// Reference data.
    public enum DataReference: Swift.Equatable {
        /// Reference information about the content.
        case contentreference(QConnectClientTypes.ContentReference)
        /// Reference information about the generative content.
        case generativereference(QConnectClientTypes.GenerativeReference)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.DataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case reference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DataReference.self, forKey: .reference)
        reference = referenceDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DataDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension QConnectClientTypes {
    /// Summary of the data.
    public struct DataSummary: Swift.Equatable {
        /// Details about the data.
        /// This member is required.
        public var details: QConnectClientTypes.DataDetails?
        /// Reference information about the content.
        /// This member is required.
        public var reference: QConnectClientTypes.DataReference?

        public init(
            details: QConnectClientTypes.DataDetails? = nil,
            reference: QConnectClientTypes.DataReference? = nil
        )
        {
            self.details = details
            self.reference = reference
        }
    }

}

extension DeleteAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let assistantAssociationId = assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

public struct DeleteAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct DeleteAssistantAssociationInputBody: Swift.Equatable {
}

extension DeleteAssistantAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssistantAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssistantAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

public struct DeleteAssistantInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct DeleteAssistantInputBody: Swift.Equatable {
}

extension DeleteAssistantInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssistantOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAssistantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct DeleteContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteContentInputBody: Swift.Equatable {
}

extension DeleteContentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let importJobId = importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

public struct DeleteImportJobInput: Swift.Equatable {
    /// The identifier of the import job to be deleted.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteImportJobInputBody: Swift.Equatable {
}

extension DeleteImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteImportJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DeleteKnowledgeBaseInput: Swift.Equatable {
    /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteKnowledgeBaseInputBody: Swift.Equatable {
}

extension DeleteKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKnowledgeBaseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteQuickResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

public struct DeleteQuickResponseInput: Swift.Equatable {
    /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response to delete.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

struct DeleteQuickResponseInputBody: Swift.Equatable {
}

extension DeleteQuickResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteQuickResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteQuickResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteQuickResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.Document: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentReference
        case excerpt
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentReference = self.contentReference {
            try encodeContainer.encode(contentReference, forKey: .contentReference)
        }
        if let excerpt = self.excerpt {
            try encodeContainer.encode(excerpt, forKey: .excerpt)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentReferenceDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentReference.self, forKey: .contentReference)
        contentReference = contentReferenceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DocumentText.self, forKey: .title)
        title = titleDecoded
        let excerptDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DocumentText.self, forKey: .excerpt)
        excerpt = excerptDecoded
    }
}

extension QConnectClientTypes {
    /// The document.
    public struct Document: Swift.Equatable {
        /// A reference to the content resource.
        /// This member is required.
        public var contentReference: QConnectClientTypes.ContentReference?
        /// The excerpt from the document.
        public var excerpt: QConnectClientTypes.DocumentText?
        /// The title of the document.
        public var title: QConnectClientTypes.DocumentText?

        public init(
            contentReference: QConnectClientTypes.ContentReference? = nil,
            excerpt: QConnectClientTypes.DocumentText? = nil,
            title: QConnectClientTypes.DocumentText? = nil
        )
        {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }
    }

}

extension QConnectClientTypes.DocumentText: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highlights
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for highlight0 in highlights {
                try highlightsContainer.encode(highlight0)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([QConnectClientTypes.Highlight?].self, forKey: .highlights)
        var highlightsDecoded0:[QConnectClientTypes.Highlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [QConnectClientTypes.Highlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension QConnectClientTypes.DocumentText: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentText(highlights: \(Swift.String(describing: highlights)), text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// The text of the document.
    public struct DocumentText: Swift.Equatable {
        /// Highlights in the document text.
        public var highlights: [QConnectClientTypes.Highlight]?
        /// Text in the document.
        public var text: Swift.String?

        public init(
            highlights: [QConnectClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension QConnectClientTypes {
    public enum ExternalSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSource] {
            return [
                .amazonConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonConnect: return "AMAZON_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalSource(rawValue: rawValue) ?? ExternalSource.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.ExternalSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ExternalSource.self, forKey: .source)
        source = sourceDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Configuration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension QConnectClientTypes {
    /// The configuration information of the external data source.
    public struct ExternalSourceConfiguration: Swift.Equatable {
        /// The configuration information of the external data source.
        /// This member is required.
        public var configuration: QConnectClientTypes.Configuration?
        /// The type of the external data source.
        /// This member is required.
        public var source: QConnectClientTypes.ExternalSource?

        public init(
            configuration: QConnectClientTypes.Configuration? = nil,
            source: QConnectClientTypes.ExternalSource? = nil
        )
        {
            self.configuration = configuration
            self.source = source
        }
    }

}

extension QConnectClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.FilterField.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QConnectClientTypes {
    /// A search filter.
    public struct Filter: Swift.Equatable {
        /// The field on which to filter.
        /// This member is required.
        public var field: QConnectClientTypes.FilterField?
        /// The operator to use for comparing the field’s value with the provided value.
        /// This member is required.
        public var `operator`: QConnectClientTypes.FilterOperator?
        /// The desired field value on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            field: QConnectClientTypes.FilterField? = nil,
            `operator`: QConnectClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QConnectClientTypes {
    public enum FilterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterField(rawValue: rawValue) ?? FilterField.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.GenerativeContentFeedbackData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relevance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relevance = self.relevance {
            try encodeContainer.encode(relevance.rawValue, forKey: .relevance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relevanceDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Relevance.self, forKey: .relevance)
        relevance = relevanceDecoded
    }
}

extension QConnectClientTypes {
    /// The feedback information for a generative target type.
    public struct GenerativeContentFeedbackData: Swift.Equatable {
        /// The relevance of the feedback.
        /// This member is required.
        public var relevance: QConnectClientTypes.Relevance?

        public init(
            relevance: QConnectClientTypes.Relevance? = nil
        )
        {
            self.relevance = relevance
        }
    }

}

extension QConnectClientTypes.GenerativeDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completion
        case rankingData
        case references
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completion = self.completion {
            try encodeContainer.encode(completion, forKey: .completion)
        }
        if let rankingData = self.rankingData {
            try encodeContainer.encode(rankingData, forKey: .rankingData)
        }
        if let references = references {
            var referencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .references)
            for datasummary0 in references {
                try referencesContainer.encode(datasummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let completionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completion)
        completion = completionDecoded
        let referencesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.DataSummary?].self, forKey: .references)
        var referencesDecoded0:[QConnectClientTypes.DataSummary]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [QConnectClientTypes.DataSummary]()
            for structure0 in referencesContainer {
                if let structure0 = structure0 {
                    referencesDecoded0?.append(structure0)
                }
            }
        }
        references = referencesDecoded0
        let rankingDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RankingData.self, forKey: .rankingData)
        rankingData = rankingDataDecoded
    }
}

extension QConnectClientTypes.GenerativeDataDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerativeDataDetails(rankingData: \(Swift.String(describing: rankingData)), references: \(Swift.String(describing: references)), completion: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// Details about generative data.
    public struct GenerativeDataDetails: Swift.Equatable {
        /// The LLM response.
        /// This member is required.
        public var completion: Swift.String?
        /// Details about the generative content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// The references used to generative the LLM response.
        /// This member is required.
        public var references: [QConnectClientTypes.DataSummary]?

        public init(
            completion: Swift.String? = nil,
            rankingData: QConnectClientTypes.RankingData? = nil,
            references: [QConnectClientTypes.DataSummary]? = nil
        )
        {
            self.completion = completion
            self.rankingData = rankingData
            self.references = references
        }
    }

}

extension QConnectClientTypes.GenerativeReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationId
        case modelId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationId = self.generationId {
            try encodeContainer.encode(generationId, forKey: .generationId)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationId)
        generationId = generationIdDecoded
    }
}

extension QConnectClientTypes {
    /// Reference information about generative content.
    public struct GenerativeReference: Swift.Equatable {
        /// The identifier of the LLM model.
        public var generationId: Swift.String?
        /// The identifier of the LLM model.
        public var modelId: Swift.String?

        public init(
            generationId: Swift.String? = nil,
            modelId: Swift.String? = nil
        )
        {
            self.generationId = generationId
            self.modelId = modelId
        }
    }

}

extension GetAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let assistantAssociationId = assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

public struct GetAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct GetAssistantAssociationInputBody: Swift.Equatable {
}

extension GetAssistantAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssistantAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct GetAssistantAssociationOutput: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: QConnectClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: QConnectClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct GetAssistantAssociationOutputBody: Swift.Equatable {
    let assistantAssociation: QConnectClientTypes.AssistantAssociationData?
}

extension GetAssistantAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

enum GetAssistantAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

public struct GetAssistantInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct GetAssistantInputBody: Swift.Equatable {
}

extension GetAssistantInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssistantOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct GetAssistantOutput: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: QConnectClientTypes.AssistantData?

    public init(
        assistant: QConnectClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct GetAssistantOutputBody: Swift.Equatable {
    let assistant: QConnectClientTypes.AssistantData?
}

extension GetAssistantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

enum GetAssistantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct GetContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentInputBody: Swift.Equatable {
}

extension GetContentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetContentOutput: Swift.Equatable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct GetContentOutputBody: Swift.Equatable {
    let content: QConnectClientTypes.ContentData?
}

extension GetContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

enum GetContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContentSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/summary"
    }
}

public struct GetContentSummaryInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentSummaryInputBody: Swift.Equatable {
}

extension GetContentSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContentSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContentSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentSummary = output.contentSummary
        } else {
            self.contentSummary = nil
        }
    }
}

public struct GetContentSummaryOutput: Swift.Equatable {
    /// The content summary.
    public var contentSummary: QConnectClientTypes.ContentSummary?

    public init(
        contentSummary: QConnectClientTypes.ContentSummary? = nil
    )
    {
        self.contentSummary = contentSummary
    }
}

struct GetContentSummaryOutputBody: Swift.Equatable {
    let contentSummary: QConnectClientTypes.ContentSummary?
}

extension GetContentSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummaryDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentSummary.self, forKey: .contentSummary)
        contentSummary = contentSummaryDecoded
    }
}

enum GetContentSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let importJobId = importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

public struct GetImportJobInput: Swift.Equatable {
    /// The identifier of the import job to retrieve.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base that the import job belongs to.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetImportJobInputBody: Swift.Equatable {
}

extension GetImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.importJob = output.importJob
        } else {
            self.importJob = nil
        }
    }
}

public struct GetImportJobOutput: Swift.Equatable {
    /// The import job.
    public var importJob: QConnectClientTypes.ImportJobData?

    public init(
        importJob: QConnectClientTypes.ImportJobData? = nil
    )
    {
        self.importJob = importJob
    }
}

struct GetImportJobOutputBody: Swift.Equatable {
    let importJob: QConnectClientTypes.ImportJobData?
}

extension GetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobData.self, forKey: .importJob)
        importJob = importJobDecoded
    }
}

enum GetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetKnowledgeBaseInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetKnowledgeBaseInputBody: Swift.Equatable {
}

extension GetKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct GetKnowledgeBaseOutput: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct GetKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBase: QConnectClientTypes.KnowledgeBaseData?
}

extension GetKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum GetKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQuickResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

public struct GetQuickResponseInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

struct GetQuickResponseInputBody: Swift.Equatable {
}

extension GetQuickResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetQuickResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQuickResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.quickResponse = output.quickResponse
        } else {
            self.quickResponse = nil
        }
    }
}

public struct GetQuickResponseOutput: Swift.Equatable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

struct GetQuickResponseOutputBody: Swift.Equatable {
    let quickResponse: QConnectClientTypes.QuickResponseData?
}

extension GetQuickResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickResponse
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseData.self, forKey: .quickResponse)
        quickResponse = quickResponseDecoded
    }
}

enum GetQuickResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if waitTimeSeconds != 0 {
                let waitTimeSecondsQueryItem = ClientRuntime.URLQueryItem(name: "waitTimeSeconds".urlPercentEncoding(), value: Swift.String(waitTimeSeconds).urlPercentEncoding())
                items.append(waitTimeSecondsQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations"
    }
}

public struct GetRecommendationsInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
    public var waitTimeSeconds: Swift.Int

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        waitTimeSeconds: Swift.Int = 0
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.sessionId = sessionId
        self.waitTimeSeconds = waitTimeSeconds
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
}

extension GetRecommendationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommendations = output.recommendations
            self.triggers = output.triggers
        } else {
            self.recommendations = nil
            self.triggers = nil
        }
    }
}

public struct GetRecommendationsOutput: Swift.Equatable {
    /// The recommendations.
    /// This member is required.
    public var recommendations: [QConnectClientTypes.RecommendationData]?
    /// The triggers corresponding to recommendations.
    public var triggers: [QConnectClientTypes.RecommendationTrigger]?

    public init(
        recommendations: [QConnectClientTypes.RecommendationData]? = nil,
        triggers: [QConnectClientTypes.RecommendationTrigger]? = nil
    )
    {
        self.recommendations = recommendations
        self.triggers = triggers
    }
}

struct GetRecommendationsOutputBody: Swift.Equatable {
    let recommendations: [QConnectClientTypes.RecommendationData]?
    let triggers: [QConnectClientTypes.RecommendationTrigger]?
}

extension GetRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendations
        case triggers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([QConnectClientTypes.RecommendationData?].self, forKey: .recommendations)
        var recommendationsDecoded0:[QConnectClientTypes.RecommendationData]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [QConnectClientTypes.RecommendationData]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([QConnectClientTypes.RecommendationTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[QConnectClientTypes.RecommendationTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [QConnectClientTypes.RecommendationTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

enum GetRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetSessionOutput: Swift.Equatable {
    /// The session.
    public var session: QConnectClientTypes.SessionData?

    public init(
        session: QConnectClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct GetSessionOutputBody: Swift.Equatable {
    let session: QConnectClientTypes.SessionData?
}

extension GetSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

enum GetSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.GroupingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = self.criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for groupingvalue0 in values {
                try valuesContainer.encode(groupingvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .criteria)
        criteria = criteriaDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QConnectClientTypes.GroupingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupingConfiguration(values: \(Swift.String(describing: values)), criteria: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// The configuration information of the grouping of Amazon Q users.
    public struct GroupingConfiguration: Swift.Equatable {
        /// The criteria used for grouping Amazon Q users. The following is the list of supported criteria values.
        ///
        /// * RoutingProfileArn: Grouping the users by their [Amazon Connect routing profile ARN](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html). User should have [SearchRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_SearchRoutingProfiles.html) and [DescribeRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribeRoutingProfile.html) permissions when setting criteria to this value.
        public var criteria: Swift.String?
        /// The list of values that define different groups of Amazon Q users.
        ///
        /// * When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of [Amazon Connect routing profiles](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html) as values of this parameter.
        public var values: [Swift.String]?

        public init(
            criteria: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.criteria = criteria
            self.values = values
        }
    }

}

extension QConnectClientTypes.Highlight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffsetInclusive
        case endOffsetExclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetInclusive != 0 {
            try encodeContainer.encode(beginOffsetInclusive, forKey: .beginOffsetInclusive)
        }
        if endOffsetExclusive != 0 {
            try encodeContainer.encode(endOffsetExclusive, forKey: .endOffsetExclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffsetInclusive) ?? 0
        beginOffsetInclusive = beginOffsetInclusiveDecoded
        let endOffsetExclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffsetExclusive) ?? 0
        endOffsetExclusive = endOffsetExclusiveDecoded
    }
}

extension QConnectClientTypes {
    /// Offset specification to describe highlighting of document excerpts for rendering search results and recommendations.
    public struct Highlight: Swift.Equatable {
        /// The offset for the start of the highlight.
        public var beginOffsetInclusive: Swift.Int
        /// The offset for the end of the highlight.
        public var endOffsetExclusive: Swift.Int

        public init(
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        )
        {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }

}

extension QConnectClientTypes.ImportJobData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case externalSourceConfiguration
        case failedRecordReport
        case importJobId
        case importJobType
        case knowledgeBaseArn
        case knowledgeBaseId
        case lastModifiedTime
        case metadata
        case status
        case uploadId
        case url
        case urlExpiry
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let externalSourceConfiguration = self.externalSourceConfiguration {
            try encodeContainer.encode(externalSourceConfiguration, forKey: .externalSourceConfiguration)
        }
        if let failedRecordReport = self.failedRecordReport {
            try encodeContainer.encode(failedRecordReport, forKey: .failedRecordReport)
        }
        if let importJobId = self.importJobId {
            try encodeContainer.encode(importJobId, forKey: .importJobId)
        }
        if let importJobType = self.importJobType {
            try encodeContainer.encode(importJobType.rawValue, forKey: .importJobType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = self.urlExpiry {
            try encodeContainer.encodeTimestamp(urlExpiry, format: .epochSeconds, forKey: .urlExpiry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importJobId)
        importJobId = importJobIdDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let importJobTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobType.self, forKey: .importJobType)
        importJobType = importJobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let failedRecordReportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedRecordReport)
        failedRecordReport = failedRecordReportDecoded
        let urlExpiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let externalSourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ExternalSourceConfiguration.self, forKey: .externalSourceConfiguration)
        externalSourceConfiguration = externalSourceConfigurationDecoded
    }
}

extension QConnectClientTypes.ImportJobData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobData(createdTime: \(Swift.String(describing: createdTime)), externalSourceConfiguration: \(Swift.String(describing: externalSourceConfiguration)), importJobId: \(Swift.String(describing: importJobId)), importJobType: \(Swift.String(describing: importJobType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), failedRecordReport: \"CONTENT_REDACTED\", url: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// Summary information about the import job.
    public struct ImportJobData: Swift.Equatable {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The configuration information of the external data source.
        public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
        /// The link to donwload the information of resource data that failed to be imported.
        public var failedRecordReport: Swift.String?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of the import job.
        /// This member is required.
        public var importJobType: QConnectClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job data was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The metadata fields of the imported Amazon Q resources.
        public var metadata: [Swift.String:Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: QConnectClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?
        /// The download link to the resource file that is uploaded to the import job.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: ClientRuntime.Date?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
            failedRecordReport: Swift.String? = nil,
            importJobId: Swift.String? = nil,
            importJobType: QConnectClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            status: QConnectClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: ClientRuntime.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension QConnectClientTypes {
    public enum ImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleted
        case deleteFailed
        case deleteInProgress
        case failed
        case startInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobStatus] {
            return [
                .complete,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .failed,
                .startInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportJobStatus(rawValue: rawValue) ?? ImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.ImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case externalSourceConfiguration
        case importJobId
        case importJobType
        case knowledgeBaseArn
        case knowledgeBaseId
        case lastModifiedTime
        case metadata
        case status
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let externalSourceConfiguration = self.externalSourceConfiguration {
            try encodeContainer.encode(externalSourceConfiguration, forKey: .externalSourceConfiguration)
        }
        if let importJobId = self.importJobId {
            try encodeContainer.encode(importJobId, forKey: .importJobId)
        }
        if let importJobType = self.importJobType {
            try encodeContainer.encode(importJobType.rawValue, forKey: .importJobType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importJobId)
        importJobId = importJobIdDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let importJobTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobType.self, forKey: .importJobType)
        importJobType = importJobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let externalSourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ExternalSourceConfiguration.self, forKey: .externalSourceConfiguration)
        externalSourceConfiguration = externalSourceConfigurationDecoded
    }
}

extension QConnectClientTypes {
    /// Summary information about the import job.
    public struct ImportJobSummary: Swift.Equatable {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The configuration information of the external source that the resource data are imported from.
        public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of import job.
        /// This member is required.
        public var importJobType: QConnectClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The metadata fields of the imported Amazon Q resources.
        public var metadata: [Swift.String:Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: QConnectClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
            importJobId: Swift.String? = nil,
            importJobType: QConnectClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            status: QConnectClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }
    }

}

extension QConnectClientTypes {
    public enum ImportJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobType] {
            return [
                .quickResponses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportJobType(rawValue: rawValue) ?? ImportJobType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.KnowledgeBaseAssociationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
    }
}

extension QConnectClientTypes {
    /// Association information about the knowledge base.
    public struct KnowledgeBaseAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        public var knowledgeBaseId: Swift.String?

        public init(
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension QConnectClientTypes.KnowledgeBaseData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case lastContentModificationTime
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let lastContentModificationTime = self.lastContentModificationTime {
            try encodeContainer.encodeTimestamp(lastContentModificationTime, format: .epochSeconds, forKey: .lastContentModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let lastContentModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastContentModificationTime)
        lastContentModificationTime = lastContentModificationTimeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Information about the knowledge base.
    public struct KnowledgeBaseData: Swift.Equatable {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public var lastContentModificationTime: ClientRuntime.Date?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: QConnectClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
            lastContentModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
            status: QConnectClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension QConnectClientTypes {
    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStatus(rawValue: rawValue) ?? KnowledgeBaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.KnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Summary information about the knowledge base.
    public struct KnowledgeBaseSummary: Swift.Equatable {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: QConnectClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt, and kms:GenerateDataKey* permissions to the IAM identity using the key to invoke Amazon Q. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html).
        public var serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public var sourceConfiguration: QConnectClientTypes.SourceConfiguration?
        /// The status of the knowledge base summary.
        /// This member is required.
        public var status: QConnectClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: QConnectClientTypes.KnowledgeBaseType? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: QConnectClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: QConnectClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: QConnectClientTypes.SourceConfiguration? = nil,
            status: QConnectClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension QConnectClientTypes {
    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case external
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .custom,
                .external,
                .quickResponses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .external: return "EXTERNAL"
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseType(rawValue: rawValue) ?? KnowledgeBaseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAssistantAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssistantAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

public struct ListAssistantAssociationsInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsInputBody: Swift.Equatable {
}

extension ListAssistantAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssistantAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociationSummaries = output.assistantAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantAssociationsOutput: Swift.Equatable {
    /// Summary information about assistant associations.
    /// This member is required.
    public var assistantAssociationSummaries: [QConnectClientTypes.AssistantAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantAssociationSummaries: [QConnectClientTypes.AssistantAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantAssociationSummaries = assistantAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsOutputBody: Swift.Equatable {
    let assistantAssociationSummaries: [QConnectClientTypes.AssistantAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListAssistantAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociationSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.AssistantAssociationSummary?].self, forKey: .assistantAssociationSummaries)
        var assistantAssociationSummariesDecoded0:[QConnectClientTypes.AssistantAssociationSummary]? = nil
        if let assistantAssociationSummariesContainer = assistantAssociationSummariesContainer {
            assistantAssociationSummariesDecoded0 = [QConnectClientTypes.AssistantAssociationSummary]()
            for structure0 in assistantAssociationSummariesContainer {
                if let structure0 = structure0 {
                    assistantAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantAssociationSummaries = assistantAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssistantAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssistantsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssistantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assistants"
    }
}

public struct ListAssistantsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantsInputBody: Swift.Equatable {
}

extension ListAssistantsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssistantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistantSummaries = output.assistantSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantsOutput: Swift.Equatable {
    /// Information about the assistants.
    /// This member is required.
    public var assistantSummaries: [QConnectClientTypes.AssistantSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantSummaries: [QConnectClientTypes.AssistantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantSummaries = assistantSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantsOutputBody: Swift.Equatable {
    let assistantSummaries: [QConnectClientTypes.AssistantSummary]?
    let nextToken: Swift.String?
}

extension ListAssistantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.AssistantSummary?].self, forKey: .assistantSummaries)
        var assistantSummariesDecoded0:[QConnectClientTypes.AssistantSummary]? = nil
        if let assistantSummariesContainer = assistantSummariesContainer {
            assistantSummariesDecoded0 = [QConnectClientTypes.AssistantSummary]()
            for structure0 in assistantSummariesContainer {
                if let structure0 = structure0 {
                    assistantSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantSummaries = assistantSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssistantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

public struct ListContentsInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContentsInputBody: Swift.Equatable {
}

extension ListContentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListContentsOutput: Swift.Equatable {
    /// Information about the content.
    /// This member is required.
    public var contentSummaries: [QConnectClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [QConnectClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct ListContentsOutputBody: Swift.Equatable {
    let contentSummaries: [QConnectClientTypes.ContentSummary]?
    let nextToken: Swift.String?
}

extension ListContentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[QConnectClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [QConnectClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListContentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

public struct ListImportJobsInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportJobsInputBody: Swift.Equatable {
}

extension ListImportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.importJobSummaries = output.importJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.importJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportJobsOutput: Swift.Equatable {
    /// Summary information about the import jobs.
    /// This member is required.
    public var importJobSummaries: [QConnectClientTypes.ImportJobSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        importJobSummaries: [QConnectClientTypes.ImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobSummaries = importJobSummaries
        self.nextToken = nextToken
    }
}

struct ListImportJobsOutputBody: Swift.Equatable {
    let importJobSummaries: [QConnectClientTypes.ImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.ImportJobSummary?].self, forKey: .importJobSummaries)
        var importJobSummariesDecoded0:[QConnectClientTypes.ImportJobSummary]? = nil
        if let importJobSummariesContainer = importJobSummariesContainer {
            importJobSummariesDecoded0 = [QConnectClientTypes.ImportJobSummary]()
            for structure0 in importJobSummariesContainer {
                if let structure0 = structure0 {
                    importJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        importJobSummaries = importJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKnowledgeBasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListKnowledgeBasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/knowledgeBases"
    }
}

public struct ListKnowledgeBasesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesInputBody: Swift.Equatable {
}

extension ListKnowledgeBasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKnowledgeBasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKnowledgeBasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseSummaries = output.knowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.knowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKnowledgeBasesOutput: Swift.Equatable {
    /// Information about the knowledge bases.
    /// This member is required.
    public var knowledgeBaseSummaries: [QConnectClientTypes.KnowledgeBaseSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [QConnectClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesOutputBody: Swift.Equatable {
    let knowledgeBaseSummaries: [QConnectClientTypes.KnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.KnowledgeBaseSummary?].self, forKey: .knowledgeBaseSummaries)
        var knowledgeBaseSummariesDecoded0:[QConnectClientTypes.KnowledgeBaseSummary]? = nil
        if let knowledgeBaseSummariesContainer = knowledgeBaseSummariesContainer {
            knowledgeBaseSummariesDecoded0 = [QConnectClientTypes.KnowledgeBaseSummary]()
            for structure0 in knowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    knowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        knowledgeBaseSummaries = knowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKnowledgeBasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQuickResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListQuickResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

public struct ListQuickResponsesInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListQuickResponsesInputBody: Swift.Equatable {
}

extension ListQuickResponsesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListQuickResponsesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQuickResponsesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quickResponseSummaries = output.quickResponseSummaries
        } else {
            self.nextToken = nil
            self.quickResponseSummaries = nil
        }
    }
}

public struct ListQuickResponsesOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the quick responses.
    /// This member is required.
    public var quickResponseSummaries: [QConnectClientTypes.QuickResponseSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quickResponseSummaries: [QConnectClientTypes.QuickResponseSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickResponseSummaries = quickResponseSummaries
    }
}

struct ListQuickResponsesOutputBody: Swift.Equatable {
    let quickResponseSummaries: [QConnectClientTypes.QuickResponseSummary]?
    let nextToken: Swift.String?
}

extension ListQuickResponsesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case quickResponseSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.QuickResponseSummary?].self, forKey: .quickResponseSummaries)
        var quickResponseSummariesDecoded0:[QConnectClientTypes.QuickResponseSummary]? = nil
        if let quickResponseSummariesContainer = quickResponseSummariesContainer {
            quickResponseSummariesDecoded0 = [QConnectClientTypes.QuickResponseSummary]()
            for structure0 in quickResponseSummariesContainer {
                if let structure0 = structure0 {
                    quickResponseSummariesDecoded0?.append(structure0)
                }
            }
        }
        quickResponseSummaries = quickResponseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQuickResponsesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.NotifyRecommendationsReceivedError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case recommendationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QConnectClientTypes {
    /// An error occurred when creating a recommendation.
    public struct NotifyRecommendationsReceivedError: Swift.Equatable {
        /// A recommendation is causing an error.
        public var message: Swift.String?
        /// The identifier of the recommendation that is in error.
        public var recommendationId: Swift.String?

        public init(
            message: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.message = message
            self.recommendationId = recommendationId
        }
    }

}

extension NotifyRecommendationsReceivedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationid0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationid0)
            }
        }
    }
}

extension NotifyRecommendationsReceivedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations/notify"
    }
}

public struct NotifyRecommendationsReceivedInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifiers of the recommendations.
    /// This member is required.
    public var recommendationIds: [Swift.String]?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.recommendationIds = recommendationIds
        self.sessionId = sessionId
    }
}

struct NotifyRecommendationsReceivedInputBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
}

extension NotifyRecommendationsReceivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension NotifyRecommendationsReceivedOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotifyRecommendationsReceivedOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.recommendationIds = output.recommendationIds
        } else {
            self.errors = nil
            self.recommendationIds = nil
        }
    }
}

public struct NotifyRecommendationsReceivedOutput: Swift.Equatable {
    /// The identifiers of recommendations that are causing errors.
    public var errors: [QConnectClientTypes.NotifyRecommendationsReceivedError]?
    /// The identifiers of the recommendations.
    public var recommendationIds: [Swift.String]?

    public init(
        errors: [QConnectClientTypes.NotifyRecommendationsReceivedError]? = nil,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.recommendationIds = recommendationIds
    }
}

struct NotifyRecommendationsReceivedOutputBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
    let errors: [QConnectClientTypes.NotifyRecommendationsReceivedError]?
}

extension NotifyRecommendationsReceivedOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case recommendationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([QConnectClientTypes.NotifyRecommendationsReceivedError?].self, forKey: .errors)
        var errorsDecoded0:[QConnectClientTypes.NotifyRecommendationsReceivedError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QConnectClientTypes.NotifyRecommendationsReceivedError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum NotifyRecommendationsReceivedOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension PreconditionFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided revisionId does not match, indicating the content has been modified since it was last read.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QConnectClientTypes {
    public enum Priority: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Priority] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Priority(rawValue: rawValue) ?? Priority.sdkUnknown(rawValue)
        }
    }
}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentFeedback
        case targetId
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentFeedback = self.contentFeedback {
            try encodeContainer.encode(contentFeedback, forKey: .contentFeedback)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/feedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// Information about the feedback provided.
    /// This member is required.
    public var contentFeedback: QConnectClientTypes.ContentFeedbackData?
    /// The identifier of the feedback target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The type of the feedback target.
    /// This member is required.
    public var targetType: QConnectClientTypes.TargetType?

    public init(
        assistantId: Swift.String? = nil,
        contentFeedback: QConnectClientTypes.ContentFeedbackData? = nil,
        targetId: Swift.String? = nil,
        targetType: QConnectClientTypes.TargetType? = nil
    )
    {
        self.assistantId = assistantId
        self.contentFeedback = contentFeedback
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let targetId: Swift.String?
    let targetType: QConnectClientTypes.TargetType?
    let contentFeedback: QConnectClientTypes.ContentFeedbackData?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentFeedback
        case targetId
        case targetType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let contentFeedbackDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentFeedbackData.self, forKey: .contentFeedback)
        contentFeedback = contentFeedbackDecoded
    }
}

extension PutFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFeedbackOutputBody = try responseDecoder.decode(responseBody: data)
            self.assistantArn = output.assistantArn
            self.assistantId = output.assistantId
            self.contentFeedback = output.contentFeedback
            self.targetId = output.targetId
            self.targetType = output.targetType
        } else {
            self.assistantArn = nil
            self.assistantId = nil
            self.contentFeedback = nil
            self.targetId = nil
            self.targetType = nil
        }
    }
}

public struct PutFeedbackOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
    /// This member is required.
    public var assistantArn: Swift.String?
    /// The identifier of the Amazon Q assistant.
    /// This member is required.
    public var assistantId: Swift.String?
    /// Information about the feedback provided.
    /// This member is required.
    public var contentFeedback: QConnectClientTypes.ContentFeedbackData?
    /// The identifier of the feedback target.
    /// This member is required.
    public var targetId: Swift.String?
    /// The type of the feedback target.
    /// This member is required.
    public var targetType: QConnectClientTypes.TargetType?

    public init(
        assistantArn: Swift.String? = nil,
        assistantId: Swift.String? = nil,
        contentFeedback: QConnectClientTypes.ContentFeedbackData? = nil,
        targetId: Swift.String? = nil,
        targetType: QConnectClientTypes.TargetType? = nil
    )
    {
        self.assistantArn = assistantArn
        self.assistantId = assistantId
        self.contentFeedback = contentFeedback
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct PutFeedbackOutputBody: Swift.Equatable {
    let assistantId: Swift.String?
    let assistantArn: Swift.String?
    let targetId: Swift.String?
    let targetType: QConnectClientTypes.TargetType?
    let contentFeedback: QConnectClientTypes.ContentFeedbackData?
}

extension PutFeedbackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case contentFeedback
        case targetId
        case targetType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let contentFeedbackDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentFeedbackData.self, forKey: .contentFeedback)
        contentFeedback = contentFeedbackDecoded
    }
}

enum PutFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QueryAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), queryCondition: \(Swift.String(describing: queryCondition)), sessionId: \(Swift.String(describing: sessionId)), queryText: \"CONTENT_REDACTED\")"}
}

extension QueryAssistantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryCondition
        case queryText
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryCondition = queryCondition {
            var queryConditionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryCondition)
            for querycondition0 in queryCondition {
                try queryConditionContainer.encode(querycondition0)
            }
        }
        if let queryText = self.queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension QueryAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/query"
    }
}

public struct QueryAssistantInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Information about how to query content.
    public var queryCondition: [QConnectClientTypes.QueryCondition]?
    /// The text to search for.
    /// This member is required.
    public var queryText: Swift.String?
    /// The identifier of the Amazon Q session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryCondition: [QConnectClientTypes.QueryCondition]? = nil,
        queryText: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryCondition = queryCondition
        self.queryText = queryText
        self.sessionId = sessionId
    }
}

struct QueryAssistantInputBody: Swift.Equatable {
    let queryText: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let sessionId: Swift.String?
    let queryCondition: [QConnectClientTypes.QueryCondition]?
}

extension QueryAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryCondition
        case queryText
        case sessionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let queryConditionContainer = try containerValues.decodeIfPresent([QConnectClientTypes.QueryCondition?].self, forKey: .queryCondition)
        var queryConditionDecoded0:[QConnectClientTypes.QueryCondition]? = nil
        if let queryConditionContainer = queryConditionContainer {
            queryConditionDecoded0 = [QConnectClientTypes.QueryCondition]()
            for union0 in queryConditionContainer {
                if let union0 = union0 {
                    queryConditionDecoded0?.append(union0)
                }
            }
        }
        queryCondition = queryConditionDecoded0
    }
}

extension QueryAssistantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryAssistantOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct QueryAssistantOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the query.
    /// This member is required.
    public var results: [QConnectClientTypes.ResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [QConnectClientTypes.ResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct QueryAssistantOutputBody: Swift.Equatable {
    let results: [QConnectClientTypes.ResultData]?
    let nextToken: Swift.String?
}

extension QueryAssistantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([QConnectClientTypes.ResultData?].self, forKey: .results)
        var resultsDecoded0:[QConnectClientTypes.ResultData]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [QConnectClientTypes.ResultData]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum QueryAssistantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.QueryCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case single
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .single(single):
                try container.encode(single, forKey: .single)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let singleDecoded = try values.decodeIfPresent(QConnectClientTypes.QueryConditionItem.self, forKey: .single)
        if let single = singleDecoded {
            self = .single(single)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// Information about how to query content.
    public enum QueryCondition: Swift.Equatable {
        /// The condition for the query.
        case single(QConnectClientTypes.QueryConditionItem)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes {
    public enum QueryConditionComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryConditionComparisonOperator] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryConditionComparisonOperator(rawValue: rawValue) ?? QueryConditionComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum QueryConditionFieldName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resultType
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryConditionFieldName] {
            return [
                .resultType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resultType: return "RESULT_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryConditionFieldName(rawValue: rawValue) ?? QueryConditionFieldName.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.QueryConditionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparator
        case field
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = self.comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QueryConditionFieldName.self, forKey: .field)
        field = fieldDecoded
        let comparatorDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QueryConditionComparisonOperator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QConnectClientTypes {
    /// The condition for the query.
    public struct QueryConditionItem: Swift.Equatable {
        /// The comparison operator for query condition to query on.
        /// This member is required.
        public var comparator: QConnectClientTypes.QueryConditionComparisonOperator?
        /// The name of the field for query condition to query on.
        /// This member is required.
        public var field: QConnectClientTypes.QueryConditionFieldName?
        /// The value for the query condition to query on.
        /// This member is required.
        public var value: Swift.String?

        public init(
            comparator: QConnectClientTypes.QueryConditionComparisonOperator? = nil,
            field: QConnectClientTypes.QueryConditionFieldName? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparator = comparator
            self.field = field
            self.value = value
        }
    }

}

extension QConnectClientTypes.QueryRecommendationTriggerData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension QConnectClientTypes.QueryRecommendationTriggerData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryRecommendationTriggerData(text: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// Data associated with the QUERY RecommendationTriggerType.
    public struct QueryRecommendationTriggerData: Swift.Equatable {
        /// The text associated with the recommendation trigger.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension QConnectClientTypes {
    public enum QueryResultType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generativeAnswer
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryResultType] {
            return [
                .generativeAnswer,
                .knowledgeContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generativeAnswer: return "GENERATIVE_ANSWER"
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryResultType(rawValue: rawValue) ?? QueryResultType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.QuickResponseContentProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .content(content):
                try container.encode(content, forKey: .content)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .content)
        if let content = contentDecoded {
            self = .content(content)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// The container quick response content.
    public enum QuickResponseContentProvider: Swift.Equatable {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.QuickResponseContents: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markdown
        case plainText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let markdown = self.markdown {
            try encodeContainer.encode(markdown, forKey: .markdown)
        }
        if let plainText = self.plainText {
            try encodeContainer.encode(plainText, forKey: .plainText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseContentProvider.self, forKey: .plainText)
        plainText = plainTextDecoded
        let markdownDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseContentProvider.self, forKey: .markdown)
        markdown = markdownDecoded
    }
}

extension QConnectClientTypes {
    /// The content of the quick response stored in different media types.
    public struct QuickResponseContents: Swift.Equatable {
        /// The container quick response content.
        public var markdown: QConnectClientTypes.QuickResponseContentProvider?
        /// The container quick response content.
        public var plainText: QConnectClientTypes.QuickResponseContentProvider?

        public init(
            markdown: QConnectClientTypes.QuickResponseContentProvider? = nil,
            plainText: QConnectClientTypes.QuickResponseContentProvider? = nil
        )
        {
            self.markdown = markdown
            self.plainText = plainText
        }
    }

}

extension QConnectClientTypes.QuickResponseData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case contentType
        case contents
        case createdTime
        case description
        case groupingConfiguration
        case isActive
        case knowledgeBaseArn
        case knowledgeBaseId
        case language
        case lastModifiedBy
        case lastModifiedTime
        case name
        case quickResponseArn
        case quickResponseId
        case shortcutKey
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let contents = self.contents {
            try encodeContainer.encode(contents, forKey: .contents)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupingConfiguration = self.groupingConfiguration {
            try encodeContainer.encode(groupingConfiguration, forKey: .groupingConfiguration)
        }
        if let isActive = self.isActive {
            try encodeContainer.encode(isActive, forKey: .isActive)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickResponseArn = self.quickResponseArn {
            try encodeContainer.encode(quickResponseArn, forKey: .quickResponseArn)
        }
        if let quickResponseId = self.quickResponseId {
            try encodeContainer.encode(quickResponseId, forKey: .quickResponseId)
        }
        if let shortcutKey = self.shortcutKey {
            try encodeContainer.encode(shortcutKey, forKey: .shortcutKey)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseArn)
        quickResponseArn = quickResponseArnDecoded
        let quickResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseId)
        quickResponseId = quickResponseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let contentsDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseContents.self, forKey: .contents)
        contents = contentsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let groupingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.GroupingConfiguration.self, forKey: .groupingConfiguration)
        groupingConfiguration = groupingConfigurationDecoded
        let shortcutKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortcutKey)
        shortcutKey = shortcutKeyDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let isActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isActive)
        isActive = isActiveDecoded
        let channelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channels)
        var channelsDecoded0:[Swift.String]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Swift.String]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// Information about the quick response.
    public struct QuickResponseData: Swift.Equatable {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        public var contents: QConnectClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written.
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response data was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The status of the quick response data.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: QConnectClientTypes.QuickResponseContents? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }

}

extension QConnectClientTypes.QuickResponseDataProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .content(content):
                try container.encode(content, forKey: .content)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .content)
        if let content = contentDecoded {
            self = .content(content)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// The container of quick response data.
    public enum QuickResponseDataProvider: Swift.Equatable {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.QuickResponseFilterField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeNoExistence
        case name
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeNoExistence = self.includeNoExistence {
            try encodeContainer.encode(includeNoExistence, forKey: .includeNoExistence)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for quickresponsefiltervalue0 in values {
                try valuesContainer.encode(quickresponsefiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let includeNoExistenceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNoExistence)
        includeNoExistence = includeNoExistenceDecoded
    }
}

extension QConnectClientTypes {
    /// The quick response fields to filter the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseFilterField: Swift.Equatable {
        /// Whether to treat null value as a match for the attribute field.
        public var includeNoExistence: Swift.Bool?
        /// The name of the attribute field to filter the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for filtering.
        /// This member is required.
        public var `operator`: QConnectClientTypes.QuickResponseFilterOperator?
        /// The values of attribute field to filter the quick response by.
        public var values: [Swift.String]?

        public init(
            includeNoExistence: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.QuickResponseFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension QConnectClientTypes {
    public enum QuickResponseFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseFilterOperator] {
            return [
                .equals,
                .prefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuickResponseFilterOperator(rawValue: rawValue) ?? QuickResponseFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.QuickResponseOrderField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let orderDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension QConnectClientTypes {
    /// The quick response fields to order the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseOrderField: Swift.Equatable {
        /// The name of the attribute to order the quick response query results by.
        /// This member is required.
        public var name: Swift.String?
        /// The order at which the quick responses are sorted by.
        public var order: QConnectClientTypes.Order?

        public init(
            name: Swift.String? = nil,
            order: QConnectClientTypes.Order? = nil
        )
        {
            self.name = name
            self.order = order
        }
    }

}

extension QConnectClientTypes.QuickResponseQueryField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowFuzziness
        case name
        case `operator` = "operator"
        case priority
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowFuzziness = self.allowFuzziness {
            try encodeContainer.encode(allowFuzziness, forKey: .allowFuzziness)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority.rawValue, forKey: .priority)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for quickresponsequeryvalue0 in values {
                try valuesContainer.encode(quickresponsequeryvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseQueryOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let allowFuzzinessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowFuzziness)
        allowFuzziness = allowFuzzinessDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Priority.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension QConnectClientTypes {
    /// The quick response fields to query quick responses by. The following is the list of supported field names.
    ///
    /// * content
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    public struct QuickResponseQueryField: Swift.Equatable {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public var allowFuzziness: Swift.Bool?
        /// The name of the attribute to query the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for matching attribute field values in the query.
        /// This member is required.
        public var `operator`: QConnectClientTypes.QuickResponseQueryOperator?
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public var priority: QConnectClientTypes.Priority?
        /// The values of the attribute to query the quick responses by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            allowFuzziness: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: QConnectClientTypes.QuickResponseQueryOperator? = nil,
            priority: QConnectClientTypes.Priority? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }
    }

}

extension QConnectClientTypes {
    public enum QuickResponseQueryOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case containsAndPrefix
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseQueryOperator] {
            return [
                .contains,
                .containsAndPrefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .containsAndPrefix: return "CONTAINS_AND_PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuickResponseQueryOperator(rawValue: rawValue) ?? QuickResponseQueryOperator.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.QuickResponseSearchExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case orderOnField
        case queries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for quickresponsefilterfield0 in filters {
                try filtersContainer.encode(quickresponsefilterfield0)
            }
        }
        if let orderOnField = self.orderOnField {
            try encodeContainer.encode(orderOnField, forKey: .orderOnField)
        }
        if let queries = queries {
            var queriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queries)
            for quickresponsequeryfield0 in queries {
                try queriesContainer.encode(quickresponsequeryfield0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queriesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.QuickResponseQueryField?].self, forKey: .queries)
        var queriesDecoded0:[QConnectClientTypes.QuickResponseQueryField]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [QConnectClientTypes.QuickResponseQueryField]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([QConnectClientTypes.QuickResponseFilterField?].self, forKey: .filters)
        var filtersDecoded0:[QConnectClientTypes.QuickResponseFilterField]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QConnectClientTypes.QuickResponseFilterField]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let orderOnFieldDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseOrderField.self, forKey: .orderOnField)
        orderOnField = orderOnFieldDecoded
    }
}

extension QConnectClientTypes {
    /// Information about the import job.
    public struct QuickResponseSearchExpression: Swift.Equatable {
        /// The configuration of filtering rules applied to quick response query results.
        public var filters: [QConnectClientTypes.QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public var orderOnField: QConnectClientTypes.QuickResponseOrderField?
        /// The quick response query expressions.
        public var queries: [QConnectClientTypes.QuickResponseQueryField]?

        public init(
            filters: [QConnectClientTypes.QuickResponseFilterField]? = nil,
            orderOnField: QConnectClientTypes.QuickResponseOrderField? = nil,
            queries: [QConnectClientTypes.QuickResponseQueryField]? = nil
        )
        {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }
    }

}

extension QConnectClientTypes.QuickResponseSearchResultData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesInterpolated
        case attributesNotInterpolated
        case channels
        case contentType
        case contents
        case createdTime
        case description
        case groupingConfiguration
        case isActive
        case knowledgeBaseArn
        case knowledgeBaseId
        case language
        case lastModifiedBy
        case lastModifiedTime
        case name
        case quickResponseArn
        case quickResponseId
        case shortcutKey
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesInterpolated = attributesInterpolated {
            var attributesInterpolatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesInterpolated)
            for contactattributekey0 in attributesInterpolated {
                try attributesInterpolatedContainer.encode(contactattributekey0)
            }
        }
        if let attributesNotInterpolated = attributesNotInterpolated {
            var attributesNotInterpolatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesNotInterpolated)
            for contactattributekey0 in attributesNotInterpolated {
                try attributesNotInterpolatedContainer.encode(contactattributekey0)
            }
        }
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let contents = self.contents {
            try encodeContainer.encode(contents, forKey: .contents)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupingConfiguration = self.groupingConfiguration {
            try encodeContainer.encode(groupingConfiguration, forKey: .groupingConfiguration)
        }
        if let isActive = self.isActive {
            try encodeContainer.encode(isActive, forKey: .isActive)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickResponseArn = self.quickResponseArn {
            try encodeContainer.encode(quickResponseArn, forKey: .quickResponseArn)
        }
        if let quickResponseId = self.quickResponseId {
            try encodeContainer.encode(quickResponseId, forKey: .quickResponseId)
        }
        if let shortcutKey = self.shortcutKey {
            try encodeContainer.encode(shortcutKey, forKey: .shortcutKey)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseArn)
        quickResponseArn = quickResponseArnDecoded
        let quickResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseId)
        quickResponseId = quickResponseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseStatus.self, forKey: .status)
        status = statusDecoded
        let contentsDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseContents.self, forKey: .contents)
        contents = contentsDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let isActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isActive)
        isActive = isActiveDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let groupingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.GroupingConfiguration.self, forKey: .groupingConfiguration)
        groupingConfiguration = groupingConfigurationDecoded
        let shortcutKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortcutKey)
        shortcutKey = shortcutKeyDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let channelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channels)
        var channelsDecoded0:[Swift.String]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Swift.String]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let attributesNotInterpolatedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributesNotInterpolated)
        var attributesNotInterpolatedDecoded0:[Swift.String]? = nil
        if let attributesNotInterpolatedContainer = attributesNotInterpolatedContainer {
            attributesNotInterpolatedDecoded0 = [Swift.String]()
            for string0 in attributesNotInterpolatedContainer {
                if let string0 = string0 {
                    attributesNotInterpolatedDecoded0?.append(string0)
                }
            }
        }
        attributesNotInterpolated = attributesNotInterpolatedDecoded0
        let attributesInterpolatedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributesInterpolated)
        var attributesInterpolatedDecoded0:[Swift.String]? = nil
        if let attributesInterpolatedContainer = attributesInterpolatedContainer {
            attributesInterpolatedDecoded0 = [Swift.String]()
            for string0 in attributesInterpolatedContainer {
                if let string0 = string0 {
                    attributesInterpolatedDecoded0?.append(string0)
                }
            }
        }
        attributesInterpolated = attributesInterpolatedDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes.QuickResponseSearchResultData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseSearchResultData(channels: \(Swift.String(describing: channels)), contentType: \(Swift.String(describing: contentType)), contents: \(Swift.String(describing: contents)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), shortcutKey: \(Swift.String(describing: shortcutKey)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), attributesInterpolated: \"CONTENT_REDACTED\", attributesNotInterpolated: \"CONTENT_REDACTED\")"}
}

extension QConnectClientTypes {
    /// The result of quick response search.
    public struct QuickResponseSearchResultData: Swift.Equatable {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public var attributesInterpolated: [Swift.String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public var attributesNotInterpolated: [Swift.String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        /// This member is required.
        public var contents: QConnectClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        /// This member is required.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written.
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response search result data was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            attributesInterpolated: [Swift.String]? = nil,
            attributesNotInterpolated: [Swift.String]? = nil,
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: QConnectClientTypes.QuickResponseContents? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }

}

extension QConnectClientTypes {
    public enum QuickResponseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseStatus] {
            return [
                .created,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuickResponseStatus(rawValue: rawValue) ?? QuickResponseStatus.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.QuickResponseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case contentType
        case createdTime
        case description
        case isActive
        case knowledgeBaseArn
        case knowledgeBaseId
        case lastModifiedBy
        case lastModifiedTime
        case name
        case quickResponseArn
        case quickResponseId
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isActive = self.isActive {
            try encodeContainer.encode(isActive, forKey: .isActive)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quickResponseArn = self.quickResponseArn {
            try encodeContainer.encode(quickResponseArn, forKey: .quickResponseArn)
        }
        if let quickResponseId = self.quickResponseId {
            try encodeContainer.encode(quickResponseId, forKey: .quickResponseId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseArn)
        quickResponseArn = quickResponseArnDecoded
        let quickResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quickResponseId)
        quickResponseId = quickResponseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let isActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isActive)
        isActive = isActiveDecoded
        let channelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channels)
        var channelsDecoded0:[Swift.String]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Swift.String]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QConnectClientTypes {
    /// The summary information about the quick response.
    public struct QuickResponseSummary: Swift.Equatable {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response summary was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: QConnectClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            status: QConnectClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }
    }

}

extension QConnectClientTypes.RankingData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relevanceLevel
        case relevanceScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relevanceLevel = self.relevanceLevel {
            try encodeContainer.encode(relevanceLevel.rawValue, forKey: .relevanceLevel)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relevanceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevanceScore) ?? 0.0
        relevanceScore = relevanceScoreDecoded
        let relevanceLevelDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RelevanceLevel.self, forKey: .relevanceLevel)
        relevanceLevel = relevanceLevelDecoded
    }
}

extension QConnectClientTypes {
    /// Details about the source content ranking data.
    public struct RankingData: Swift.Equatable {
        /// The relevance score of the content.
        public var relevanceLevel: QConnectClientTypes.RelevanceLevel?
        /// The relevance level of the recommendation.
        public var relevanceScore: Swift.Double

        public init(
            relevanceLevel: QConnectClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0
        )
        {
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
        }
    }

}

extension QConnectClientTypes.RecommendationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case document
        case recommendationId
        case relevanceLevel
        case relevanceScore
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let relevanceLevel = self.relevanceLevel {
            try encodeContainer.encode(relevanceLevel.rawValue, forKey: .relevanceLevel)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevanceScore) ?? 0.0
        relevanceScore = relevanceScoreDecoded
        let relevanceLevelDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RelevanceLevel.self, forKey: .relevanceLevel)
        relevanceLevel = relevanceLevelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DataSummary.self, forKey: .data)
        data = dataDecoded
    }
}

extension QConnectClientTypes {
    /// Information about the recommendation.
    public struct RecommendationData: Swift.Equatable {
        /// Summary of the recommended content.
        public var data: QConnectClientTypes.DataSummary?
        /// The recommended document.
        public var document: QConnectClientTypes.Document?
        /// The identifier of the recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The relevance level of the recommendation.
        public var relevanceLevel: QConnectClientTypes.RelevanceLevel?
        /// The relevance score of the recommendation.
        public var relevanceScore: Swift.Double
        /// The type of recommendation.
        public var type: QConnectClientTypes.RecommendationType?

        public init(
            data: QConnectClientTypes.DataSummary? = nil,
            document: QConnectClientTypes.Document? = nil,
            recommendationId: Swift.String? = nil,
            relevanceLevel: QConnectClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0,
            type: QConnectClientTypes.RecommendationType? = nil
        )
        {
            self.data = data
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }
    }

}

extension QConnectClientTypes {
    public enum RecommendationSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case issueDetection
        case other
        case ruleEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSourceType] {
            return [
                .issueDetection,
                .other,
                .ruleEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .issueDetection: return "ISSUE_DETECTION"
            case .other: return "OTHER"
            case .ruleEvaluation: return "RULE_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationSourceType(rawValue: rawValue) ?? RecommendationSourceType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.RecommendationTrigger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case id
        case recommendationIds
        case source
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationid0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationid0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RecommendationTriggerType.self, forKey: .type)
        type = typeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RecommendationSourceType.self, forKey: .source)
        source = sourceDecoded
        let dataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RecommendationTriggerData.self, forKey: .data)
        data = dataDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension QConnectClientTypes {
    /// A recommendation trigger provides context on the event that produced the referenced recommendations. Recommendations are only referenced in recommendationIds by a single RecommendationTrigger.
    public struct RecommendationTrigger: Swift.Equatable {
        /// A union type containing information related to the trigger.
        /// This member is required.
        public var data: QConnectClientTypes.RecommendationTriggerData?
        /// The identifier of the recommendation trigger.
        /// This member is required.
        public var id: Swift.String?
        /// The identifiers of the recommendations.
        /// This member is required.
        public var recommendationIds: [Swift.String]?
        /// The source of the recommendation trigger.
        ///
        /// * ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.
        ///
        /// * RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        /// This member is required.
        public var source: QConnectClientTypes.RecommendationSourceType?
        /// The type of recommendation trigger.
        /// This member is required.
        public var type: QConnectClientTypes.RecommendationTriggerType?

        public init(
            data: QConnectClientTypes.RecommendationTriggerData? = nil,
            id: Swift.String? = nil,
            recommendationIds: [Swift.String]? = nil,
            source: QConnectClientTypes.RecommendationSourceType? = nil,
            type: QConnectClientTypes.RecommendationTriggerType? = nil
        )
        {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }
    }

}

extension QConnectClientTypes.RecommendationTriggerData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case query
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .query(query):
                try container.encode(query, forKey: .query)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try values.decodeIfPresent(QConnectClientTypes.QueryRecommendationTriggerData.self, forKey: .query)
        if let query = queryDecoded {
            self = .query(query)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// A union type containing information related to the trigger.
    public enum RecommendationTriggerData: Swift.Equatable {
        /// Data associated with the QUERY RecommendationTriggerType.
        case query(QConnectClientTypes.QueryRecommendationTriggerData)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes {
    public enum RecommendationTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generative
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTriggerType] {
            return [
                .generative,
                .query,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generative: return "GENERATIVE"
            case .query: return "QUERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTriggerType(rawValue: rawValue) ?? RecommendationTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generativeAnswer
        case generativeResponse
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .generativeAnswer,
                .generativeResponse,
                .knowledgeContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generativeAnswer: return "GENERATIVE_ANSWER"
            case .generativeResponse: return "GENERATIVE_RESPONSE"
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationType(rawValue: rawValue) ?? RecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum Relevance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case helpful
        case notHelpful
        case sdkUnknown(Swift.String)

        public static var allCases: [Relevance] {
            return [
                .helpful,
                .notHelpful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .helpful: return "HELPFUL"
            case .notHelpful: return "NOT_HELPFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Relevance(rawValue: rawValue) ?? Relevance.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes {
    public enum RelevanceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceLevel] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelevanceLevel(rawValue: rawValue) ?? RelevanceLevel.sdkUnknown(rawValue)
        }
    }
}

extension RemoveKnowledgeBaseTemplateUriInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

public struct RemoveKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct RemoveKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
}

extension RemoveKnowledgeBaseTemplateUriInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveKnowledgeBaseTemplateUriOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveKnowledgeBaseTemplateUriOutput: Swift.Equatable {

    public init() { }
}

enum RemoveKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.RenderingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = self.templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension QConnectClientTypes {
    /// Information about how to render the content.
    public struct RenderingConfiguration: Swift.Equatable {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:
        ///
        /// * Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted
        ///
        /// * ServiceNow: number, short_description, sys_mod_count, workflow_state, or active
        ///
        /// * Zendesk: id, title, updated_at, or draft
        ///
        ///
        /// The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_GetContent.html).
        public var templateUri: Swift.String?

        public init(
            templateUri: Swift.String? = nil
        )
        {
            self.templateUri = templateUri
        }
    }

}

extension RequestTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension QConnectClientTypes.ResultData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case document
        case relevanceScore
        case resultId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
        if let resultId = self.resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevanceScore) ?? 0.0
        relevanceScore = relevanceScoreDecoded
        let dataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DataSummary.self, forKey: .data)
        data = dataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QueryResultType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QConnectClientTypes {
    /// Information about the result.
    public struct ResultData: Swift.Equatable {
        /// Summary of the recommended content.
        public var data: QConnectClientTypes.DataSummary?
        /// The document.
        public var document: QConnectClientTypes.Document?
        /// The relevance score of the results.
        public var relevanceScore: Swift.Double
        /// The identifier of the result data.
        /// This member is required.
        public var resultId: Swift.String?
        /// The type of the query result.
        public var type: QConnectClientTypes.QueryResultType?

        public init(
            data: QConnectClientTypes.DataSummary? = nil,
            document: QConnectClientTypes.Document? = nil,
            relevanceScore: Swift.Double = 0.0,
            resultId: Swift.String? = nil,
            type: QConnectClientTypes.QueryResultType? = nil
        )
        {
            self.data = data
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
            self.type = type
        }
    }

}

extension SearchContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = self.searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

extension SearchContentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search"
    }
}

public struct SearchContentInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.SearchExpression?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.SearchExpression? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchContentInputBody: Swift.Equatable {
    let searchExpression: QConnectClientTypes.SearchExpression?
}

extension SearchContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct SearchContentOutput: Swift.Equatable {
    /// Summary information about the content.
    /// This member is required.
    public var contentSummaries: [QConnectClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [QConnectClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct SearchContentOutputBody: Swift.Equatable {
    let contentSummaries: [QConnectClientTypes.ContentSummary]?
    let nextToken: Swift.String?
}

extension SearchContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[QConnectClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [QConnectClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.SearchExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QConnectClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[QConnectClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QConnectClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension QConnectClientTypes {
    /// The search expression.
    public struct SearchExpression: Swift.Equatable {
        /// The search expression filters.
        /// This member is required.
        public var filters: [QConnectClientTypes.Filter]?

        public init(
            filters: [QConnectClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension SearchQuickResponsesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchQuickResponsesInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchExpression: \(Swift.String(describing: searchExpression)), attributes: \"CONTENT_REDACTED\")"}
}

extension SearchQuickResponsesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, contactAttributes0) in attributes {
                try attributesContainer.encode(contactAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let searchExpression = self.searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

extension SearchQuickResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchQuickResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search/quickResponses"
    }
}

public struct SearchQuickResponsesInput: Swift.Equatable {
    /// The [user-defined Amazon Connect contact attributes](https://docs.aws.amazon.com/connect/latest/adminguide/connect-attrib-list.html#user-defined-attributes) to be resolved when search results are returned.
    public var attributes: [Swift.String:Swift.String]?
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression for querying the quick response.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.QuickResponseSearchExpression?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.QuickResponseSearchExpression? = nil
    )
    {
        self.attributes = attributes
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchQuickResponsesInputBody: Swift.Equatable {
    let searchExpression: QConnectClientTypes.QuickResponseSearchExpression?
    let attributes: [Swift.String:Swift.String]?
}

extension SearchQuickResponsesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case searchExpression
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseSearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, contactattributevalue0) in attributesContainer {
                if let contactattributevalue0 = contactattributevalue0 {
                    attributesDecoded0?[key0] = contactattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SearchQuickResponsesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchQuickResponsesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct SearchQuickResponsesOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The results of the quick response search.
    /// This member is required.
    public var results: [QConnectClientTypes.QuickResponseSearchResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [QConnectClientTypes.QuickResponseSearchResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct SearchQuickResponsesOutputBody: Swift.Equatable {
    let results: [QConnectClientTypes.QuickResponseSearchResultData]?
    let nextToken: Swift.String?
}

extension SearchQuickResponsesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([QConnectClientTypes.QuickResponseSearchResultData?].self, forKey: .results)
        var resultsDecoded0:[QConnectClientTypes.QuickResponseSearchResultData]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [QConnectClientTypes.QuickResponseSearchResultData]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchQuickResponsesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = self.searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

extension SearchSessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/searchSessions"
    }
}

public struct SearchSessionsInput: Swift.Equatable {
    /// The identifier of the Amazon Q assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: QConnectClientTypes.SearchExpression?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: QConnectClientTypes.SearchExpression? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchSessionsInputBody: Swift.Equatable {
    let searchExpression: QConnectClientTypes.SearchExpression?
}

extension SearchSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessionSummaries = output.sessionSummaries
        } else {
            self.nextToken = nil
            self.sessionSummaries = nil
        }
    }
}

public struct SearchSessionsOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the sessions.
    /// This member is required.
    public var sessionSummaries: [QConnectClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [QConnectClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

struct SearchSessionsOutputBody: Swift.Equatable {
    let sessionSummaries: [QConnectClientTypes.SessionSummary]?
    let nextToken: Swift.String?
}

extension SearchSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessionSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionSummariesContainer = try containerValues.decodeIfPresent([QConnectClientTypes.SessionSummary?].self, forKey: .sessionSummaries)
        var sessionSummariesDecoded0:[QConnectClientTypes.SessionSummary]? = nil
        if let sessionSummariesContainer = sessionSummariesContainer {
            sessionSummariesDecoded0 = [QConnectClientTypes.SessionSummary]()
            for structure0 in sessionSummariesContainer {
                if let structure0 = structure0 {
                    sessionSummariesDecoded0?.append(structure0)
                }
            }
        }
        sessionSummaries = sessionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension QConnectClientTypes {
    /// The configuration information for the customer managed key used for encryption.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Amazon Q, see [Enable Amazon Q in Connect for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-q.html). For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id).
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QConnectClientTypes.SessionData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case integrationConfiguration
        case name
        case sessionArn
        case sessionId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationConfiguration = self.integrationConfiguration {
            try encodeContainer.encode(integrationConfiguration, forKey: .integrationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let integrationConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SessionIntegrationConfiguration.self, forKey: .integrationConfiguration)
        integrationConfiguration = integrationConfigurationDecoded
    }
}

extension QConnectClientTypes {
    /// Information about the session.
    public struct SessionData: Swift.Equatable {
        /// The description of the session.
        public var description: Swift.String?
        /// The configuration information for the session integration.
        public var integrationConfiguration: QConnectClientTypes.SessionIntegrationConfiguration?
        /// The name of the session.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            integrationConfiguration: QConnectClientTypes.SessionIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }
    }

}

extension QConnectClientTypes.SessionIntegrationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicIntegrationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicIntegrationArn = self.topicIntegrationArn {
            try encodeContainer.encode(topicIntegrationArn, forKey: .topicIntegrationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicIntegrationArn)
        topicIntegrationArn = topicIntegrationArnDecoded
    }
}

extension QConnectClientTypes {
    /// The configuration information for the session integration.
    public struct SessionIntegrationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        )
        {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }

}

extension QConnectClientTypes.SessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
    }
}

extension QConnectClientTypes {
    /// Summary information about the session.
    public struct SessionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Q assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Amazon Q assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }
    }

}

extension QConnectClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appintegrations = "appIntegrations"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .appintegrations(appintegrations):
                try container.encode(appintegrations, forKey: .appintegrations)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let appintegrationsDecoded = try values.decodeIfPresent(QConnectClientTypes.AppIntegrationsConfiguration.self, forKey: .appintegrations)
        if let appintegrations = appintegrationsDecoded {
            self = .appintegrations(appintegrations)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QConnectClientTypes {
    /// Configuration information about the external data source.
    public enum SourceConfiguration: Swift.Equatable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appintegrations(QConnectClientTypes.AppIntegrationsConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension QConnectClientTypes.SourceContentDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case rankingData
        case textData
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let rankingData = self.rankingData {
            try encodeContainer.encode(rankingData, forKey: .rankingData)
        }
        if let textData = self.textData {
            try encodeContainer.encode(textData, forKey: .textData)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.SourceContentType.self, forKey: .type)
        type = typeDecoded
        let textDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.TextData.self, forKey: .textData)
        textData = textDataDecoded
        let rankingDataDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.RankingData.self, forKey: .rankingData)
        rankingData = rankingDataDecoded
    }
}

extension QConnectClientTypes {
    /// Details about the source content data.
    public struct SourceContentDataDetails: Swift.Equatable {
        /// The identifier of the source content.
        /// This member is required.
        public var id: Swift.String?
        /// Details about the source content ranking data.
        /// This member is required.
        public var rankingData: QConnectClientTypes.RankingData?
        /// Details about the source content text data.
        /// This member is required.
        public var textData: QConnectClientTypes.TextData?
        /// The type of the source content.
        /// This member is required.
        public var type: QConnectClientTypes.SourceContentType?

        public init(
            id: Swift.String? = nil,
            rankingData: QConnectClientTypes.RankingData? = nil,
            textData: QConnectClientTypes.TextData? = nil,
            type: QConnectClientTypes.SourceContentType? = nil
        )
        {
            self.id = id
            self.rankingData = rankingData
            self.textData = textData
            self.type = type
        }
    }

}

extension QConnectClientTypes {
    public enum SourceContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceContentType] {
            return [
                .knowledgeContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceContentType(rawValue: rawValue) ?? SourceContentType.sdkUnknown(rawValue)
        }
    }
}

extension StartContentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case presignedUrlTimeToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let presignedUrlTimeToLive = self.presignedUrlTimeToLive {
            try encodeContainer.encode(presignedUrlTimeToLive, forKey: .presignedUrlTimeToLive)
        }
    }
}

extension StartContentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/upload"
    }
}

public struct StartContentUploadInput: Swift.Equatable {
    /// The type of content to upload.
    /// This member is required.
    public var contentType: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The expected expiration time of the generated presigned URL, specified in minutes.
    public var presignedUrlTimeToLive: Swift.Int?

    public init(
        contentType: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        presignedUrlTimeToLive: Swift.Int? = nil
    )
    {
        self.contentType = contentType
        self.knowledgeBaseId = knowledgeBaseId
        self.presignedUrlTimeToLive = presignedUrlTimeToLive
    }
}

struct StartContentUploadInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let presignedUrlTimeToLive: Swift.Int?
}

extension StartContentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case presignedUrlTimeToLive
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let presignedUrlTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .presignedUrlTimeToLive)
        presignedUrlTimeToLive = presignedUrlTimeToLiveDecoded
    }
}

extension StartContentUploadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadOutput(headersToInclude: \(Swift.String(describing: headersToInclude)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension StartContentUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartContentUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.headersToInclude = output.headersToInclude
            self.uploadId = output.uploadId
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.headersToInclude = nil
            self.uploadId = nil
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct StartContentUploadOutput: Swift.Equatable {
    /// The headers to include in the upload.
    /// This member is required.
    public var headersToInclude: [Swift.String:Swift.String]?
    /// The identifier of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The URL of the upload.
    /// This member is required.
    public var url: Swift.String?
    /// The expiration time of the URL as an epoch timestamp.
    /// This member is required.
    public var urlExpiry: ClientRuntime.Date?

    public init(
        headersToInclude: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil,
        url: Swift.String? = nil,
        urlExpiry: ClientRuntime.Date? = nil
    )
    {
        self.headersToInclude = headersToInclude
        self.uploadId = uploadId
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct StartContentUploadOutputBody: Swift.Equatable {
    let uploadId: Swift.String?
    let url: Swift.String?
    let urlExpiry: ClientRuntime.Date?
    let headersToInclude: [Swift.String:Swift.String]?
}

extension StartContentUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude
        case uploadId
        case url
        case urlExpiry
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in headersToIncludeContainer {
                if let nonemptystring0 = nonemptystring0 {
                    headersToIncludeDecoded0?[key0] = nonemptystring0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

enum StartContentUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case externalSourceConfiguration
        case importJobType
        case metadata
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let externalSourceConfiguration = self.externalSourceConfiguration {
            try encodeContainer.encode(externalSourceConfiguration, forKey: .externalSourceConfiguration)
        }
        if let importJobType = self.importJobType {
            try encodeContainer.encode(importJobType.rawValue, forKey: .importJobType)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension StartImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

public struct StartImportJobInput: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    public var clientToken: Swift.String?
    /// The configuration information of the external source that the resource data are imported from.
    public var externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
    /// The type of the import job.
    ///
    /// * For importing quick response resource, set the value to QUICK_RESPONSES.
    /// This member is required.
    public var importJobType: QConnectClientTypes.ImportJobType?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    ///
    /// * For importing Amazon Q quick responses, this should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The metadata fields of the imported Amazon Q resources.
    public var metadata: [Swift.String:Swift.String]?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration? = nil,
        importJobType: QConnectClientTypes.ImportJobType? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.externalSourceConfiguration = externalSourceConfiguration
        self.importJobType = importJobType
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.uploadId = uploadId
    }
}

struct StartImportJobInputBody: Swift.Equatable {
    let importJobType: QConnectClientTypes.ImportJobType?
    let uploadId: Swift.String?
    let clientToken: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let externalSourceConfiguration: QConnectClientTypes.ExternalSourceConfiguration?
}

extension StartImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case externalSourceConfiguration
        case importJobType
        case metadata
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobTypeDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobType.self, forKey: .importJobType)
        importJobType = importJobTypeDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let externalSourceConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ExternalSourceConfiguration.self, forKey: .externalSourceConfiguration)
        externalSourceConfiguration = externalSourceConfigurationDecoded
    }
}

extension StartImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.importJob = output.importJob
        } else {
            self.importJob = nil
        }
    }
}

public struct StartImportJobOutput: Swift.Equatable {
    /// The import job.
    public var importJob: QConnectClientTypes.ImportJobData?

    public init(
        importJob: QConnectClientTypes.ImportJobData? = nil
    )
    {
        self.importJob = importJob
    }
}

struct StartImportJobOutputBody: Swift.Equatable {
    let importJob: QConnectClientTypes.ImportJobData?
}

extension StartImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ImportJobData.self, forKey: .importJob)
        importJob = importJobDecoded
    }
}

enum StartImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QConnectClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case recommendation
        case result
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .recommendation,
                .result,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .recommendation: return "RECOMMENDATION"
            case .result: return "RESULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension QConnectClientTypes.TextData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excerpt
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excerpt = self.excerpt {
            try encodeContainer.encode(excerpt, forKey: .excerpt)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DocumentText.self, forKey: .title)
        title = titleDecoded
        let excerptDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.DocumentText.self, forKey: .excerpt)
        excerpt = excerptDecoded
    }
}

extension QConnectClientTypes {
    /// Details about the source content text data.
    public struct TextData: Swift.Equatable {
        /// The text of the document.
        public var excerpt: QConnectClientTypes.DocumentText?
        /// The text of the document.
        public var title: QConnectClientTypes.DocumentText?

        public init(
            excerpt: QConnectClientTypes.DocumentText? = nil,
            title: QConnectClientTypes.DocumentText? = nil
        )
        {
            self.excerpt = excerpt
            self.title = title
        }
    }

}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Q in Connect throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overrideLinkOutUri = self.overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let removeOverrideLinkOutUri = self.removeOverrideLinkOutUri {
            try encodeContainer.encode(removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension UpdateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct UpdateContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Amazon Q, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
    public var overrideLinkOutUri: Swift.String?
    /// Unset the existing overrideLinkOutUri if it exists.
    public var removeOverrideLinkOutUri: Swift.Bool?
    /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
    public var revisionId: Swift.String?
    /// The title of the content.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_StartContentUpload.html).
    public var uploadId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        removeOverrideLinkOutUri: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.overrideLinkOutUri = overrideLinkOutUri
        self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
        self.revisionId = revisionId
        self.title = title
        self.uploadId = uploadId
    }
}

struct UpdateContentInputBody: Swift.Equatable {
    let revisionId: Swift.String?
    let title: Swift.String?
    let overrideLinkOutUri: Swift.String?
    let removeOverrideLinkOutUri: Swift.Bool?
    let metadata: [Swift.String:Swift.String]?
    let uploadId: Swift.String?
}

extension UpdateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let removeOverrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOverrideLinkOutUri)
        removeOverrideLinkOutUri = removeOverrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension UpdateContentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateContentOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct UpdateContentOutput: Swift.Equatable {
    /// The content.
    public var content: QConnectClientTypes.ContentData?

    public init(
        content: QConnectClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct UpdateContentOutputBody: Swift.Equatable {
    let content: QConnectClientTypes.ContentData?
}

extension UpdateContentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

enum UpdateContentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKnowledgeBaseTemplateUriInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = self.templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }
}

extension UpdateKnowledgeBaseTemplateUriInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

public struct UpdateKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The template URI to update.
    /// This member is required.
    public var templateUri: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        templateUri: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.templateUri = templateUri
    }
}

struct UpdateKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
    let templateUri: Swift.String?
}

extension UpdateKnowledgeBaseTemplateUriInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension UpdateKnowledgeBaseTemplateUriOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKnowledgeBaseTemplateUriOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct UpdateKnowledgeBaseTemplateUriOutput: Swift.Equatable {
    /// The knowledge base to update.
    public var knowledgeBase: QConnectClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: QConnectClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct UpdateKnowledgeBaseTemplateUriOutputBody: Swift.Equatable {
    let knowledgeBase: QConnectClientTypes.KnowledgeBaseData?
}

extension UpdateKnowledgeBaseTemplateUriOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum UpdateKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateQuickResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case content
        case contentType
        case description
        case groupingConfiguration
        case isActive
        case language
        case name
        case removeDescription
        case removeGroupingConfiguration
        case removeShortcutKey
        case shortcutKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupingConfiguration = self.groupingConfiguration {
            try encodeContainer.encode(groupingConfiguration, forKey: .groupingConfiguration)
        }
        if let isActive = self.isActive {
            try encodeContainer.encode(isActive, forKey: .isActive)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let removeDescription = self.removeDescription {
            try encodeContainer.encode(removeDescription, forKey: .removeDescription)
        }
        if let removeGroupingConfiguration = self.removeGroupingConfiguration {
            try encodeContainer.encode(removeGroupingConfiguration, forKey: .removeGroupingConfiguration)
        }
        if let removeShortcutKey = self.removeShortcutKey {
            try encodeContainer.encode(removeShortcutKey, forKey: .removeShortcutKey)
        }
        if let shortcutKey = self.shortcutKey {
            try encodeContainer.encode(shortcutKey, forKey: .shortcutKey)
        }
    }
}

extension UpdateQuickResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

public struct UpdateQuickResponseInput: Swift.Equatable {
    /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
    public var channels: [Swift.String]?
    /// The updated content of the quick response.
    public var content: QConnectClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
    public var contentType: Swift.String?
    /// The updated description of the quick response.
    public var description: Swift.String?
    /// The updated grouping configuration of the quick response.
    public var groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Amazon Q Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    public var name: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?
    /// Whether to remove the description from the quick response.
    public var removeDescription: Swift.Bool?
    /// Whether to remove the grouping configuration of the quick response.
    public var removeGroupingConfiguration: Swift.Bool?
    /// Whether to remove the shortcut key of the quick response.
    public var removeShortcutKey: Swift.Bool?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?

    public init(
        channels: [Swift.String]? = nil,
        content: QConnectClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: QConnectClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        quickResponseId: Swift.String? = nil,
        removeDescription: Swift.Bool? = nil,
        removeGroupingConfiguration: Swift.Bool? = nil,
        removeShortcutKey: Swift.Bool? = nil,
        shortcutKey: Swift.String? = nil
    )
    {
        self.channels = channels
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.quickResponseId = quickResponseId
        self.removeDescription = removeDescription
        self.removeGroupingConfiguration = removeGroupingConfiguration
        self.removeShortcutKey = removeShortcutKey
        self.shortcutKey = shortcutKey
    }
}

struct UpdateQuickResponseInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: QConnectClientTypes.QuickResponseDataProvider?
    let contentType: Swift.String?
    let groupingConfiguration: QConnectClientTypes.GroupingConfiguration?
    let removeGroupingConfiguration: Swift.Bool?
    let description: Swift.String?
    let removeDescription: Swift.Bool?
    let shortcutKey: Swift.String?
    let removeShortcutKey: Swift.Bool?
    let isActive: Swift.Bool?
    let channels: [Swift.String]?
    let language: Swift.String?
}

extension UpdateQuickResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case content
        case contentType
        case description
        case groupingConfiguration
        case isActive
        case language
        case name
        case removeDescription
        case removeGroupingConfiguration
        case removeShortcutKey
        case shortcutKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseDataProvider.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let groupingConfigurationDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.GroupingConfiguration.self, forKey: .groupingConfiguration)
        groupingConfiguration = groupingConfigurationDecoded
        let removeGroupingConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeGroupingConfiguration)
        removeGroupingConfiguration = removeGroupingConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let removeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeDescription)
        removeDescription = removeDescriptionDecoded
        let shortcutKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortcutKey)
        shortcutKey = shortcutKeyDecoded
        let removeShortcutKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeShortcutKey)
        removeShortcutKey = removeShortcutKeyDecoded
        let isActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isActive)
        isActive = isActiveDecoded
        let channelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channels)
        var channelsDecoded0:[Swift.String]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Swift.String]()
            for string0 in channelsContainer {
                if let string0 = string0 {
                    channelsDecoded0?.append(string0)
                }
            }
        }
        channels = channelsDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension UpdateQuickResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateQuickResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.quickResponse = output.quickResponse
        } else {
            self.quickResponse = nil
        }
    }
}

public struct UpdateQuickResponseOutput: Swift.Equatable {
    /// The quick response.
    public var quickResponse: QConnectClientTypes.QuickResponseData?

    public init(
        quickResponse: QConnectClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

struct UpdateQuickResponseOutputBody: Swift.Equatable {
    let quickResponse: QConnectClientTypes.QuickResponseData?
}

extension UpdateQuickResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quickResponse
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quickResponseDecoded = try containerValues.decodeIfPresent(QConnectClientTypes.QuickResponseData.self, forKey: .quickResponse)
        quickResponse = quickResponseDecoded
    }
}

enum UpdateQuickResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PreconditionFailedException": return try await PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by a service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
