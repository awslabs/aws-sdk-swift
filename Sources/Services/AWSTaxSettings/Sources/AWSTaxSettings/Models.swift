//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// The access is denied for the Amazon Web ServicesSupport API.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \"CONTENT_REDACTED\")"}
}

extension TaxSettingsClientTypes {

    /// The details of the address associated with the TRN information.
    public struct Address: Swift.Sendable {
        /// The first line of the address.
        /// This member is required.
        public var addressLine1: Swift.String?
        /// The second line of the address, if applicable.
        public var addressLine2: Swift.String?
        /// The third line of the address, if applicable. Currently, the Tax Settings API accepts the addressLine3 parameter only for Saudi Arabia. When you specify a TRN in Saudi Arabia, you must enter the addressLine3 and specify the building number for the address. For example, you might enter 1234.
        public var addressLine3: Swift.String?
        /// The city that the address is in.
        /// This member is required.
        public var city: Swift.String?
        /// The country code for the country that the address is in.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The district or county the address is located. For addresses in Brazil, this parameter uses the name of the neighborhood. When you set a TRN in Brazil, use districtOrCounty for the neighborhood name.
        public var districtOrCounty: Swift.String?
        /// The postal code associated with the address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state, region, or province that the address is located. This field is only required for Canada, India, United Arab Emirates, Romania, and Brazil (CPF). It is optional for all other countries. If this is required for tax settings, use the same name as shown on the Tax Settings page.
        public var stateOrRegion: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        ) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension TaxSettingsClientTypes {

    public enum AddressRoleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case billingAddress
        case contactAddress
        case taxAddress
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressRoleType] {
            return [
                .billingAddress,
                .contactAddress,
                .taxAddress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .billingAddress: return "BillingAddress"
            case .contactAddress: return "ContactAddress"
            case .taxAddress: return "TaxAddress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// The jurisdiction details of the TRN information of the customers. This doesn't contain full legal address, and contains only country code and state/region/province.
    public struct Jurisdiction: Swift.Sendable {
        /// The country code of the jurisdiction.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The state, region, or province associated with the country of the jurisdiction, if applicable.
        public var stateOrRegion: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        ) {
            self.countryCode = countryCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension TaxSettingsClientTypes {

    /// The meta data information associated with the account.
    public struct AccountMetaData: Swift.Sendable {
        /// The Amazon Web Services accounts name.
        public var accountName: Swift.String?
        /// The details of the address associated with the TRN information.
        public var address: TaxSettingsClientTypes.Address?
        /// Address roles associated with the account containing country code information.
        public var addressRoleMap: [Swift.String: TaxSettingsClientTypes.Jurisdiction]?
        /// The type of address associated with the legal profile.
        public var addressType: TaxSettingsClientTypes.AddressRoleType?
        /// Seller information associated with the account.
        public var seller: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            address: TaxSettingsClientTypes.Address? = nil,
            addressRoleMap: [Swift.String: TaxSettingsClientTypes.Jurisdiction]? = nil,
            addressType: TaxSettingsClientTypes.AddressRoleType? = nil,
            seller: Swift.String? = nil
        ) {
            self.accountName = accountName
            self.address = address
            self.addressRoleMap = addressRoleMap
            self.addressType = addressType
            self.seller = seller
        }
    }
}

extension TaxSettingsClientTypes.AccountMetaData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension TaxSettingsClientTypes {

    /// Tax inheritance information associated with the account.
    public struct TaxInheritanceDetails: Swift.Sendable {
        /// Tax inheritance reason information associated with the account.
        public var inheritanceObtainedReason: Swift.String?
        /// Tax inheritance parent account information associated with the account.
        public var parentEntityId: Swift.String?

        public init(
            inheritanceObtainedReason: Swift.String? = nil,
            parentEntityId: Swift.String? = nil
        ) {
            self.inheritanceObtainedReason = inheritanceObtainedReason
            self.parentEntityId = parentEntityId
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Brazil.
    public struct BrazilAdditionalInfo: Swift.Sendable {
        /// The Cadastro de Contribuintes Mobiliários (CCM) code for your TRN in Brazil. This only applies for a CNPJ tax type for the São Paulo municipality.
        public var ccmCode: Swift.String?
        /// Legal nature of business, based on your TRN in Brazil. This only applies for a CNPJ tax type.
        public var legalNatureCode: Swift.String?

        public init(
            ccmCode: Swift.String? = nil,
            legalNatureCode: Swift.String? = nil
        ) {
            self.ccmCode = ccmCode
            self.legalNatureCode = legalNatureCode
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Canada .
    public struct CanadaAdditionalInfo: Swift.Sendable {
        /// The Quebec Sales Tax ID number. Leave blank if you do not have a Quebec Sales Tax ID number.
        public var canadaQuebecSalesTaxNumber: Swift.String?
        /// Manitoba Retail Sales Tax ID number. Customers purchasing Amazon Web Services services for resale in Manitoba must provide a valid Retail Sales Tax ID number for Manitoba. Leave this blank if you do not have a Retail Sales Tax ID number in Manitoba or are not purchasing Amazon Web Services services for resale.
        public var canadaRetailSalesTaxNumber: Swift.String?
        /// The value for this parameter must be true if the provincialSalesTaxId value is provided for a TRN in British Columbia, Saskatchewan, or Manitoba provinces. To claim a provincial sales tax (PST) and retail sales tax (RST) reseller exemption, you must confirm that purchases from this account were made for resale. Otherwise, remove the PST or RST number from the provincialSalesTaxId parameter from your request.
        public var isResellerAccount: Swift.Bool?
        /// The provincial sales tax ID for your TRN in Canada. This parameter can represent the following:
        ///
        /// * Provincial sales tax ID number for British Columbia and Saskatchewan provinces
        ///
        /// * Manitoba retail sales tax ID number for Manitoba province
        ///
        /// * Quebec sales tax ID number for Quebec province
        ///
        ///
        /// The Tax Setting API only accepts this parameter if the TRN is specified for the previous provinces. For other provinces, the Tax Settings API doesn't accept this parameter.
        public var provincialSalesTaxId: Swift.String?

        public init(
            canadaQuebecSalesTaxNumber: Swift.String? = nil,
            canadaRetailSalesTaxNumber: Swift.String? = nil,
            isResellerAccount: Swift.Bool? = nil,
            provincialSalesTaxId: Swift.String? = nil
        ) {
            self.canadaQuebecSalesTaxNumber = canadaQuebecSalesTaxNumber
            self.canadaRetailSalesTaxNumber = canadaRetailSalesTaxNumber
            self.isResellerAccount = isResellerAccount
            self.provincialSalesTaxId = provincialSalesTaxId
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information to specify for a TRN in Egypt.
    public struct EgyptAdditionalInfo: Swift.Sendable {
        /// The unique identification number provided by the Egypt Tax Authority.
        public var uniqueIdentificationNumber: Swift.String?
        /// The expiration date of the unique identification number provided by the Egypt Tax Authority.
        public var uniqueIdentificationNumberExpirationDate: Swift.String?

        public init(
            uniqueIdentificationNumber: Swift.String? = nil,
            uniqueIdentificationNumberExpirationDate: Swift.String? = nil
        ) {
            self.uniqueIdentificationNumber = uniqueIdentificationNumber
            self.uniqueIdentificationNumberExpirationDate = uniqueIdentificationNumberExpirationDate
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Estonia.
    public struct EstoniaAdditionalInfo: Swift.Sendable {
        /// Registry commercial code (RCC) for your TRN in Estonia. This value is an eight-numeric string, such as 12345678.
        /// This member is required.
        public var registryCommercialCode: Swift.String?

        public init(
            registryCommercialCode: Swift.String? = nil
        ) {
            self.registryCommercialCode = registryCommercialCode
        }
    }
}

extension TaxSettingsClientTypes {

    public enum PersonType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case legalPerson
        case physicalPerson
        case sdkUnknown(Swift.String)

        public static var allCases: [PersonType] {
            return [
                .business,
                .legalPerson,
                .physicalPerson
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "Business"
            case .legalPerson: return "Legal Person"
            case .physicalPerson: return "Physical Person"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Georgia.
    public struct GeorgiaAdditionalInfo: Swift.Sendable {
        /// The legal person or physical person assigned to this TRN in Georgia.
        /// This member is required.
        public var personType: TaxSettingsClientTypes.PersonType?

        public init(
            personType: TaxSettingsClientTypes.PersonType? = nil
        ) {
            self.personType = personType
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information to specify for a TRN in Greece.
    public struct GreeceAdditionalInfo: Swift.Sendable {
        /// The code of contracting authority for e-invoicing.
        public var contractingAuthorityCode: Swift.String?

        public init(
            contractingAuthorityCode: Swift.String? = nil
        ) {
            self.contractingAuthorityCode = contractingAuthorityCode
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information in India.
    public struct IndiaAdditionalInfo: Swift.Sendable {
        /// India pan information associated with the account.
        public var pan: Swift.String?

        public init(
            pan: Swift.String? = nil
        ) {
            self.pan = pan
        }
    }
}

extension TaxSettingsClientTypes {

    public enum IndonesiaTaxRegistrationNumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nik
        case nitku
        case npwp
        case passportNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [IndonesiaTaxRegistrationNumberType] {
            return [
                .nik,
                .nitku,
                .npwp,
                .passportNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nik: return "NIK"
            case .nitku: return "NITKU"
            case .npwp: return "NPWP"
            case .passportNumber: return "PassportNumber"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Indonesia.
    public struct IndonesiaAdditionalInfo: Swift.Sendable {
        /// VAT-exempt customers have a Directorate General of Taxation (DGT) exemption letter or certificate (Surat Keterangan Bebas) decision number. Non-collected VAT have a DGT letter or certificate (Surat Keterangan Tidak Dipungut).
        public var decisionNumber: Swift.String?
        /// Exception code if you are designated by Directorate General of Taxation (DGT) as a VAT collector, non-collected VAT, or VAT-exempt customer.
        public var ppnExceptionDesignationCode: Swift.String?
        /// The tax registration number type.
        public var taxRegistrationNumberType: TaxSettingsClientTypes.IndonesiaTaxRegistrationNumberType?

        public init(
            decisionNumber: Swift.String? = nil,
            ppnExceptionDesignationCode: Swift.String? = nil,
            taxRegistrationNumberType: TaxSettingsClientTypes.IndonesiaTaxRegistrationNumberType? = nil
        ) {
            self.decisionNumber = decisionNumber
            self.ppnExceptionDesignationCode = ppnExceptionDesignationCode
            self.taxRegistrationNumberType = taxRegistrationNumberType
        }
    }
}

extension TaxSettingsClientTypes {

    public enum IsraelCustomerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case sdkUnknown(Swift.String)

        public static var allCases: [IsraelCustomerType] {
            return [
                .business,
                .individual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "Business"
            case .individual: return "Individual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    public enum IsraelDealerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorized
        case nonAuthorized
        case sdkUnknown(Swift.String)

        public static var allCases: [IsraelDealerType] {
            return [
                .authorized,
                .nonAuthorized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorized: return "Authorized"
            case .nonAuthorized: return "Non-authorized"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Israel.
    public struct IsraelAdditionalInfo: Swift.Sendable {
        /// Customer type for your TRN in Israel. The value can be Business or Individual. Use Businessfor entities such as not-for-profit and financial institutions.
        /// This member is required.
        public var customerType: TaxSettingsClientTypes.IsraelCustomerType?
        /// Dealer type for your TRN in Israel. If you're not a local authorized dealer with an Israeli VAT ID, specify your tax identification number so that Amazon Web Services can send you a compliant tax invoice.
        /// This member is required.
        public var dealerType: TaxSettingsClientTypes.IsraelDealerType?

        public init(
            customerType: TaxSettingsClientTypes.IsraelCustomerType? = nil,
            dealerType: TaxSettingsClientTypes.IsraelDealerType? = nil
        ) {
            self.customerType = customerType
            self.dealerType = dealerType
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Italy.
    public struct ItalyAdditionalInfo: Swift.Sendable {
        /// The tender procedure identification code.
        public var cigNumber: Swift.String?
        /// Additional tax information to specify for a TRN in Italy. This is managed by the Interministerial Committee for Economic Planning (CIPE) which characterizes every public investment project (Individual Project Code).
        public var cupNumber: Swift.String?
        /// Additional tax information to specify for a TRN in Italy. Use CodiceDestinatario to receive your invoices via web service (API) or FTP.
        public var sdiAccountId: Swift.String?
        /// List of service tax codes for your TRN in Italy. You can use your customer tax code as part of a VAT Group.
        public var taxCode: Swift.String?

        public init(
            cigNumber: Swift.String? = nil,
            cupNumber: Swift.String? = nil,
            sdiAccountId: Swift.String? = nil,
            taxCode: Swift.String? = nil
        ) {
            self.cigNumber = cigNumber
            self.cupNumber = cupNumber
            self.sdiAccountId = sdiAccountId
            self.taxCode = taxCode
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Kenya.
    public struct KenyaAdditionalInfo: Swift.Sendable {
        /// The legal person or physical person assigned to this TRN in Kenya.
        /// This member is required.
        public var personType: TaxSettingsClientTypes.PersonType?

        public init(
            personType: TaxSettingsClientTypes.PersonType? = nil
        ) {
            self.personType = personType
        }
    }
}

extension TaxSettingsClientTypes {

    public enum MalaysiaServiceTaxCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case consultancy
        case digitalSvcElectronicMedium
        case itServices
        case trainingOrCoaching
        case sdkUnknown(Swift.String)

        public static var allCases: [MalaysiaServiceTaxCode] {
            return [
                .consultancy,
                .digitalSvcElectronicMedium,
                .itServices,
                .trainingOrCoaching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .consultancy: return "Consultancy"
            case .digitalSvcElectronicMedium: return "Digital Service And Electronic Medium"
            case .itServices: return "IT Services"
            case .trainingOrCoaching: return "Training Or Coaching"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Malaysia.
    public struct MalaysiaAdditionalInfo: Swift.Sendable {
        /// The tax registration number (TRN) in Malaysia. For individual, you can specify the taxInformationNumber in MalaysiaAdditionalInfo with NRIC type, and a valid MyKad or NRIC number. For business, you must specify a businessRegistrationNumber in MalaysiaAdditionalInfo with a TIN type and tax identification number. For business resellers, you must specify a businessRegistrationNumber and taxInformationNumber in MalaysiaAdditionalInfo with a sales and service tax (SST) type and a valid SST number. For business resellers with service codes, you must specify businessRegistrationNumber, taxInformationNumber, and distinct serviceTaxCodes in MalaysiaAdditionalInfo with a SST type and valid sales and service tax (SST) number. By using this API operation, Amazon Web Services registers your self-declaration that you’re an authorized business reseller registered with the Royal Malaysia Customs Department (RMCD), and have a valid SST number.
        public var businessRegistrationNumber: Swift.String?
        /// List of service tax codes for your TRN in Malaysia.
        public var serviceTaxCodes: [TaxSettingsClientTypes.MalaysiaServiceTaxCode]?
        /// The tax information number in Malaysia. For individual, you can specify the taxInformationNumber in MalaysiaAdditionalInfo with NRIC type, and a valid MyKad or NRIC number. For business resellers, you must specify a businessRegistrationNumber and taxInformationNumber in MalaysiaAdditionalInfo with a sales and service tax (SST) type and a valid SST number. For business resellers with service codes, you must specify businessRegistrationNumber, taxInformationNumber, and distinct serviceTaxCodes in MalaysiaAdditionalInfo with a SST type and valid sales and service tax (SST) number. By using this API operation, Amazon Web Services registers your self-declaration that you’re an authorized business reseller registered with the Royal Malaysia Customs Department (RMCD), and have a valid SST number.
        public var taxInformationNumber: Swift.String?

        public init(
            businessRegistrationNumber: Swift.String? = nil,
            serviceTaxCodes: [TaxSettingsClientTypes.MalaysiaServiceTaxCode]? = [],
            taxInformationNumber: Swift.String? = nil
        ) {
            self.businessRegistrationNumber = businessRegistrationNumber
            self.serviceTaxCodes = serviceTaxCodes
            self.taxInformationNumber = taxInformationNumber
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Poland.
    public struct PolandAdditionalInfo: Swift.Sendable {
        /// The individual tax registration number (NIP). Individual NIP is valid for other taxes excluding VAT purposes.
        public var individualRegistrationNumber: Swift.String?
        /// True if your business is a member of a VAT group with a NIP active for VAT purposes. Otherwise, this is false.
        public var isGroupVatEnabled: Swift.Bool?

        public init(
            individualRegistrationNumber: Swift.String? = nil,
            isGroupVatEnabled: Swift.Bool? = nil
        ) {
            self.individualRegistrationNumber = individualRegistrationNumber
            self.isGroupVatEnabled = isGroupVatEnabled
        }
    }
}

extension TaxSettingsClientTypes {

    public enum TaxRegistrationNumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case localRegistrationNumber
        case taxRegistrationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [TaxRegistrationNumberType] {
            return [
                .localRegistrationNumber,
                .taxRegistrationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .localRegistrationNumber: return "LocalRegistrationNumber"
            case .taxRegistrationNumber: return "TaxRegistrationNumber"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information to specify for a TRN in Romania.
    public struct RomaniaAdditionalInfo: Swift.Sendable {
        /// The tax registration number type. The value can be TaxRegistrationNumber or LocalRegistrationNumber.
        /// This member is required.
        public var taxRegistrationNumberType: TaxSettingsClientTypes.TaxRegistrationNumberType?

        public init(
            taxRegistrationNumberType: TaxSettingsClientTypes.TaxRegistrationNumberType? = nil
        ) {
            self.taxRegistrationNumberType = taxRegistrationNumberType
        }
    }
}

extension TaxSettingsClientTypes {

    public enum SaudiArabiaTaxRegistrationNumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case commercialRegistrationNumber
        case taxIdentificationNumber
        case taxRegistrationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SaudiArabiaTaxRegistrationNumberType] {
            return [
                .commercialRegistrationNumber,
                .taxIdentificationNumber,
                .taxRegistrationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .commercialRegistrationNumber: return "CommercialRegistrationNumber"
            case .taxIdentificationNumber: return "TaxIdentificationNumber"
            case .taxRegistrationNumber: return "TaxRegistrationNumber"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Saudi Arabia.
    public struct SaudiArabiaAdditionalInfo: Swift.Sendable {
        /// The tax registration number type.
        public var taxRegistrationNumberType: TaxSettingsClientTypes.SaudiArabiaTaxRegistrationNumberType?

        public init(
            taxRegistrationNumberType: TaxSettingsClientTypes.SaudiArabiaTaxRegistrationNumberType? = nil
        ) {
            self.taxRegistrationNumberType = taxRegistrationNumberType
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in South Korea.
    public struct SouthKoreaAdditionalInfo: Swift.Sendable {
        /// The business legal name based on the most recently uploaded tax registration certificate.
        /// This member is required.
        public var businessRepresentativeName: Swift.String?
        /// Item of business based on the most recently uploaded tax registration certificate.
        /// This member is required.
        public var itemOfBusiness: Swift.String?
        /// Line of business based on the most recently uploaded tax registration certificate.
        /// This member is required.
        public var lineOfBusiness: Swift.String?

        public init(
            businessRepresentativeName: Swift.String? = nil,
            itemOfBusiness: Swift.String? = nil,
            lineOfBusiness: Swift.String? = nil
        ) {
            self.businessRepresentativeName = businessRepresentativeName
            self.itemOfBusiness = itemOfBusiness
            self.lineOfBusiness = lineOfBusiness
        }
    }
}

extension TaxSettingsClientTypes {

    public enum RegistrationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case intraEu
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationType] {
            return [
                .intraEu,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .intraEu: return "Intra-EU"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Spain.
    public struct SpainAdditionalInfo: Swift.Sendable {
        /// The registration type in Spain.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.RegistrationType?

        public init(
            registrationType: TaxSettingsClientTypes.RegistrationType? = nil
        ) {
            self.registrationType = registrationType
        }
    }
}

extension TaxSettingsClientTypes {

    public enum Industries: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case banks
        case circulatingOrg
        case developmentAgencies
        case insurance
        case pensionAndBenefitFunds
        case professionalOrg
        case sdkUnknown(Swift.String)

        public static var allCases: [Industries] {
            return [
                .banks,
                .circulatingOrg,
                .developmentAgencies,
                .insurance,
                .pensionAndBenefitFunds,
                .professionalOrg
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .banks: return "Banks"
            case .circulatingOrg: return "CirculatingOrg"
            case .developmentAgencies: return "DevelopmentAgencies"
            case .insurance: return "Insurance"
            case .pensionAndBenefitFunds: return "PensionAndBenefitFunds"
            case .professionalOrg: return "ProfessionalOrg"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Turkey.
    public struct TurkeyAdditionalInfo: Swift.Sendable {
        /// The industry information that tells the Tax Settings API if you're subject to additional withholding taxes. This information required for business-to-business (B2B) customers. This information is conditionally mandatory for B2B customers who are subject to KDV tax.
        public var industries: TaxSettingsClientTypes.Industries?
        /// The Registered Electronic Mail (REM) that is used to send notarized communication. This parameter is optional for business-to-business (B2B) and business-to-government (B2G) customers. It's not required for business-to-consumer (B2C) customers.
        public var kepEmailId: Swift.String?
        /// Secondary tax ID (“harcama birimi VKN”si”). If one isn't provided, we will use your VKN as the secondary ID.
        public var secondaryTaxId: Swift.String?
        /// The tax office where you're registered. You can enter this information as a string. The Tax Settings API will add this information to your invoice. This parameter is required for business-to-business (B2B) and business-to-government customers. It's not required for business-to-consumer (B2C) customers.
        public var taxOffice: Swift.String?

        public init(
            industries: TaxSettingsClientTypes.Industries? = nil,
            kepEmailId: Swift.String? = nil,
            secondaryTaxId: Swift.String? = nil,
            taxOffice: Swift.String? = nil
        ) {
            self.industries = industries
            self.kepEmailId = kepEmailId
            self.secondaryTaxId = secondaryTaxId
            self.taxOffice = taxOffice
        }
    }
}

extension TaxSettingsClientTypes {

    public enum UkraineTrnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case sdkUnknown(Swift.String)

        public static var allCases: [UkraineTrnType] {
            return [
                .business,
                .individual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "Business"
            case .individual: return "Individual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN in Ukraine.
    public struct UkraineAdditionalInfo: Swift.Sendable {
        /// The tax registration type.
        /// This member is required.
        public var ukraineTrnType: TaxSettingsClientTypes.UkraineTrnType?

        public init(
            ukraineTrnType: TaxSettingsClientTypes.UkraineTrnType? = nil
        ) {
            self.ukraineTrnType = ukraineTrnType
        }
    }
}

extension TaxSettingsClientTypes {

    public enum UzbekistanTaxRegistrationNumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case sdkUnknown(Swift.String)

        public static var allCases: [UzbekistanTaxRegistrationNumberType] {
            return [
                .business,
                .individual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "Business"
            case .individual: return "Individual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information to specify for a TRN in Uzbekistan.
    public struct UzbekistanAdditionalInfo: Swift.Sendable {
        /// The tax registration number type. The tax registration number type valid values are Business and Individual.
        public var taxRegistrationNumberType: TaxSettingsClientTypes.UzbekistanTaxRegistrationNumberType?
        /// The unique 12-digit number issued to identify VAT-registered identities in Uzbekistan.
        public var vatRegistrationNumber: Swift.String?

        public init(
            taxRegistrationNumberType: TaxSettingsClientTypes.UzbekistanTaxRegistrationNumberType? = nil,
            vatRegistrationNumber: Swift.String? = nil
        ) {
            self.taxRegistrationNumberType = taxRegistrationNumberType
            self.vatRegistrationNumber = vatRegistrationNumber
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information to specify for a TRN in Vietnam.
    public struct VietnamAdditionalInfo: Swift.Sendable {
        /// The electronic transaction code number on the tax return document. This field must be provided for successful API operation.
        public var electronicTransactionCodeNumber: Swift.String?
        /// The enterprise identification number for tax registration. This field must be provided for successful API operation.
        public var enterpriseIdentificationNumber: Swift.String?
        /// The payment voucher number on the tax return payment document. This field must be provided for successful API operation.
        public var paymentVoucherNumber: Swift.String?
        /// The date on the tax return payment document. This field must be provided for successful API operation.
        public var paymentVoucherNumberDate: Swift.String?

        public init(
            electronicTransactionCodeNumber: Swift.String? = nil,
            enterpriseIdentificationNumber: Swift.String? = nil,
            paymentVoucherNumber: Swift.String? = nil,
            paymentVoucherNumberDate: Swift.String? = nil
        ) {
            self.electronicTransactionCodeNumber = electronicTransactionCodeNumber
            self.enterpriseIdentificationNumber = enterpriseIdentificationNumber
            self.paymentVoucherNumber = paymentVoucherNumber
            self.paymentVoucherNumberDate = paymentVoucherNumberDate
        }
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your TRN. The Tax Settings API returns country-specific information in the response when any additional information is present with your TRN for the following countries.
    public struct AdditionalInfoResponse: Swift.Sendable {
        /// Additional tax information associated with your TRN in Brazil. The Tax Settings API returns this information in your response when any additional information is present with your TRN in Brazil.
        public var brazilAdditionalInfo: TaxSettingsClientTypes.BrazilAdditionalInfo?
        /// Additional tax information associated with your TRN in Canada.
        public var canadaAdditionalInfo: TaxSettingsClientTypes.CanadaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Egypt.
        public var egyptAdditionalInfo: TaxSettingsClientTypes.EgyptAdditionalInfo?
        /// Additional tax information associated with your TRN in Estonia.
        public var estoniaAdditionalInfo: TaxSettingsClientTypes.EstoniaAdditionalInfo?
        /// Additional tax information associated with your TRN in Georgia.
        public var georgiaAdditionalInfo: TaxSettingsClientTypes.GeorgiaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Greece.
        public var greeceAdditionalInfo: TaxSettingsClientTypes.GreeceAdditionalInfo?
        /// Additional tax information in India.
        public var indiaAdditionalInfo: TaxSettingsClientTypes.IndiaAdditionalInfo?
        /// Additional tax information associated with your TRN in Indonesia.
        public var indonesiaAdditionalInfo: TaxSettingsClientTypes.IndonesiaAdditionalInfo?
        /// Additional tax information associated with your TRN in Israel.
        public var israelAdditionalInfo: TaxSettingsClientTypes.IsraelAdditionalInfo?
        /// Additional tax information associated with your TRN in Italy.
        public var italyAdditionalInfo: TaxSettingsClientTypes.ItalyAdditionalInfo?
        /// Additional tax information associated with your TRN in Kenya.
        public var kenyaAdditionalInfo: TaxSettingsClientTypes.KenyaAdditionalInfo?
        /// Additional tax information associated with your TRN in Malaysia.
        public var malaysiaAdditionalInfo: TaxSettingsClientTypes.MalaysiaAdditionalInfo?
        /// Additional tax information associated with your TRN in Poland.
        public var polandAdditionalInfo: TaxSettingsClientTypes.PolandAdditionalInfo?
        /// Additional tax information to specify for a TRN in Romania.
        public var romaniaAdditionalInfo: TaxSettingsClientTypes.RomaniaAdditionalInfo?
        /// Additional tax information associated with your TRN in Saudi Arabia.
        public var saudiArabiaAdditionalInfo: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo?
        /// Additional tax information associated with your TRN in South Korea.
        public var southKoreaAdditionalInfo: TaxSettingsClientTypes.SouthKoreaAdditionalInfo?
        /// Additional tax information associated with your TRN in Spain.
        public var spainAdditionalInfo: TaxSettingsClientTypes.SpainAdditionalInfo?
        /// Additional tax information associated with your TRN in Turkey.
        public var turkeyAdditionalInfo: TaxSettingsClientTypes.TurkeyAdditionalInfo?
        /// Additional tax information associated with your TRN in Ukraine.
        public var ukraineAdditionalInfo: TaxSettingsClientTypes.UkraineAdditionalInfo?
        /// Additional tax information associated with your TRN in Uzbekistan.
        public var uzbekistanAdditionalInfo: TaxSettingsClientTypes.UzbekistanAdditionalInfo?
        /// Additional tax information to specify for a TRN in Vietnam.
        public var vietnamAdditionalInfo: TaxSettingsClientTypes.VietnamAdditionalInfo?

        public init(
            brazilAdditionalInfo: TaxSettingsClientTypes.BrazilAdditionalInfo? = nil,
            canadaAdditionalInfo: TaxSettingsClientTypes.CanadaAdditionalInfo? = nil,
            egyptAdditionalInfo: TaxSettingsClientTypes.EgyptAdditionalInfo? = nil,
            estoniaAdditionalInfo: TaxSettingsClientTypes.EstoniaAdditionalInfo? = nil,
            georgiaAdditionalInfo: TaxSettingsClientTypes.GeorgiaAdditionalInfo? = nil,
            greeceAdditionalInfo: TaxSettingsClientTypes.GreeceAdditionalInfo? = nil,
            indiaAdditionalInfo: TaxSettingsClientTypes.IndiaAdditionalInfo? = nil,
            indonesiaAdditionalInfo: TaxSettingsClientTypes.IndonesiaAdditionalInfo? = nil,
            israelAdditionalInfo: TaxSettingsClientTypes.IsraelAdditionalInfo? = nil,
            italyAdditionalInfo: TaxSettingsClientTypes.ItalyAdditionalInfo? = nil,
            kenyaAdditionalInfo: TaxSettingsClientTypes.KenyaAdditionalInfo? = nil,
            malaysiaAdditionalInfo: TaxSettingsClientTypes.MalaysiaAdditionalInfo? = nil,
            polandAdditionalInfo: TaxSettingsClientTypes.PolandAdditionalInfo? = nil,
            romaniaAdditionalInfo: TaxSettingsClientTypes.RomaniaAdditionalInfo? = nil,
            saudiArabiaAdditionalInfo: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo? = nil,
            southKoreaAdditionalInfo: TaxSettingsClientTypes.SouthKoreaAdditionalInfo? = nil,
            spainAdditionalInfo: TaxSettingsClientTypes.SpainAdditionalInfo? = nil,
            turkeyAdditionalInfo: TaxSettingsClientTypes.TurkeyAdditionalInfo? = nil,
            ukraineAdditionalInfo: TaxSettingsClientTypes.UkraineAdditionalInfo? = nil,
            uzbekistanAdditionalInfo: TaxSettingsClientTypes.UzbekistanAdditionalInfo? = nil,
            vietnamAdditionalInfo: TaxSettingsClientTypes.VietnamAdditionalInfo? = nil
        ) {
            self.brazilAdditionalInfo = brazilAdditionalInfo
            self.canadaAdditionalInfo = canadaAdditionalInfo
            self.egyptAdditionalInfo = egyptAdditionalInfo
            self.estoniaAdditionalInfo = estoniaAdditionalInfo
            self.georgiaAdditionalInfo = georgiaAdditionalInfo
            self.greeceAdditionalInfo = greeceAdditionalInfo
            self.indiaAdditionalInfo = indiaAdditionalInfo
            self.indonesiaAdditionalInfo = indonesiaAdditionalInfo
            self.israelAdditionalInfo = israelAdditionalInfo
            self.italyAdditionalInfo = italyAdditionalInfo
            self.kenyaAdditionalInfo = kenyaAdditionalInfo
            self.malaysiaAdditionalInfo = malaysiaAdditionalInfo
            self.polandAdditionalInfo = polandAdditionalInfo
            self.romaniaAdditionalInfo = romaniaAdditionalInfo
            self.saudiArabiaAdditionalInfo = saudiArabiaAdditionalInfo
            self.southKoreaAdditionalInfo = southKoreaAdditionalInfo
            self.spainAdditionalInfo = spainAdditionalInfo
            self.turkeyAdditionalInfo = turkeyAdditionalInfo
            self.ukraineAdditionalInfo = ukraineAdditionalInfo
            self.uzbekistanAdditionalInfo = uzbekistanAdditionalInfo
            self.vietnamAdditionalInfo = vietnamAdditionalInfo
        }
    }
}

extension TaxSettingsClientTypes {

    public enum TaxRegistrationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cnpj
        case cpf
        case gst
        case nric
        case sst
        case tin
        case vat
        case sdkUnknown(Swift.String)

        public static var allCases: [TaxRegistrationType] {
            return [
                .cnpj,
                .cpf,
                .gst,
                .nric,
                .sst,
                .tin,
                .vat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cnpj: return "CNPJ"
            case .cpf: return "CPF"
            case .gst: return "GST"
            case .nric: return "NRIC"
            case .sst: return "SST"
            case .tin: return "TIN"
            case .vat: return "VAT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    public enum Sector: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case business
        case individual
        case publicInstitutions
        case sdkUnknown(Swift.String)

        public static var allCases: [Sector] {
            return [
                .business,
                .individual,
                .publicInstitutions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .business: return "Business"
            case .individual: return "Individual"
            case .publicInstitutions: return "Government"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    public enum TaxRegistrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case pending
        case rejected
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [TaxRegistrationStatus] {
            return [
                .deleted,
                .pending,
                .rejected,
                .verified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "Deleted"
            case .pending: return "Pending"
            case .rejected: return "Rejected"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// The metadata for your tax document.
    public struct TaxDocumentMetadata: Swift.Sendable {
        /// The tax document access token, which contains information that the Tax Settings API uses to locate the tax document. If you update your tax registration, the existing taxDocumentAccessToken won't be valid. To get the latest token, call the GetTaxRegistration or ListTaxRegistrations API operation. This token is valid for 24 hours.
        /// This member is required.
        public var taxDocumentAccessToken: Swift.String?
        /// The name of your tax document.
        /// This member is required.
        public var taxDocumentName: Swift.String?

        public init(
            taxDocumentAccessToken: Swift.String? = nil,
            taxDocumentName: Swift.String? = nil
        ) {
            self.taxDocumentAccessToken = taxDocumentAccessToken
            self.taxDocumentName = taxDocumentName
        }
    }
}

extension TaxSettingsClientTypes {

    /// Your TRN information with jurisdiction details. This doesn't contain the full legal address associated with the TRN information.
    public struct TaxRegistrationWithJurisdiction: Swift.Sendable {
        /// Additional tax information associated with your TRN.
        public var additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoResponse?
        /// The email address to receive VAT invoices.
        public var certifiedEmailId: Swift.String?
        /// The jurisdiction associated with your TRN information.
        /// This member is required.
        public var jurisdiction: TaxSettingsClientTypes.Jurisdiction?
        /// The legal name associated with your TRN information.
        /// This member is required.
        public var legalName: Swift.String?
        /// Your tax registration unique identifier.
        /// This member is required.
        public var registrationId: Swift.String?
        /// The type of your tax registration. This can be either VAT or GST.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.TaxRegistrationType?
        /// The industry that describes your business. For business-to-business (B2B) customers, specify Business. For business-to-consumer (B2C) customers, specify Individual. For business-to-government (B2G), specify Government.Note that certain values may not applicable for the request country. Please refer to country specific information in API document.
        public var sector: TaxSettingsClientTypes.Sector?
        /// The status of your TRN. This can be either Verified, Pending, Deleted, or Rejected.
        /// This member is required.
        public var status: TaxSettingsClientTypes.TaxRegistrationStatus?
        /// The metadata for your tax document.
        public var taxDocumentMetadatas: [TaxSettingsClientTypes.TaxDocumentMetadata]?

        public init(
            additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoResponse? = nil,
            certifiedEmailId: Swift.String? = nil,
            jurisdiction: TaxSettingsClientTypes.Jurisdiction? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationType: TaxSettingsClientTypes.TaxRegistrationType? = nil,
            sector: TaxSettingsClientTypes.Sector? = nil,
            status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil,
            taxDocumentMetadatas: [TaxSettingsClientTypes.TaxDocumentMetadata]? = nil
        ) {
            self.additionalTaxInformation = additionalTaxInformation
            self.certifiedEmailId = certifiedEmailId
            self.jurisdiction = jurisdiction
            self.legalName = legalName
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.sector = sector
            self.status = status
            self.taxDocumentMetadatas = taxDocumentMetadatas
        }
    }
}

extension TaxSettingsClientTypes.TaxRegistrationWithJurisdiction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension TaxSettingsClientTypes {

    /// An object with your accountId and TRN information.
    public struct AccountDetails: Swift.Sendable {
        /// List of unique account identifiers.
        public var accountId: Swift.String?
        /// The meta data information associated with the account.
        public var accountMetaData: TaxSettingsClientTypes.AccountMetaData?
        /// Tax inheritance information associated with the account.
        public var taxInheritanceDetails: TaxSettingsClientTypes.TaxInheritanceDetails?
        /// Your TRN information. Instead of having full legal address, here TRN information will have jurisdiction details (for example, country code and state/region/province if applicable).
        public var taxRegistration: TaxSettingsClientTypes.TaxRegistrationWithJurisdiction?

        public init(
            accountId: Swift.String? = nil,
            accountMetaData: TaxSettingsClientTypes.AccountMetaData? = nil,
            taxInheritanceDetails: TaxSettingsClientTypes.TaxInheritanceDetails? = nil,
            taxRegistration: TaxSettingsClientTypes.TaxRegistrationWithJurisdiction? = nil
        ) {
            self.accountId = accountId
            self.accountMetaData = accountMetaData
            self.taxInheritanceDetails = taxInheritanceDetails
            self.taxRegistration = taxRegistration
        }
    }
}

extension TaxSettingsClientTypes.AccountDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension TaxSettingsClientTypes {

    /// Additional tax information associated with your tax registration number (TRN). Depending on the TRN for a specific country, you might need to specify this information when you set your TRN. You can only specify one of the following parameters and the value can't be empty. The parameter that you specify must match the country for the TRN, if available. For example, if you set a TRN in Canada for specific provinces, you must also specify the canadaAdditionalInfo parameter.
    public struct AdditionalInfoRequest: Swift.Sendable {
        /// Additional tax information associated with your TRN in Canada.
        public var canadaAdditionalInfo: TaxSettingsClientTypes.CanadaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Egypt.
        public var egyptAdditionalInfo: TaxSettingsClientTypes.EgyptAdditionalInfo?
        /// Additional tax information to specify for a TRN in Estonia.
        public var estoniaAdditionalInfo: TaxSettingsClientTypes.EstoniaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Georgia.
        public var georgiaAdditionalInfo: TaxSettingsClientTypes.GeorgiaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Greece.
        public var greeceAdditionalInfo: TaxSettingsClientTypes.GreeceAdditionalInfo?
        ///
        public var indonesiaAdditionalInfo: TaxSettingsClientTypes.IndonesiaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Israel.
        public var israelAdditionalInfo: TaxSettingsClientTypes.IsraelAdditionalInfo?
        /// Additional tax information to specify for a TRN in Italy.
        public var italyAdditionalInfo: TaxSettingsClientTypes.ItalyAdditionalInfo?
        /// Additional tax information to specify for a TRN in Kenya.
        public var kenyaAdditionalInfo: TaxSettingsClientTypes.KenyaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Malaysia.
        public var malaysiaAdditionalInfo: TaxSettingsClientTypes.MalaysiaAdditionalInfo?
        /// Additional tax information associated with your TRN in Poland.
        public var polandAdditionalInfo: TaxSettingsClientTypes.PolandAdditionalInfo?
        /// Additional tax information to specify for a TRN in Romania.
        public var romaniaAdditionalInfo: TaxSettingsClientTypes.RomaniaAdditionalInfo?
        /// Additional tax information associated with your TRN in Saudi Arabia.
        public var saudiArabiaAdditionalInfo: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo?
        /// Additional tax information to specify for a TRN in South Korea.
        public var southKoreaAdditionalInfo: TaxSettingsClientTypes.SouthKoreaAdditionalInfo?
        /// Additional tax information to specify for a TRN in Spain.
        public var spainAdditionalInfo: TaxSettingsClientTypes.SpainAdditionalInfo?
        /// Additional tax information to specify for a TRN in Turkey.
        public var turkeyAdditionalInfo: TaxSettingsClientTypes.TurkeyAdditionalInfo?
        /// Additional tax information associated with your TRN in Ukraine.
        public var ukraineAdditionalInfo: TaxSettingsClientTypes.UkraineAdditionalInfo?
        /// Additional tax information to specify for a TRN in Uzbekistan.
        public var uzbekistanAdditionalInfo: TaxSettingsClientTypes.UzbekistanAdditionalInfo?
        /// Additional tax information to specify for a TRN in Vietnam.
        public var vietnamAdditionalInfo: TaxSettingsClientTypes.VietnamAdditionalInfo?

        public init(
            canadaAdditionalInfo: TaxSettingsClientTypes.CanadaAdditionalInfo? = nil,
            egyptAdditionalInfo: TaxSettingsClientTypes.EgyptAdditionalInfo? = nil,
            estoniaAdditionalInfo: TaxSettingsClientTypes.EstoniaAdditionalInfo? = nil,
            georgiaAdditionalInfo: TaxSettingsClientTypes.GeorgiaAdditionalInfo? = nil,
            greeceAdditionalInfo: TaxSettingsClientTypes.GreeceAdditionalInfo? = nil,
            indonesiaAdditionalInfo: TaxSettingsClientTypes.IndonesiaAdditionalInfo? = nil,
            israelAdditionalInfo: TaxSettingsClientTypes.IsraelAdditionalInfo? = nil,
            italyAdditionalInfo: TaxSettingsClientTypes.ItalyAdditionalInfo? = nil,
            kenyaAdditionalInfo: TaxSettingsClientTypes.KenyaAdditionalInfo? = nil,
            malaysiaAdditionalInfo: TaxSettingsClientTypes.MalaysiaAdditionalInfo? = nil,
            polandAdditionalInfo: TaxSettingsClientTypes.PolandAdditionalInfo? = nil,
            romaniaAdditionalInfo: TaxSettingsClientTypes.RomaniaAdditionalInfo? = nil,
            saudiArabiaAdditionalInfo: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo? = nil,
            southKoreaAdditionalInfo: TaxSettingsClientTypes.SouthKoreaAdditionalInfo? = nil,
            spainAdditionalInfo: TaxSettingsClientTypes.SpainAdditionalInfo? = nil,
            turkeyAdditionalInfo: TaxSettingsClientTypes.TurkeyAdditionalInfo? = nil,
            ukraineAdditionalInfo: TaxSettingsClientTypes.UkraineAdditionalInfo? = nil,
            uzbekistanAdditionalInfo: TaxSettingsClientTypes.UzbekistanAdditionalInfo? = nil,
            vietnamAdditionalInfo: TaxSettingsClientTypes.VietnamAdditionalInfo? = nil
        ) {
            self.canadaAdditionalInfo = canadaAdditionalInfo
            self.egyptAdditionalInfo = egyptAdditionalInfo
            self.estoniaAdditionalInfo = estoniaAdditionalInfo
            self.georgiaAdditionalInfo = georgiaAdditionalInfo
            self.greeceAdditionalInfo = greeceAdditionalInfo
            self.indonesiaAdditionalInfo = indonesiaAdditionalInfo
            self.israelAdditionalInfo = israelAdditionalInfo
            self.italyAdditionalInfo = italyAdditionalInfo
            self.kenyaAdditionalInfo = kenyaAdditionalInfo
            self.malaysiaAdditionalInfo = malaysiaAdditionalInfo
            self.polandAdditionalInfo = polandAdditionalInfo
            self.romaniaAdditionalInfo = romaniaAdditionalInfo
            self.saudiArabiaAdditionalInfo = saudiArabiaAdditionalInfo
            self.southKoreaAdditionalInfo = southKoreaAdditionalInfo
            self.spainAdditionalInfo = spainAdditionalInfo
            self.turkeyAdditionalInfo = turkeyAdditionalInfo
            self.ukraineAdditionalInfo = ukraineAdditionalInfo
            self.uzbekistanAdditionalInfo = uzbekistanAdditionalInfo
            self.vietnamAdditionalInfo = vietnamAdditionalInfo
        }
    }
}

/// Failed to upload the tax exemption document to Amazon Web ServicesSupport case.
public struct AttachmentUploadException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AttachmentUploadException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension AttachmentUploadException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentUploadException(message: \"CONTENT_REDACTED\")"}
}

extension TaxSettingsClientTypes {

    /// The address domain associate with the tax information.
    public struct Authority: Swift.Sendable {
        /// The country code for the country that the address is in.
        /// This member is required.
        public var country: Swift.String?
        /// The state that the address is located.
        public var state: Swift.String?

        public init(
            country: Swift.String? = nil,
            state: Swift.String? = nil
        ) {
            self.country = country
            self.state = state
        }
    }
}

/// The exception when the input is creating conflict with the given state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// 409
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(errorCode: \(Swift.String(describing: properties.errorCode)), message: \"CONTENT_REDACTED\")"}
}

/// The exception thrown when an unexpected error occurs when processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// 500
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(errorCode: \(Swift.String(describing: properties.errorCode)), message: \"CONTENT_REDACTED\")"}
}

extension TaxSettingsClientTypes {

    public enum ValidationExceptionErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case expiredToken
        case fieldValidationFailed
        case invalidToken
        case malformedToken
        case missingInput
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionErrorCode] {
            return [
                .expiredToken,
                .fieldValidationFailed,
                .invalidToken,
                .malformedToken,
                .missingInput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .expiredToken: return "ExpiredToken"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .invalidToken: return "InvalidToken"
            case .malformedToken: return "MalformedToken"
            case .missingInput: return "MissingInput"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// The information about the specified parameter in the request that caused an error.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The name of the parameter that caused a ValidationException error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

/// The exception when the input doesn't pass validation for at least one of the input parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// 400
        /// This member is required.
        public internal(set) var errorCode: TaxSettingsClientTypes.ValidationExceptionErrorCode? = nil
        /// 400
        public internal(set) var fieldList: [TaxSettingsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: TaxSettingsClientTypes.ValidationExceptionErrorCode? = nil,
        fieldList: [TaxSettingsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(errorCode: \(Swift.String(describing: properties.errorCode)), fieldList: \(Swift.String(describing: properties.fieldList)), message: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteTaxRegistrationInput: Swift.Sendable {
    /// List of unique account identifiers.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
    }
}

extension TaxSettingsClientTypes {

    /// The error object for representing failures in the BatchDeleteTaxRegistration operation.
    public struct BatchDeleteTaxRegistrationError: Swift.Sendable {
        /// The unique account identifier for the account whose tax registration couldn't be deleted during the BatchDeleteTaxRegistration operation.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code for an individual failure in BatchDeleteTaxRegistration operation.
        public var code: Swift.String?
        /// The error message for an individual failure in the BatchDeleteTaxRegistration operation.
        /// This member is required.
        public var message: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.code = code
            self.message = message
        }
    }
}

extension TaxSettingsClientTypes.BatchDeleteTaxRegistrationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteTaxRegistrationError(accountId: \(Swift.String(describing: accountId)), code: \(Swift.String(describing: code)), message: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteTaxRegistrationOutput: Swift.Sendable {
    /// The list of errors for the accounts the TRN information could not be deleted for.
    /// This member is required.
    public var errors: [TaxSettingsClientTypes.BatchDeleteTaxRegistrationError]?

    public init(
        errors: [TaxSettingsClientTypes.BatchDeleteTaxRegistrationError]? = nil
    ) {
        self.errors = errors
    }
}

/// The exception thrown when the input doesn't have a resource associated to it.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// 404
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(errorCode: \(Swift.String(describing: properties.errorCode)), message: \"CONTENT_REDACTED\")"}
}

public struct BatchGetTaxExemptionsInput: Swift.Sendable {
    /// List of unique account identifiers.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
    }
}

extension TaxSettingsClientTypes {

    public enum EntityExemptionAccountStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case expired
        case `none`
        case pending
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityExemptionAccountStatus] {
            return [
                .expired,
                .none,
                .pending,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .expired: return "Expired"
            case .none: return "None"
            case .pending: return "Pending"
            case .valid: return "Valid"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// The tax exemption type.
    public struct TaxExemptionType: Swift.Sendable {
        /// The tax exemption's applicable jurisdictions.
        public var applicableJurisdictions: [TaxSettingsClientTypes.Authority]?
        /// The tax exemption's type description.
        public var description: Swift.String?
        /// The tax exemption's type display name.
        public var displayName: Swift.String?

        public init(
            applicableJurisdictions: [TaxSettingsClientTypes.Authority]? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil
        ) {
            self.applicableJurisdictions = applicableJurisdictions
            self.description = description
            self.displayName = displayName
        }
    }
}

extension TaxSettingsClientTypes {

    /// The tax exemption.
    public struct TaxExemption: Swift.Sendable {
        /// The address domain associate with tax exemption.
        /// This member is required.
        public var authority: TaxSettingsClientTypes.Authority?
        /// The tax exemption effective date.
        public var effectiveDate: Foundation.Date?
        /// The tax exemption expiration date.
        public var expirationDate: Foundation.Date?
        /// The tax exemption status.
        public var status: TaxSettingsClientTypes.EntityExemptionAccountStatus?
        /// The tax exemption recording time in the TaxSettings system.
        public var systemEffectiveDate: Foundation.Date?
        /// The tax exemption type.
        /// This member is required.
        public var taxExemptionType: TaxSettingsClientTypes.TaxExemptionType?

        public init(
            authority: TaxSettingsClientTypes.Authority? = nil,
            effectiveDate: Foundation.Date? = nil,
            expirationDate: Foundation.Date? = nil,
            status: TaxSettingsClientTypes.EntityExemptionAccountStatus? = nil,
            systemEffectiveDate: Foundation.Date? = nil,
            taxExemptionType: TaxSettingsClientTypes.TaxExemptionType? = nil
        ) {
            self.authority = authority
            self.effectiveDate = effectiveDate
            self.expirationDate = expirationDate
            self.status = status
            self.systemEffectiveDate = systemEffectiveDate
            self.taxExemptionType = taxExemptionType
        }
    }
}

extension TaxSettingsClientTypes {

    /// The tax exemption details.
    public struct TaxExemptionDetails: Swift.Sendable {
        /// The indicator if the tax exemption is inherited from the consolidated billing family management account.
        public var heritageObtainedDetails: Swift.Bool?
        /// The consolidated billing family management account the tax exemption inherited from.
        public var heritageObtainedParentEntity: Swift.String?
        /// The reason of the heritage inheritance.
        public var heritageObtainedReason: Swift.String?
        /// Tax exemptions.
        public var taxExemptions: [TaxSettingsClientTypes.TaxExemption]?

        public init(
            heritageObtainedDetails: Swift.Bool? = nil,
            heritageObtainedParentEntity: Swift.String? = nil,
            heritageObtainedReason: Swift.String? = nil,
            taxExemptions: [TaxSettingsClientTypes.TaxExemption]? = nil
        ) {
            self.heritageObtainedDetails = heritageObtainedDetails
            self.heritageObtainedParentEntity = heritageObtainedParentEntity
            self.heritageObtainedReason = heritageObtainedReason
            self.taxExemptions = taxExemptions
        }
    }
}

public struct BatchGetTaxExemptionsOutput: Swift.Sendable {
    /// The list of accounts that failed to get tax exemptions.
    public var failedAccounts: [Swift.String]?
    /// The tax exemption details map of accountId and tax exemption details.
    public var taxExemptionDetailsMap: [Swift.String: TaxSettingsClientTypes.TaxExemptionDetails]?

    public init(
        failedAccounts: [Swift.String]? = nil,
        taxExemptionDetailsMap: [Swift.String: TaxSettingsClientTypes.TaxExemptionDetails]? = nil
    ) {
        self.failedAccounts = failedAccounts
        self.taxExemptionDetailsMap = taxExemptionDetailsMap
    }
}

extension TaxSettingsClientTypes {

    /// The tax registration document.
    public struct TaxRegistrationDocFile: Swift.Sendable {
        /// The tax registration document content.
        /// This member is required.
        public var fileContent: Foundation.Data?
        /// The tax registration document name.
        /// This member is required.
        public var fileName: Swift.String?

        public init(
            fileContent: Foundation.Data? = nil,
            fileName: Swift.String? = nil
        ) {
            self.fileContent = fileContent
            self.fileName = fileName
        }
    }
}

extension TaxSettingsClientTypes {

    /// The Amazon S3 bucket in your account where your tax document is located.
    public struct SourceS3Location: Swift.Sendable {
        /// The name of your Amazon S3 bucket that your tax document is located.
        /// This member is required.
        public var bucket: Swift.String?
        /// The object key of your tax document object in Amazon S3.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        ) {
            self.bucket = bucket
            self.key = key
        }
    }
}

extension TaxSettingsClientTypes {

    /// Tax registration document information.
    public struct TaxRegistrationDocument: Swift.Sendable {
        /// The tax registration document.
        public var file: TaxSettingsClientTypes.TaxRegistrationDocFile?
        /// The Amazon S3 location where your tax registration document is stored.
        public var s3Location: TaxSettingsClientTypes.SourceS3Location?

        public init(
            file: TaxSettingsClientTypes.TaxRegistrationDocFile? = nil,
            s3Location: TaxSettingsClientTypes.SourceS3Location? = nil
        ) {
            self.file = file
            self.s3Location = s3Location
        }
    }
}

extension TaxSettingsClientTypes {

    /// Required information to verify your TRN.
    public struct VerificationDetails: Swift.Sendable {
        /// Date of birth to verify your submitted TRN. Use the YYYY-MM-DD format.
        public var dateOfBirth: Swift.String?
        /// The tax registration document, which is required for specific countries such as Bangladesh, Kenya, South Korea and Spain.
        public var taxRegistrationDocuments: [TaxSettingsClientTypes.TaxRegistrationDocument]?

        public init(
            dateOfBirth: Swift.String? = nil,
            taxRegistrationDocuments: [TaxSettingsClientTypes.TaxRegistrationDocument]? = nil
        ) {
            self.dateOfBirth = dateOfBirth
            self.taxRegistrationDocuments = taxRegistrationDocuments
        }
    }
}

extension TaxSettingsClientTypes {

    /// The TRN information you provide when you add a new TRN, or update.
    public struct TaxRegistrationEntry: Swift.Sendable {
        /// Additional tax information associated with your TRN. You only need to specify this parameter if Amazon Web Services collects any additional information for your country within [AdditionalInfoRequest].
        public var additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoRequest?
        /// The email address to receive VAT invoices.
        public var certifiedEmailId: Swift.String?
        /// The legal address associated with your TRN. If you're setting a TRN in Brazil for the CNPJ tax type, you don't need to specify the legal address. For TRNs in other countries and for CPF tax types Brazil, you must specify the legal address.
        public var legalAddress: TaxSettingsClientTypes.Address?
        /// The legal name associated with your TRN. If you're setting a TRN in Brazil, you don't need to specify the legal name. For TRNs in other countries, you must specify the legal name.
        public var legalName: Swift.String?
        /// Your tax registration unique identifier.
        /// This member is required.
        public var registrationId: Swift.String?
        /// Your tax registration type. This can be either VAT or GST.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.TaxRegistrationType?
        /// The industry that describes your business. For business-to-business (B2B) customers, specify Business. For business-to-consumer (B2C) customers, specify Individual. For business-to-government (B2G), specify Government.Note that certain values may not applicable for the request country. Please refer to country specific information in API document.
        public var sector: TaxSettingsClientTypes.Sector?
        /// Additional details needed to verify your TRN information in Brazil. You only need to specify this parameter when you set a TRN in Brazil that is the CPF tax type. Don't specify this parameter to set a TRN in Brazil of the CNPJ tax type or to set a TRN for another country.
        public var verificationDetails: TaxSettingsClientTypes.VerificationDetails?

        public init(
            additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoRequest? = nil,
            certifiedEmailId: Swift.String? = nil,
            legalAddress: TaxSettingsClientTypes.Address? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationType: TaxSettingsClientTypes.TaxRegistrationType? = nil,
            sector: TaxSettingsClientTypes.Sector? = nil,
            verificationDetails: TaxSettingsClientTypes.VerificationDetails? = nil
        ) {
            self.additionalTaxInformation = additionalTaxInformation
            self.certifiedEmailId = certifiedEmailId
            self.legalAddress = legalAddress
            self.legalName = legalName
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.sector = sector
            self.verificationDetails = verificationDetails
        }
    }
}

extension TaxSettingsClientTypes.TaxRegistrationEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct BatchPutTaxRegistrationInput: Swift.Sendable {
    /// List of unique account identifiers.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Your TRN information that will be stored to the accounts mentioned in putEntries.
    /// This member is required.
    public var taxRegistrationEntry: TaxSettingsClientTypes.TaxRegistrationEntry?

    public init(
        accountIds: [Swift.String]? = nil,
        taxRegistrationEntry: TaxSettingsClientTypes.TaxRegistrationEntry? = nil
    ) {
        self.accountIds = accountIds
        self.taxRegistrationEntry = taxRegistrationEntry
    }
}

extension BatchPutTaxRegistrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutTaxRegistrationInput(accountIds: \(Swift.String(describing: accountIds)), taxRegistrationEntry: \"CONTENT_REDACTED\")"}
}

extension TaxSettingsClientTypes {

    /// The error object for representing failures in the BatchPutTaxRegistration operation.
    public struct BatchPutTaxRegistrationError: Swift.Sendable {
        /// The unique account identifier for the account that the tax registration couldn't be added, or updated during the BatchPutTaxRegistration operation.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code for an individual failure in the BatchPutTaxRegistration operation.
        public var code: Swift.String?
        /// The error message for an individual failure in the BatchPutTaxRegistration operation.
        /// This member is required.
        public var message: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.code = code
            self.message = message
        }
    }
}

extension TaxSettingsClientTypes.BatchPutTaxRegistrationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutTaxRegistrationError(accountId: \(Swift.String(describing: accountId)), code: \(Swift.String(describing: code)), message: \"CONTENT_REDACTED\")"}
}

public struct BatchPutTaxRegistrationOutput: Swift.Sendable {
    /// List of errors for the accounts the TRN information could not be added or updated to.
    /// This member is required.
    public var errors: [TaxSettingsClientTypes.BatchPutTaxRegistrationError]?
    /// The status of your TRN stored in the system after processing. Based on the validation occurring on the TRN, the status can be Verified, Pending or Rejected.
    public var status: TaxSettingsClientTypes.TaxRegistrationStatus?

    public init(
        errors: [TaxSettingsClientTypes.BatchPutTaxRegistrationError]? = nil,
        status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil
    ) {
        self.errors = errors
        self.status = status
    }
}

/// You've exceeded the Amazon Web ServicesSupport case creation limit for your account.
public struct CaseCreationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CaseCreationLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension CaseCreationLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseCreationLimitExceededException(message: \"CONTENT_REDACTED\")"}
}

public struct DeleteSupplementalTaxRegistrationInput: Swift.Sendable {
    /// The unique authority Id for the supplemental TRN information that needs to be deleted.
    /// This member is required.
    public var authorityId: Swift.String?

    public init(
        authorityId: Swift.String? = nil
    ) {
        self.authorityId = authorityId
    }
}

public struct DeleteSupplementalTaxRegistrationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTaxRegistrationInput: Swift.Sendable {
    /// Unique account identifier for the TRN information that needs to be deleted. If this isn't passed, the account ID corresponding to the credentials of the API caller will be used for this parameter.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    ) {
        self.accountId = accountId
    }
}

public struct DeleteTaxRegistrationOutput: Swift.Sendable {

    public init() { }
}

extension TaxSettingsClientTypes {

    /// The location of the Amazon S3 bucket that you specify to download your tax documents to.
    public struct DestinationS3Location: Swift.Sendable {
        /// The name of your Amazon S3 bucket that you specify to download your tax documents to.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon S3 object prefix that you specify for your tax document file.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        ) {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension TaxSettingsClientTypes {

    /// The exemption certificate.
    public struct ExemptionCertificate: Swift.Sendable {
        /// The exemption certificate file content.
        /// This member is required.
        public var documentFile: Foundation.Data?
        /// The exemption certificate file name.
        /// This member is required.
        public var documentName: Swift.String?

        public init(
            documentFile: Foundation.Data? = nil,
            documentName: Swift.String? = nil
        ) {
            self.documentFile = documentFile
            self.documentName = documentName
        }
    }
}

public struct GetTaxExemptionTypesInput: Swift.Sendable {

    public init() { }
}

public struct GetTaxExemptionTypesOutput: Swift.Sendable {
    /// The supported types of tax exemptions.
    public var taxExemptionTypes: [TaxSettingsClientTypes.TaxExemptionType]?

    public init(
        taxExemptionTypes: [TaxSettingsClientTypes.TaxExemptionType]? = nil
    ) {
        self.taxExemptionTypes = taxExemptionTypes
    }
}

public struct GetTaxInheritanceInput: Swift.Sendable {

    public init() { }
}

extension TaxSettingsClientTypes {

    public enum HeritageStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case optin
        case optout
        case sdkUnknown(Swift.String)

        public static var allCases: [HeritageStatus] {
            return [
                .optin,
                .optout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optin: return "OptIn"
            case .optout: return "OptOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTaxInheritanceOutput: Swift.Sendable {
    /// The tax inheritance status.
    public var heritageStatus: TaxSettingsClientTypes.HeritageStatus?

    public init(
        heritageStatus: TaxSettingsClientTypes.HeritageStatus? = nil
    ) {
        self.heritageStatus = heritageStatus
    }
}

public struct GetTaxRegistrationInput: Swift.Sendable {
    /// Your unique account identifier.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    ) {
        self.accountId = accountId
    }
}

extension TaxSettingsClientTypes {

    /// Your TRN information.
    public struct TaxRegistration: Swift.Sendable {
        /// Additional tax information associated with your TRN.
        public var additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoResponse?
        /// The email address to receive VAT invoices.
        public var certifiedEmailId: Swift.String?
        /// The legal address associated with your TRN registration.
        /// This member is required.
        public var legalAddress: TaxSettingsClientTypes.Address?
        /// The legal name associated with your TRN registration.
        /// This member is required.
        public var legalName: Swift.String?
        /// Your tax registration unique identifier.
        /// This member is required.
        public var registrationId: Swift.String?
        /// Type of your tax registration.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.TaxRegistrationType?
        /// The industry that describes your business. For business-to-business (B2B) customers, specify Business. For business-to-consumer (B2C) customers, specify Individual. For business-to-government (B2G), specify Government. Note that certain values may not applicable for the request country. Please refer to country specific information in API document.
        public var sector: TaxSettingsClientTypes.Sector?
        /// The status of your TRN. This can be either Verified, Pending, Deleted, or Rejected.
        /// This member is required.
        public var status: TaxSettingsClientTypes.TaxRegistrationStatus?
        /// The metadata for your tax document.
        public var taxDocumentMetadatas: [TaxSettingsClientTypes.TaxDocumentMetadata]?

        public init(
            additionalTaxInformation: TaxSettingsClientTypes.AdditionalInfoResponse? = nil,
            certifiedEmailId: Swift.String? = nil,
            legalAddress: TaxSettingsClientTypes.Address? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationType: TaxSettingsClientTypes.TaxRegistrationType? = nil,
            sector: TaxSettingsClientTypes.Sector? = nil,
            status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil,
            taxDocumentMetadatas: [TaxSettingsClientTypes.TaxDocumentMetadata]? = nil
        ) {
            self.additionalTaxInformation = additionalTaxInformation
            self.certifiedEmailId = certifiedEmailId
            self.legalAddress = legalAddress
            self.legalName = legalName
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.sector = sector
            self.status = status
            self.taxDocumentMetadatas = taxDocumentMetadatas
        }
    }
}

extension TaxSettingsClientTypes.TaxRegistration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetTaxRegistrationOutput: Swift.Sendable {
    /// TRN information of the account mentioned in the request.
    public var taxRegistration: TaxSettingsClientTypes.TaxRegistration?

    public init(
        taxRegistration: TaxSettingsClientTypes.TaxRegistration? = nil
    ) {
        self.taxRegistration = taxRegistration
    }
}

extension GetTaxRegistrationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTaxRegistrationOutput(taxRegistration: \"CONTENT_REDACTED\")"}
}

public struct GetTaxRegistrationDocumentInput: Swift.Sendable {
    /// The Amazon S3 bucket that you specify to download your tax documents to.
    public var destinationS3Location: TaxSettingsClientTypes.DestinationS3Location?
    /// The metadata for your tax document.
    /// This member is required.
    public var taxDocumentMetadata: TaxSettingsClientTypes.TaxDocumentMetadata?

    public init(
        destinationS3Location: TaxSettingsClientTypes.DestinationS3Location? = nil,
        taxDocumentMetadata: TaxSettingsClientTypes.TaxDocumentMetadata? = nil
    ) {
        self.destinationS3Location = destinationS3Location
        self.taxDocumentMetadata = taxDocumentMetadata
    }
}

public struct GetTaxRegistrationDocumentOutput: Swift.Sendable {
    /// The file path of the Amazon S3 bucket where you want to download your tax document to.
    public var destinationFilePath: Swift.String?
    /// The Amazon S3 presigned URL of the tax registration document.
    public var presignedS3Url: Swift.String?

    public init(
        destinationFilePath: Swift.String? = nil,
        presignedS3Url: Swift.String? = nil
    ) {
        self.destinationFilePath = destinationFilePath
        self.presignedS3Url = presignedS3Url
    }
}

public struct ListSupplementalTaxRegistrationsInput: Swift.Sendable {
    /// The number of taxRegistrations results you want in one response.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension TaxSettingsClientTypes {

    public enum SupplementalTaxRegistrationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vat
        case sdkUnknown(Swift.String)

        public static var allCases: [SupplementalTaxRegistrationType] {
            return [
                .vat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vat: return "VAT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TaxSettingsClientTypes {

    /// Supplemental TRN details.
    public struct SupplementalTaxRegistration: Swift.Sendable {
        /// The details of the address associated with the TRN information.
        /// This member is required.
        public var address: TaxSettingsClientTypes.Address?
        /// Unique authority ID for the supplemental TRN.
        /// This member is required.
        public var authorityId: Swift.String?
        /// The legal name associated with your TRN registration.
        /// This member is required.
        public var legalName: Swift.String?
        /// The supplemental TRN unique identifier.
        /// This member is required.
        public var registrationId: Swift.String?
        /// Type of supplemental TRN. Currently, this can only be VAT.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.SupplementalTaxRegistrationType?
        /// The status of your TRN.
        /// This member is required.
        public var status: TaxSettingsClientTypes.TaxRegistrationStatus?

        public init(
            address: TaxSettingsClientTypes.Address? = nil,
            authorityId: Swift.String? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationType: TaxSettingsClientTypes.SupplementalTaxRegistrationType? = nil,
            status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil
        ) {
            self.address = address
            self.authorityId = authorityId
            self.legalName = legalName
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.status = status
        }
    }
}

extension TaxSettingsClientTypes.SupplementalTaxRegistration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct ListSupplementalTaxRegistrationsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of supplemental tax registrations.
    /// This member is required.
    public var taxRegistrations: [TaxSettingsClientTypes.SupplementalTaxRegistration]?

    public init(
        nextToken: Swift.String? = nil,
        taxRegistrations: [TaxSettingsClientTypes.SupplementalTaxRegistration]? = nil
    ) {
        self.nextToken = nextToken
        self.taxRegistrations = taxRegistrations
    }
}

extension ListSupplementalTaxRegistrationsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSupplementalTaxRegistrationsOutput(nextToken: \(Swift.String(describing: nextToken)), taxRegistrations: \"CONTENT_REDACTED\")"}
}

public struct ListTaxExemptionsInput: Swift.Sendable {
    /// The number of results you want in one response.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTaxExemptionsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The tax exemption details map of accountId and tax exemption details.
    public var taxExemptionDetailsMap: [Swift.String: TaxSettingsClientTypes.TaxExemptionDetails]?

    public init(
        nextToken: Swift.String? = nil,
        taxExemptionDetailsMap: [Swift.String: TaxSettingsClientTypes.TaxExemptionDetails]? = nil
    ) {
        self.nextToken = nextToken
        self.taxExemptionDetailsMap = taxExemptionDetailsMap
    }
}

public struct ListTaxRegistrationsInput: Swift.Sendable {
    /// Number of accountDetails results you want in one response.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTaxRegistrationsOutput: Swift.Sendable {
    /// The list of account details. This contains account Ids and TRN Information for each of the linked accounts.
    /// This member is required.
    public var accountDetails: [TaxSettingsClientTypes.AccountDetails]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        accountDetails: [TaxSettingsClientTypes.AccountDetails]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.accountDetails = accountDetails
        self.nextToken = nextToken
    }
}

extension ListTaxRegistrationsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTaxRegistrationsOutput(nextToken: \(Swift.String(describing: nextToken)), accountDetails: \"CONTENT_REDACTED\")"}
}

extension TaxSettingsClientTypes {

    /// The supplemental TRN information to provide when adding or updating a supplemental TRN.
    public struct SupplementalTaxRegistrationEntry: Swift.Sendable {
        /// The details of the address associated with the TRN information.
        /// This member is required.
        public var address: TaxSettingsClientTypes.Address?
        /// The legal name associated with your TRN registration.
        /// This member is required.
        public var legalName: Swift.String?
        /// The supplemental TRN unique identifier.
        /// This member is required.
        public var registrationId: Swift.String?
        /// Type of supplemental TRN. Currently, this can only be VAT.
        /// This member is required.
        public var registrationType: TaxSettingsClientTypes.SupplementalTaxRegistrationType?

        public init(
            address: TaxSettingsClientTypes.Address? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationType: TaxSettingsClientTypes.SupplementalTaxRegistrationType? = nil
        ) {
            self.address = address
            self.legalName = legalName
            self.registrationId = registrationId
            self.registrationType = registrationType
        }
    }
}

extension TaxSettingsClientTypes.SupplementalTaxRegistrationEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct PutSupplementalTaxRegistrationInput: Swift.Sendable {
    /// The supplemental TRN information that will be stored for the caller account ID.
    /// This member is required.
    public var taxRegistrationEntry: TaxSettingsClientTypes.SupplementalTaxRegistrationEntry?

    public init(
        taxRegistrationEntry: TaxSettingsClientTypes.SupplementalTaxRegistrationEntry? = nil
    ) {
        self.taxRegistrationEntry = taxRegistrationEntry
    }
}

extension PutSupplementalTaxRegistrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSupplementalTaxRegistrationInput(taxRegistrationEntry: \"CONTENT_REDACTED\")"}
}

public struct PutSupplementalTaxRegistrationOutput: Swift.Sendable {
    /// Unique authority ID for the supplemental TRN information that was stored.
    /// This member is required.
    public var authorityId: Swift.String?
    /// The status of the supplemental TRN stored in the system after processing. Based on the validation occurring on the TRN, the status can be Verified, Pending, Rejected, or Deleted.
    /// This member is required.
    public var status: TaxSettingsClientTypes.TaxRegistrationStatus?

    public init(
        authorityId: Swift.String? = nil,
        status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil
    ) {
        self.authorityId = authorityId
        self.status = status
    }
}

public struct PutTaxExemptionInput: Swift.Sendable {
    /// The list of unique account identifiers.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The address domain associate with the tax information.
    /// This member is required.
    public var authority: TaxSettingsClientTypes.Authority?
    /// The exemption certificate.
    /// This member is required.
    public var exemptionCertificate: TaxSettingsClientTypes.ExemptionCertificate?
    /// The exemption type. Use the supported tax exemption type description.
    /// This member is required.
    public var exemptionType: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        authority: TaxSettingsClientTypes.Authority? = nil,
        exemptionCertificate: TaxSettingsClientTypes.ExemptionCertificate? = nil,
        exemptionType: Swift.String? = nil
    ) {
        self.accountIds = accountIds
        self.authority = authority
        self.exemptionCertificate = exemptionCertificate
        self.exemptionType = exemptionType
    }
}

public struct PutTaxExemptionOutput: Swift.Sendable {
    /// The customer support case ID.
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    ) {
        self.caseId = caseId
    }
}

public struct PutTaxInheritanceInput: Swift.Sendable {
    /// The tax inheritance status.
    public var heritageStatus: TaxSettingsClientTypes.HeritageStatus?

    public init(
        heritageStatus: TaxSettingsClientTypes.HeritageStatus? = nil
    ) {
        self.heritageStatus = heritageStatus
    }
}

public struct PutTaxInheritanceOutput: Swift.Sendable {

    public init() { }
}

public struct PutTaxRegistrationInput: Swift.Sendable {
    /// Your unique account identifier.
    public var accountId: Swift.String?
    /// Your TRN information that will be stored to the account mentioned in accountId.
    /// This member is required.
    public var taxRegistrationEntry: TaxSettingsClientTypes.TaxRegistrationEntry?

    public init(
        accountId: Swift.String? = nil,
        taxRegistrationEntry: TaxSettingsClientTypes.TaxRegistrationEntry? = nil
    ) {
        self.accountId = accountId
        self.taxRegistrationEntry = taxRegistrationEntry
    }
}

extension PutTaxRegistrationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutTaxRegistrationInput(accountId: \(Swift.String(describing: accountId)), taxRegistrationEntry: \"CONTENT_REDACTED\")"}
}

public struct PutTaxRegistrationOutput: Swift.Sendable {
    /// The status of your TRN stored in the system after processing. Based on the validation occurring on the TRN, the status can be Verified, Pending or Rejected.
    public var status: TaxSettingsClientTypes.TaxRegistrationStatus?

    public init(
        status: TaxSettingsClientTypes.TaxRegistrationStatus? = nil
    ) {
        self.status = status
    }
}

extension BatchDeleteTaxRegistrationInput {

    static func urlPathProvider(_ value: BatchDeleteTaxRegistrationInput) -> Swift.String? {
        return "/BatchDeleteTaxRegistration"
    }
}

extension BatchGetTaxExemptionsInput {

    static func urlPathProvider(_ value: BatchGetTaxExemptionsInput) -> Swift.String? {
        return "/BatchGetTaxExemptions"
    }
}

extension BatchPutTaxRegistrationInput {

    static func urlPathProvider(_ value: BatchPutTaxRegistrationInput) -> Swift.String? {
        return "/BatchPutTaxRegistration"
    }
}

extension DeleteSupplementalTaxRegistrationInput {

    static func urlPathProvider(_ value: DeleteSupplementalTaxRegistrationInput) -> Swift.String? {
        return "/DeleteSupplementalTaxRegistration"
    }
}

extension DeleteTaxRegistrationInput {

    static func urlPathProvider(_ value: DeleteTaxRegistrationInput) -> Swift.String? {
        return "/DeleteTaxRegistration"
    }
}

extension GetTaxExemptionTypesInput {

    static func urlPathProvider(_ value: GetTaxExemptionTypesInput) -> Swift.String? {
        return "/GetTaxExemptionTypes"
    }
}

extension GetTaxInheritanceInput {

    static func urlPathProvider(_ value: GetTaxInheritanceInput) -> Swift.String? {
        return "/GetTaxInheritance"
    }
}

extension GetTaxRegistrationInput {

    static func urlPathProvider(_ value: GetTaxRegistrationInput) -> Swift.String? {
        return "/GetTaxRegistration"
    }
}

extension GetTaxRegistrationDocumentInput {

    static func urlPathProvider(_ value: GetTaxRegistrationDocumentInput) -> Swift.String? {
        return "/GetTaxRegistrationDocument"
    }
}

extension ListSupplementalTaxRegistrationsInput {

    static func urlPathProvider(_ value: ListSupplementalTaxRegistrationsInput) -> Swift.String? {
        return "/ListSupplementalTaxRegistrations"
    }
}

extension ListTaxExemptionsInput {

    static func urlPathProvider(_ value: ListTaxExemptionsInput) -> Swift.String? {
        return "/ListTaxExemptions"
    }
}

extension ListTaxRegistrationsInput {

    static func urlPathProvider(_ value: ListTaxRegistrationsInput) -> Swift.String? {
        return "/ListTaxRegistrations"
    }
}

extension PutSupplementalTaxRegistrationInput {

    static func urlPathProvider(_ value: PutSupplementalTaxRegistrationInput) -> Swift.String? {
        return "/PutSupplementalTaxRegistration"
    }
}

extension PutTaxExemptionInput {

    static func urlPathProvider(_ value: PutTaxExemptionInput) -> Swift.String? {
        return "/PutTaxExemption"
    }
}

extension PutTaxInheritanceInput {

    static func urlPathProvider(_ value: PutTaxInheritanceInput) -> Swift.String? {
        return "/PutTaxInheritance"
    }
}

extension PutTaxRegistrationInput {

    static func urlPathProvider(_ value: PutTaxRegistrationInput) -> Swift.String? {
        return "/PutTaxRegistration"
    }
}

extension BatchDeleteTaxRegistrationInput {

    static func write(value: BatchDeleteTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetTaxExemptionsInput {

    static func write(value: BatchGetTaxExemptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchPutTaxRegistrationInput {

    static func write(value: BatchPutTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taxRegistrationEntry"].write(value.taxRegistrationEntry, with: TaxSettingsClientTypes.TaxRegistrationEntry.write(value:to:))
    }
}

extension DeleteSupplementalTaxRegistrationInput {

    static func write(value: DeleteSupplementalTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorityId"].write(value.authorityId)
    }
}

extension DeleteTaxRegistrationInput {

    static func write(value: DeleteTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }
}

extension GetTaxRegistrationInput {

    static func write(value: GetTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }
}

extension GetTaxRegistrationDocumentInput {

    static func write(value: GetTaxRegistrationDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationS3Location"].write(value.destinationS3Location, with: TaxSettingsClientTypes.DestinationS3Location.write(value:to:))
        try writer["taxDocumentMetadata"].write(value.taxDocumentMetadata, with: TaxSettingsClientTypes.TaxDocumentMetadata.write(value:to:))
    }
}

extension ListSupplementalTaxRegistrationsInput {

    static func write(value: ListSupplementalTaxRegistrationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTaxExemptionsInput {

    static func write(value: ListTaxExemptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTaxRegistrationsInput {

    static func write(value: ListTaxRegistrationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension PutSupplementalTaxRegistrationInput {

    static func write(value: PutSupplementalTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taxRegistrationEntry"].write(value.taxRegistrationEntry, with: TaxSettingsClientTypes.SupplementalTaxRegistrationEntry.write(value:to:))
    }
}

extension PutTaxExemptionInput {

    static func write(value: PutTaxExemptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authority"].write(value.authority, with: TaxSettingsClientTypes.Authority.write(value:to:))
        try writer["exemptionCertificate"].write(value.exemptionCertificate, with: TaxSettingsClientTypes.ExemptionCertificate.write(value:to:))
        try writer["exemptionType"].write(value.exemptionType)
    }
}

extension PutTaxInheritanceInput {

    static func write(value: PutTaxInheritanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["heritageStatus"].write(value.heritageStatus)
    }
}

extension PutTaxRegistrationInput {

    static func write(value: PutTaxRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["taxRegistrationEntry"].write(value.taxRegistrationEntry, with: TaxSettingsClientTypes.TaxRegistrationEntry.write(value:to:))
    }
}

extension BatchDeleteTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteTaxRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteTaxRegistrationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.BatchDeleteTaxRegistrationError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetTaxExemptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetTaxExemptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetTaxExemptionsOutput()
        value.failedAccounts = try reader["failedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.taxExemptionDetailsMap = try reader["taxExemptionDetailsMap"].readMapIfPresent(valueReadingClosure: TaxSettingsClientTypes.TaxExemptionDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BatchPutTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutTaxRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutTaxRegistrationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.BatchPutTaxRegistrationError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteSupplementalTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSupplementalTaxRegistrationOutput {
        return DeleteSupplementalTaxRegistrationOutput()
    }
}

extension DeleteTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTaxRegistrationOutput {
        return DeleteTaxRegistrationOutput()
    }
}

extension GetTaxExemptionTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaxExemptionTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaxExemptionTypesOutput()
        value.taxExemptionTypes = try reader["taxExemptionTypes"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.TaxExemptionType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTaxInheritanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaxInheritanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaxInheritanceOutput()
        value.heritageStatus = try reader["heritageStatus"].readIfPresent()
        return value
    }
}

extension GetTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaxRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaxRegistrationOutput()
        value.taxRegistration = try reader["taxRegistration"].readIfPresent(with: TaxSettingsClientTypes.TaxRegistration.read(from:))
        return value
    }
}

extension GetTaxRegistrationDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaxRegistrationDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaxRegistrationDocumentOutput()
        value.destinationFilePath = try reader["destinationFilePath"].readIfPresent()
        value.presignedS3Url = try reader["presignedS3Url"].readIfPresent()
        return value
    }
}

extension ListSupplementalTaxRegistrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSupplementalTaxRegistrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSupplementalTaxRegistrationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.taxRegistrations = try reader["taxRegistrations"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.SupplementalTaxRegistration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTaxExemptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTaxExemptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTaxExemptionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.taxExemptionDetailsMap = try reader["taxExemptionDetailsMap"].readMapIfPresent(valueReadingClosure: TaxSettingsClientTypes.TaxExemptionDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTaxRegistrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTaxRegistrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTaxRegistrationsOutput()
        value.accountDetails = try reader["accountDetails"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.AccountDetails.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PutSupplementalTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSupplementalTaxRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSupplementalTaxRegistrationOutput()
        value.authorityId = try reader["authorityId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PutTaxExemptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTaxExemptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutTaxExemptionOutput()
        value.caseId = try reader["caseId"].readIfPresent()
        return value
    }
}

extension PutTaxInheritanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTaxInheritanceOutput {
        return PutTaxInheritanceOutput()
    }
}

extension PutTaxRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTaxRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutTaxRegistrationOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

enum BatchDeleteTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetTaxExemptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSupplementalTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaxExemptionTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaxInheritanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaxRegistrationDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSupplementalTaxRegistrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTaxExemptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTaxRegistrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSupplementalTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTaxExemptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AttachmentUploadException": return try AttachmentUploadException.makeError(baseError: baseError)
            case "CaseCreationLimitExceededException": return try CaseCreationLimitExceededException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTaxInheritanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTaxRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CaseCreationLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CaseCreationLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CaseCreationLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AttachmentUploadException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AttachmentUploadException {
        let reader = baseError.errorBodyReader
        var value = AttachmentUploadException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TaxSettingsClientTypes.BatchDeleteTaxRegistrationError {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.BatchDeleteTaxRegistrationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.BatchDeleteTaxRegistrationError()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxExemptionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxExemptionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxExemptionDetails()
        value.taxExemptions = try reader["taxExemptions"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.TaxExemption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.heritageObtainedDetails = try reader["heritageObtainedDetails"].readIfPresent()
        value.heritageObtainedParentEntity = try reader["heritageObtainedParentEntity"].readIfPresent()
        value.heritageObtainedReason = try reader["heritageObtainedReason"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxExemption {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxExemption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxExemption()
        value.authority = try reader["authority"].readIfPresent(with: TaxSettingsClientTypes.Authority.read(from:))
        value.taxExemptionType = try reader["taxExemptionType"].readIfPresent(with: TaxSettingsClientTypes.TaxExemptionType.read(from:))
        value.effectiveDate = try reader["effectiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.systemEffectiveDate = try reader["systemEffectiveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxExemptionType {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxExemptionType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxExemptionType()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.applicableJurisdictions = try reader["applicableJurisdictions"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.Authority.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TaxSettingsClientTypes.Authority {

    static func write(value: TaxSettingsClientTypes.Authority?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["country"].write(value.country)
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.Authority {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.Authority()
        value.country = try reader["country"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.BatchPutTaxRegistrationError {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.BatchPutTaxRegistrationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.BatchPutTaxRegistrationError()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxRegistration {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxRegistration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxRegistration()
        value.registrationId = try reader["registrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["registrationType"].readIfPresent() ?? .sdkUnknown("")
        value.legalName = try reader["legalName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.sector = try reader["sector"].readIfPresent()
        value.taxDocumentMetadatas = try reader["taxDocumentMetadatas"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.TaxDocumentMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.certifiedEmailId = try reader["certifiedEmailId"].readIfPresent()
        value.additionalTaxInformation = try reader["additionalTaxInformation"].readIfPresent(with: TaxSettingsClientTypes.AdditionalInfoResponse.read(from:))
        value.legalAddress = try reader["legalAddress"].readIfPresent(with: TaxSettingsClientTypes.Address.read(from:))
        return value
    }
}

extension TaxSettingsClientTypes.Address {

    static func write(value: TaxSettingsClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressLine1"].write(value.addressLine1)
        try writer["addressLine2"].write(value.addressLine2)
        try writer["addressLine3"].write(value.addressLine3)
        try writer["city"].write(value.city)
        try writer["countryCode"].write(value.countryCode)
        try writer["districtOrCounty"].write(value.districtOrCounty)
        try writer["postalCode"].write(value.postalCode)
        try writer["stateOrRegion"].write(value.stateOrRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.Address()
        value.addressLine1 = try reader["addressLine1"].readIfPresent() ?? ""
        value.addressLine2 = try reader["addressLine2"].readIfPresent()
        value.addressLine3 = try reader["addressLine3"].readIfPresent()
        value.districtOrCounty = try reader["districtOrCounty"].readIfPresent()
        value.city = try reader["city"].readIfPresent() ?? ""
        value.stateOrRegion = try reader["stateOrRegion"].readIfPresent()
        value.postalCode = try reader["postalCode"].readIfPresent() ?? ""
        value.countryCode = try reader["countryCode"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.AdditionalInfoResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.AdditionalInfoResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.AdditionalInfoResponse()
        value.malaysiaAdditionalInfo = try reader["malaysiaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.MalaysiaAdditionalInfo.read(from:))
        value.israelAdditionalInfo = try reader["israelAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.IsraelAdditionalInfo.read(from:))
        value.estoniaAdditionalInfo = try reader["estoniaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.EstoniaAdditionalInfo.read(from:))
        value.canadaAdditionalInfo = try reader["canadaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.CanadaAdditionalInfo.read(from:))
        value.brazilAdditionalInfo = try reader["brazilAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.BrazilAdditionalInfo.read(from:))
        value.spainAdditionalInfo = try reader["spainAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.SpainAdditionalInfo.read(from:))
        value.kenyaAdditionalInfo = try reader["kenyaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.KenyaAdditionalInfo.read(from:))
        value.southKoreaAdditionalInfo = try reader["southKoreaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.SouthKoreaAdditionalInfo.read(from:))
        value.turkeyAdditionalInfo = try reader["turkeyAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.TurkeyAdditionalInfo.read(from:))
        value.georgiaAdditionalInfo = try reader["georgiaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.GeorgiaAdditionalInfo.read(from:))
        value.italyAdditionalInfo = try reader["italyAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.ItalyAdditionalInfo.read(from:))
        value.romaniaAdditionalInfo = try reader["romaniaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.RomaniaAdditionalInfo.read(from:))
        value.ukraineAdditionalInfo = try reader["ukraineAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.UkraineAdditionalInfo.read(from:))
        value.polandAdditionalInfo = try reader["polandAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.PolandAdditionalInfo.read(from:))
        value.saudiArabiaAdditionalInfo = try reader["saudiArabiaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo.read(from:))
        value.indiaAdditionalInfo = try reader["indiaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.IndiaAdditionalInfo.read(from:))
        value.indonesiaAdditionalInfo = try reader["indonesiaAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.IndonesiaAdditionalInfo.read(from:))
        value.vietnamAdditionalInfo = try reader["vietnamAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.VietnamAdditionalInfo.read(from:))
        value.egyptAdditionalInfo = try reader["egyptAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.EgyptAdditionalInfo.read(from:))
        value.greeceAdditionalInfo = try reader["greeceAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.GreeceAdditionalInfo.read(from:))
        value.uzbekistanAdditionalInfo = try reader["uzbekistanAdditionalInfo"].readIfPresent(with: TaxSettingsClientTypes.UzbekistanAdditionalInfo.read(from:))
        return value
    }
}

extension TaxSettingsClientTypes.UzbekistanAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.UzbekistanAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taxRegistrationNumberType"].write(value.taxRegistrationNumberType)
        try writer["vatRegistrationNumber"].write(value.vatRegistrationNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.UzbekistanAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.UzbekistanAdditionalInfo()
        value.taxRegistrationNumberType = try reader["taxRegistrationNumberType"].readIfPresent()
        value.vatRegistrationNumber = try reader["vatRegistrationNumber"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.GreeceAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.GreeceAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractingAuthorityCode"].write(value.contractingAuthorityCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.GreeceAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.GreeceAdditionalInfo()
        value.contractingAuthorityCode = try reader["contractingAuthorityCode"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.EgyptAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.EgyptAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uniqueIdentificationNumber"].write(value.uniqueIdentificationNumber)
        try writer["uniqueIdentificationNumberExpirationDate"].write(value.uniqueIdentificationNumberExpirationDate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.EgyptAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.EgyptAdditionalInfo()
        value.uniqueIdentificationNumber = try reader["uniqueIdentificationNumber"].readIfPresent()
        value.uniqueIdentificationNumberExpirationDate = try reader["uniqueIdentificationNumberExpirationDate"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.VietnamAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.VietnamAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["electronicTransactionCodeNumber"].write(value.electronicTransactionCodeNumber)
        try writer["enterpriseIdentificationNumber"].write(value.enterpriseIdentificationNumber)
        try writer["paymentVoucherNumber"].write(value.paymentVoucherNumber)
        try writer["paymentVoucherNumberDate"].write(value.paymentVoucherNumberDate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.VietnamAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.VietnamAdditionalInfo()
        value.enterpriseIdentificationNumber = try reader["enterpriseIdentificationNumber"].readIfPresent()
        value.electronicTransactionCodeNumber = try reader["electronicTransactionCodeNumber"].readIfPresent()
        value.paymentVoucherNumber = try reader["paymentVoucherNumber"].readIfPresent()
        value.paymentVoucherNumberDate = try reader["paymentVoucherNumberDate"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.IndonesiaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.IndonesiaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decisionNumber"].write(value.decisionNumber)
        try writer["ppnExceptionDesignationCode"].write(value.ppnExceptionDesignationCode)
        try writer["taxRegistrationNumberType"].write(value.taxRegistrationNumberType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.IndonesiaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.IndonesiaAdditionalInfo()
        value.taxRegistrationNumberType = try reader["taxRegistrationNumberType"].readIfPresent()
        value.ppnExceptionDesignationCode = try reader["ppnExceptionDesignationCode"].readIfPresent()
        value.decisionNumber = try reader["decisionNumber"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.IndiaAdditionalInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.IndiaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.IndiaAdditionalInfo()
        value.pan = try reader["pan"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.SaudiArabiaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taxRegistrationNumberType"].write(value.taxRegistrationNumberType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.SaudiArabiaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.SaudiArabiaAdditionalInfo()
        value.taxRegistrationNumberType = try reader["taxRegistrationNumberType"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.PolandAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.PolandAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["individualRegistrationNumber"].write(value.individualRegistrationNumber)
        try writer["isGroupVatEnabled"].write(value.isGroupVatEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.PolandAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.PolandAdditionalInfo()
        value.individualRegistrationNumber = try reader["individualRegistrationNumber"].readIfPresent()
        value.isGroupVatEnabled = try reader["isGroupVatEnabled"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.UkraineAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.UkraineAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ukraineTrnType"].write(value.ukraineTrnType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.UkraineAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.UkraineAdditionalInfo()
        value.ukraineTrnType = try reader["ukraineTrnType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.RomaniaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.RomaniaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taxRegistrationNumberType"].write(value.taxRegistrationNumberType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.RomaniaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.RomaniaAdditionalInfo()
        value.taxRegistrationNumberType = try reader["taxRegistrationNumberType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.ItalyAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.ItalyAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cigNumber"].write(value.cigNumber)
        try writer["cupNumber"].write(value.cupNumber)
        try writer["sdiAccountId"].write(value.sdiAccountId)
        try writer["taxCode"].write(value.taxCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.ItalyAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.ItalyAdditionalInfo()
        value.sdiAccountId = try reader["sdiAccountId"].readIfPresent()
        value.cigNumber = try reader["cigNumber"].readIfPresent()
        value.cupNumber = try reader["cupNumber"].readIfPresent()
        value.taxCode = try reader["taxCode"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.GeorgiaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.GeorgiaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["personType"].write(value.personType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.GeorgiaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.GeorgiaAdditionalInfo()
        value.personType = try reader["personType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.TurkeyAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.TurkeyAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["industries"].write(value.industries)
        try writer["kepEmailId"].write(value.kepEmailId)
        try writer["secondaryTaxId"].write(value.secondaryTaxId)
        try writer["taxOffice"].write(value.taxOffice)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TurkeyAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TurkeyAdditionalInfo()
        value.taxOffice = try reader["taxOffice"].readIfPresent()
        value.kepEmailId = try reader["kepEmailId"].readIfPresent()
        value.secondaryTaxId = try reader["secondaryTaxId"].readIfPresent()
        value.industries = try reader["industries"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.SouthKoreaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.SouthKoreaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessRepresentativeName"].write(value.businessRepresentativeName)
        try writer["itemOfBusiness"].write(value.itemOfBusiness)
        try writer["lineOfBusiness"].write(value.lineOfBusiness)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.SouthKoreaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.SouthKoreaAdditionalInfo()
        value.businessRepresentativeName = try reader["businessRepresentativeName"].readIfPresent() ?? ""
        value.lineOfBusiness = try reader["lineOfBusiness"].readIfPresent() ?? ""
        value.itemOfBusiness = try reader["itemOfBusiness"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.KenyaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.KenyaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["personType"].write(value.personType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.KenyaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.KenyaAdditionalInfo()
        value.personType = try reader["personType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.SpainAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.SpainAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["registrationType"].write(value.registrationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.SpainAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.SpainAdditionalInfo()
        value.registrationType = try reader["registrationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.BrazilAdditionalInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.BrazilAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.BrazilAdditionalInfo()
        value.ccmCode = try reader["ccmCode"].readIfPresent()
        value.legalNatureCode = try reader["legalNatureCode"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.CanadaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.CanadaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canadaQuebecSalesTaxNumber"].write(value.canadaQuebecSalesTaxNumber)
        try writer["canadaRetailSalesTaxNumber"].write(value.canadaRetailSalesTaxNumber)
        try writer["isResellerAccount"].write(value.isResellerAccount)
        try writer["provincialSalesTaxId"].write(value.provincialSalesTaxId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.CanadaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.CanadaAdditionalInfo()
        value.provincialSalesTaxId = try reader["provincialSalesTaxId"].readIfPresent()
        value.canadaQuebecSalesTaxNumber = try reader["canadaQuebecSalesTaxNumber"].readIfPresent()
        value.canadaRetailSalesTaxNumber = try reader["canadaRetailSalesTaxNumber"].readIfPresent()
        value.isResellerAccount = try reader["isResellerAccount"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.EstoniaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.EstoniaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["registryCommercialCode"].write(value.registryCommercialCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.EstoniaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.EstoniaAdditionalInfo()
        value.registryCommercialCode = try reader["registryCommercialCode"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.IsraelAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.IsraelAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerType"].write(value.customerType)
        try writer["dealerType"].write(value.dealerType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.IsraelAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.IsraelAdditionalInfo()
        value.dealerType = try reader["dealerType"].readIfPresent() ?? .sdkUnknown("")
        value.customerType = try reader["customerType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.MalaysiaAdditionalInfo {

    static func write(value: TaxSettingsClientTypes.MalaysiaAdditionalInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessRegistrationNumber"].write(value.businessRegistrationNumber)
        try writer["serviceTaxCodes"].writeList(value.serviceTaxCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<TaxSettingsClientTypes.MalaysiaServiceTaxCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taxInformationNumber"].write(value.taxInformationNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.MalaysiaAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.MalaysiaAdditionalInfo()
        value.serviceTaxCodes = try reader["serviceTaxCodes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<TaxSettingsClientTypes.MalaysiaServiceTaxCode>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.taxInformationNumber = try reader["taxInformationNumber"].readIfPresent()
        value.businessRegistrationNumber = try reader["businessRegistrationNumber"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxDocumentMetadata {

    static func write(value: TaxSettingsClientTypes.TaxDocumentMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taxDocumentAccessToken"].write(value.taxDocumentAccessToken)
        try writer["taxDocumentName"].write(value.taxDocumentName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxDocumentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxDocumentMetadata()
        value.taxDocumentAccessToken = try reader["taxDocumentAccessToken"].readIfPresent() ?? ""
        value.taxDocumentName = try reader["taxDocumentName"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.SupplementalTaxRegistration {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.SupplementalTaxRegistration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.SupplementalTaxRegistration()
        value.registrationId = try reader["registrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["registrationType"].readIfPresent() ?? .sdkUnknown("")
        value.legalName = try reader["legalName"].readIfPresent() ?? ""
        value.address = try reader["address"].readIfPresent(with: TaxSettingsClientTypes.Address.read(from:))
        value.authorityId = try reader["authorityId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TaxSettingsClientTypes.AccountDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.AccountDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.AccountDetails()
        value.accountId = try reader["accountId"].readIfPresent()
        value.taxRegistration = try reader["taxRegistration"].readIfPresent(with: TaxSettingsClientTypes.TaxRegistrationWithJurisdiction.read(from:))
        value.taxInheritanceDetails = try reader["taxInheritanceDetails"].readIfPresent(with: TaxSettingsClientTypes.TaxInheritanceDetails.read(from:))
        value.accountMetaData = try reader["accountMetaData"].readIfPresent(with: TaxSettingsClientTypes.AccountMetaData.read(from:))
        return value
    }
}

extension TaxSettingsClientTypes.AccountMetaData {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.AccountMetaData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.AccountMetaData()
        value.accountName = try reader["accountName"].readIfPresent()
        value.seller = try reader["seller"].readIfPresent()
        value.address = try reader["address"].readIfPresent(with: TaxSettingsClientTypes.Address.read(from:))
        value.addressType = try reader["addressType"].readIfPresent()
        value.addressRoleMap = try reader["addressRoleMap"].readMapIfPresent(valueReadingClosure: TaxSettingsClientTypes.Jurisdiction.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TaxSettingsClientTypes.Jurisdiction {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.Jurisdiction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.Jurisdiction()
        value.stateOrRegion = try reader["stateOrRegion"].readIfPresent()
        value.countryCode = try reader["countryCode"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.TaxInheritanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxInheritanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxInheritanceDetails()
        value.parentEntityId = try reader["parentEntityId"].readIfPresent()
        value.inheritanceObtainedReason = try reader["inheritanceObtainedReason"].readIfPresent()
        return value
    }
}

extension TaxSettingsClientTypes.TaxRegistrationWithJurisdiction {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.TaxRegistrationWithJurisdiction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.TaxRegistrationWithJurisdiction()
        value.registrationId = try reader["registrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["registrationType"].readIfPresent() ?? .sdkUnknown("")
        value.legalName = try reader["legalName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.sector = try reader["sector"].readIfPresent()
        value.taxDocumentMetadatas = try reader["taxDocumentMetadatas"].readListIfPresent(memberReadingClosure: TaxSettingsClientTypes.TaxDocumentMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.certifiedEmailId = try reader["certifiedEmailId"].readIfPresent()
        value.additionalTaxInformation = try reader["additionalTaxInformation"].readIfPresent(with: TaxSettingsClientTypes.AdditionalInfoResponse.read(from:))
        value.jurisdiction = try reader["jurisdiction"].readIfPresent(with: TaxSettingsClientTypes.Jurisdiction.read(from:))
        return value
    }
}

extension TaxSettingsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> TaxSettingsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TaxSettingsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension TaxSettingsClientTypes.TaxRegistrationEntry {

    static func write(value: TaxSettingsClientTypes.TaxRegistrationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalTaxInformation"].write(value.additionalTaxInformation, with: TaxSettingsClientTypes.AdditionalInfoRequest.write(value:to:))
        try writer["certifiedEmailId"].write(value.certifiedEmailId)
        try writer["legalAddress"].write(value.legalAddress, with: TaxSettingsClientTypes.Address.write(value:to:))
        try writer["legalName"].write(value.legalName)
        try writer["registrationId"].write(value.registrationId)
        try writer["registrationType"].write(value.registrationType)
        try writer["sector"].write(value.sector)
        try writer["verificationDetails"].write(value.verificationDetails, with: TaxSettingsClientTypes.VerificationDetails.write(value:to:))
    }
}

extension TaxSettingsClientTypes.VerificationDetails {

    static func write(value: TaxSettingsClientTypes.VerificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dateOfBirth"].write(value.dateOfBirth)
        try writer["taxRegistrationDocuments"].writeList(value.taxRegistrationDocuments, memberWritingClosure: TaxSettingsClientTypes.TaxRegistrationDocument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TaxSettingsClientTypes.TaxRegistrationDocument {

    static func write(value: TaxSettingsClientTypes.TaxRegistrationDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file, with: TaxSettingsClientTypes.TaxRegistrationDocFile.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: TaxSettingsClientTypes.SourceS3Location.write(value:to:))
    }
}

extension TaxSettingsClientTypes.TaxRegistrationDocFile {

    static func write(value: TaxSettingsClientTypes.TaxRegistrationDocFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileContent"].write(value.fileContent)
        try writer["fileName"].write(value.fileName)
    }
}

extension TaxSettingsClientTypes.SourceS3Location {

    static func write(value: TaxSettingsClientTypes.SourceS3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
    }
}

extension TaxSettingsClientTypes.AdditionalInfoRequest {

    static func write(value: TaxSettingsClientTypes.AdditionalInfoRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canadaAdditionalInfo"].write(value.canadaAdditionalInfo, with: TaxSettingsClientTypes.CanadaAdditionalInfo.write(value:to:))
        try writer["egyptAdditionalInfo"].write(value.egyptAdditionalInfo, with: TaxSettingsClientTypes.EgyptAdditionalInfo.write(value:to:))
        try writer["estoniaAdditionalInfo"].write(value.estoniaAdditionalInfo, with: TaxSettingsClientTypes.EstoniaAdditionalInfo.write(value:to:))
        try writer["georgiaAdditionalInfo"].write(value.georgiaAdditionalInfo, with: TaxSettingsClientTypes.GeorgiaAdditionalInfo.write(value:to:))
        try writer["greeceAdditionalInfo"].write(value.greeceAdditionalInfo, with: TaxSettingsClientTypes.GreeceAdditionalInfo.write(value:to:))
        try writer["indonesiaAdditionalInfo"].write(value.indonesiaAdditionalInfo, with: TaxSettingsClientTypes.IndonesiaAdditionalInfo.write(value:to:))
        try writer["israelAdditionalInfo"].write(value.israelAdditionalInfo, with: TaxSettingsClientTypes.IsraelAdditionalInfo.write(value:to:))
        try writer["italyAdditionalInfo"].write(value.italyAdditionalInfo, with: TaxSettingsClientTypes.ItalyAdditionalInfo.write(value:to:))
        try writer["kenyaAdditionalInfo"].write(value.kenyaAdditionalInfo, with: TaxSettingsClientTypes.KenyaAdditionalInfo.write(value:to:))
        try writer["malaysiaAdditionalInfo"].write(value.malaysiaAdditionalInfo, with: TaxSettingsClientTypes.MalaysiaAdditionalInfo.write(value:to:))
        try writer["polandAdditionalInfo"].write(value.polandAdditionalInfo, with: TaxSettingsClientTypes.PolandAdditionalInfo.write(value:to:))
        try writer["romaniaAdditionalInfo"].write(value.romaniaAdditionalInfo, with: TaxSettingsClientTypes.RomaniaAdditionalInfo.write(value:to:))
        try writer["saudiArabiaAdditionalInfo"].write(value.saudiArabiaAdditionalInfo, with: TaxSettingsClientTypes.SaudiArabiaAdditionalInfo.write(value:to:))
        try writer["southKoreaAdditionalInfo"].write(value.southKoreaAdditionalInfo, with: TaxSettingsClientTypes.SouthKoreaAdditionalInfo.write(value:to:))
        try writer["spainAdditionalInfo"].write(value.spainAdditionalInfo, with: TaxSettingsClientTypes.SpainAdditionalInfo.write(value:to:))
        try writer["turkeyAdditionalInfo"].write(value.turkeyAdditionalInfo, with: TaxSettingsClientTypes.TurkeyAdditionalInfo.write(value:to:))
        try writer["ukraineAdditionalInfo"].write(value.ukraineAdditionalInfo, with: TaxSettingsClientTypes.UkraineAdditionalInfo.write(value:to:))
        try writer["uzbekistanAdditionalInfo"].write(value.uzbekistanAdditionalInfo, with: TaxSettingsClientTypes.UzbekistanAdditionalInfo.write(value:to:))
        try writer["vietnamAdditionalInfo"].write(value.vietnamAdditionalInfo, with: TaxSettingsClientTypes.VietnamAdditionalInfo.write(value:to:))
    }
}

extension TaxSettingsClientTypes.DestinationS3Location {

    static func write(value: TaxSettingsClientTypes.DestinationS3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
    }
}

extension TaxSettingsClientTypes.SupplementalTaxRegistrationEntry {

    static func write(value: TaxSettingsClientTypes.SupplementalTaxRegistrationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address, with: TaxSettingsClientTypes.Address.write(value:to:))
        try writer["legalName"].write(value.legalName)
        try writer["registrationId"].write(value.registrationId)
        try writer["registrationType"].write(value.registrationType)
    }
}

extension TaxSettingsClientTypes.ExemptionCertificate {

    static func write(value: TaxSettingsClientTypes.ExemptionCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["documentFile"].write(value.documentFile)
        try writer["documentName"].write(value.documentName)
    }
}

public enum TaxSettingsClientTypes {}
