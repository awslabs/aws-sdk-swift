//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct DeleteApiKeyOutput {

    public init() { }
}

public struct DeleteAuthorizerOutput {

    public init() { }
}

public struct DeleteBasePathMappingOutput {

    public init() { }
}

public struct DeleteClientCertificateOutput {

    public init() { }
}

public struct DeleteDeploymentOutput {

    public init() { }
}

public struct DeleteDocumentationPartOutput {

    public init() { }
}

public struct DeleteDocumentationVersionOutput {

    public init() { }
}

public struct DeleteDomainNameOutput {

    public init() { }
}

public struct DeleteGatewayResponseOutput {

    public init() { }
}

public struct DeleteIntegrationOutput {

    public init() { }
}

public struct DeleteIntegrationResponseOutput {

    public init() { }
}

public struct DeleteMethodOutput {

    public init() { }
}

public struct DeleteMethodResponseOutput {

    public init() { }
}

public struct DeleteModelOutput {

    public init() { }
}

public struct DeleteRequestValidatorOutput {

    public init() { }
}

public struct DeleteResourceOutput {

    public init() { }
}

public struct DeleteRestApiOutput {

    public init() { }
}

public struct DeleteStageOutput {

    public init() { }
}

public struct DeleteUsagePlanKeyOutput {

    public init() { }
}

public struct DeleteUsagePlanOutput {

    public init() { }
}

public struct DeleteVpcLinkOutput {

    public init() { }
}

public struct FlushStageAuthorizersCacheOutput {

    public init() { }
}

public struct FlushStageCacheOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

extension APIGatewayClientTypes {
    /// Access log settings, including the access log format and access log destination ARN.
    public struct AccessLogSettings {
        /// The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension APIGatewayClientTypes {
    /// The API request rate limits.
    public struct ThrottleSettings {
        /// The API target request burst rate limit. This allows more requests through for a period of time than the target rate limit.
        public var burstLimit: Swift.Int
        /// The API target request rate limit.
        public var rateLimit: Swift.Double

        public init(
            burstLimit: Swift.Int = 0,
            rateLimit: Swift.Double = 0.0
        )
        {
            self.burstLimit = burstLimit
            self.rateLimit = rateLimit
        }
    }

}

extension APIGatewayClientTypes {
    /// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
    public struct ApiKey {
        /// The timestamp when the API Key was created.
        public var createdDate: Foundation.Date?
        /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
        public var customerId: Swift.String?
        /// The description of the API Key.
        public var description: Swift.String?
        /// Specifies whether the API Key can be used by callers.
        public var enabled: Swift.Bool
        /// The identifier of the API Key.
        public var id: Swift.String?
        /// The timestamp when the API Key was last updated.
        public var lastUpdatedDate: Foundation.Date?
        /// The name of the API Key.
        public var name: Swift.String?
        /// A list of Stage resources that are associated with the ApiKey resource.
        public var stageKeys: [Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?
        /// The value of the API Key.
        public var value: Swift.String?

        public init(
            createdDate: Foundation.Date? = nil,
            customerId: Swift.String? = nil,
            description: Swift.String? = nil,
            enabled: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            stageKeys: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.customerId = customerId
            self.description = description
            self.enabled = enabled
            self.id = id
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.stageKeys = stageKeys
            self.tags = tags
            self.value = value
        }
    }

}

extension APIGatewayClientTypes {

    public enum ApiKeysFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeysFormat] {
            return [
                .csv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {

    public enum ApiKeySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorizer
        case header
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeySourceType] {
            return [
                .authorizer,
                .header
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorizer: return "AUTHORIZER"
            case .header: return "HEADER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// API stage name of the associated API stage in a usage plan.
    public struct ApiStage {
        /// API Id of the associated API stage in a usage plan.
        public var apiId: Swift.String?
        /// API stage name of the associated API stage in a usage plan.
        public var stage: Swift.String?
        /// Map containing method level throttling information for API stage in a usage plan.
        public var throttle: [Swift.String: APIGatewayClientTypes.ThrottleSettings]?

        public init(
            apiId: Swift.String? = nil,
            stage: Swift.String? = nil,
            throttle: [Swift.String: APIGatewayClientTypes.ThrottleSettings]? = nil
        )
        {
            self.apiId = apiId
            self.stage = stage
            self.throttle = throttle
        }
    }

}

extension APIGatewayClientTypes {

    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cognitoUserPools
        case request
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .cognitoUserPools,
                .request,
                .token
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cognitoUserPools: return "COGNITO_USER_POOLS"
            case .request: return "REQUEST"
            case .token: return "TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
    public struct Authorizer {
        /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
        public var authType: Swift.String?
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
        public var authorizerCredentials: Swift.String?
        /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
        public var authorizerUri: Swift.String?
        /// The identifier for the authorizer resource.
        public var id: Swift.String?
        /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
        public var identitySource: Swift.String?
        /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// The name of the authorizer.
        public var name: Swift.String?
        /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
        public var providerARNs: [Swift.String]?
        /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
        public var type: APIGatewayClientTypes.AuthorizerType?

        public init(
            authType: Swift.String? = nil,
            authorizerCredentials: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerUri: Swift.String? = nil,
            id: Swift.String? = nil,
            identitySource: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil,
            name: Swift.String? = nil,
            providerARNs: [Swift.String]? = nil,
            type: APIGatewayClientTypes.AuthorizerType? = nil
        )
        {
            self.authType = authType
            self.authorizerCredentials = authorizerCredentials
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.id = id
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.name = name
            self.providerARNs = providerARNs
            self.type = type
        }
    }

}

/// The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request configuration has conflicts. For details, see the accompanying error message.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeded the rate limit. Retry after the specified time period.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The requested resource is not found. Make sure that the request URI is correct.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request has reached its throttling limit. Retry after the specified time period.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request is denied because the caller has insufficient permissions.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension APIGatewayClientTypes {
    /// A reference to a unique stage identified in the format {restApiId}/{stage}.
    public struct StageKey {
        /// The string identifier of the associated RestApi.
        public var restApiId: Swift.String?
        /// The stage name associated with the stage key.
        public var stageName: Swift.String?

        public init(
            restApiId: Swift.String? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.restApiId = restApiId
            self.stageName = stageName
        }
    }

}

/// Request to create an ApiKey resource.
public struct CreateApiKeyInput {
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the ApiKey.
    public var description: Swift.String?
    /// Specifies whether the ApiKey can be used by callers.
    public var enabled: Swift.Bool?
    /// Specifies whether (true) or not (false) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
    public var generateDistinctId: Swift.Bool?
    /// The name of the ApiKey.
    public var name: Swift.String?
    /// DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
    public var stageKeys: [APIGatewayClientTypes.StageKey]?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies a value of the API key.
    public var value: Swift.String?

    public init(
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool? = false,
        generateDistinctId: Swift.Bool? = false,
        name: Swift.String? = nil,
        stageKeys: [APIGatewayClientTypes.StageKey]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.generateDistinctId = generateDistinctId
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct CreateApiKeyOutput {
    /// The timestamp when the API Key was created.
    public var createdDate: Foundation.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

/// Request to add a new Authorizer to an existing RestApi resource.
public struct CreateAuthorizerInput {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    /// This member is required.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.restApiId = restApiId
        self.type = type
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct CreateAuthorizerOutput {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

/// Requests API Gateway to create a new BasePathMapping resource.
public struct CreateBasePathMappingInput {
    /// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to create.
    /// This member is required.
    public var domainName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.restApiId = restApiId
        self.stage = stage
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct CreateBasePathMappingOutput {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

/// The requested service is not available. For details see the accompanying error message. Retry after the specified time period.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension APIGatewayClientTypes {

    /// Returns the size of the CacheCluster.
    public enum CacheClusterSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case size0Point5Gb
        case size118Gb
        case size13Point5Gb
        case size1Point6Gb
        case size237Gb
        case size28Point4Gb
        case size58Point2Gb
        case size6Point1Gb
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterSize] {
            return [
                .size0Point5Gb,
                .size118Gb,
                .size13Point5Gb,
                .size1Point6Gb,
                .size237Gb,
                .size28Point4Gb,
                .size58Point2Gb,
                .size6Point1Gb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .size0Point5Gb: return "0.5"
            case .size118Gb: return "118"
            case .size13Point5Gb: return "13.5"
            case .size1Point6Gb: return "1.6"
            case .size237Gb: return "237"
            case .size28Point4Gb: return "28.4"
            case .size58Point2Gb: return "58.2"
            case .size6Point1Gb: return "6.1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// The input configuration for a canary deployment.
    public struct DeploymentCanarySettings {
        /// The percentage (0.0-100.0) of traffic routed to the canary deployment.
        public var percentTraffic: Swift.Double
        /// A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String: Swift.String]?
        /// A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init(
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String: Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

/// Requests API Gateway to create a Deployment resource.
public struct CreateDeploymentInput {
    /// Enables a cache cluster for the Stage resource specified in the input.
    public var cacheClusterEnabled: Swift.Bool?
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The input configuration for the canary deployment when the deployment is a canary release deployment.
    public var canarySettings: APIGatewayClientTypes.DeploymentCanarySettings?
    /// The description for the Deployment resource to create.
    public var description: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The description of the Stage resource for the Deployment resource to create.
    public var stageDescription: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool?
    /// A map that defines the stage variables for the Stage resource that is associated with the new deployment. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String: Swift.String]?

    public init(
        cacheClusterEnabled: Swift.Bool? = nil,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: APIGatewayClientTypes.DeploymentCanarySettings? = nil,
        description: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageDescription: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tracingEnabled: Swift.Bool? = nil,
        variables: [Swift.String: Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.description = description
        self.restApiId = restApiId
        self.stageDescription = stageDescription
        self.stageName = stageName
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

extension APIGatewayClientTypes {
    /// Represents a summary of a Method resource, given a particular date and time.
    public struct MethodSnapshot {
        /// Specifies whether the method requires a valid ApiKey.
        public var apiKeyRequired: Swift.Bool
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?

        public init(
            apiKeyRequired: Swift.Bool = false,
            authorizationType: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationType = authorizationType
        }
    }

}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct CreateDeploymentOutput {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

extension APIGatewayClientTypes {

    public enum DocumentationPartType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case api
        case authorizer
        case method
        case model
        case pathParameter
        case queryParameter
        case requestBody
        case requestHeader
        case resource
        case response
        case responseBody
        case responseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentationPartType] {
            return [
                .api,
                .authorizer,
                .method,
                .model,
                .pathParameter,
                .queryParameter,
                .requestBody,
                .requestHeader,
                .resource,
                .response,
                .responseBody,
                .responseHeader
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .authorizer: return "AUTHORIZER"
            case .method: return "METHOD"
            case .model: return "MODEL"
            case .pathParameter: return "PATH_PARAMETER"
            case .queryParameter: return "QUERY_PARAMETER"
            case .requestBody: return "REQUEST_BODY"
            case .requestHeader: return "REQUEST_HEADER"
            case .resource: return "RESOURCE"
            case .response: return "RESPONSE"
            case .responseBody: return "RESPONSE_BODY"
            case .responseHeader: return "RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Specifies the target API entity to which the documentation applies.
    public struct DocumentationPartLocation {
        /// The HTTP verb of a method. It is a valid field for the API entity types of METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any method. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's method attribute must match that of the parent entity exactly.
        public var method: Swift.String?
        /// The name of the targeted API entity. It is a valid and required field for the API entity types of AUTHORIZER, MODEL, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY and RESPONSE_HEADER. It is an invalid field for any other entity type.
        public var name: Swift.String?
        /// The URL path of the target. It is a valid field for the API entity types of RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is / for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other location attributes, the child entity's path attribute must match that of the parent entity as a prefix.
        public var path: Swift.String?
        /// The HTTP status code of a response. It is a valid field for the API entity types of RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any status code. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's statusCode attribute must match that of the parent entity exactly.
        public var statusCode: Swift.String?
        /// The type of API entity to which the documentation content applies. Valid values are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Content inheritance does not apply to any entity of the API, AUTHORIZER, METHOD, MODEL, REQUEST_BODY, or RESOURCE type.
        /// This member is required.
        public var type: APIGatewayClientTypes.DocumentationPartType?

        public init(
            method: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            statusCode: Swift.String? = nil,
            type: APIGatewayClientTypes.DocumentationPartType? = nil
        )
        {
            self.method = method
            self.name = name
            self.path = path
            self.statusCode = statusCode
            self.type = type
        }
    }

}

/// Creates a new documentation part of a given API.
public struct CreateDocumentationPartInput {
    /// The location of the targeted API entity of the to-be-created documentation part.
    /// This member is required.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
    /// This member is required.
    public var properties: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.location = location
        self.properties = properties
        self.restApiId = restApiId
    }
}

/// A documentation part for a targeted API entity.
public struct CreateDocumentationPartOutput {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

/// Creates a new documentation version of a given API.
public struct CreateDocumentationVersionInput {
    /// A description about the new documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the new snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The stage name to be associated with the new documentation snapshot.
    public var stageName: Swift.String?

    public init(
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// A snapshot of the documentation of an API.
public struct CreateDocumentationVersionOutput {
    /// The date when the API documentation snapshot is created.
    public var createdDate: Foundation.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

extension APIGatewayClientTypes {

    /// The endpoint type. The valid values are EDGE for edge-optimized API setup, most suitable for mobile applications; REGIONAL for regional API endpoint setup, most suitable for calling from AWS Region; and PRIVATE for private APIs.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edge
        case `private`
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .private,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .private: return "PRIVATE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// The endpoint configuration to indicate the types of endpoints an API (RestApi) or its custom domain name (DomainName) has.
    public struct EndpointConfiguration {
        /// A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is "EDGE". For a regional API and its custom domain name, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public var types: [APIGatewayClientTypes.EndpointType]?
        /// A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for PRIVATE endpoint type.
        public var vpcEndpointIds: [Swift.String]?

        public init(
            types: [APIGatewayClientTypes.EndpointType]? = nil,
            vpcEndpointIds: [Swift.String]? = nil
        )
        {
            self.types = types
            self.vpcEndpointIds = vpcEndpointIds
        }
    }

}

extension APIGatewayClientTypes {
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public struct MutualTlsAuthenticationInput {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket
        public var truststoreVersion: Swift.String?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

extension APIGatewayClientTypes {

    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A request to create a new domain name.
public struct CreateDomainNameInput {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// [Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.
    public var certificateBody: Swift.String?
    /// [Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.
    public var certificateChain: Swift.String?
    /// The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// [Deprecated] Your edge-optimized endpoint's domain name certificate's private key.
    public var certificatePrivateKey: Swift.String?
    /// The name of the DomainName resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthenticationInput?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used by regional endpoint for this domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The user-friendly name of the certificate that will be used by regional endpoint for this domain name.
    public var regionalCertificateName: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificatePrivateKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthenticationInput? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.certificateName = certificateName
        self.certificatePrivateKey = certificatePrivateKey
        self.domainName = domainName
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

extension APIGatewayClientTypes {

    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case pending
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pending,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pending: return "PENDING"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public struct MutualTlsAuthentication {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct CreateDomainNameOutput {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded. API Gateway doesn't change this value if you update the certificate.
    public var certificateUploadDate: Foundation.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: Foundation.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

/// Request to add a new Model to an existing RestApi resource.
public struct CreateModelInput {
    /// The content-type for the model.
    /// This member is required.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The RestApi identifier under which the Model will be created.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. The maximum size of the model is 400 KB.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.name = name
        self.restApiId = restApiId
        self.schema = schema
    }
}

/// Represents the data structure of a method's request or response payload.
public struct CreateModelOutput {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

/// Creates a RequestValidator of a given RestApi.
public struct CreateRequestValidatorInput {
    /// The name of the to-be-created RequestValidator.
    public var name: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (true) or not (false).
    public var validateRequestBody: Swift.Bool?
    /// A Boolean flag to indicate whether to validate request parameters, true, or not false.
    public var validateRequestParameters: Swift.Bool?

    public init(
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        validateRequestBody: Swift.Bool? = false,
        validateRequestParameters: Swift.Bool? = false
    )
    {
        self.name = name
        self.restApiId = restApiId
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

/// A set of validation rules for incoming Method requests.
public struct CreateRequestValidatorOutput {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

/// Requests API Gateway to create a Resource resource.
public struct CreateResourceInput {
    /// The parent resource's identifier.
    /// This member is required.
    public var parentId: Swift.String?
    /// The last path segment for this resource.
    /// This member is required.
    public var pathPart: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        parentId: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.parentId = parentId
        self.pathPart = pathPart
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {

    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {

    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
    public struct IntegrationResponse {
        /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
        public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
        /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String: Swift.String]?
        /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String: Swift.String]?
        /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
        public var selectionPattern: Swift.String?
        /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
        public var statusCode: Swift.String?

        public init(
            contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
            responseParameters: [Swift.String: Swift.String]? = nil,
            responseTemplates: [Swift.String: Swift.String]? = nil,
            selectionPattern: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.contentHandling = contentHandling
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.selectionPattern = selectionPattern
            self.statusCode = statusCode
        }
    }

}

extension APIGatewayClientTypes {
    /// Specifies the TLS configuration for an integration.
    public struct TlsConfig {
        /// Specifies whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations. Enabling insecureSkipVerification isn't recommended, especially for integrations with public HTTPS endpoints. If you enable insecureSkipVerification, you increase the risk of man-in-the-middle attacks.
        public var insecureSkipVerification: Swift.Bool

        public init(
            insecureSkipVerification: Swift.Bool = false
        )
        {
            self.insecureSkipVerification = insecureSkipVerification
        }
    }

}

extension APIGatewayClientTypes {

    /// The integration type. The valid value is HTTP for integrating an API method with an HTTP backend; AWS with any Amazon Web Services service endpoints; MOCK for testing without actually invoking the backend; HTTP_PROXY for integrating with the HTTP proxy integration; AWS_PROXY for integrating with the Lambda proxy integration.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
    public struct Integration {
        /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
        public var cacheKeyParameters: [Swift.String]?
        /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
        public var cacheNamespace: Swift.String?
        /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
        public var connectionType: APIGatewayClientTypes.ConnectionType?
        /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
        public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
        public var credentials: Swift.String?
        /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
        public var httpMethod: Swift.String?
        /// Specifies the integration's responses.
        public var integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]?
        /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
        public var passthroughBehavior: Swift.String?
        /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
        public var requestParameters: [Swift.String: Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
        public var requestTemplates: [Swift.String: Swift.String]?
        /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
        public var timeoutInMillis: Swift.Int
        /// Specifies the TLS configuration for an integration.
        public var tlsConfig: APIGatewayClientTypes.TlsConfig?
        /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
        public var type: APIGatewayClientTypes.IntegrationType?
        /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
        public var uri: Swift.String?

        public init(
            cacheKeyParameters: [Swift.String]? = nil,
            cacheNamespace: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionType: APIGatewayClientTypes.ConnectionType? = nil,
            contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
            credentials: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]? = nil,
            passthroughBehavior: Swift.String? = nil,
            requestParameters: [Swift.String: Swift.String]? = nil,
            requestTemplates: [Swift.String: Swift.String]? = nil,
            timeoutInMillis: Swift.Int = 0,
            tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
            type: APIGatewayClientTypes.IntegrationType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.cacheKeyParameters = cacheKeyParameters
            self.cacheNamespace = cacheNamespace
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandling = contentHandling
            self.credentials = credentials
            self.httpMethod = httpMethod
            self.integrationResponses = integrationResponses
            self.passthroughBehavior = passthroughBehavior
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
            self.type = type
            self.uri = uri
        }
    }

}

extension APIGatewayClientTypes {
    /// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
    public struct MethodResponse {
        /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
        public var responseModels: [Swift.String: Swift.String]?
        /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
        public var responseParameters: [Swift.String: Swift.Bool]?
        /// The method response's status code.
        public var statusCode: Swift.String?

        public init(
            responseModels: [Swift.String: Swift.String]? = nil,
            responseParameters: [Swift.String: Swift.Bool]? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.statusCode = statusCode
        }
    }

}

extension APIGatewayClientTypes {
    /// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
    public struct Method {
        /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?
        /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
        public var authorizerId: Swift.String?
        /// The method's HTTP verb.
        public var httpMethod: Swift.String?
        /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
        public var methodIntegration: APIGatewayClientTypes.Integration?
        /// Gets a method response associated with a given HTTP status code.
        public var methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]?
        /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
        public var operationName: Swift.String?
        /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
        public var requestModels: [Swift.String: Swift.String]?
        /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
        public var requestParameters: [Swift.String: Swift.Bool]?
        /// The identifier of a RequestValidator for request validation.
        public var requestValidatorId: Swift.String?

        public init(
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            methodIntegration: APIGatewayClientTypes.Integration? = nil,
            methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String: Swift.String]? = nil,
            requestParameters: [Swift.String: Swift.Bool]? = nil,
            requestValidatorId: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.httpMethod = httpMethod
            self.methodIntegration = methodIntegration
            self.methodResponses = methodResponses
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.requestValidatorId = requestValidatorId
        }
    }

}

/// Represents an API resource.
public struct CreateResourceOutput {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String: APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String: APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

/// The POST Request to add a new RestApi resource to your collection.
public struct CreateRestApiInput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The ID of the RestApi that you want to clone from.
    public var cloneFrom: Swift.String?
    /// The description of the RestApi.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The name of the RestApi.
    /// This member is required.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        cloneFrom: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.cloneFrom = cloneFrom
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
    }
}

/// Represents a REST API.
public struct CreateRestApiOutput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

extension APIGatewayClientTypes {
    /// Configuration settings of a canary deployment.
    public struct CanarySettings {
        /// The ID of the canary deployment.
        public var deploymentId: Swift.String?
        /// The percent (0-100) of traffic diverted to a canary deployment.
        public var percentTraffic: Swift.Double
        /// Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String: Swift.String]?
        /// A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init(
            deploymentId: Swift.String? = nil,
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String: Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

/// Requests API Gateway to create a Stage resource.
public struct CreateStageInput {
    /// Whether cache clustering is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool?
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The canary deployment settings of this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of the Deployment resource for the Stage resource.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description of the Stage resource.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name for the Stage resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool?
    /// A map that defines the stage variables for the new Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String: Swift.String]?

    public init(
        cacheClusterEnabled: Swift.Bool? = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tracingEnabled: Swift.Bool? = false,
        variables: [Swift.String: Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

extension APIGatewayClientTypes {

    /// Returns the status of the CacheCluster.
    public enum CacheClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case createInProgress
        case deleteInProgress
        case flushInProgress
        case notAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterStatus] {
            return [
                .available,
                .createInProgress,
                .deleteInProgress,
                .flushInProgress,
                .notAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .flushInProgress: return "FLUSH_IN_PROGRESS"
            case .notAvailable: return "NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {

    public enum UnauthorizedCacheControlHeaderStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failWith403
        case succeedWithoutResponseHeader
        case succeedWithResponseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [UnauthorizedCacheControlHeaderStrategy] {
            return [
                .failWith403,
                .succeedWithoutResponseHeader,
                .succeedWithResponseHeader
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failWith403: return "FAIL_WITH_403"
            case .succeedWithoutResponseHeader: return "SUCCEED_WITHOUT_RESPONSE_HEADER"
            case .succeedWithResponseHeader: return "SUCCEED_WITH_RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Specifies the method setting properties.
    public struct MethodSetting {
        /// Specifies whether the cached responses are encrypted.
        public var cacheDataEncrypted: Swift.Bool
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
        public var cacheTtlInSeconds: Swift.Int
        /// Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
        public var cachingEnabled: Swift.Bool
        /// Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs.
        public var dataTraceEnabled: Swift.Bool
        /// Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are OFF, ERROR, and INFO. Choose ERROR to write only error-level entries to CloudWatch Logs, or choose INFO to include all ERROR events as well as extra informational events.
        public var loggingLevel: Swift.String?
        /// Specifies whether Amazon CloudWatch metrics are enabled for this method.
        public var metricsEnabled: Swift.Bool
        /// Specifies whether authorization is required for a cache invalidation request.
        public var requireAuthorizationForCacheControl: Swift.Bool
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double
        /// Specifies how to handle unauthorized requests for cache invalidation.
        public var unauthorizedCacheControlHeaderStrategy: APIGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy?

        public init(
            cacheDataEncrypted: Swift.Bool = false,
            cacheTtlInSeconds: Swift.Int = 0,
            cachingEnabled: Swift.Bool = false,
            dataTraceEnabled: Swift.Bool = false,
            loggingLevel: Swift.String? = nil,
            metricsEnabled: Swift.Bool = false,
            requireAuthorizationForCacheControl: Swift.Bool = false,
            throttlingBurstLimit: Swift.Int = 0,
            throttlingRateLimit: Swift.Double = 0.0,
            unauthorizedCacheControlHeaderStrategy: APIGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy? = nil
        )
        {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }
    }

}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct CreateStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage. To activate a method-level cache, set CachingEnabled to true for a method.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String: Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String: Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

extension APIGatewayClientTypes {

    public enum QuotaPeriodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaPeriodType] {
            return [
                .day,
                .month,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// Quotas configured for a usage plan.
    public struct QuotaSettings {
        /// The target maximum number of requests that can be made in a given time period.
        public var limit: Swift.Int
        /// The number of requests subtracted from the given limit in the initial time period.
        public var offset: Swift.Int
        /// The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
        public var period: APIGatewayClientTypes.QuotaPeriodType?

        public init(
            limit: Swift.Int = 0,
            offset: Swift.Int = 0,
            period: APIGatewayClientTypes.QuotaPeriodType? = nil
        )
        {
            self.limit = limit
            self.offset = offset
            self.period = period
        }
    }

}

/// The POST request to create a usage plan with the name, description, throttle limits and quota limits, as well as the associated API stages, specified in the payload.
public struct CreateUsagePlanInput {
    /// The associated API stages of the usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of the usage plan.
    public var description: Swift.String?
    /// The name of the usage plan.
    /// This member is required.
    public var name: Swift.String?
    /// The quota of the usage plan.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?
    /// The throttling limits of the usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.name = name
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Don’t rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct CreateUsagePlanOutput {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

/// The POST request to create a usage plan key for adding an existing API key to a usage plan.
public struct CreateUsagePlanKeyInput {
    /// The identifier of a UsagePlanKey resource for a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// The type of a UsagePlanKey resource for a plan customer.
    /// This member is required.
    public var keyType: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-created UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        keyType: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.keyType = keyType
        self.usagePlanId = usagePlanId
    }
}

/// Represents a usage plan key to identify a plan customer.
public struct CreateUsagePlanKeyOutput {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

/// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
public struct CreateVpcLinkInput {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The name used to label and identify the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    /// This member is required.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.targetArns = targetArns
    }
}

extension APIGatewayClientTypes {

    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct CreateVpcLinkOutput {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

/// A request to delete the ApiKey resource.
public struct DeleteApiKeyInput {
    /// The identifier of the ApiKey resource to be deleted.
    /// This member is required.
    public var apiKey: Swift.String?

    public init(
        apiKey: Swift.String? = nil
    )
    {
        self.apiKey = apiKey
    }
}

/// Request to delete an existing Authorizer resource.
public struct DeleteAuthorizerInput {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

/// A request to delete the BasePathMapping resource.
public struct DeleteBasePathMappingInput {
    /// The base path name of the BasePathMapping resource to delete. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

/// A request to delete the ClientCertificate resource.
public struct DeleteClientCertificateInput {
    /// The identifier of the ClientCertificate resource to be deleted.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init(
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

/// Requests API Gateway to delete a Deployment resource.
public struct DeleteDeploymentInput {
    /// The identifier of the Deployment resource to delete.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

/// Deletes an existing documentation part of an API.
public struct DeleteDocumentationPartInput {
    /// The identifier of the to-be-deleted documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

/// Deletes an existing documentation version of an API.
public struct DeleteDocumentationVersionInput {
    /// The version identifier of a to-be-deleted documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

/// A request to delete the DomainName resource.
public struct DeleteDomainNameInput {
    /// The name of the DomainName resource to be deleted.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension APIGatewayClientTypes {

    public enum GatewayResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case apiConfigurationError
        case authorizerConfigurationError
        case authorizerFailure
        case badRequestBody
        case badRequestParameters
        case default4xx
        case default5xx
        case expiredToken
        case integrationFailure
        case integrationTimeout
        case invalidApiKey
        case invalidSignature
        case missingAuthenticationToken
        case quotaExceeded
        case requestTooLarge
        case resourceNotFound
        case throttled
        case unauthorized
        case unsupportedMediaType
        case wafFiltered
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayResponseType] {
            return [
                .accessDenied,
                .apiConfigurationError,
                .authorizerConfigurationError,
                .authorizerFailure,
                .badRequestBody,
                .badRequestParameters,
                .default4xx,
                .default5xx,
                .expiredToken,
                .integrationFailure,
                .integrationTimeout,
                .invalidApiKey,
                .invalidSignature,
                .missingAuthenticationToken,
                .quotaExceeded,
                .requestTooLarge,
                .resourceNotFound,
                .throttled,
                .unauthorized,
                .unsupportedMediaType,
                .wafFiltered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .apiConfigurationError: return "API_CONFIGURATION_ERROR"
            case .authorizerConfigurationError: return "AUTHORIZER_CONFIGURATION_ERROR"
            case .authorizerFailure: return "AUTHORIZER_FAILURE"
            case .badRequestBody: return "BAD_REQUEST_BODY"
            case .badRequestParameters: return "BAD_REQUEST_PARAMETERS"
            case .default4xx: return "DEFAULT_4XX"
            case .default5xx: return "DEFAULT_5XX"
            case .expiredToken: return "EXPIRED_TOKEN"
            case .integrationFailure: return "INTEGRATION_FAILURE"
            case .integrationTimeout: return "INTEGRATION_TIMEOUT"
            case .invalidApiKey: return "INVALID_API_KEY"
            case .invalidSignature: return "INVALID_SIGNATURE"
            case .missingAuthenticationToken: return "MISSING_AUTHENTICATION_TOKEN"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case .requestTooLarge: return "REQUEST_TOO_LARGE"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .throttled: return "THROTTLED"
            case .unauthorized: return "UNAUTHORIZED"
            case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
            case .wafFiltered: return "WAF_FILTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
public struct DeleteGatewayResponseInput {
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

/// Represents a delete integration request.
public struct DeleteIntegrationInput {
    /// Specifies a delete integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a delete integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents a delete integration response request.
public struct DeleteIntegrationResponseInput {
    /// Specifies a delete integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a delete integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies a delete integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Request to delete an existing Method resource.
public struct DeleteMethodInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// A request to delete an existing MethodResponse resource.
public struct DeleteMethodResponseInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code identifier for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Request to delete an existing model in an existing RestApi resource.
public struct DeleteModelInput {
    /// The name of the model to delete.
    /// This member is required.
    public var modelName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

/// Deletes a specified RequestValidator of a given RestApi.
public struct DeleteRequestValidatorInput {
    /// The identifier of the RequestValidator to be deleted.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

/// Request to delete a Resource.
public struct DeleteResourceInput {
    /// The identifier of the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Request to delete the specified API from your collection.
public struct DeleteRestApiInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

/// Requests API Gateway to delete a Stage resource.
public struct DeleteStageInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to delete.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// The DELETE request to delete a usage plan of a given plan Id.
public struct DeleteUsagePlanInput {
    /// The Id of the to-be-deleted usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

/// The DELETE request to delete a usage plan key and remove the underlying API key from the associated usage plan.
public struct DeleteUsagePlanKeyInput {
    /// The Id of the UsagePlanKey resource to be deleted.
    /// This member is required.
    public var keyId: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-deleted UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

/// Deletes an existing VpcLink of a specified identifier.
public struct DeleteVpcLinkInput {
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

/// Request to flush authorizer cache entries on a specified stage.
public struct FlushStageAuthorizersCacheInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the stage to flush.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// Requests API Gateway to flush a stage's cache.
public struct FlushStageCacheInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the stage to flush its cache.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// A request to generate a ClientCertificate resource.
public struct GenerateClientCertificateInput {
    /// The description of the ClientCertificate.
    public var description: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct GenerateClientCertificateOutput {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: Foundation.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: Foundation.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

/// Requests API Gateway to get information about the current Account resource.
public struct GetAccountInput {

    public init() { }
}

/// Represents an AWS account that is associated with API Gateway.
public struct GetAccountOutput {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current Account.
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current Account.
    public var throttleSettings: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

/// A request to get information about the current ApiKey resource.
public struct GetApiKeyInput {
    /// The identifier of the ApiKey resource.
    /// This member is required.
    public var apiKey: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains the key value.
    public var includeValue: Swift.Bool?

    public init(
        apiKey: Swift.String? = nil,
        includeValue: Swift.Bool? = nil
    )
    {
        self.apiKey = apiKey
        self.includeValue = includeValue
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct GetApiKeyOutput {
    /// The timestamp when the API Key was created.
    public var createdDate: Foundation.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

/// A request to get information about the current ApiKeys resource.
public struct GetApiKeysInput {
    /// The identifier of a customer in Amazon Web Services Marketplace or an external system, such as a developer portal.
    public var customerId: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains key values.
    public var includeValues: Swift.Bool?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The name of queried API keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        customerId: Swift.String? = nil,
        includeValues: Swift.Bool? = nil,
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.includeValues = includeValues
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
    }
}

/// Represents a collection of API keys as represented by an ApiKeys resource.
public struct GetApiKeysOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.ApiKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// A list of warning messages logged during the import of API keys when the failOnWarnings option is set to true.
    public var warnings: [Swift.String]?

    public init(
        items: [APIGatewayClientTypes.ApiKey]? = nil,
        position: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.items = items
        self.position = position
        self.warnings = warnings
    }
}

/// Request to describe an existing Authorizer resource.
public struct GetAuthorizerInput {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct GetAuthorizerOutput {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

/// Request to describe an existing Authorizers resource.
public struct GetAuthorizersInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

/// Represents a collection of Authorizer resources.
public struct GetAuthorizersOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Authorizer]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Authorizer]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request to describe a BasePathMapping resource.
public struct GetBasePathMappingInput {
    /// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify any base path name after the domain name.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to be described.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct GetBasePathMappingOutput {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

/// A request to get information about a collection of BasePathMapping resources.
public struct GetBasePathMappingsInput {
    /// The domain name of a BasePathMapping resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// Represents the base path that callers of the API must provide as part of the URL after the domain name.
    public struct BasePathMapping {
        /// The base path name that callers of the API must provide as part of the URL after the domain name.
        public var basePath: Swift.String?
        /// The string identifier of the associated RestApi.
        public var restApiId: Swift.String?
        /// The name of the associated stage.
        public var stage: Swift.String?

        public init(
            basePath: Swift.String? = nil,
            restApiId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.restApiId = restApiId
            self.stage = stage
        }
    }

}

/// Represents a collection of BasePathMapping resources.
public struct GetBasePathMappingsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.BasePathMapping]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.BasePathMapping]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// A request to get information about the current ClientCertificate resource.
public struct GetClientCertificateInput {
    /// The identifier of the ClientCertificate resource to be described.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init(
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct GetClientCertificateOutput {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: Foundation.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: Foundation.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

/// A request to get information about a collection of ClientCertificate resources.
public struct GetClientCertificatesInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
    public struct ClientCertificate {
        /// The identifier of the client certificate.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the client certificate was created.
        public var createdDate: Foundation.Date?
        /// The description of the client certificate.
        public var description: Swift.String?
        /// The timestamp when the client certificate will expire.
        public var expirationDate: Foundation.Date?
        /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
        public var pemEncodedCertificate: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            clientCertificateId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            expirationDate: Foundation.Date? = nil,
            pemEncodedCertificate: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.description = description
            self.expirationDate = expirationDate
            self.pemEncodedCertificate = pemEncodedCertificate
            self.tags = tags
        }
    }

}

/// Represents a collection of ClientCertificate resources.
public struct GetClientCertificatesOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.ClientCertificate]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.ClientCertificate]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Requests API Gateway to get information about a Deployment resource.
public struct GetDeploymentInput {
    /// The identifier of the Deployment resource to get information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// A query parameter to retrieve the specified embedded resources of the returned Deployment resource in the response. In a REST API call, this embed parameter value is a list of comma-separated strings, as in GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2. The SDK and other platform-dependent libraries might use a different format for the list. Currently, this request supports only retrieval of the embedded API summary this way. Hence, the parameter value must be a single-valued list containing only the "apisummary" string. For example, GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary.
    public var embed: [Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        embed: [Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.embed = embed
        self.restApiId = restApiId
    }
}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct GetDeploymentOutput {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

/// Requests API Gateway to get information about a Deployments collection.
public struct GetDeploymentsInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
    public struct Deployment {
        /// A summary of the RestApi at the date and time that the deployment resource was created.
        public var apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]?
        /// The date and time that the deployment resource was created.
        public var createdDate: Foundation.Date?
        /// The description for the deployment resource.
        public var description: Swift.String?
        /// The identifier for the deployment resource.
        public var id: Swift.String?

        public init(
            apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.apiSummary = apiSummary
            self.createdDate = createdDate
            self.description = description
            self.id = id
        }
    }

}

/// Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on how to interact with your collection. The collection offers a paginated view of the contained deployments.
public struct GetDeploymentsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Deployment]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Deployment]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Gets a specified documentation part of a given API.
public struct GetDocumentationPartInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

/// A documentation part for a targeted API entity.
public struct GetDocumentationPartOutput {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

extension APIGatewayClientTypes {

    public enum LocationStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case documented
        case undocumented
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationStatusType] {
            return [
                .documented,
                .undocumented
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .documented: return "DOCUMENTED"
            case .undocumented: return "UNDOCUMENTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Gets the documentation parts of an API. The result may be filtered by the type, name, or path of API entities (targets).
public struct GetDocumentationPartsInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The status of the API documentation parts to retrieve. Valid values are DOCUMENTED for retrieving DocumentationPart resources with content and UNDOCUMENTED for DocumentationPart resources without content.
    public var locationStatus: APIGatewayClientTypes.LocationStatusType?
    /// The name of API entities of the to-be-retrieved documentation parts.
    public var nameQuery: Swift.String?
    /// The path of API entities of the to-be-retrieved documentation parts.
    public var path: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The type of API entities of the to-be-retrieved documentation parts.
    public var type: APIGatewayClientTypes.DocumentationPartType?

    public init(
        limit: Swift.Int? = nil,
        locationStatus: APIGatewayClientTypes.LocationStatusType? = nil,
        nameQuery: Swift.String? = nil,
        path: Swift.String? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        type: APIGatewayClientTypes.DocumentationPartType? = nil
    )
    {
        self.limit = limit
        self.locationStatus = locationStatus
        self.nameQuery = nameQuery
        self.path = path
        self.position = position
        self.restApiId = restApiId
        self.type = type
    }
}

extension APIGatewayClientTypes {
    /// A documentation part for a targeted API entity.
    public struct DocumentationPart {
        /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
        public var id: Swift.String?
        /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
        public var location: APIGatewayClientTypes.DocumentationPartLocation?
        /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
        public var properties: Swift.String?

        public init(
            id: Swift.String? = nil,
            location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
            properties: Swift.String? = nil
        )
        {
            self.id = id
            self.location = location
            self.properties = properties
        }
    }

}

/// The collection of documentation parts of an API.
public struct GetDocumentationPartsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DocumentationPart]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DocumentationPart]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Gets a documentation snapshot of an API.
public struct GetDocumentationVersionInput {
    /// The version identifier of the to-be-retrieved documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

/// A snapshot of the documentation of an API.
public struct GetDocumentationVersionOutput {
    /// The date when the API documentation snapshot is created.
    public var createdDate: Foundation.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

/// Gets the documentation versions of an API.
public struct GetDocumentationVersionsInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// A snapshot of the documentation of an API.
    public struct DocumentationVersion {
        /// The date when the API documentation snapshot is created.
        public var createdDate: Foundation.Date?
        /// The description of the API documentation snapshot.
        public var description: Swift.String?
        /// The version identifier of the API documentation snapshot.
        public var version: Swift.String?

        public init(
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.version = version
        }
    }

}

/// The collection of documentation snapshots of an API.
public struct GetDocumentationVersionsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DocumentationVersion]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DocumentationVersion]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request to get the name of a DomainName resource.
public struct GetDomainNameInput {
    /// The name of the DomainName resource.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct GetDomainNameOutput {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded. API Gateway doesn't change this value if you update the certificate.
    public var certificateUploadDate: Foundation.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: Foundation.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

/// Request to describe a collection of DomainName resources.
public struct GetDomainNamesInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// Represents a custom domain name as a user-friendly host name of an API (RestApi).
    public struct DomainName {
        /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded. API Gateway doesn't change this value if you update the certificate.
        public var certificateUploadDate: Foundation.Date?
        /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
        public var distributionDomainName: Swift.String?
        /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
        public var distributionHostedZoneId: Swift.String?
        /// The custom domain name as an API host name, for example, my-api.example.com.
        public var domainName: Swift.String?
        /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the DomainName migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
        public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
        /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
        public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
        public var regionalCertificateArn: Swift.String?
        /// The name of the certificate that will be used for validating the regional domain name.
        public var regionalCertificateName: Swift.String?
        /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
        public var regionalDomainName: Swift.String?
        /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
        public var regionalHostedZoneId: Swift.String?
        /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: Foundation.Date? = nil,
            distributionDomainName: Swift.String? = nil,
            distributionHostedZoneId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
            mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            regionalCertificateArn: Swift.String? = nil,
            regionalCertificateName: Swift.String? = nil,
            regionalDomainName: Swift.String? = nil,
            regionalHostedZoneId: Swift.String? = nil,
            securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.distributionDomainName = distributionDomainName
            self.distributionHostedZoneId = distributionHostedZoneId
            self.domainName = domainName
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointConfiguration = endpointConfiguration
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.regionalCertificateArn = regionalCertificateArn
            self.regionalCertificateName = regionalCertificateName
            self.regionalDomainName = regionalDomainName
            self.regionalHostedZoneId = regionalHostedZoneId
            self.securityPolicy = securityPolicy
            self.tags = tags
        }
    }

}

/// Represents a collection of DomainName resources.
public struct GetDomainNamesOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DomainName]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DomainName]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request a new export of a RestApi for a particular Stage.
public struct GetExportInput {
    /// The content-type of the export, for example application/json. Currently application/json and application/yaml are supported for exportType ofoas30 and swagger. This should be specified in the Accept header for direct API requests.
    public var accepts: Swift.String?
    /// The type of export. Acceptable values are 'oas30' for OpenAPI 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.
    /// This member is required.
    public var exportType: Swift.String?
    /// A key-value map of query string parameters that specify properties of the export, depending on the requested exportType. For exportTypeoas30 and swagger, any combination of the following parameters are supported: extensions='integrations' or extensions='apigateway' will export the API with x-amazon-apigateway-integration extensions. extensions='authorizers' will export the API with x-amazon-apigateway-authorizer extensions. postman will export the API with Postman extensions, allowing for import to the Postman tool
    public var parameters: [Swift.String: Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage that will be exported.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        accepts: Swift.String? = nil,
        exportType: Swift.String? = nil,
        parameters: [Swift.String: Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.accepts = accepts
        self.exportType = exportType
        self.parameters = parameters
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// The binary blob response to GetExport, which contains the generated SDK.
public struct GetExportOutput {
    /// The binary blob response to GetExport, which contains the export.
    public var body: Foundation.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response. This will correspond to a valid 'accept' type in the request.
    public var contentType: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

/// Gets a GatewayResponse of a specified response type on the given RestApi.
public struct GetGatewayResponseInput {
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct GetGatewayResponseOutput {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

/// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
public struct GetGatewayResponsesInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500. The GatewayResponses collection does not support pagination and the limit does not apply here.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set. The GatewayResponse collection does not support pagination and the position does not apply here.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
    public struct GatewayResponse {
        /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
        public var defaultResponse: Swift.Bool
        /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
        public var responseParameters: [Swift.String: Swift.String]?
        /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
        public var responseTemplates: [Swift.String: Swift.String]?
        /// The response type of the associated GatewayResponse.
        public var responseType: APIGatewayClientTypes.GatewayResponseType?
        /// The HTTP status code for this GatewayResponse.
        public var statusCode: Swift.String?

        public init(
            defaultResponse: Swift.Bool = false,
            responseParameters: [Swift.String: Swift.String]? = nil,
            responseTemplates: [Swift.String: Swift.String]? = nil,
            responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.defaultResponse = defaultResponse
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.responseType = responseType
            self.statusCode = statusCode
        }
    }

}

/// The collection of the GatewayResponse instances of a RestApi as a responseType-to-GatewayResponse object map of key-value pairs. As such, pagination is not supported for querying this collection.
public struct GetGatewayResponsesOutput {
    /// Returns the entire collection, because of no pagination support.
    public var items: [APIGatewayClientTypes.GatewayResponse]?
    /// The current pagination position in the paged result set. The GatewayResponse collection does not support pagination and the position does not apply here.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.GatewayResponse]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Represents a request to get the integration configuration.
public struct GetIntegrationInput {
    /// Specifies a get integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a get integration request's resource identifier
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct GetIntegrationOutput {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

/// Represents a get integration response request.
public struct GetIntegrationResponseInput {
    /// Specifies a get integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a get integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies a get integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct GetIntegrationResponseOutput {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

/// Request to describe an existing Method resource.
public struct GetMethodInput {
    /// Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct GetMethodOutput {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String: Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String: Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

/// Request to describe a MethodResponse resource.
public struct GetMethodResponseInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct GetMethodResponseOutput {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String: Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String: Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

/// Request to list information about a model in an existing RestApi resource.
public struct GetModelInput {
    /// A query parameter of a Boolean value to resolve (true) all external model references and returns a flattened model schema or not (false) The default is false.
    public var flatten: Swift.Bool?
    /// The name of the model as an identifier.
    /// This member is required.
    public var modelName: Swift.String?
    /// The RestApi identifier under which the Model exists.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        flatten: Swift.Bool? = false,
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.flatten = flatten
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

/// Represents the data structure of a method's request or response payload.
public struct GetModelOutput {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

/// Request to list existing Models defined for a RestApi resource.
public struct GetModelsInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// Represents the data structure of a method's request or response payload.
    public struct Model {
        /// The content-type for the model.
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The identifier for the model resource.
        public var id: Swift.String?
        /// The name of the model. Must be an alphanumeric string.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
        public var schema: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.id = id
            self.name = name
            self.schema = schema
        }
    }

}

/// Represents a collection of Model resources.
public struct GetModelsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Model]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Model]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request to generate a sample mapping template used to transform the payload.
public struct GetModelTemplateInput {
    /// The name of the model for which to generate a template.
    /// This member is required.
    public var modelName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

/// Represents a mapping template used to transform a payload.
public struct GetModelTemplateOutput {
    /// The Apache Velocity Template Language (VTL) template content used for the template resource.
    public var value: Swift.String?

    public init(
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

/// Gets a RequestValidator of a given RestApi.
public struct GetRequestValidatorInput {
    /// The identifier of the RequestValidator to be retrieved.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

/// A set of validation rules for incoming Method requests.
public struct GetRequestValidatorOutput {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

/// Gets the RequestValidators collection of a given RestApi.
public struct GetRequestValidatorsInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// A set of validation rules for incoming Method requests.
    public struct RequestValidator {
        /// The identifier of this RequestValidator.
        public var id: Swift.String?
        /// The name of this RequestValidator
        public var name: Swift.String?
        /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
        public var validateRequestBody: Swift.Bool
        /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
        public var validateRequestParameters: Swift.Bool

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            validateRequestBody: Swift.Bool = false,
            validateRequestParameters: Swift.Bool = false
        )
        {
            self.id = id
            self.name = name
            self.validateRequestBody = validateRequestBody
            self.validateRequestParameters = validateRequestParameters
        }
    }

}

/// A collection of RequestValidator resources of a given RestApi.
public struct GetRequestValidatorsOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.RequestValidator]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.RequestValidator]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request to list information about a resource.
public struct GetResourceInput {
    /// A query parameter to retrieve the specified resources embedded in the returned Resource representation in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods.
    public var embed: [Swift.String]?
    /// The identifier for the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        embed: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents an API resource.
public struct GetResourceOutput {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String: APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String: APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

/// Request to list information about a collection of resources.
public struct GetResourcesInput {
    /// A query parameter used to retrieve the specified resources embedded in the returned Resources resource in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources?embed=methods.
    public var embed: [Swift.String]?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        embed: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// Represents an API resource.
    public struct Resource {
        /// The resource's identifier.
        public var id: Swift.String?
        /// The parent resource's identifier.
        public var parentId: Swift.String?
        /// The full path for this resource.
        public var path: Swift.String?
        /// The last path segment for this resource.
        public var pathPart: Swift.String?
        /// Gets an API resource's method of a given HTTP verb.
        public var resourceMethods: [Swift.String: APIGatewayClientTypes.Method]?

        public init(
            id: Swift.String? = nil,
            parentId: Swift.String? = nil,
            path: Swift.String? = nil,
            pathPart: Swift.String? = nil,
            resourceMethods: [Swift.String: APIGatewayClientTypes.Method]? = nil
        )
        {
            self.id = id
            self.parentId = parentId
            self.path = path
            self.pathPart = pathPart
            self.resourceMethods = resourceMethods
        }
    }

}

/// Represents a collection of Resource resources.
public struct GetResourcesOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Resource]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Resource]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// The GET request to list an existing RestApi defined for your collection.
public struct GetRestApiInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

/// Represents a REST API.
public struct GetRestApiOutput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// The GET request to list existing RestApis defined for your collection.
public struct GetRestApisInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// Represents a REST API.
    public struct RestApi {
        /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
        public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
        /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
        public var binaryMediaTypes: [Swift.String]?
        /// The timestamp when the API was created.
        public var createdDate: Foundation.Date?
        /// The API's description.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool
        /// The endpoint configuration of this RestApi showing the endpoint types of the API.
        public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
        /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
        public var id: Swift.String?
        /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
        public var minimumCompressionSize: Swift.Int?
        /// The API's name.
        public var name: Swift.String?
        /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
        public var policy: Swift.String?
        /// The API's root resource ID.
        public var rootResourceId: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init(
            apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
            binaryMediaTypes: [Swift.String]? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool = false,
            endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
            id: Swift.String? = nil,
            minimumCompressionSize: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil,
            rootResourceId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.policy = policy
            self.rootResourceId = rootResourceId
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

/// Contains references to your APIs and links that guide you in how to interact with your collection. A collection offers a paginated view of your APIs.
public struct GetRestApisOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.RestApi]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.RestApi]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Request a new generated client SDK for a RestApi and Stage.
public struct GetSdkInput {
    /// A string-to-string key-value map of query parameters sdkType-dependent properties of the SDK. For sdkType of objectivec or swift, a parameter named classPrefix is required. For sdkType of android, parameters named groupId, artifactId, artifactVersion, and invokerPackage are required. For sdkType of java, parameters named serviceName and javaPackageName are required.
    public var parameters: [Swift.String: Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The language for the generated SDK. Currently java, javascript, android, objectivec (for iOS), swift (for iOS), and ruby are supported.
    /// This member is required.
    public var sdkType: Swift.String?
    /// The name of the Stage that the SDK will use.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        parameters: [Swift.String: Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        sdkType: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.parameters = parameters
        self.restApiId = restApiId
        self.sdkType = sdkType
        self.stageName = stageName
    }
}

/// The binary blob response to GetSdk, which contains the generated SDK.
public struct GetSdkOutput {
    /// The binary blob response to GetSdk, which contains the generated SDK.
    public var body: Foundation.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response.
    public var contentType: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

/// Get an SdkType instance.
public struct GetSdkTypeInput {
    /// The identifier of the queried SdkType instance.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension APIGatewayClientTypes {
    /// A configuration property of an SDK type.
    public struct SdkConfigurationProperty {
        /// The default value of an SdkType configuration property.
        public var defaultValue: Swift.String?
        /// The description of an SdkType configuration property.
        public var description: Swift.String?
        /// The user-friendly name of an SdkType configuration property.
        public var friendlyName: Swift.String?
        /// The name of a an SdkType configuration property.
        public var name: Swift.String?
        /// A boolean flag of an SdkType configuration property to indicate if the associated SDK configuration property is required (true) or not (false).
        public var `required`: Swift.Bool

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool = false
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.friendlyName = friendlyName
            self.name = name
            self.`required` = `required`
        }
    }

}

/// A type of SDK that API Gateway can generate.
public struct GetSdkTypeOutput {
    /// A list of configuration properties of an SdkType.
    public var configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]?
    /// The description of an SdkType.
    public var description: Swift.String?
    /// The user-friendly name of an SdkType instance.
    public var friendlyName: Swift.String?
    /// The identifier of an SdkType instance.
    public var id: Swift.String?

    public init(
        configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]? = nil,
        description: Swift.String? = nil,
        friendlyName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.configurationProperties = configurationProperties
        self.description = description
        self.friendlyName = friendlyName
        self.id = id
    }
}

/// Get the SdkTypes collection.
public struct GetSdkTypesInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// A type of SDK that API Gateway can generate.
    public struct SdkType {
        /// A list of configuration properties of an SdkType.
        public var configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]?
        /// The description of an SdkType.
        public var description: Swift.String?
        /// The user-friendly name of an SdkType instance.
        public var friendlyName: Swift.String?
        /// The identifier of an SdkType instance.
        public var id: Swift.String?

        public init(
            configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.configurationProperties = configurationProperties
            self.description = description
            self.friendlyName = friendlyName
            self.id = id
        }
    }

}

/// The collection of SdkType instances.
public struct GetSdkTypesOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.SdkType]?

    public init(
        items: [APIGatewayClientTypes.SdkType]? = nil
    )
    {
        self.items = items
    }
}

/// Requests API Gateway to get information about a Stage resource.
public struct GetStageInput {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to get information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct GetStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage. To activate a method-level cache, set CachingEnabled to true for a method.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String: Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String: Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

/// Requests API Gateway to get information about one or more Stage resources.
public struct GetStagesInput {
    /// The stages' deployment identifiers.
    public var deploymentId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

extension APIGatewayClientTypes {
    /// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
    public struct Stage {
        /// Settings for logging access in this stage.
        public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
        /// Specifies whether a cache cluster is enabled for the stage. To activate a method-level cache, set CachingEnabled to true for a method.
        public var cacheClusterEnabled: Swift.Bool
        /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
        public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
        /// The status of the cache cluster for the stage, if enabled.
        public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
        /// Settings for the canary deployment in this stage.
        public var canarySettings: APIGatewayClientTypes.CanarySettings?
        /// The identifier of a client certificate for an API stage.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: Foundation.Date?
        /// The identifier of the Deployment that the stage points to.
        public var deploymentId: Swift.String?
        /// The stage's description.
        public var description: Swift.String?
        /// The version of the associated API documentation.
        public var documentationVersion: Swift.String?
        /// The timestamp when the stage last updated.
        public var lastUpdatedDate: Foundation.Date?
        /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
        public var methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]?
        /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public var stageName: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies whether active tracing with X-ray is enabled for the Stage.
        public var tracingEnabled: Swift.Bool
        /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var variables: [Swift.String: Swift.String]?
        /// The ARN of the WebAcl associated with the Stage.
        public var webAclArn: Swift.String?

        public init(
            accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
            cacheClusterEnabled: Swift.Bool = false,
            cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
            cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
            canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            documentationVersion: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]? = nil,
            stageName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            tracingEnabled: Swift.Bool = false,
            variables: [Swift.String: Swift.String]? = nil,
            webAclArn: Swift.String? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tags = tags
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }
    }

}

/// A list of Stage resources that are associated with the ApiKey resource.
public struct GetStagesOutput {
    /// The current page of elements from this collection.
    public var item: [APIGatewayClientTypes.Stage]?

    public init(
        item: [APIGatewayClientTypes.Stage]? = nil
    )
    {
        self.item = item
    }
}

/// Gets the Tags collection for a given resource.
public struct GetTagsInput {
    /// (Not currently supported) The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// (Not currently supported) The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.resourceArn = resourceArn
    }
}

/// The collection of tags. Each tag element is associated with a given resource.
public struct GetTagsOutput {
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// The GET request to get the usage data of a usage plan in a specified time interval.
public struct GetUsageInput {
    /// The ending date (e.g., 2016-12-31) of the usage data.
    /// This member is required.
    public var endDate: Swift.String?
    /// The Id of the API key associated with the resultant usage data.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date (e.g., 2016-01-01) of the usage data.
    /// This member is required.
    public var startDate: Swift.String?
    /// The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.keyId = keyId
        self.limit = limit
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

/// Represents the usage data of a usage plan.
public struct GetUsageOutput {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String: [[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        items: [Swift.String: [[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

/// The GET request to get a usage plan of a given plan identifier.
public struct GetUsagePlanInput {
    /// The identifier of the UsagePlan resource to be retrieved.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Don’t rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct GetUsagePlanOutput {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

/// The GET request to get a usage plan key of a given key identifier.
public struct GetUsagePlanKeyInput {
    /// The key Id of the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

/// Represents a usage plan key to identify a plan customer.
public struct GetUsagePlanKeyOutput {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

/// The GET request to get all the usage plan keys representing the API keys added to a specified usage plan.
public struct GetUsagePlanKeysInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// A query parameter specifying the name of the to-be-returned usage plan keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
        self.usagePlanId = usagePlanId
    }
}

extension APIGatewayClientTypes {
    /// Represents a usage plan key to identify a plan customer.
    public struct UsagePlanKey {
        /// The Id of a usage plan key.
        public var id: Swift.String?
        /// The name of a usage plan key.
        public var name: Swift.String?
        /// The type of a usage plan key. Currently, the valid key type is API_KEY.
        public var type: Swift.String?
        /// The value of a usage plan key.
        public var value: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

/// Represents the collection of usage plan keys added to usage plans for the associated API keys and, possibly, other types of keys.
public struct GetUsagePlanKeysOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.UsagePlanKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.UsagePlanKey]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// The GET request to get all the usage plans of the caller's account.
public struct GetUsagePlansInput {
    /// The identifier of the API key associated with the usage plans.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Don’t rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
    public struct UsagePlan {
        /// The associated API stages of a usage plan.
        public var apiStages: [APIGatewayClientTypes.ApiStage]?
        /// The description of a usage plan.
        public var description: Swift.String?
        /// The identifier of a UsagePlan resource.
        public var id: Swift.String?
        /// The name of a usage plan.
        public var name: Swift.String?
        /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
        public var productCode: Swift.String?
        /// The target maximum number of permitted requests per a given unit time interval.
        public var quota: APIGatewayClientTypes.QuotaSettings?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?
        /// A map containing method level throttling information for API stage in a usage plan.
        public var throttle: APIGatewayClientTypes.ThrottleSettings?

        public init(
            apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            quota: APIGatewayClientTypes.QuotaSettings? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            throttle: APIGatewayClientTypes.ThrottleSettings? = nil
        )
        {
            self.apiStages = apiStages
            self.description = description
            self.id = id
            self.name = name
            self.productCode = productCode
            self.quota = quota
            self.tags = tags
            self.throttle = throttle
        }
    }

}

/// Represents a collection of usage plans for an AWS account.
public struct GetUsagePlansOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.UsagePlan]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.UsagePlan]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// Gets a specified VPC link under the caller's account in a region.
public struct GetVpcLinkInput {
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct GetVpcLinkOutput {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

/// Gets the VpcLinks collection under the caller's account in a selected region.
public struct GetVpcLinksInput {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

extension APIGatewayClientTypes {
    /// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
    public struct VpcLink {
        /// The description of the VPC link.
        public var description: Swift.String?
        /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
        public var id: Swift.String?
        /// The name used to label and identify the VPC link.
        public var name: Swift.String?
        /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
        public var status: APIGatewayClientTypes.VpcLinkStatus?
        /// A description about the VPC link status.
        public var statusMessage: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?
        /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
        public var targetArns: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: APIGatewayClientTypes.VpcLinkStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            targetArns: [Swift.String]? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.targetArns = targetArns
        }
    }

}

/// The collection of VPC links under the caller's account in a region.
public struct GetVpcLinksOutput {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.VpcLink]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.VpcLink]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

/// The POST request to import API keys from an external source, such as a CSV-formatted file.
public struct ImportApiKeysInput {
    /// The payload of the POST request to import API keys. For the payload format, see API Key File Format.
    /// This member is required.
    public var body: Foundation.Data?
    /// A query parameter to indicate whether to rollback ApiKey importation (true) or not (false) when error is encountered.
    public var failOnWarnings: Swift.Bool?
    /// A query parameter to specify the input format to imported API keys. Currently, only the csv format is supported.
    /// This member is required.
    public var format: APIGatewayClientTypes.ApiKeysFormat?

    public init(
        body: Foundation.Data? = nil,
        failOnWarnings: Swift.Bool? = false,
        format: APIGatewayClientTypes.ApiKeysFormat? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.format = format
    }
}

/// The identifier of an ApiKey used in a UsagePlan.
public struct ImportApiKeysOutput {
    /// A list of all the ApiKey identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages.
    public var warnings: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

extension APIGatewayClientTypes {

    public enum PutMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [PutMode] {
            return [
                .merge,
                .overwrite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .merge: return "merge"
            case .overwrite: return "overwrite"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Import documentation parts from an external (e.g., OpenAPI) definition file.
public struct ImportDocumentationPartsInput {
    /// Raw byte array representing the to-be-imported documentation parts. To import from an OpenAPI file, this is a JSON object.
    /// This member is required.
    public var body: Foundation.Data?
    /// A query parameter to specify whether to rollback the documentation importation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// A query parameter to indicate whether to overwrite (overwrite) any existing DocumentationParts definition or to merge (merge) the new definition into the existing one. The default value is merge.
    public var mode: APIGatewayClientTypes.PutMode?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        failOnWarnings: Swift.Bool? = false,
        mode: APIGatewayClientTypes.PutMode? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.restApiId = restApiId
    }
}

/// A collection of the imported DocumentationPart identifiers.
public struct ImportDocumentationPartsOutput {
    /// A list of the returned documentation part identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages reported during import of documentation parts.
    public var warnings: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

/// A POST request to import an API to API Gateway using an input of an API definition file.
public struct ImportRestApiInput {
    /// The POST request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: Foundation.Data?
    /// A query parameter to indicate whether to rollback the API creation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// A key-value map of context-specific query string parameters specifying the behavior of different API importing operations. The following shows operation-specific parameters and their supported values. To exclude DocumentationParts from the import, set parameters as ignore=documentation. To configure the endpoint type, set parameters as endpointConfigurationTypes=EDGE, endpointConfigurationTypes=REGIONAL, or endpointConfigurationTypes=PRIVATE. The default endpoint type is EDGE. To handle imported basepath, set parameters as basepath=ignore, basepath=prepend or basepath=split.
    public var parameters: [Swift.String: Swift.String]?

    public init(
        body: Foundation.Data? = nil,
        failOnWarnings: Swift.Bool? = false,
        parameters: [Swift.String: Swift.String]? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.parameters = parameters
    }
}

/// Represents a REST API.
public struct ImportRestApiOutput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
public struct PutGatewayResponseInput {
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The response type of the associated GatewayResponse
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The HTTP status code of the GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct PutGatewayResponseOutput {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

/// Sets up a method's integration.
public struct PutIntegrationInput {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration. Specify this value only if you specify VPC_LINK as the connection type.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies whether credentials are required for a put integration.
    public var credentials: Swift.String?
    /// Specifies the HTTP method for the integration.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The HTTP method for the integration.
    public var integrationHttpMethod: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Specifies a put integration request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int?
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies a put integration input's type.
    /// This member is required.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification, for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationHttpMethod: Swift.String? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationHttpMethod = integrationHttpMethod
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct PutIntegrationOutput {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

/// Represents a put integration response request.
public struct PutIntegrationResponseInput {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies a put integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a put integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name must be a valid and unique response header name and JSON-expression a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Specifies a put integration response's templates.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies the selection pattern of a put integration response.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.restApiId = restApiId
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct PutIntegrationResponseOutput {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

/// Request to add a method to an existing Resource resource.
public struct PutMethodInput {
    /// Specifies whether the method required a valid ApiKey.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    /// This member is required.
    public var authorizationType: Swift.String?
    /// Specifies the identifier of an Authorizer to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// Specifies the Model resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a Model name as the value.
    public var requestModels: [Swift.String: Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or body-mapping templates.
    public var requestParameters: [Swift.String: Swift.Bool]?
    /// The identifier of a RequestValidator for validating the method request.
    public var requestValidatorId: Swift.String?
    /// The Resource identifier for the new Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = false,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct PutMethodOutput {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String: Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String: Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

/// Request to add a MethodResponse to an existing Method resource.
public struct PutMethodResponseInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the Model resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a Model name as the value.
    public var responseModels: [Swift.String: Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String: Swift.Bool]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The method response's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: Swift.Bool]? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct PutMethodResponseOutput {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String: Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String: Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

/// A PUT request to update an existing API, with external API definitions specified as the request body.
public struct PutRestApiInput {
    /// The PUT request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: Foundation.Data?
    /// A query parameter to indicate whether to rollback the API update (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// The mode query parameter to specify the update mode. Valid values are "merge" and "overwrite". By default, the update mode is "merge".
    public var mode: APIGatewayClientTypes.PutMode?
    /// Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ignore=documentation as a parameters value, as in the AWS CLI command of aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'.
    public var parameters: [Swift.String: Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        failOnWarnings: Swift.Bool? = false,
        mode: APIGatewayClientTypes.PutMode? = nil,
        parameters: [Swift.String: Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.parameters = parameters
        self.restApiId = restApiId
    }
}

/// Represents a REST API.
public struct PutRestApiOutput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Adds or updates a tag on a given resource.
public struct TagResourceInput {
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// Make a request to simulate the invocation of an Authorizer.
public struct TestInvokeAuthorizerInput {
    /// A key-value map of additional context variables.
    public var additionalContext: [Swift.String: Swift.String]?
    /// Specifies a test invoke authorizer request's Authorizer ID.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// A key-value map of headers to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, should be specified.
    public var headers: [Swift.String: Swift.String]?
    /// The headers as a map from string to list of values to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, may be specified.
    public var multiValueHeaders: [Swift.String: [Swift.String]]?
    /// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed Stage.
    public var stageVariables: [Swift.String: Swift.String]?

    public init(
        additionalContext: [Swift.String: Swift.String]? = nil,
        authorizerId: Swift.String? = nil,
        body: Swift.String? = nil,
        headers: [Swift.String: Swift.String]? = nil,
        multiValueHeaders: [Swift.String: [Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.additionalContext = additionalContext
        self.authorizerId = authorizerId
        self.body = body
        self.headers = headers
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

/// Represents the response of the test invoke request for a custom Authorizer
public struct TestInvokeAuthorizerOutput {
    /// The authorization response.
    public var authorization: [Swift.String: [Swift.String]]?
    /// The open identity claims, with any supported custom attributes, returned from the Cognito Your User Pool configured for the API.
    public var claims: [Swift.String: Swift.String]?
    /// The HTTP status code that the client would have received. Value is 0 if the authorizer succeeded.
    public var clientStatus: Swift.Int
    /// The execution latency, in ms, of the test authorizer request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test authorizer request.
    public var log: Swift.String?
    /// The JSON policy document returned by the Authorizer
    public var policy: Swift.String?
    /// The principal identity returned by the Authorizer
    public var principalId: Swift.String?

    public init(
        authorization: [Swift.String: [Swift.String]]? = nil,
        claims: [Swift.String: Swift.String]? = nil,
        clientStatus: Swift.Int = 0,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        policy: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.authorization = authorization
        self.claims = claims
        self.clientStatus = clientStatus
        self.latency = latency
        self.log = log
        self.policy = policy
        self.principalId = principalId
    }
}

/// Make a request to simulate the invocation of a Method.
public struct TestInvokeMethodInput {
    /// The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// A ClientCertificate identifier to use in the test invocation. API Gateway will use the certificate when making the HTTPS request to the defined back-end endpoint.
    public var clientCertificateId: Swift.String?
    /// A key-value map of headers to simulate an incoming invocation request.
    public var headers: [Swift.String: Swift.String]?
    /// Specifies a test invoke method request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The headers as a map from string to list of values to simulate an incoming invocation request.
    public var multiValueHeaders: [Swift.String: [Swift.String]]?
    /// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// Specifies a test invoke method request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed Stage.
    public var stageVariables: [Swift.String: Swift.String]?

    public init(
        body: Swift.String? = nil,
        clientCertificateId: Swift.String? = nil,
        headers: [Swift.String: Swift.String]? = nil,
        httpMethod: Swift.String? = nil,
        multiValueHeaders: [Swift.String: [Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.body = body
        self.clientCertificateId = clientCertificateId
        self.headers = headers
        self.httpMethod = httpMethod
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

/// Represents the response of the test invoke request in the HTTP method.
public struct TestInvokeMethodOutput {
    /// The body of the HTTP response.
    public var body: Swift.String?
    /// The headers of the HTTP response.
    public var headers: [Swift.String: Swift.String]?
    /// The execution latency, in ms, of the test invoke request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test invoke request.
    public var log: Swift.String?
    /// The headers of the HTTP response as a map from string to list of values.
    public var multiValueHeaders: [Swift.String: [Swift.String]]?
    /// The HTTP status code.
    public var status: Swift.Int

    public init(
        body: Swift.String? = nil,
        headers: [Swift.String: Swift.String]? = nil,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        multiValueHeaders: [Swift.String: [Swift.String]]? = nil,
        status: Swift.Int = 0
    )
    {
        self.body = body
        self.headers = headers
        self.latency = latency
        self.log = log
        self.multiValueHeaders = multiValueHeaders
        self.status = status
    }
}

/// Removes a tag from a given resource.
public struct UntagResourceInput {
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension APIGatewayClientTypes {

    public enum Op: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case copy
        case move
        case remove
        case replace
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [Op] {
            return [
                .add,
                .copy,
                .move,
                .remove,
                .replace,
                .test
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "add"
            case .copy: return "copy"
            case .move: return "move"
            case .remove: return "remove"
            case .replace: return "replace"
            case .test: return "test"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension APIGatewayClientTypes {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public struct PatchOperation {
        /// The copy update operation's source as identified by a JSON-Pointer value referencing the location within the targeted resource to copy the value from. For example, to promote a canary deployment, you copy the canary deployment ID to the affiliated deployment ID by calling a PATCH request on a Stage resource with "op":"copy", "from":"/canarySettings/deploymentId" and "path":"/deploymentId".
        public var from: Swift.String?
        /// An update operation to be performed with this PATCH request. The valid value can be add, remove, replace or copy. Not all valid operations are supported for a given resource. Support of the operations depends on specific operational contexts. Attempts to apply an unsupported operation on a resource will return an error message..
        public var op: APIGatewayClientTypes.Op?
        /// The op operation's target, as identified by a JSON Pointer value that references a location within the targeted resource. For example, if the target resource has an updateable property of {"name":"value"}, the path for this property is /name. If the name property value is a JSON object (e.g., {"name": {"child/name": "child-value"}}), the path for the child/name property will be /name/child~1name. Any slash ("/") character appearing in path names must be escaped with "~1", as shown in the example above. Each op operation can have only one path associated with it.
        public var path: Swift.String?
        /// The new target value of the update operation. It is applicable for the add or replace operation. When using AWS CLI to update a property of a JSON value, enclose the JSON object with a pair of single quotes in a Linux shell, e.g., '{"a": ...}'.
        public var value: Swift.String?

        public init(
            from: Swift.String? = nil,
            op: APIGatewayClientTypes.Op? = nil,
            path: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.from = from
            self.op = op
            self.path = path
            self.value = value
        }
    }

}

/// Requests API Gateway to change information about the current Account resource.
public struct UpdateAccountInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.patchOperations = patchOperations
    }
}

/// Represents an AWS account that is associated with API Gateway.
public struct UpdateAccountOutput {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current Account.
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current Account.
    public var throttleSettings: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

/// A request to change information about an ApiKey resource.
public struct UpdateApiKeyInput {
    /// The identifier of the ApiKey resource to be updated.
    /// This member is required.
    public var apiKey: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        apiKey: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.apiKey = apiKey
        self.patchOperations = patchOperations
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct UpdateApiKeyOutput {
    /// The timestamp when the API Key was created.
    public var createdDate: Foundation.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

/// Request to update an existing Authorizer resource.
public struct UpdateAuthorizerInput {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct UpdateAuthorizerOutput {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

/// A request to change information about the BasePathMapping resource.
public struct UpdateBasePathMappingInput {
    /// The base path of the BasePathMapping resource to change. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to change.
    /// This member is required.
    public var domainName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct UpdateBasePathMappingOutput {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

/// A request to change information about an ClientCertificate resource.
public struct UpdateClientCertificateInput {
    /// The identifier of the ClientCertificate resource to be updated.
    /// This member is required.
    public var clientCertificateId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        clientCertificateId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.patchOperations = patchOperations
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct UpdateClientCertificateOutput {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: Foundation.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: Foundation.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

/// Requests API Gateway to change information about a Deployment resource.
public struct UpdateDeploymentInput {
    /// The replacement identifier for the Deployment resource to change information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct UpdateDeploymentOutput {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

/// Updates an existing documentation part of a given API.
public struct UpdateDocumentationPartInput {
    /// The identifier of the to-be-updated documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// A documentation part for a targeted API entity.
public struct UpdateDocumentationPartOutput {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

/// Updates an existing documentation version of an API.
public struct UpdateDocumentationVersionInput {
    /// The version identifier of the to-be-updated documentation version.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// A snapshot of the documentation of an API.
public struct UpdateDocumentationVersionOutput {
    /// The date when the API documentation snapshot is created.
    public var createdDate: Foundation.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

/// A request to change information about the DomainName resource.
public struct UpdateDomainNameInput {
    /// The name of the DomainName resource to be changed.
    /// This member is required.
    public var domainName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        domainName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct UpdateDomainNameOutput {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded. API Gateway doesn't change this value if you update the certificate.
    public var certificateUploadDate: Foundation.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: Foundation.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

/// Updates a GatewayResponse of a specified response type on the given RestApi.
public struct UpdateGatewayResponseInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct UpdateGatewayResponseOutput {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

/// Represents an update integration request.
public struct UpdateIntegrationInput {
    /// Represents an update integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// Represents an update integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct UpdateIntegrationOutput {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String: APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

/// Represents an update integration response request.
public struct UpdateIntegrationResponseInput {
    /// Specifies an update integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// Specifies an update integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies an update integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct UpdateIntegrationResponseOutput {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

/// Request to update an existing Method resource.
public struct UpdateMethodInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct UpdateMethodOutput {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String: Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String: Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String: APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

/// A request to update an existing MethodResponse resource.
public struct UpdateMethodResponseInput {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct UpdateMethodResponseOutput {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String: Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String: Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

/// Request to update an existing model in an existing RestApi resource.
public struct UpdateModelInput {
    /// The name of the model to update.
    /// This member is required.
    public var modelName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// Represents the data structure of a method's request or response payload.
public struct UpdateModelOutput {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

/// Updates a RequestValidator of a given RestApi.
public struct UpdateRequestValidatorInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of RequestValidator to be updated.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

/// A set of validation rules for incoming Method requests.
public struct UpdateRequestValidatorOutput {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

/// Request to change information about a Resource resource.
public struct UpdateResourceInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

/// Represents an API resource.
public struct UpdateResourceOutput {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String: APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String: APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

/// Request to update an existing RestApi resource in your collection.
public struct UpdateRestApiInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

/// Represents a REST API.
public struct UpdateRestApiOutput {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Requests API Gateway to change information about a Stage resource.
public struct UpdateStageInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to change information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct UpdateStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage. To activate a method-level cache, set CachingEnabled to true for a method.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String: Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        methodSettings: [Swift.String: APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String: Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

/// The PATCH request to grant a temporary extension to the remaining quota of a usage plan associated with a specified API key.
public struct UpdateUsageInput {
    /// The identifier of the API key associated with the usage plan in which a temporary extension is granted to the remaining quota.
    /// This member is required.
    public var keyId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

/// Represents the usage data of a usage plan.
public struct UpdateUsageOutput {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String: [[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        items: [Swift.String: [[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

/// The PATCH request to update a usage plan of a given plan Id.
public struct UpdateUsagePlanInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Id of the to-be-updated usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Don’t rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct UpdateUsagePlanOutput {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

/// Updates an existing VpcLink of a specified identifier.
public struct UpdateVpcLinkInput {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.vpcLinkId = vpcLinkId
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct UpdateVpcLinkOutput {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

extension CreateApiKeyInput {

    static func urlPathProvider(_ value: CreateApiKeyInput) -> Swift.String? {
        return "/apikeys"
    }
}

extension CreateAuthorizerInput {

    static func urlPathProvider(_ value: CreateAuthorizerInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

extension CreateBasePathMappingInput {

    static func urlPathProvider(_ value: CreateBasePathMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

extension CreateDocumentationPartInput {

    static func urlPathProvider(_ value: CreateDocumentationPartInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

extension CreateDocumentationVersionInput {

    static func urlPathProvider(_ value: CreateDocumentationVersionInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

extension CreateDomainNameInput {

    static func urlPathProvider(_ value: CreateDomainNameInput) -> Swift.String? {
        return "/domainnames"
    }
}

extension CreateModelInput {

    static func urlPathProvider(_ value: CreateModelInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

extension CreateRequestValidatorInput {

    static func urlPathProvider(_ value: CreateRequestValidatorInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

extension CreateResourceInput {

    static func urlPathProvider(_ value: CreateResourceInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let parentId = value.parentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(parentId.urlPercentEncoding())"
    }
}

extension CreateRestApiInput {

    static func urlPathProvider(_ value: CreateRestApiInput) -> Swift.String? {
        return "/restapis"
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

extension CreateUsagePlanInput {

    static func urlPathProvider(_ value: CreateUsagePlanInput) -> Swift.String? {
        return "/usageplans"
    }
}

extension CreateUsagePlanKeyInput {

    static func urlPathProvider(_ value: CreateUsagePlanKeyInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

extension CreateVpcLinkInput {

    static func urlPathProvider(_ value: CreateVpcLinkInput) -> Swift.String? {
        return "/vpclinks"
    }
}

extension DeleteApiKeyInput {

    static func urlPathProvider(_ value: DeleteApiKeyInput) -> Swift.String? {
        guard let apiKey = value.apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

extension DeleteAuthorizerInput {

    static func urlPathProvider(_ value: DeleteAuthorizerInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension DeleteBasePathMappingInput {

    static func urlPathProvider(_ value: DeleteBasePathMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let basePath = value.basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

extension DeleteClientCertificateInput {

    static func urlPathProvider(_ value: DeleteClientCertificateInput) -> Swift.String? {
        guard let clientCertificateId = value.clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension DeleteDocumentationPartInput {

    static func urlPathProvider(_ value: DeleteDocumentationPartInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationPartId = value.documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

extension DeleteDocumentationVersionInput {

    static func urlPathProvider(_ value: DeleteDocumentationVersionInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationVersion = value.documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

extension DeleteDomainNameInput {

    static func urlPathProvider(_ value: DeleteDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteGatewayResponseInput {

    static func urlPathProvider(_ value: DeleteGatewayResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let responseType = value.responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

extension DeleteIntegrationInput {

    static func urlPathProvider(_ value: DeleteIntegrationInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

extension DeleteIntegrationResponseInput {

    static func urlPathProvider(_ value: DeleteIntegrationResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension DeleteMethodInput {

    static func urlPathProvider(_ value: DeleteMethodInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

extension DeleteMethodResponseInput {

    static func urlPathProvider(_ value: DeleteMethodResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension DeleteModelInput {

    static func urlPathProvider(_ value: DeleteModelInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let modelName = value.modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

extension DeleteRequestValidatorInput {

    static func urlPathProvider(_ value: DeleteRequestValidatorInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let requestValidatorId = value.requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

extension DeleteResourceInput {

    static func urlPathProvider(_ value: DeleteResourceInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

extension DeleteRestApiInput {

    static func urlPathProvider(_ value: DeleteRestApiInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension DeleteUsagePlanInput {

    static func urlPathProvider(_ value: DeleteUsagePlanInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

extension DeleteUsagePlanKeyInput {

    static func urlPathProvider(_ value: DeleteUsagePlanKeyInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        guard let keyId = value.keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

extension DeleteVpcLinkInput {

    static func urlPathProvider(_ value: DeleteVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension FlushStageAuthorizersCacheInput {

    static func urlPathProvider(_ value: FlushStageAuthorizersCacheInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

extension FlushStageCacheInput {

    static func urlPathProvider(_ value: FlushStageCacheInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/data"
    }
}

extension GenerateClientCertificateInput {

    static func urlPathProvider(_ value: GenerateClientCertificateInput) -> Swift.String? {
        return "/clientcertificates"
    }
}

extension GetAccountInput {

    static func urlPathProvider(_ value: GetAccountInput) -> Swift.String? {
        return "/account"
    }
}

extension GetApiKeyInput {

    static func urlPathProvider(_ value: GetApiKeyInput) -> Swift.String? {
        guard let apiKey = value.apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

extension GetApiKeyInput {

    static func queryItemProvider(_ value: GetApiKeyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeValue = value.includeValue {
            let includeValueQueryItem = Smithy.URIQueryItem(name: "includeValue".urlPercentEncoding(), value: Swift.String(includeValue).urlPercentEncoding())
            items.append(includeValueQueryItem)
        }
        return items
    }
}

extension GetApiKeysInput {

    static func urlPathProvider(_ value: GetApiKeysInput) -> Swift.String? {
        return "/apikeys"
    }
}

extension GetApiKeysInput {

    static func queryItemProvider(_ value: GetApiKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeValues = value.includeValues {
            let includeValuesQueryItem = Smithy.URIQueryItem(name: "includeValues".urlPercentEncoding(), value: Swift.String(includeValues).urlPercentEncoding())
            items.append(includeValuesQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let customerId = value.customerId {
            let customerIdQueryItem = Smithy.URIQueryItem(name: "customerId".urlPercentEncoding(), value: Swift.String(customerId).urlPercentEncoding())
            items.append(customerIdQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let nameQuery = value.nameQuery {
            let nameQueryQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        return items
    }
}

extension GetAuthorizerInput {

    static func urlPathProvider(_ value: GetAuthorizerInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension GetAuthorizersInput {

    static func urlPathProvider(_ value: GetAuthorizersInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

extension GetAuthorizersInput {

    static func queryItemProvider(_ value: GetAuthorizersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetBasePathMappingInput {

    static func urlPathProvider(_ value: GetBasePathMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let basePath = value.basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

extension GetBasePathMappingsInput {

    static func urlPathProvider(_ value: GetBasePathMappingsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

extension GetBasePathMappingsInput {

    static func queryItemProvider(_ value: GetBasePathMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetClientCertificateInput {

    static func urlPathProvider(_ value: GetClientCertificateInput) -> Swift.String? {
        guard let clientCertificateId = value.clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

extension GetClientCertificatesInput {

    static func urlPathProvider(_ value: GetClientCertificatesInput) -> Swift.String? {
        return "/clientcertificates"
    }
}

extension GetClientCertificatesInput {

    static func queryItemProvider(_ value: GetClientCertificatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension GetDeploymentInput {

    static func queryItemProvider(_ value: GetDeploymentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let embed = value.embed {
            embed.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetDeploymentsInput {

    static func urlPathProvider(_ value: GetDeploymentsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

extension GetDeploymentsInput {

    static func queryItemProvider(_ value: GetDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDocumentationPartInput {

    static func urlPathProvider(_ value: GetDocumentationPartInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationPartId = value.documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

extension GetDocumentationPartsInput {

    static func urlPathProvider(_ value: GetDocumentationPartsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

extension GetDocumentationPartsInput {

    static func queryItemProvider(_ value: GetDocumentationPartsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let locationStatus = value.locationStatus {
            let locationStatusQueryItem = Smithy.URIQueryItem(name: "locationStatus".urlPercentEncoding(), value: Swift.String(locationStatus.rawValue).urlPercentEncoding())
            items.append(locationStatusQueryItem)
        }
        if let path = value.path {
            let pathQueryItem = Smithy.URIQueryItem(name: "path".urlPercentEncoding(), value: Swift.String(path).urlPercentEncoding())
            items.append(pathQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let nameQuery = value.nameQuery {
            let nameQueryQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension GetDocumentationVersionInput {

    static func urlPathProvider(_ value: GetDocumentationVersionInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationVersion = value.documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

extension GetDocumentationVersionsInput {

    static func urlPathProvider(_ value: GetDocumentationVersionsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

extension GetDocumentationVersionsInput {

    static func queryItemProvider(_ value: GetDocumentationVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDomainNameInput {

    static func urlPathProvider(_ value: GetDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension GetDomainNamesInput {

    static func urlPathProvider(_ value: GetDomainNamesInput) -> Swift.String? {
        return "/domainnames"
    }
}

extension GetDomainNamesInput {

    static func queryItemProvider(_ value: GetDomainNamesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetExportInput {

    static func urlPathProvider(_ value: GetExportInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        guard let exportType = value.exportType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/exports/\(exportType.urlPercentEncoding())"
    }
}

extension GetExportInput {

    static func headerProvider(_ value: GetExportInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accepts = value.accepts {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accepts)))
        }
        return items
    }
}

extension GetExportInput {

    static func queryItemProvider(_ value: GetExportInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let parameters = value.parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension GetGatewayResponseInput {

    static func urlPathProvider(_ value: GetGatewayResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let responseType = value.responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

extension GetGatewayResponsesInput {

    static func urlPathProvider(_ value: GetGatewayResponsesInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses"
    }
}

extension GetGatewayResponsesInput {

    static func queryItemProvider(_ value: GetGatewayResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetIntegrationInput {

    static func urlPathProvider(_ value: GetIntegrationInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

extension GetIntegrationResponseInput {

    static func urlPathProvider(_ value: GetIntegrationResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension GetMethodInput {

    static func urlPathProvider(_ value: GetMethodInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

extension GetMethodResponseInput {

    static func urlPathProvider(_ value: GetMethodResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension GetModelInput {

    static func urlPathProvider(_ value: GetModelInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let modelName = value.modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

extension GetModelInput {

    static func queryItemProvider(_ value: GetModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let flatten = value.flatten {
            let flattenQueryItem = Smithy.URIQueryItem(name: "flatten".urlPercentEncoding(), value: Swift.String(flatten).urlPercentEncoding())
            items.append(flattenQueryItem)
        }
        return items
    }
}

extension GetModelsInput {

    static func urlPathProvider(_ value: GetModelsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

extension GetModelsInput {

    static func queryItemProvider(_ value: GetModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetModelTemplateInput {

    static func urlPathProvider(_ value: GetModelTemplateInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let modelName = value.modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())/default_template"
    }
}

extension GetRequestValidatorInput {

    static func urlPathProvider(_ value: GetRequestValidatorInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let requestValidatorId = value.requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

extension GetRequestValidatorsInput {

    static func urlPathProvider(_ value: GetRequestValidatorsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

extension GetRequestValidatorsInput {

    static func queryItemProvider(_ value: GetRequestValidatorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetResourceInput {

    static func urlPathProvider(_ value: GetResourceInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

extension GetResourceInput {

    static func queryItemProvider(_ value: GetResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let embed = value.embed {
            embed.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetResourcesInput {

    static func urlPathProvider(_ value: GetResourcesInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources"
    }
}

extension GetResourcesInput {

    static func queryItemProvider(_ value: GetResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let embed = value.embed {
            embed.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetRestApiInput {

    static func urlPathProvider(_ value: GetRestApiInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

extension GetRestApisInput {

    static func urlPathProvider(_ value: GetRestApisInput) -> Swift.String? {
        return "/restapis"
    }
}

extension GetRestApisInput {

    static func queryItemProvider(_ value: GetRestApisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetSdkInput {

    static func urlPathProvider(_ value: GetSdkInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        guard let sdkType = value.sdkType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/sdks/\(sdkType.urlPercentEncoding())"
    }
}

extension GetSdkInput {

    static func queryItemProvider(_ value: GetSdkInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let parameters = value.parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension GetSdkTypeInput {

    static func urlPathProvider(_ value: GetSdkTypeInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/sdktypes/\(id.urlPercentEncoding())"
    }
}

extension GetSdkTypesInput {

    static func urlPathProvider(_ value: GetSdkTypesInput) -> Swift.String? {
        return "/sdktypes"
    }
}

extension GetSdkTypesInput {

    static func queryItemProvider(_ value: GetSdkTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension GetStagesInput {

    static func urlPathProvider(_ value: GetStagesInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

extension GetStagesInput {

    static func queryItemProvider(_ value: GetStagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deploymentId = value.deploymentId {
            let deploymentIdQueryItem = Smithy.URIQueryItem(name: "deploymentId".urlPercentEncoding(), value: Swift.String(deploymentId).urlPercentEncoding())
            items.append(deploymentIdQueryItem)
        }
        return items
    }
}

extension GetTagsInput {

    static func urlPathProvider(_ value: GetTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetTagsInput {

    static func queryItemProvider(_ value: GetTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetUsageInput {

    static func urlPathProvider(_ value: GetUsageInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/usage"
    }
}

extension GetUsageInput {

    static func queryItemProvider(_ value: GetUsageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endDate = value.endDate else {
            let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endDateQueryItem = Smithy.URIQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(endDate).urlPercentEncoding())
        items.append(endDateQueryItem)
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let keyId = value.keyId {
            let keyIdQueryItem = Smithy.URIQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
            items.append(keyIdQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        guard let startDate = value.startDate else {
            let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startDateQueryItem = Smithy.URIQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(startDate).urlPercentEncoding())
        items.append(startDateQueryItem)
        return items
    }
}

extension GetUsagePlanInput {

    static func urlPathProvider(_ value: GetUsagePlanInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

extension GetUsagePlanKeyInput {

    static func urlPathProvider(_ value: GetUsagePlanKeyInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        guard let keyId = value.keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

extension GetUsagePlanKeysInput {

    static func urlPathProvider(_ value: GetUsagePlanKeysInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

extension GetUsagePlanKeysInput {

    static func queryItemProvider(_ value: GetUsagePlanKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let nameQuery = value.nameQuery {
            let nameQueryQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        return items
    }
}

extension GetUsagePlansInput {

    static func urlPathProvider(_ value: GetUsagePlansInput) -> Swift.String? {
        return "/usageplans"
    }
}

extension GetUsagePlansInput {

    static func queryItemProvider(_ value: GetUsagePlansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let keyId = value.keyId {
            let keyIdQueryItem = Smithy.URIQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
            items.append(keyIdQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetVpcLinkInput {

    static func urlPathProvider(_ value: GetVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension GetVpcLinksInput {

    static func urlPathProvider(_ value: GetVpcLinksInput) -> Swift.String? {
        return "/vpclinks"
    }
}

extension GetVpcLinksInput {

    static func queryItemProvider(_ value: GetVpcLinksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = value.position {
            let positionQueryItem = Smithy.URIQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension ImportApiKeysInput {

    static func urlPathProvider(_ value: ImportApiKeysInput) -> Swift.String? {
        return "/apikeys"
    }
}

extension ImportApiKeysInput {

    static func queryItemProvider(_ value: ImportApiKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "mode", value: "import"))
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        return items
    }
}

extension ImportDocumentationPartsInput {

    static func urlPathProvider(_ value: ImportDocumentationPartsInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

extension ImportDocumentationPartsInput {

    static func queryItemProvider(_ value: ImportDocumentationPartsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = Smithy.URIQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        return items
    }
}

extension ImportRestApiInput {

    static func urlPathProvider(_ value: ImportRestApiInput) -> Swift.String? {
        return "/restapis"
    }
}

extension ImportRestApiInput {

    static func queryItemProvider(_ value: ImportRestApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "mode", value: "import"))
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let parameters = value.parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension PutGatewayResponseInput {

    static func urlPathProvider(_ value: PutGatewayResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let responseType = value.responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

extension PutIntegrationInput {

    static func urlPathProvider(_ value: PutIntegrationInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

extension PutIntegrationResponseInput {

    static func urlPathProvider(_ value: PutIntegrationResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension PutMethodInput {

    static func urlPathProvider(_ value: PutMethodInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

extension PutMethodResponseInput {

    static func urlPathProvider(_ value: PutMethodResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension PutRestApiInput {

    static func urlPathProvider(_ value: PutRestApiInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

extension PutRestApiInput {

    static func queryItemProvider(_ value: PutRestApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let mode = value.mode {
            let modeQueryItem = Smithy.URIQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let parameters = value.parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TestInvokeAuthorizerInput {

    static func urlPathProvider(_ value: TestInvokeAuthorizerInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension TestInvokeMethodInput {

    static func urlPathProvider(_ value: TestInvokeMethodInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccountInput {

    static func urlPathProvider(_ value: UpdateAccountInput) -> Swift.String? {
        return "/account"
    }
}

extension UpdateApiKeyInput {

    static func urlPathProvider(_ value: UpdateApiKeyInput) -> Swift.String? {
        guard let apiKey = value.apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

extension UpdateAuthorizerInput {

    static func urlPathProvider(_ value: UpdateAuthorizerInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension UpdateBasePathMappingInput {

    static func urlPathProvider(_ value: UpdateBasePathMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let basePath = value.basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

extension UpdateClientCertificateInput {

    static func urlPathProvider(_ value: UpdateClientCertificateInput) -> Swift.String? {
        guard let clientCertificateId = value.clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

extension UpdateDeploymentInput {

    static func urlPathProvider(_ value: UpdateDeploymentInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension UpdateDocumentationPartInput {

    static func urlPathProvider(_ value: UpdateDocumentationPartInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationPartId = value.documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

extension UpdateDocumentationVersionInput {

    static func urlPathProvider(_ value: UpdateDocumentationVersionInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let documentationVersion = value.documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

extension UpdateDomainNameInput {

    static func urlPathProvider(_ value: UpdateDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateGatewayResponseInput {

    static func urlPathProvider(_ value: UpdateGatewayResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let responseType = value.responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateIntegrationInput {

    static func urlPathProvider(_ value: UpdateIntegrationInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

extension UpdateIntegrationResponseInput {

    static func urlPathProvider(_ value: UpdateIntegrationResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension UpdateMethodInput {

    static func urlPathProvider(_ value: UpdateMethodInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

extension UpdateMethodResponseInput {

    static func urlPathProvider(_ value: UpdateMethodResponseInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let httpMethod = value.httpMethod else {
            return nil
        }
        guard let statusCode = value.statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

extension UpdateModelInput {

    static func urlPathProvider(_ value: UpdateModelInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let modelName = value.modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

extension UpdateRequestValidatorInput {

    static func urlPathProvider(_ value: UpdateRequestValidatorInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let requestValidatorId = value.requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

extension UpdateResourceInput {

    static func urlPathProvider(_ value: UpdateResourceInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

extension UpdateRestApiInput {

    static func urlPathProvider(_ value: UpdateRestApiInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        guard let restApiId = value.restApiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension UpdateUsageInput {

    static func urlPathProvider(_ value: UpdateUsageInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        guard let keyId = value.keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())/usage"
    }
}

extension UpdateUsagePlanInput {

    static func urlPathProvider(_ value: UpdateUsagePlanInput) -> Swift.String? {
        guard let usagePlanId = value.usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

extension UpdateVpcLinkInput {

    static func urlPathProvider(_ value: UpdateVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension CreateApiKeyInput {

    static func write(value: CreateApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerId"].write(value.customerId)
        try writer["description"].write(value.description)
        try writer["enabled"].write(value.enabled)
        try writer["generateDistinctId"].write(value.generateDistinctId)
        try writer["name"].write(value.name)
        try writer["stageKeys"].writeList(value.stageKeys, memberWritingClosure: APIGatewayClientTypes.StageKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["value"].write(value.value)
    }
}

extension CreateAuthorizerInput {

    static func write(value: CreateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["authorizerCredentials"].write(value.authorizerCredentials)
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["identitySource"].write(value.identitySource)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
        try writer["name"].write(value.name)
        try writer["providerARNs"].writeList(value.providerARNs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateBasePathMappingInput {

    static func write(value: CreateBasePathMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["basePath"].write(value.basePath)
        try writer["restApiId"].write(value.restApiId)
        try writer["stage"].write(value.stage)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cacheClusterEnabled"].write(value.cacheClusterEnabled)
        try writer["cacheClusterSize"].write(value.cacheClusterSize)
        try writer["canarySettings"].write(value.canarySettings, with: APIGatewayClientTypes.DeploymentCanarySettings.write(value:to:))
        try writer["description"].write(value.description)
        try writer["stageDescription"].write(value.stageDescription)
        try writer["stageName"].write(value.stageName)
        try writer["tracingEnabled"].write(value.tracingEnabled)
        try writer["variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDocumentationPartInput {

    static func write(value: CreateDocumentationPartInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location, with: APIGatewayClientTypes.DocumentationPartLocation.write(value:to:))
        try writer["properties"].write(value.properties)
    }
}

extension CreateDocumentationVersionInput {

    static func write(value: CreateDocumentationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["documentationVersion"].write(value.documentationVersion)
        try writer["stageName"].write(value.stageName)
    }
}

extension CreateDomainNameInput {

    static func write(value: CreateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["certificateBody"].write(value.certificateBody)
        try writer["certificateChain"].write(value.certificateChain)
        try writer["certificateName"].write(value.certificateName)
        try writer["certificatePrivateKey"].write(value.certificatePrivateKey)
        try writer["domainName"].write(value.domainName)
        try writer["endpointConfiguration"].write(value.endpointConfiguration, with: APIGatewayClientTypes.EndpointConfiguration.write(value:to:))
        try writer["mutualTlsAuthentication"].write(value.mutualTlsAuthentication, with: APIGatewayClientTypes.MutualTlsAuthenticationInput.write(value:to:))
        try writer["ownershipVerificationCertificateArn"].write(value.ownershipVerificationCertificateArn)
        try writer["regionalCertificateArn"].write(value.regionalCertificateArn)
        try writer["regionalCertificateName"].write(value.regionalCertificateName)
        try writer["securityPolicy"].write(value.securityPolicy)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateModelInput {

    static func write(value: CreateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension CreateRequestValidatorInput {

    static func write(value: CreateRequestValidatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["validateRequestBody"].write(value.validateRequestBody)
        try writer["validateRequestParameters"].write(value.validateRequestParameters)
    }
}

extension CreateResourceInput {

    static func write(value: CreateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pathPart"].write(value.pathPart)
    }
}

extension CreateRestApiInput {

    static func write(value: CreateRestApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeySource"].write(value.apiKeySource)
        try writer["binaryMediaTypes"].writeList(value.binaryMediaTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["cloneFrom"].write(value.cloneFrom)
        try writer["description"].write(value.description)
        try writer["disableExecuteApiEndpoint"].write(value.disableExecuteApiEndpoint)
        try writer["endpointConfiguration"].write(value.endpointConfiguration, with: APIGatewayClientTypes.EndpointConfiguration.write(value:to:))
        try writer["minimumCompressionSize"].write(value.minimumCompressionSize)
        try writer["name"].write(value.name)
        try writer["policy"].write(value.policy)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["version"].write(value.version)
    }
}

extension CreateStageInput {

    static func write(value: CreateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cacheClusterEnabled"].write(value.cacheClusterEnabled)
        try writer["cacheClusterSize"].write(value.cacheClusterSize)
        try writer["canarySettings"].write(value.canarySettings, with: APIGatewayClientTypes.CanarySettings.write(value:to:))
        try writer["deploymentId"].write(value.deploymentId)
        try writer["description"].write(value.description)
        try writer["documentationVersion"].write(value.documentationVersion)
        try writer["stageName"].write(value.stageName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tracingEnabled"].write(value.tracingEnabled)
        try writer["variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUsagePlanInput {

    static func write(value: CreateUsagePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiStages"].writeList(value.apiStages, memberWritingClosure: APIGatewayClientTypes.ApiStage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["quota"].write(value.quota, with: APIGatewayClientTypes.QuotaSettings.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["throttle"].write(value.throttle, with: APIGatewayClientTypes.ThrottleSettings.write(value:to:))
    }
}

extension CreateUsagePlanKeyInput {

    static func write(value: CreateUsagePlanKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyId"].write(value.keyId)
        try writer["keyType"].write(value.keyType)
    }
}

extension CreateVpcLinkInput {

    static func write(value: CreateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetArns"].writeList(value.targetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GenerateClientCertificateInput {

    static func write(value: GenerateClientCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ImportApiKeysInput {

    static func write(value: ImportApiKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension ImportDocumentationPartsInput {

    static func write(value: ImportDocumentationPartsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension ImportRestApiInput {

    static func write(value: ImportRestApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension PutGatewayResponseInput {

    static func write(value: PutGatewayResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["statusCode"].write(value.statusCode)
    }
}

extension PutIntegrationInput {

    static func write(value: PutIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cacheKeyParameters"].writeList(value.cacheKeyParameters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["cacheNamespace"].write(value.cacheNamespace)
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionType"].write(value.connectionType)
        try writer["contentHandling"].write(value.contentHandling)
        try writer["credentials"].write(value.credentials)
        try writer["httpMethod"].write(value.integrationHttpMethod)
        try writer["passthroughBehavior"].write(value.passthroughBehavior)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestTemplates"].writeMap(value.requestTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeoutInMillis"].write(value.timeoutInMillis)
        try writer["tlsConfig"].write(value.tlsConfig, with: APIGatewayClientTypes.TlsConfig.write(value:to:))
        try writer["type"].write(value.type)
        try writer["uri"].write(value.uri)
    }
}

extension PutIntegrationResponseInput {

    static func write(value: PutIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentHandling"].write(value.contentHandling)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["selectionPattern"].write(value.selectionPattern)
    }
}

extension PutMethodInput {

    static func write(value: PutMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeyRequired"].write(value.apiKeyRequired)
        try writer["authorizationScopes"].writeList(value.authorizationScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizationType"].write(value.authorizationType)
        try writer["authorizerId"].write(value.authorizerId)
        try writer["operationName"].write(value.operationName)
        try writer["requestModels"].writeMap(value.requestModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestValidatorId"].write(value.requestValidatorId)
    }
}

extension PutMethodResponseInput {

    static func write(value: PutMethodResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["responseModels"].writeMap(value.responseModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutRestApiInput {

    static func write(value: PutRestApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TestInvokeAuthorizerInput {

    static func write(value: TestInvokeAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalContext"].writeMap(value.additionalContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["body"].write(value.body)
        try writer["headers"].writeMap(value.headers, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["multiValueHeaders"].writeMap(value.multiValueHeaders, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["pathWithQueryString"].write(value.pathWithQueryString)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TestInvokeMethodInput {

    static func write(value: TestInvokeMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["clientCertificateId"].write(value.clientCertificateId)
        try writer["headers"].writeMap(value.headers, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["multiValueHeaders"].writeMap(value.multiValueHeaders, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["pathWithQueryString"].write(value.pathWithQueryString)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccountInput {

    static func write(value: UpdateAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApiKeyInput {

    static func write(value: UpdateApiKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAuthorizerInput {

    static func write(value: UpdateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBasePathMappingInput {

    static func write(value: UpdateBasePathMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateClientCertificateInput {

    static func write(value: UpdateClientCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDeploymentInput {

    static func write(value: UpdateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDocumentationPartInput {

    static func write(value: UpdateDocumentationPartInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDocumentationVersionInput {

    static func write(value: UpdateDocumentationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDomainNameInput {

    static func write(value: UpdateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGatewayResponseInput {

    static func write(value: UpdateGatewayResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateIntegrationInput {

    static func write(value: UpdateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateIntegrationResponseInput {

    static func write(value: UpdateIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMethodInput {

    static func write(value: UpdateMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMethodResponseInput {

    static func write(value: UpdateMethodResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateModelInput {

    static func write(value: UpdateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRequestValidatorInput {

    static func write(value: UpdateRequestValidatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResourceInput {

    static func write(value: UpdateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRestApiInput {

    static func write(value: UpdateRestApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateStageInput {

    static func write(value: UpdateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUsageInput {

    static func write(value: UpdateUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUsagePlanInput {

    static func write(value: UpdateUsagePlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateVpcLinkInput {

    static func write(value: UpdateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patchOperations"].writeList(value.patchOperations, memberWritingClosure: APIGatewayClientTypes.PatchOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiKeyOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerId = try reader["customerId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.stageKeys = try reader["stageKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension CreateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAuthorizerOutput()
        value.authType = try reader["authType"].readIfPresent()
        value.authorizerCredentials = try reader["authorizerCredentials"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.identitySource = try reader["identitySource"].readIfPresent()
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.providerARNs = try reader["providerARNs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension CreateBasePathMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBasePathMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBasePathMappingOutput()
        value.basePath = try reader["basePath"].readIfPresent()
        value.restApiId = try reader["restApiId"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.apiSummary = try reader["apiSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: APIGatewayClientTypes.MethodSnapshot.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension CreateDocumentationPartOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDocumentationPartOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDocumentationPartOutput()
        value.id = try reader["id"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: APIGatewayClientTypes.DocumentationPartLocation.read(from:))
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension CreateDocumentationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDocumentationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDocumentationVersionOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension CreateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainNameOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.distributionDomainName = try reader["distributionDomainName"].readIfPresent()
        value.distributionHostedZoneId = try reader["distributionHostedZoneId"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: APIGatewayClientTypes.MutualTlsAuthentication.read(from:))
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        value.regionalCertificateArn = try reader["regionalCertificateArn"].readIfPresent()
        value.regionalCertificateName = try reader["regionalCertificateName"].readIfPresent()
        value.regionalDomainName = try reader["regionalDomainName"].readIfPresent()
        value.regionalHostedZoneId = try reader["regionalHostedZoneId"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension CreateRequestValidatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRequestValidatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRequestValidatorOutput()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.validateRequestBody = try reader["validateRequestBody"].readIfPresent() ?? false
        value.validateRequestParameters = try reader["validateRequestParameters"].readIfPresent() ?? false
        return value
    }
}

extension CreateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceOutput()
        value.id = try reader["id"].readIfPresent()
        value.parentId = try reader["parentId"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.pathPart = try reader["pathPart"].readIfPresent()
        value.resourceMethods = try reader["resourceMethods"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.Method.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRestApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRestApiOutput()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: APIGatewayClientTypes.AccessLogSettings.read(from:))
        value.cacheClusterEnabled = try reader["cacheClusterEnabled"].readIfPresent() ?? false
        value.cacheClusterSize = try reader["cacheClusterSize"].readIfPresent()
        value.cacheClusterStatus = try reader["cacheClusterStatus"].readIfPresent()
        value.canarySettings = try reader["canarySettings"].readIfPresent(with: APIGatewayClientTypes.CanarySettings.read(from:))
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentationVersion = try reader["documentationVersion"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.methodSettings = try reader["methodSettings"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodSetting.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tracingEnabled = try reader["tracingEnabled"].readIfPresent() ?? false
        value.variables = try reader["variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.webAclArn = try reader["webAclArn"].readIfPresent()
        return value
    }
}

extension CreateUsagePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUsagePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUsagePlanOutput()
        value.apiStages = try reader["apiStages"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ApiStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.productCode = try reader["productCode"].readIfPresent()
        value.quota = try reader["quota"].readIfPresent(with: APIGatewayClientTypes.QuotaSettings.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.throttle = try reader["throttle"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        return value
    }
}

extension CreateUsagePlanKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUsagePlanKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUsagePlanKeyOutput()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension CreateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcLinkOutput()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetArns = try reader["targetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiKeyOutput {
        return DeleteApiKeyOutput()
    }
}

extension DeleteAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthorizerOutput {
        return DeleteAuthorizerOutput()
    }
}

extension DeleteBasePathMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBasePathMappingOutput {
        return DeleteBasePathMappingOutput()
    }
}

extension DeleteClientCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteClientCertificateOutput {
        return DeleteClientCertificateOutput()
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeploymentOutput {
        return DeleteDeploymentOutput()
    }
}

extension DeleteDocumentationPartOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDocumentationPartOutput {
        return DeleteDocumentationPartOutput()
    }
}

extension DeleteDocumentationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDocumentationVersionOutput {
        return DeleteDocumentationVersionOutput()
    }
}

extension DeleteDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainNameOutput {
        return DeleteDomainNameOutput()
    }
}

extension DeleteGatewayResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayResponseOutput {
        return DeleteGatewayResponseOutput()
    }
}

extension DeleteIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationOutput {
        return DeleteIntegrationOutput()
    }
}

extension DeleteIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationResponseOutput {
        return DeleteIntegrationResponseOutput()
    }
}

extension DeleteMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMethodOutput {
        return DeleteMethodOutput()
    }
}

extension DeleteMethodResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMethodResponseOutput {
        return DeleteMethodResponseOutput()
    }
}

extension DeleteModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelOutput {
        return DeleteModelOutput()
    }
}

extension DeleteRequestValidatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRequestValidatorOutput {
        return DeleteRequestValidatorOutput()
    }
}

extension DeleteResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceOutput {
        return DeleteResourceOutput()
    }
}

extension DeleteRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRestApiOutput {
        return DeleteRestApiOutput()
    }
}

extension DeleteStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStageOutput {
        return DeleteStageOutput()
    }
}

extension DeleteUsagePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUsagePlanOutput {
        return DeleteUsagePlanOutput()
    }
}

extension DeleteUsagePlanKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUsagePlanKeyOutput {
        return DeleteUsagePlanKeyOutput()
    }
}

extension DeleteVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcLinkOutput {
        return DeleteVpcLinkOutput()
    }
}

extension FlushStageAuthorizersCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FlushStageAuthorizersCacheOutput {
        return FlushStageAuthorizersCacheOutput()
    }
}

extension FlushStageCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FlushStageCacheOutput {
        return FlushStageCacheOutput()
    }
}

extension GenerateClientCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateClientCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateClientCertificateOutput()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pemEncodedCertificate = try reader["pemEncodedCertificate"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountOutput()
        value.apiKeyVersion = try reader["apiKeyVersion"].readIfPresent()
        value.cloudwatchRoleArn = try reader["cloudwatchRoleArn"].readIfPresent()
        value.features = try reader["features"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.throttleSettings = try reader["throttleSettings"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        return value
    }
}

extension GetApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiKeyOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerId = try reader["customerId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.stageKeys = try reader["stageKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension GetApiKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiKeysOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ApiKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizerOutput()
        value.authType = try reader["authType"].readIfPresent()
        value.authorizerCredentials = try reader["authorizerCredentials"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.identitySource = try reader["identitySource"].readIfPresent()
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.providerARNs = try reader["providerARNs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension GetAuthorizersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizersOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.Authorizer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetBasePathMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBasePathMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBasePathMappingOutput()
        value.basePath = try reader["basePath"].readIfPresent()
        value.restApiId = try reader["restApiId"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension GetBasePathMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBasePathMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBasePathMappingsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.BasePathMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetClientCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetClientCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetClientCertificateOutput()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pemEncodedCertificate = try reader["pemEncodedCertificate"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetClientCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetClientCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetClientCertificatesOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ClientCertificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.apiSummary = try reader["apiSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: APIGatewayClientTypes.MethodSnapshot.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension GetDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetDocumentationPartOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentationPartOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentationPartOutput()
        value.id = try reader["id"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: APIGatewayClientTypes.DocumentationPartLocation.read(from:))
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension GetDocumentationPartsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentationPartsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentationPartsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.DocumentationPart.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetDocumentationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentationVersionOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension GetDocumentationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentationVersionsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.DocumentationVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNameOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.distributionDomainName = try reader["distributionDomainName"].readIfPresent()
        value.distributionHostedZoneId = try reader["distributionHostedZoneId"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: APIGatewayClientTypes.MutualTlsAuthentication.read(from:))
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        value.regionalCertificateArn = try reader["regionalCertificateArn"].readIfPresent()
        value.regionalCertificateName = try reader["regionalCertificateName"].readIfPresent()
        value.regionalDomainName = try reader["regionalDomainName"].readIfPresent()
        value.regionalHostedZoneId = try reader["regionalHostedZoneId"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNamesOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.DomainName.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExportOutput {
        var value = GetExportOutput()
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            value.contentDisposition = contentDispositionHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension GetGatewayResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGatewayResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayResponseOutput()
        value.defaultResponse = try reader["defaultResponse"].readIfPresent() ?? false
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseType = try reader["responseType"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension GetGatewayResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGatewayResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayResponsesOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.GatewayResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationOutput()
        value.cacheKeyParameters = try reader["cacheKeyParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cacheNamespace = try reader["cacheNamespace"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.credentials = try reader["credentials"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.integrationResponses = try reader["integrationResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.IntegrationResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent() ?? 0
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: APIGatewayClientTypes.TlsConfig.read(from:))
        value.type = try reader["type"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension GetIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationResponseOutput()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.selectionPattern = try reader["selectionPattern"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension GetMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMethodOutput()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.methodIntegration = try reader["methodIntegration"].readIfPresent(with: APIGatewayClientTypes.Integration.read(from:))
        value.methodResponses = try reader["methodResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestValidatorId = try reader["requestValidatorId"].readIfPresent()
        return value
    }
}

extension GetMethodResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMethodResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMethodResponseOutput()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension GetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension GetModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.Model.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetModelTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelTemplateOutput()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension GetRequestValidatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRequestValidatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRequestValidatorOutput()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.validateRequestBody = try reader["validateRequestBody"].readIfPresent() ?? false
        value.validateRequestParameters = try reader["validateRequestParameters"].readIfPresent() ?? false
        return value
    }
}

extension GetRequestValidatorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRequestValidatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRequestValidatorsOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.RequestValidator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceOutput()
        value.id = try reader["id"].readIfPresent()
        value.parentId = try reader["parentId"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.pathPart = try reader["pathPart"].readIfPresent()
        value.resourceMethods = try reader["resourceMethods"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.Method.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcesOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestApiOutput()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetRestApisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRestApisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRestApisOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.RestApi.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetSdkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSdkOutput {
        var value = GetSdkOutput()
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            value.contentDisposition = contentDispositionHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension GetSdkTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSdkTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSdkTypeOutput()
        value.configurationProperties = try reader["configurationProperties"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.SdkConfigurationProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.friendlyName = try reader["friendlyName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension GetSdkTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSdkTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSdkTypesOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.SdkType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: APIGatewayClientTypes.AccessLogSettings.read(from:))
        value.cacheClusterEnabled = try reader["cacheClusterEnabled"].readIfPresent() ?? false
        value.cacheClusterSize = try reader["cacheClusterSize"].readIfPresent()
        value.cacheClusterStatus = try reader["cacheClusterStatus"].readIfPresent()
        value.canarySettings = try reader["canarySettings"].readIfPresent(with: APIGatewayClientTypes.CanarySettings.read(from:))
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentationVersion = try reader["documentationVersion"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.methodSettings = try reader["methodSettings"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodSetting.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tracingEnabled = try reader["tracingEnabled"].readIfPresent() ?? false
        value.variables = try reader["variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.webAclArn = try reader["webAclArn"].readIfPresent()
        return value
    }
}

extension GetStagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStagesOutput()
        value.item = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.Stage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTagsOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsageOutput()
        value.endDate = try reader["endDate"].readIfPresent()
        value.items = try reader["values"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        value.startDate = try reader["startDate"].readIfPresent()
        value.usagePlanId = try reader["usagePlanId"].readIfPresent()
        return value
    }
}

extension GetUsagePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsagePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsagePlanOutput()
        value.apiStages = try reader["apiStages"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ApiStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.productCode = try reader["productCode"].readIfPresent()
        value.quota = try reader["quota"].readIfPresent(with: APIGatewayClientTypes.QuotaSettings.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.throttle = try reader["throttle"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        return value
    }
}

extension GetUsagePlanKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsagePlanKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsagePlanKeyOutput()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension GetUsagePlanKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsagePlanKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsagePlanKeysOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.UsagePlanKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetUsagePlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsagePlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsagePlansOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.UsagePlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension GetVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinkOutput()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetArns = try reader["targetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetVpcLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinksOutput()
        value.items = try reader["item"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.VpcLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        return value
    }
}

extension ImportApiKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportApiKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportApiKeysOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImportDocumentationPartsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportDocumentationPartsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportDocumentationPartsOutput()
        value.ids = try reader["ids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImportRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportRestApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportRestApiOutput()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutGatewayResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutGatewayResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutGatewayResponseOutput()
        value.defaultResponse = try reader["defaultResponse"].readIfPresent() ?? false
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseType = try reader["responseType"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension PutIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutIntegrationOutput()
        value.cacheKeyParameters = try reader["cacheKeyParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cacheNamespace = try reader["cacheNamespace"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.credentials = try reader["credentials"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.integrationResponses = try reader["integrationResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.IntegrationResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent() ?? 0
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: APIGatewayClientTypes.TlsConfig.read(from:))
        value.type = try reader["type"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension PutIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutIntegrationResponseOutput()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.selectionPattern = try reader["selectionPattern"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension PutMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutMethodOutput()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.methodIntegration = try reader["methodIntegration"].readIfPresent(with: APIGatewayClientTypes.Integration.read(from:))
        value.methodResponses = try reader["methodResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestValidatorId = try reader["requestValidatorId"].readIfPresent()
        return value
    }
}

extension PutMethodResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMethodResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutMethodResponseOutput()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension PutRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRestApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRestApiOutput()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestInvokeAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestInvokeAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestInvokeAuthorizerOutput()
        value.authorization = try reader["authorization"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.claims = try reader["claims"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.clientStatus = try reader["clientStatus"].readIfPresent() ?? 0
        value.latency = try reader["latency"].readIfPresent() ?? 0
        value.log = try reader["log"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.principalId = try reader["principalId"].readIfPresent()
        return value
    }
}

extension TestInvokeMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestInvokeMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestInvokeMethodOutput()
        value.body = try reader["body"].readIfPresent()
        value.headers = try reader["headers"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.latency = try reader["latency"].readIfPresent() ?? 0
        value.log = try reader["log"].readIfPresent()
        value.multiValueHeaders = try reader["multiValueHeaders"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? 0
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountOutput()
        value.apiKeyVersion = try reader["apiKeyVersion"].readIfPresent()
        value.cloudwatchRoleArn = try reader["cloudwatchRoleArn"].readIfPresent()
        value.features = try reader["features"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.throttleSettings = try reader["throttleSettings"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        return value
    }
}

extension UpdateApiKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiKeyOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerId = try reader["customerId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.stageKeys = try reader["stageKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension UpdateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAuthorizerOutput()
        value.authType = try reader["authType"].readIfPresent()
        value.authorizerCredentials = try reader["authorizerCredentials"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.identitySource = try reader["identitySource"].readIfPresent()
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.providerARNs = try reader["providerARNs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension UpdateBasePathMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBasePathMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBasePathMappingOutput()
        value.basePath = try reader["basePath"].readIfPresent()
        value.restApiId = try reader["restApiId"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension UpdateClientCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateClientCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateClientCertificateOutput()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pemEncodedCertificate = try reader["pemEncodedCertificate"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeploymentOutput()
        value.apiSummary = try reader["apiSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: APIGatewayClientTypes.MethodSnapshot.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension UpdateDocumentationPartOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentationPartOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDocumentationPartOutput()
        value.id = try reader["id"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: APIGatewayClientTypes.DocumentationPartLocation.read(from:))
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension UpdateDocumentationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDocumentationVersionOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension UpdateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainNameOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.distributionDomainName = try reader["distributionDomainName"].readIfPresent()
        value.distributionHostedZoneId = try reader["distributionHostedZoneId"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: APIGatewayClientTypes.MutualTlsAuthentication.read(from:))
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        value.regionalCertificateArn = try reader["regionalCertificateArn"].readIfPresent()
        value.regionalCertificateName = try reader["regionalCertificateName"].readIfPresent()
        value.regionalDomainName = try reader["regionalDomainName"].readIfPresent()
        value.regionalHostedZoneId = try reader["regionalHostedZoneId"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateGatewayResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayResponseOutput()
        value.defaultResponse = try reader["defaultResponse"].readIfPresent() ?? false
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseType = try reader["responseType"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension UpdateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationOutput()
        value.cacheKeyParameters = try reader["cacheKeyParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cacheNamespace = try reader["cacheNamespace"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.credentials = try reader["credentials"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.integrationResponses = try reader["integrationResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.IntegrationResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent() ?? 0
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: APIGatewayClientTypes.TlsConfig.read(from:))
        value.type = try reader["type"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension UpdateIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationResponseOutput()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.selectionPattern = try reader["selectionPattern"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension UpdateMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMethodOutput()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.methodIntegration = try reader["methodIntegration"].readIfPresent(with: APIGatewayClientTypes.Integration.read(from:))
        value.methodResponses = try reader["methodResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestValidatorId = try reader["requestValidatorId"].readIfPresent()
        return value
    }
}

extension UpdateMethodResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMethodResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMethodResponseOutput()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension UpdateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension UpdateRequestValidatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRequestValidatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRequestValidatorOutput()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.validateRequestBody = try reader["validateRequestBody"].readIfPresent() ?? false
        value.validateRequestParameters = try reader["validateRequestParameters"].readIfPresent() ?? false
        return value
    }
}

extension UpdateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResourceOutput()
        value.id = try reader["id"].readIfPresent()
        value.parentId = try reader["parentId"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.pathPart = try reader["pathPart"].readIfPresent()
        value.resourceMethods = try reader["resourceMethods"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.Method.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateRestApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRestApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRestApiOutput()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: APIGatewayClientTypes.AccessLogSettings.read(from:))
        value.cacheClusterEnabled = try reader["cacheClusterEnabled"].readIfPresent() ?? false
        value.cacheClusterSize = try reader["cacheClusterSize"].readIfPresent()
        value.cacheClusterStatus = try reader["cacheClusterStatus"].readIfPresent()
        value.canarySettings = try reader["canarySettings"].readIfPresent(with: APIGatewayClientTypes.CanarySettings.read(from:))
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentationVersion = try reader["documentationVersion"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.methodSettings = try reader["methodSettings"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodSetting.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tracingEnabled = try reader["tracingEnabled"].readIfPresent() ?? false
        value.variables = try reader["variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.webAclArn = try reader["webAclArn"].readIfPresent()
        return value
    }
}

extension UpdateUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUsageOutput()
        value.endDate = try reader["endDate"].readIfPresent()
        value.items = try reader["values"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.position = try reader["position"].readIfPresent()
        value.startDate = try reader["startDate"].readIfPresent()
        value.usagePlanId = try reader["usagePlanId"].readIfPresent()
        return value
    }
}

extension UpdateUsagePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUsagePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUsagePlanOutput()
        value.apiStages = try reader["apiStages"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ApiStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.productCode = try reader["productCode"].readIfPresent()
        value.quota = try reader["quota"].readIfPresent(with: APIGatewayClientTypes.QuotaSettings.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.throttle = try reader["throttle"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        return value
    }
}

extension UpdateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcLinkOutput()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetArns = try reader["targetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum CreateApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBasePathMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDocumentationPartOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDocumentationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRequestValidatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUsagePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUsagePlanKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBasePathMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteClientCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDocumentationPartOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDocumentationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMethodResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRequestValidatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUsagePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUsagePlanKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FlushStageAuthorizersCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FlushStageCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateClientCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBasePathMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBasePathMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetClientCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetClientCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentationPartOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentationPartsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGatewayResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGatewayResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMethodResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRequestValidatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRequestValidatorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRestApisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSdkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSdkTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSdkTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsagePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsagePlanKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsagePlanKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsagePlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportApiKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportDocumentationPartsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutGatewayResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMethodResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestInvokeAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestInvokeMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBasePathMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateClientCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentationPartOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMethodResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRequestValidatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRestApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUsagePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = LimitExceededException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = TooManyRequestsException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ServiceUnavailableException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension APIGatewayClientTypes.MethodSnapshot {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.MethodSnapshot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.MethodSnapshot()
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent() ?? false
        return value
    }
}

extension APIGatewayClientTypes.DocumentationPartLocation {

    static func write(value: APIGatewayClientTypes.DocumentationPartLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["method"].write(value.method)
        try writer["name"].write(value.name)
        try writer["path"].write(value.path)
        try writer["statusCode"].write(value.statusCode)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.DocumentationPartLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.DocumentationPartLocation()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.path = try reader["path"].readIfPresent()
        value.method = try reader["method"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.EndpointConfiguration {

    static func write(value: APIGatewayClientTypes.EndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<APIGatewayClientTypes.EndpointType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcEndpointIds"].writeList(value.vpcEndpointIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.EndpointConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.EndpointConfiguration()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<APIGatewayClientTypes.EndpointType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcEndpointIds = try reader["vpcEndpointIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.MutualTlsAuthentication {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.MutualTlsAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.MutualTlsAuthentication()
        value.truststoreUri = try reader["truststoreUri"].readIfPresent()
        value.truststoreVersion = try reader["truststoreVersion"].readIfPresent()
        value.truststoreWarnings = try reader["truststoreWarnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.Method {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Method {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Method()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.requestValidatorId = try reader["requestValidatorId"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.methodResponses = try reader["methodResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.methodIntegration = try reader["methodIntegration"].readIfPresent(with: APIGatewayClientTypes.Integration.read(from:))
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.Integration {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Integration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Integration()
        value.type = try reader["type"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.uri = try reader["uri"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.credentials = try reader["credentials"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent() ?? 0
        value.cacheNamespace = try reader["cacheNamespace"].readIfPresent()
        value.cacheKeyParameters = try reader["cacheKeyParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.integrationResponses = try reader["integrationResponses"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.IntegrationResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: APIGatewayClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension APIGatewayClientTypes.TlsConfig {

    static func write(value: APIGatewayClientTypes.TlsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["insecureSkipVerification"].write(value.insecureSkipVerification)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.TlsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.TlsConfig()
        value.insecureSkipVerification = try reader["insecureSkipVerification"].readIfPresent() ?? false
        return value
    }
}

extension APIGatewayClientTypes.IntegrationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.IntegrationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.IntegrationResponse()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.selectionPattern = try reader["selectionPattern"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.contentHandling = try reader["contentHandling"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.MethodResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.MethodResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.MethodResponse()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readBool(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.MethodSetting {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.MethodSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.MethodSetting()
        value.metricsEnabled = try reader["metricsEnabled"].readIfPresent() ?? false
        value.loggingLevel = try reader["loggingLevel"].readIfPresent()
        value.dataTraceEnabled = try reader["dataTraceEnabled"].readIfPresent() ?? false
        value.throttlingBurstLimit = try reader["throttlingBurstLimit"].readIfPresent() ?? 0
        value.throttlingRateLimit = try reader["throttlingRateLimit"].readIfPresent() ?? 0
        value.cachingEnabled = try reader["cachingEnabled"].readIfPresent() ?? false
        value.cacheTtlInSeconds = try reader["cacheTtlInSeconds"].readIfPresent() ?? 0
        value.cacheDataEncrypted = try reader["cacheDataEncrypted"].readIfPresent() ?? false
        value.requireAuthorizationForCacheControl = try reader["requireAuthorizationForCacheControl"].readIfPresent() ?? false
        value.unauthorizedCacheControlHeaderStrategy = try reader["unauthorizedCacheControlHeaderStrategy"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.AccessLogSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.AccessLogSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.AccessLogSettings()
        value.format = try reader["format"].readIfPresent()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.CanarySettings {

    static func write(value: APIGatewayClientTypes.CanarySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
        try writer["percentTraffic"].write(value.percentTraffic)
        try writer["stageVariableOverrides"].writeMap(value.stageVariableOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useStageCache"].write(value.useStageCache)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.CanarySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.CanarySettings()
        value.percentTraffic = try reader["percentTraffic"].readIfPresent() ?? 0
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.stageVariableOverrides = try reader["stageVariableOverrides"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useStageCache = try reader["useStageCache"].readIfPresent() ?? false
        return value
    }
}

extension APIGatewayClientTypes.ApiStage {

    static func write(value: APIGatewayClientTypes.ApiStage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["stage"].write(value.stage)
        try writer["throttle"].writeMap(value.throttle, valueWritingClosure: APIGatewayClientTypes.ThrottleSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.ApiStage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.ApiStage()
        value.apiId = try reader["apiId"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        value.throttle = try reader["throttle"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.ThrottleSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.ThrottleSettings {

    static func write(value: APIGatewayClientTypes.ThrottleSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["burstLimit"].write(value.burstLimit)
        try writer["rateLimit"].write(value.rateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.ThrottleSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.ThrottleSettings()
        value.burstLimit = try reader["burstLimit"].readIfPresent() ?? 0
        value.rateLimit = try reader["rateLimit"].readIfPresent() ?? 0
        return value
    }
}

extension APIGatewayClientTypes.QuotaSettings {

    static func write(value: APIGatewayClientTypes.QuotaSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["limit"].write(value.limit)
        try writer["offset"].write(value.offset)
        try writer["period"].write(value.period)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.QuotaSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.QuotaSettings()
        value.limit = try reader["limit"].readIfPresent() ?? 0
        value.offset = try reader["offset"].readIfPresent() ?? 0
        value.period = try reader["period"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.ApiKey {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.ApiKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.ApiKey()
        value.id = try reader["id"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.customerId = try reader["customerId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stageKeys = try reader["stageKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.Authorizer {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Authorizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Authorizer()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.providerARNs = try reader["providerARNs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authType = try reader["authType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.authorizerCredentials = try reader["authorizerCredentials"].readIfPresent()
        value.identitySource = try reader["identitySource"].readIfPresent()
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.BasePathMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.BasePathMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.BasePathMapping()
        value.basePath = try reader["basePath"].readIfPresent()
        value.restApiId = try reader["restApiId"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.ClientCertificate {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.ClientCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.ClientCertificate()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.pemEncodedCertificate = try reader["pemEncodedCertificate"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Deployment()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.apiSummary = try reader["apiSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: APIGatewayClientTypes.MethodSnapshot.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.DocumentationPart {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.DocumentationPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.DocumentationPart()
        value.id = try reader["id"].readIfPresent()
        value.location = try reader["location"].readIfPresent(with: APIGatewayClientTypes.DocumentationPartLocation.read(from:))
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.DocumentationVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.DocumentationVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.DocumentationVersion()
        value.version = try reader["version"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.DomainName {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.DomainName {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.DomainName()
        value.domainName = try reader["domainName"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.regionalDomainName = try reader["regionalDomainName"].readIfPresent()
        value.regionalHostedZoneId = try reader["regionalHostedZoneId"].readIfPresent()
        value.regionalCertificateName = try reader["regionalCertificateName"].readIfPresent()
        value.regionalCertificateArn = try reader["regionalCertificateArn"].readIfPresent()
        value.distributionDomainName = try reader["distributionDomainName"].readIfPresent()
        value.distributionHostedZoneId = try reader["distributionHostedZoneId"].readIfPresent()
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: APIGatewayClientTypes.MutualTlsAuthentication.read(from:))
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.GatewayResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.GatewayResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.GatewayResponse()
        value.responseType = try reader["responseType"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.defaultResponse = try reader["defaultResponse"].readIfPresent() ?? false
        return value
    }
}

extension APIGatewayClientTypes.Model {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Model()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        value.contentType = try reader["contentType"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.RequestValidator {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.RequestValidator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.RequestValidator()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.validateRequestBody = try reader["validateRequestBody"].readIfPresent() ?? false
        value.validateRequestParameters = try reader["validateRequestParameters"].readIfPresent() ?? false
        return value
    }
}

extension APIGatewayClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Resource()
        value.id = try reader["id"].readIfPresent()
        value.parentId = try reader["parentId"].readIfPresent()
        value.pathPart = try reader["pathPart"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.resourceMethods = try reader["resourceMethods"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.Method.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.RestApi {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.RestApi {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.RestApi()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.binaryMediaTypes = try reader["binaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumCompressionSize = try reader["minimumCompressionSize"].readIfPresent()
        value.apiKeySource = try reader["apiKeySource"].readIfPresent()
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: APIGatewayClientTypes.EndpointConfiguration.read(from:))
        value.policy = try reader["policy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent() ?? false
        value.rootResourceId = try reader["rootResourceId"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.SdkConfigurationProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.SdkConfigurationProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.SdkConfigurationProperty()
        value.name = try reader["name"].readIfPresent()
        value.friendlyName = try reader["friendlyName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent() ?? false
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.SdkType {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.SdkType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.SdkType()
        value.id = try reader["id"].readIfPresent()
        value.friendlyName = try reader["friendlyName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.configurationProperties = try reader["configurationProperties"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.SdkConfigurationProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.Stage {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.Stage()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.stageName = try reader["stageName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.cacheClusterEnabled = try reader["cacheClusterEnabled"].readIfPresent() ?? false
        value.cacheClusterSize = try reader["cacheClusterSize"].readIfPresent()
        value.cacheClusterStatus = try reader["cacheClusterStatus"].readIfPresent()
        value.methodSettings = try reader["methodSettings"].readMapIfPresent(valueReadingClosure: APIGatewayClientTypes.MethodSetting.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.variables = try reader["variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.documentationVersion = try reader["documentationVersion"].readIfPresent()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: APIGatewayClientTypes.AccessLogSettings.read(from:))
        value.canarySettings = try reader["canarySettings"].readIfPresent(with: APIGatewayClientTypes.CanarySettings.read(from:))
        value.tracingEnabled = try reader["tracingEnabled"].readIfPresent() ?? false
        value.webAclArn = try reader["webAclArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension APIGatewayClientTypes.UsagePlanKey {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.UsagePlanKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.UsagePlanKey()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension APIGatewayClientTypes.UsagePlan {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.UsagePlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.UsagePlan()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.apiStages = try reader["apiStages"].readListIfPresent(memberReadingClosure: APIGatewayClientTypes.ApiStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.throttle = try reader["throttle"].readIfPresent(with: APIGatewayClientTypes.ThrottleSettings.read(from:))
        value.quota = try reader["quota"].readIfPresent(with: APIGatewayClientTypes.QuotaSettings.read(from:))
        value.productCode = try reader["productCode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.VpcLink {

    static func read(from reader: SmithyJSON.Reader) throws -> APIGatewayClientTypes.VpcLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = APIGatewayClientTypes.VpcLink()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targetArns = try reader["targetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension APIGatewayClientTypes.StageKey {

    static func write(value: APIGatewayClientTypes.StageKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["restApiId"].write(value.restApiId)
        try writer["stageName"].write(value.stageName)
    }
}

extension APIGatewayClientTypes.DeploymentCanarySettings {

    static func write(value: APIGatewayClientTypes.DeploymentCanarySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["percentTraffic"].write(value.percentTraffic)
        try writer["stageVariableOverrides"].writeMap(value.stageVariableOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["useStageCache"].write(value.useStageCache)
    }
}

extension APIGatewayClientTypes.MutualTlsAuthenticationInput {

    static func write(value: APIGatewayClientTypes.MutualTlsAuthenticationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["truststoreUri"].write(value.truststoreUri)
        try writer["truststoreVersion"].write(value.truststoreVersion)
    }
}

extension APIGatewayClientTypes.PatchOperation {

    static func write(value: APIGatewayClientTypes.PatchOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["from"].write(value.from)
        try writer["op"].write(value.op)
        try writer["path"].write(value.path)
        try writer["value"].write(value.value)
    }
}

public enum APIGatewayClientTypes {}
