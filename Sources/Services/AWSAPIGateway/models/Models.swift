// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension APIGatewayClientTypes.AccessLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension APIGatewayClientTypes {
    /// Access log settings, including the access log format and access log destination ARN.
    public struct AccessLogSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension APIGatewayClientTypes.ApiKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let customerId = self.customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .epochSeconds, forKey: .lastUpdatedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for string0 in stageKeys {
                try stageKeysContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
    public struct ApiKey: Swift.Equatable {
        /// The timestamp when the API Key was created.
        public var createdDate: ClientRuntime.Date?
        /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
        public var customerId: Swift.String?
        /// The description of the API Key.
        public var description: Swift.String?
        /// Specifies whether the API Key can be used by callers.
        public var enabled: Swift.Bool
        /// The identifier of the API Key.
        public var id: Swift.String?
        /// The timestamp when the API Key was last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// The name of the API Key.
        public var name: Swift.String?
        /// A list of Stage resources that are associated with the ApiKey resource.
        public var stageKeys: [Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// The value of the API Key.
        public var value: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            customerId: Swift.String? = nil,
            description: Swift.String? = nil,
            enabled: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stageKeys: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.customerId = customerId
            self.description = description
            self.enabled = enabled
            self.id = id
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.stageKeys = stageKeys
            self.tags = tags
            self.value = value
        }
    }

}

extension APIGatewayClientTypes {
    public enum ApiKeySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizer
        case header
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeySourceType] {
            return [
                .authorizer,
                .header,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizer: return "AUTHORIZER"
            case .header: return "HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiKeySourceType(rawValue: rawValue) ?? ApiKeySourceType.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes {
    public enum ApiKeysFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeysFormat] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiKeysFormat(rawValue: rawValue) ?? ApiKeysFormat.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.ApiStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
        case stage
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let throttle = throttle {
            var throttleContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .throttle)
            for (dictKey0, mapOfApiStageThrottleSettings0) in throttle {
                try throttleContainer.encode(mapOfApiStageThrottleSettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let throttleContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.ThrottleSettings?].self, forKey: .throttle)
        var throttleDecoded0: [Swift.String:APIGatewayClientTypes.ThrottleSettings]? = nil
        if let throttleContainer = throttleContainer {
            throttleDecoded0 = [Swift.String:APIGatewayClientTypes.ThrottleSettings]()
            for (key0, throttlesettings0) in throttleContainer {
                if let throttlesettings0 = throttlesettings0 {
                    throttleDecoded0?[key0] = throttlesettings0
                }
            }
        }
        throttle = throttleDecoded0
    }
}

extension APIGatewayClientTypes {
    /// API stage name of the associated API stage in a usage plan.
    public struct ApiStage: Swift.Equatable {
        /// API Id of the associated API stage in a usage plan.
        public var apiId: Swift.String?
        /// API stage name of the associated API stage in a usage plan.
        public var stage: Swift.String?
        /// Map containing method level throttling information for API stage in a usage plan.
        public var throttle: [Swift.String:APIGatewayClientTypes.ThrottleSettings]?

        public init(
            apiId: Swift.String? = nil,
            stage: Swift.String? = nil,
            throttle: [Swift.String:APIGatewayClientTypes.ThrottleSettings]? = nil
        )
        {
            self.apiId = apiId
            self.stage = stage
            self.throttle = throttle
        }
    }

}

extension APIGatewayClientTypes.Authorizer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = self.authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = self.authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identitySource = self.identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for providerarn0 in providerARNs {
                try providerARNsContainer.encode(providerarn0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
    public struct Authorizer: Swift.Equatable {
        /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
        public var authType: Swift.String?
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
        public var authorizerCredentials: Swift.String?
        /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
        public var authorizerUri: Swift.String?
        /// The identifier for the authorizer resource.
        public var id: Swift.String?
        /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
        public var identitySource: Swift.String?
        /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// The name of the authorizer.
        public var name: Swift.String?
        /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
        public var providerARNs: [Swift.String]?
        /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
        public var type: APIGatewayClientTypes.AuthorizerType?

        public init(
            authType: Swift.String? = nil,
            authorizerCredentials: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerUri: Swift.String? = nil,
            id: Swift.String? = nil,
            identitySource: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil,
            name: Swift.String? = nil,
            providerARNs: [Swift.String]? = nil,
            type: APIGatewayClientTypes.AuthorizerType? = nil
        )
        {
            self.authType = authType
            self.authorizerCredentials = authorizerCredentials
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.id = id
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.name = name
            self.providerARNs = providerARNs
            self.type = type
        }
    }

}

extension APIGatewayClientTypes {
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognitoUserPools
        case request
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .cognitoUserPools,
                .request,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognitoUserPools: return "COGNITO_USER_POOLS"
            case .request: return "REQUEST"
            case .token: return "TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes.BasePathMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = self.basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = self.restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents the base path that callers of the API must provide as part of the URL after the domain name.
    public struct BasePathMapping: Swift.Equatable {
        /// The base path name that callers of the API must provide as part of the URL after the domain name.
        public var basePath: Swift.String?
        /// The string identifier of the associated RestApi.
        public var restApiId: Swift.String?
        /// The name of the associated stage.
        public var stage: Swift.String?

        public init(
            basePath: Swift.String? = nil,
            restApiId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.restApiId = restApiId
            self.stage = stage
        }
    }

}

extension APIGatewayClientTypes {
    /// Returns the size of the CacheCluster.
    public enum CacheClusterSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case size0Point5Gb
        case size118Gb
        case size13Point5Gb
        case size1Point6Gb
        case size237Gb
        case size28Point4Gb
        case size58Point2Gb
        case size6Point1Gb
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterSize] {
            return [
                .size0Point5Gb,
                .size118Gb,
                .size13Point5Gb,
                .size1Point6Gb,
                .size237Gb,
                .size28Point4Gb,
                .size58Point2Gb,
                .size6Point1Gb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .size0Point5Gb: return "0.5"
            case .size118Gb: return "118"
            case .size13Point5Gb: return "13.5"
            case .size1Point6Gb: return "1.6"
            case .size237Gb: return "237"
            case .size28Point4Gb: return "28.4"
            case .size58Point2Gb: return "58.2"
            case .size6Point1Gb: return "6.1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheClusterSize(rawValue: rawValue) ?? CacheClusterSize.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes {
    /// Returns the status of the CacheCluster.
    public enum CacheClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case createInProgress
        case deleteInProgress
        case flushInProgress
        case notAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterStatus] {
            return [
                .available,
                .createInProgress,
                .deleteInProgress,
                .flushInProgress,
                .notAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .flushInProgress: return "FLUSH_IN_PROGRESS"
            case .notAvailable: return "NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheClusterStatus(rawValue: rawValue) ?? CacheClusterStatus.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.CanarySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapOfStringToString0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentTraffic) ?? 0.0
        percentTraffic = percentTrafficDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useStageCache) ?? false
        useStageCache = useStageCacheDecoded
    }
}

extension APIGatewayClientTypes {
    /// Configuration settings of a canary deployment.
    public struct CanarySettings: Swift.Equatable {
        /// The ID of the canary deployment.
        public var deploymentId: Swift.String?
        /// The percent (0-100) of traffic diverted to a canary deployment.
        public var percentTraffic: Swift.Double
        /// Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String:Swift.String]?
        /// A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init(
            deploymentId: Swift.String? = nil,
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String:Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension APIGatewayClientTypes.ClientCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encodeTimestamp(expirationDate, format: .epochSeconds, forKey: .expirationDate)
        }
        if let pemEncodedCertificate = self.pemEncodedCertificate {
            try encodeContainer.encode(pemEncodedCertificate, forKey: .pemEncodedCertificate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
    public struct ClientCertificate: Swift.Equatable {
        /// The identifier of the client certificate.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the client certificate was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the client certificate.
        public var description: Swift.String?
        /// The timestamp when the client certificate will expire.
        public var expirationDate: ClientRuntime.Date?
        /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
        public var pemEncodedCertificate: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            expirationDate: ClientRuntime.Date? = nil,
            pemEncodedCertificate: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.description = description
            self.expirationDate = expirationDate
            self.pemEncodedCertificate = pemEncodedCertificate
            self.tags = tags
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request configuration has conflicts. For details, see the accompanying error message.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes {
    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension CreateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerId = self.customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let generateDistinctId = self.generateDistinctId {
            try encodeContainer.encode(generateDistinctId, forKey: .generateDistinctId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for stagekey0 in stageKeys {
                try stageKeysContainer.encode(stagekey0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension CreateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// Request to create an ApiKey resource.
public struct CreateApiKeyInput: Swift.Equatable {
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the ApiKey.
    public var description: Swift.String?
    /// Specifies whether the ApiKey can be used by callers.
    public var enabled: Swift.Bool?
    /// Specifies whether (true) or not (false) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
    public var generateDistinctId: Swift.Bool?
    /// The name of the ApiKey.
    public var name: Swift.String?
    /// DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
    public var stageKeys: [APIGatewayClientTypes.StageKey]?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies a value of the API key.
    public var value: Swift.String?

    public init(
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        generateDistinctId: Swift.Bool? = nil,
        name: Swift.String? = nil,
        stageKeys: [APIGatewayClientTypes.StageKey]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.generateDistinctId = generateDistinctId
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool?
    let generateDistinctId: Swift.Bool?
    let value: Swift.String?
    let stageKeys: [APIGatewayClientTypes.StageKey]?
    let customerId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let generateDistinctIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .generateDistinctId)
        generateDistinctId = generateDistinctIdDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.StageKey?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[APIGatewayClientTypes.StageKey]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [APIGatewayClientTypes.StageKey]()
            for structure0 in stageKeysContainer {
                if let structure0 = structure0 {
                    stageKeysDecoded0?.append(structure0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct CreateApiKeyOutput: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = self.authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = self.authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identitySource = self.identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for providerarn0 in providerARNs {
                try providerARNsContainer.encode(providerarn0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

/// Request to add a new Authorizer to an existing RestApi resource.
public struct CreateAuthorizerInput: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    /// This member is required.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.restApiId = restApiId
        self.type = type
    }
}

struct CreateAuthorizerInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: APIGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension CreateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension CreateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct CreateAuthorizerOutput: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct CreateAuthorizerOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: APIGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension CreateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

enum CreateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBasePathMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = self.basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = self.restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension CreateBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

/// Requests API Gateway to create a new BasePathMapping resource.
public struct CreateBasePathMappingInput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to create.
    /// This member is required.
    public var domainName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingInputBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension CreateBasePathMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateBasePathMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBasePathMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct CreateBasePathMappingOutput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingOutputBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension CreateBasePathMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum CreateBasePathMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheClusterEnabled = self.cacheClusterEnabled {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = self.cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = self.canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageDescription = self.stageDescription {
            try encodeContainer.encode(stageDescription, forKey: .stageDescription)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tracingEnabled = self.tracingEnabled {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapOfStringToString0) in variables {
                try variablesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

/// Requests API Gateway to create a Deployment resource.
public struct CreateDeploymentInput: Swift.Equatable {
    /// Enables a cache cluster for the Stage resource specified in the input.
    public var cacheClusterEnabled: Swift.Bool?
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The input configuration for the canary deployment when the deployment is a canary release deployment.
    public var canarySettings: APIGatewayClientTypes.DeploymentCanarySettings?
    /// The description for the Deployment resource to create.
    public var description: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The description of the Stage resource for the Deployment resource to create.
    public var stageDescription: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool?
    /// A map that defines the stage variables for the Stage resource that is associated with the new deployment. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?

    public init(
        cacheClusterEnabled: Swift.Bool? = nil,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: APIGatewayClientTypes.DeploymentCanarySettings? = nil,
        description: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageDescription: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tracingEnabled: Swift.Bool? = nil,
        variables: [Swift.String:Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.description = description
        self.restApiId = restApiId
        self.stageDescription = stageDescription
        self.stageName = stageName
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let stageDescription: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool?
    let cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    let variables: [Swift.String:Swift.String]?
    let canarySettings: APIGatewayClientTypes.DeploymentCanarySettings?
    let tracingEnabled: Swift.Bool?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageDescription)
        stageDescription = stageDescriptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DeploymentCanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct CreateDeploymentOutput: Swift.Equatable {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: APIGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: APIGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDocumentationPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }
}

extension CreateDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Creates a new documentation part of a given API.
public struct CreateDocumentationPartInput: Swift.Equatable {
    /// The location of the targeted API entity of the to-be-created documentation part.
    /// This member is required.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
    /// This member is required.
    public var properties: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.location = location
        self.properties = properties
        self.restApiId = restApiId
    }
}

struct CreateDocumentationPartInputBody: Swift.Equatable {
    let location: APIGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension CreateDocumentationPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case properties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreateDocumentationPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDocumentationPartOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity.
public struct CreateDocumentationPartOutput: Swift.Equatable {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct CreateDocumentationPartOutputBody: Swift.Equatable {
    let id: Swift.String?
    let location: APIGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension CreateDocumentationPartOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

enum CreateDocumentationPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDocumentationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = self.documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

extension CreateDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

/// Creates a new documentation version of a given API.
public struct CreateDocumentationVersionInput: Swift.Equatable {
    /// A description about the new documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the new snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The stage name to be associated with the new documentation snapshot.
    public var stageName: Swift.String?

    public init(
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct CreateDocumentationVersionInputBody: Swift.Equatable {
    let documentationVersion: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
}

extension CreateDocumentationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDocumentationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDocumentationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API.
public struct CreateDocumentationVersionOutput: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct CreateDocumentationVersionOutputBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension CreateDocumentationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateDocumentationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateBody = self.certificateBody {
            try encodeContainer.encode(certificateBody, forKey: .certificateBody)
        }
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let certificateName = self.certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificatePrivateKey = self.certificatePrivateKey {
            try encodeContainer.encode(certificatePrivateKey, forKey: .certificatePrivateKey)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let endpointConfiguration = self.endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = self.mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let ownershipVerificationCertificateArn = self.ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let regionalCertificateArn = self.regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = self.regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let securityPolicy = self.securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

/// A request to create a new domain name.
public struct CreateDomainNameInput: Swift.Equatable {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// [Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.
    public var certificateBody: Swift.String?
    /// [Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.
    public var certificateChain: Swift.String?
    /// The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// [Deprecated] Your edge-optimized endpoint's domain name certificate's private key.
    public var certificatePrivateKey: Swift.String?
    /// The name of the DomainName resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthenticationInput?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used by regional endpoint for this domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The user-friendly name of the certificate that will be used by regional endpoint for this domain name.
    public var regionalCertificateName: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificatePrivateKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthenticationInput? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.certificateName = certificateName
        self.certificatePrivateKey = certificatePrivateKey
        self.domainName = domainName
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateBody: Swift.String?
    let certificatePrivateKey: Swift.String?
    let certificateChain: Swift.String?
    let certificateArn: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let tags: [Swift.String:Swift.String]?
    let securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    let mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthenticationInput?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificatePrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePrivateKey)
        certificatePrivateKey = certificatePrivateKeyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let securityPolicyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension CreateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct CreateDomainNameOutput: Swift.Equatable {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension CreateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

enum CreateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

/// Request to add a new Model to an existing RestApi resource.
public struct CreateModelInput: Swift.Equatable {
    /// The content-type for the model.
    /// This member is required.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The RestApi identifier under which the Model will be created.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.name = name
        self.restApiId = restApiId
        self.schema = schema
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload.
public struct CreateModelOutput: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension CreateModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

enum CreateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRequestValidatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validateRequestBody = self.validateRequestBody {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if let validateRequestParameters = self.validateRequestParameters {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }
}

extension CreateRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

/// Creates a RequestValidator of a given RestApi.
public struct CreateRequestValidatorInput: Swift.Equatable {
    /// The name of the to-be-created RequestValidator.
    public var name: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (true) or not (false).
    public var validateRequestBody: Swift.Bool?
    /// A Boolean flag to indicate whether to validate request parameters, true, or not false.
    public var validateRequestParameters: Swift.Bool?

    public init(
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        validateRequestBody: Swift.Bool? = nil,
        validateRequestParameters: Swift.Bool? = nil
    )
    {
        self.name = name
        self.restApiId = restApiId
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorInputBody: Swift.Equatable {
    let name: Swift.String?
    let validateRequestBody: Swift.Bool?
    let validateRequestParameters: Swift.Bool?
}

extension CreateRequestValidatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension CreateRequestValidatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRequestValidatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming Method requests.
public struct CreateRequestValidatorOutput: Swift.Equatable {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension CreateRequestValidatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestBody) ?? false
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestParameters) ?? false
        validateRequestParameters = validateRequestParametersDecoded
    }
}

enum CreateRequestValidatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathPart
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathPart = self.pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
    }
}

extension CreateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let parentId = parentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(parentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to create a Resource resource.
public struct CreateResourceInput: Swift.Equatable {
    /// The parent resource's identifier.
    /// This member is required.
    public var parentId: Swift.String?
    /// The last path segment for this resource.
    /// This member is required.
    public var pathPart: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        parentId: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.parentId = parentId
        self.pathPart = pathPart
        self.restApiId = restApiId
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    let pathPart: Swift.String?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathPart
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
    }
}

extension CreateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource.
public struct CreateResourceOutput: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct CreateResourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?
}

extension CreateResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:APIGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:APIGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

enum CreateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = self.apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for string0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(string0)
            }
        }
        if let cloneFrom = self.cloneFrom {
            try encodeContainer.encode(cloneFrom, forKey: .cloneFrom)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = self.disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = self.endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let minimumCompressionSize = self.minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension CreateRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// The POST Request to add a new RestApi resource to your collection.
public struct CreateRestApiInput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The ID of the RestApi that you want to clone from.
    public var cloneFrom: Swift.String?
    /// The description of the RestApi.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The name of the RestApi.
    /// This member is required.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        cloneFrom: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.cloneFrom = cloneFrom
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
    }
}

struct CreateRestApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let version: Swift.String?
    let cloneFrom: Swift.String?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool?
}

extension CreateRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let cloneFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneFrom)
        cloneFrom = cloneFromDecoded
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension CreateRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRestApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.rootResourceId = output.rootResourceId
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.rootResourceId = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API.
public struct CreateRestApiOutput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateRestApiOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
    let rootResourceId: Swift.String?
}

extension CreateRestApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

enum CreateRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheClusterEnabled = self.cacheClusterEnabled {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = self.cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = self.canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = self.documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tracingEnabled = self.tracingEnabled {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapOfStringToString0) in variables {
                try variablesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

/// Requests API Gateway to create a Stage resource.
public struct CreateStageInput: Swift.Equatable {
    /// Whether cache clustering is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool?
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The canary deployment settings of this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of the Deployment resource for the Stage resource.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description of the Stage resource.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name for the Stage resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool?
    /// A map that defines the stage variables for the new Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?

    public init(
        cacheClusterEnabled: Swift.Bool? = nil,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool? = nil,
        variables: [Swift.String:Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool?
    let cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let canarySettings: APIGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct CreateStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct CreateStageOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    let canarySettings: APIGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension CreateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled) ?? false
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:APIGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled) ?? false
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum CreateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUsagePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for apistage0 in apiStages {
                try apiStagesContainer.encode(apistage0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quota = self.quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let throttle = self.throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }
}

extension CreateUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usageplans"
    }
}

/// The POST request to create a usage plan with the name, description, throttle limits and quota limits, as well as the associated API stages, specified in the payload.
public struct CreateUsagePlanInput: Swift.Equatable {
    /// The associated API stages of the usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of the usage plan.
    public var description: Swift.String?
    /// The name of the usage plan.
    /// This member is required.
    public var name: Swift.String?
    /// The quota of the usage plan.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// The throttling limits of the usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.name = name
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [APIGatewayClientTypes.ApiStage]?
    let throttle: APIGatewayClientTypes.ThrottleSettings?
    let quota: APIGatewayClientTypes.QuotaSettings?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUsagePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[APIGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [APIGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUsagePlanKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType, forKey: .keyType)
        }
    }
}

extension CreateUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

/// The POST request to create a usage plan key for adding an existing API key to a usage plan.
public struct CreateUsagePlanKeyInput: Swift.Equatable {
    /// The identifier of a UsagePlanKey resource for a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// The type of a UsagePlanKey resource for a plan customer.
    /// This member is required.
    public var keyType: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-created UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        keyType: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.keyType = keyType
        self.usagePlanId = usagePlanId
    }
}

struct CreateUsagePlanKeyInputBody: Swift.Equatable {
    let keyId: Swift.String?
    let keyType: Swift.String?
}

extension CreateUsagePlanKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId
        case keyType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension CreateUsagePlanKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUsagePlanKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// Represents a usage plan key to identify a plan customer.
public struct CreateUsagePlanKeyOutput: Swift.Equatable {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct CreateUsagePlanKeyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let type: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
}

extension CreateUsagePlanKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateUsagePlanKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUsagePlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUsagePlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Dont rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct CreateUsagePlanOutput: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [APIGatewayClientTypes.ApiStage]?
    let throttle: APIGatewayClientTypes.ThrottleSettings?
    let quota: APIGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUsagePlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[APIGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [APIGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateUsagePlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for string0 in targetArns {
                try targetArnsContainer.encode(string0)
            }
        }
    }
}

extension CreateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vpclinks"
    }
}

/// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
public struct CreateVpcLinkInput: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The name used to label and identify the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    /// This member is required.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct CreateVpcLinkOutput: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: APIGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to delete the ApiKey resource.
public struct DeleteApiKeyInput: Swift.Equatable {
    /// The identifier of the ApiKey resource to be deleted.
    /// This member is required.
    public var apiKey: Swift.String?

    public init(
        apiKey: Swift.String? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct DeleteApiKeyInputBody: Swift.Equatable {
}

extension DeleteApiKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApiKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to delete an existing Authorizer resource.
public struct DeleteAuthorizerInput: Swift.Equatable {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct DeleteAuthorizerInputBody: Swift.Equatable {
}

extension DeleteAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAuthorizerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// A request to delete the BasePathMapping resource.
public struct DeleteBasePathMappingInput: Swift.Equatable {
    /// The base path name of the BasePathMapping resource to delete. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct DeleteBasePathMappingInputBody: Swift.Equatable {
}

extension DeleteBasePathMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBasePathMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBasePathMappingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBasePathMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to delete the ClientCertificate resource.
public struct DeleteClientCertificateInput: Swift.Equatable {
    /// The identifier of the ClientCertificate resource to be deleted.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init(
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct DeleteClientCertificateInputBody: Swift.Equatable {
}

extension DeleteClientCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteClientCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteClientCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteClientCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to delete a Deployment resource.
public struct DeleteDeploymentInput: Swift.Equatable {
    /// The identifier of the Deployment resource to delete.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
}

extension DeleteDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeploymentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Deletes an existing documentation part of an API.
public struct DeleteDocumentationPartInput: Swift.Equatable {
    /// The identifier of the to-be-deleted documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationPartInputBody: Swift.Equatable {
}

extension DeleteDocumentationPartInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentationPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDocumentationPartOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDocumentationPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Deletes an existing documentation version of an API.
public struct DeleteDocumentationVersionInput: Swift.Equatable {
    /// The version identifier of a to-be-deleted documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationVersionInputBody: Swift.Equatable {
}

extension DeleteDocumentationVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDocumentationVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDocumentationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// A request to delete the DomainName resource.
public struct DeleteDomainNameInput: Swift.Equatable {
    /// The name of the DomainName resource to be deleted.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainNameOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
public struct DeleteGatewayResponseInput: Swift.Equatable {
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct DeleteGatewayResponseInputBody: Swift.Equatable {
}

extension DeleteGatewayResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGatewayResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGatewayResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents a delete integration request.
public struct DeleteIntegrationInput: Swift.Equatable {
    /// Specifies a delete integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a delete integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteIntegrationInputBody: Swift.Equatable {
}

extension DeleteIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a delete integration response request.
public struct DeleteIntegrationResponseInput: Swift.Equatable {
    /// Specifies a delete integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a delete integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies a delete integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteIntegrationResponseInputBody: Swift.Equatable {
}

extension DeleteIntegrationResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntegrationResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to delete an existing Method resource.
public struct DeleteMethodInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteMethodInputBody: Swift.Equatable {
}

extension DeleteMethodInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMethodOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// A request to delete an existing MethodResponse resource.
public struct DeleteMethodResponseInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code identifier for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteMethodResponseInputBody: Swift.Equatable {
}

extension DeleteMethodResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMethodResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMethodResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMethodResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to delete an existing model in an existing RestApi resource.
public struct DeleteModelInput: Swift.Equatable {
    /// The name of the model to delete.
    /// This member is required.
    public var modelName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Deletes a specified RequestValidator of a given RestApi.
public struct DeleteRequestValidatorInput: Swift.Equatable {
    /// The identifier of the RequestValidator to be deleted.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct DeleteRequestValidatorInputBody: Swift.Equatable {
}

extension DeleteRequestValidatorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRequestValidatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRequestValidatorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRequestValidatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to delete a Resource.
public struct DeleteResourceInput: Swift.Equatable {
    /// The identifier of the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
}

extension DeleteResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// Request to delete the specified API from your collection.
public struct DeleteRestApiInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct DeleteRestApiInputBody: Swift.Equatable {
}

extension DeleteRestApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRestApiOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to delete a Stage resource.
public struct DeleteStageInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to delete.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The DELETE request to delete a usage plan of a given plan Id.
public struct DeleteUsagePlanInput: Swift.Equatable {
    /// The Id of the to-be-deleted usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanInputBody: Swift.Equatable {
}

extension DeleteUsagePlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

/// The DELETE request to delete a usage plan key and remove the underlying API key from the associated usage plan.
public struct DeleteUsagePlanKeyInput: Swift.Equatable {
    /// The Id of the UsagePlanKey resource to be deleted.
    /// This member is required.
    public var keyId: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-deleted UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanKeyInputBody: Swift.Equatable {
}

extension DeleteUsagePlanKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsagePlanKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUsagePlanKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUsagePlanKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUsagePlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUsagePlanOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUsagePlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Deletes an existing VpcLink of a specified identifier.
public struct DeleteVpcLinkInput: Swift.Equatable {
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Swift.Equatable {
}

extension DeleteVpcLinkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVpcLinkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSummary = apiSummary {
            var apiSummaryContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .apiSummary)
            for (dictKey0, pathToMapOfMethodSnapshot0) in apiSummary {
                var pathToMapOfMethodSnapshot0Container = apiSummaryContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, mapOfMethodSnapshot1) in pathToMapOfMethodSnapshot0 {
                    try pathToMapOfMethodSnapshot0Container.encode(mapOfMethodSnapshot1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: APIGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: APIGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension APIGatewayClientTypes {
    /// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
    public struct Deployment: Swift.Equatable {
        /// A summary of the RestApi at the date and time that the deployment resource was created.
        public var apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
        /// The date and time that the deployment resource was created.
        public var createdDate: ClientRuntime.Date?
        /// The description for the deployment resource.
        public var description: Swift.String?
        /// The identifier for the deployment resource.
        public var id: Swift.String?

        public init(
            apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.apiSummary = apiSummary
            self.createdDate = createdDate
            self.description = description
            self.id = id
        }
    }

}

extension APIGatewayClientTypes.DeploymentCanarySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapOfStringToString0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentTraffic) ?? 0.0
        percentTraffic = percentTrafficDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useStageCache) ?? false
        useStageCache = useStageCacheDecoded
    }
}

extension APIGatewayClientTypes {
    /// The input configuration for a canary deployment.
    public struct DeploymentCanarySettings: Swift.Equatable {
        /// The percentage (0.0-100.0) of traffic routed to the canary deployment.
        public var percentTraffic: Swift.Double
        /// A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String:Swift.String]?
        /// A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init(
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String:Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension APIGatewayClientTypes.DocumentationPart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension APIGatewayClientTypes {
    /// A documentation part for a targeted API entity.
    public struct DocumentationPart: Swift.Equatable {
        /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
        public var id: Swift.String?
        /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
        public var location: APIGatewayClientTypes.DocumentationPartLocation?
        /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
        public var properties: Swift.String?

        public init(
            id: Swift.String? = nil,
            location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
            properties: Swift.String? = nil
        )
        {
            self.id = id
            self.location = location
            self.properties = properties
        }
    }

}

extension APIGatewayClientTypes.DocumentationPartLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case method
        case name
        case path
        case statusCode
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let method = self.method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartType.self, forKey: .type)
        type = typeDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let methodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .method)
        method = methodDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension APIGatewayClientTypes {
    /// Specifies the target API entity to which the documentation applies.
    public struct DocumentationPartLocation: Swift.Equatable {
        /// The HTTP verb of a method. It is a valid field for the API entity types of METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any method. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's method attribute must match that of the parent entity exactly.
        public var method: Swift.String?
        /// The name of the targeted API entity. It is a valid and required field for the API entity types of AUTHORIZER, MODEL, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY and RESPONSE_HEADER. It is an invalid field for any other entity type.
        public var name: Swift.String?
        /// The URL path of the target. It is a valid field for the API entity types of RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is / for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other location attributes, the child entity's path attribute must match that of the parent entity as a prefix.
        public var path: Swift.String?
        /// The HTTP status code of a response. It is a valid field for the API entity types of RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any status code. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's statusCode attribute must match that of the parent entity exactly.
        public var statusCode: Swift.String?
        /// The type of API entity to which the documentation content applies. Valid values are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Content inheritance does not apply to any entity of the API, AUTHORIZER, METHOD, MODEL, REQUEST_BODY, or RESOURCE type.
        /// This member is required.
        public var type: APIGatewayClientTypes.DocumentationPartType?

        public init(
            method: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            statusCode: Swift.String? = nil,
            type: APIGatewayClientTypes.DocumentationPartType? = nil
        )
        {
            self.method = method
            self.name = name
            self.path = path
            self.statusCode = statusCode
            self.type = type
        }
    }

}

extension APIGatewayClientTypes {
    public enum DocumentationPartType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case authorizer
        case method
        case model
        case pathParameter
        case queryParameter
        case requestBody
        case requestHeader
        case resource
        case response
        case responseBody
        case responseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentationPartType] {
            return [
                .api,
                .authorizer,
                .method,
                .model,
                .pathParameter,
                .queryParameter,
                .requestBody,
                .requestHeader,
                .resource,
                .response,
                .responseBody,
                .responseHeader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .authorizer: return "AUTHORIZER"
            case .method: return "METHOD"
            case .model: return "MODEL"
            case .pathParameter: return "PATH_PARAMETER"
            case .queryParameter: return "QUERY_PARAMETER"
            case .requestBody: return "REQUEST_BODY"
            case .requestHeader: return "REQUEST_HEADER"
            case .resource: return "RESOURCE"
            case .response: return "RESPONSE"
            case .responseBody: return "RESPONSE_BODY"
            case .responseHeader: return "RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentationPartType(rawValue: rawValue) ?? DocumentationPartType.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.DocumentationVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension APIGatewayClientTypes {
    /// A snapshot of the documentation of an API.
    public struct DocumentationVersion: Swift.Equatable {
        /// The date when the API documentation snapshot is created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the API documentation snapshot.
        public var description: Swift.String?
        /// The version identifier of the API documentation snapshot.
        public var version: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.version = version
        }
    }

}

extension APIGatewayClientTypes.DomainName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = self.certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = self.certificateUploadDate {
            try encodeContainer.encodeTimestamp(certificateUploadDate, format: .epochSeconds, forKey: .certificateUploadDate)
        }
        if let distributionDomainName = self.distributionDomainName {
            try encodeContainer.encode(distributionDomainName, forKey: .distributionDomainName)
        }
        if let distributionHostedZoneId = self.distributionHostedZoneId {
            try encodeContainer.encode(distributionHostedZoneId, forKey: .distributionHostedZoneId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameStatus = self.domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = self.domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointConfiguration = self.endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = self.mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let ownershipVerificationCertificateArn = self.ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let regionalCertificateArn = self.regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = self.regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let regionalDomainName = self.regionalDomainName {
            try encodeContainer.encode(regionalDomainName, forKey: .regionalDomainName)
        }
        if let regionalHostedZoneId = self.regionalHostedZoneId {
            try encodeContainer.encode(regionalHostedZoneId, forKey: .regionalHostedZoneId)
        }
        if let securityPolicy = self.securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents a custom domain name as a user-friendly host name of an API (RestApi).
    public struct DomainName: Swift.Equatable {
        /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: ClientRuntime.Date?
        /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
        public var distributionDomainName: Swift.String?
        /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
        public var distributionHostedZoneId: Swift.String?
        /// The custom domain name as an API host name, for example, my-api.example.com.
        public var domainName: Swift.String?
        /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the DomainName migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
        public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
        /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
        public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
        public var regionalCertificateArn: Swift.String?
        /// The name of the certificate that will be used for validating the regional domain name.
        public var regionalCertificateName: Swift.String?
        /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
        public var regionalDomainName: Swift.String?
        /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
        public var regionalHostedZoneId: Swift.String?
        /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: ClientRuntime.Date? = nil,
            distributionDomainName: Swift.String? = nil,
            distributionHostedZoneId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
            mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            regionalCertificateArn: Swift.String? = nil,
            regionalCertificateName: Swift.String? = nil,
            regionalDomainName: Swift.String? = nil,
            regionalHostedZoneId: Swift.String? = nil,
            securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.distributionDomainName = distributionDomainName
            self.distributionHostedZoneId = distributionHostedZoneId
            self.domainName = domainName
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointConfiguration = endpointConfiguration
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.regionalCertificateArn = regionalCertificateArn
            self.regionalCertificateName = regionalCertificateName
            self.regionalDomainName = regionalDomainName
            self.regionalHostedZoneId = regionalHostedZoneId
            self.securityPolicy = securityPolicy
            self.tags = tags
        }
    }

}

extension APIGatewayClientTypes {
    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pending
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pending,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pending: return "PENDING"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.EndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case types
        case vpcEndpointIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for endpointtype0 in types {
                try typesContainer.encode(endpointtype0.rawValue)
            }
        }
        if let vpcEndpointIds = vpcEndpointIds {
            var vpcEndpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpointIds)
            for string0 in vpcEndpointIds {
                try vpcEndpointIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.EndpointType?].self, forKey: .types)
        var typesDecoded0:[APIGatewayClientTypes.EndpointType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [APIGatewayClientTypes.EndpointType]()
            for enum0 in typesContainer {
                if let enum0 = enum0 {
                    typesDecoded0?.append(enum0)
                }
            }
        }
        types = typesDecoded0
        let vpcEndpointIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcEndpointIds)
        var vpcEndpointIdsDecoded0:[Swift.String]? = nil
        if let vpcEndpointIdsContainer = vpcEndpointIdsContainer {
            vpcEndpointIdsDecoded0 = [Swift.String]()
            for string0 in vpcEndpointIdsContainer {
                if let string0 = string0 {
                    vpcEndpointIdsDecoded0?.append(string0)
                }
            }
        }
        vpcEndpointIds = vpcEndpointIdsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// The endpoint configuration to indicate the types of endpoints an API (RestApi) or its custom domain name (DomainName) has.
    public struct EndpointConfiguration: Swift.Equatable {
        /// A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is "EDGE". For a regional API and its custom domain name, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public var types: [APIGatewayClientTypes.EndpointType]?
        /// A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for PRIVATE endpoint type.
        public var vpcEndpointIds: [Swift.String]?

        public init(
            types: [APIGatewayClientTypes.EndpointType]? = nil,
            vpcEndpointIds: [Swift.String]? = nil
        )
        {
            self.types = types
            self.vpcEndpointIds = vpcEndpointIds
        }
    }

}

extension APIGatewayClientTypes {
    /// The endpoint type. The valid values are EDGE for edge-optimized API setup, most suitable for mobile applications; REGIONAL for regional API endpoint setup, most suitable for calling from AWS Region; and PRIVATE for private APIs.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case `private`
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .private,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .private: return "PRIVATE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension FlushStageAuthorizersCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

/// Request to flush authorizer cache entries on a specified stage.
public struct FlushStageAuthorizersCacheInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the stage to flush.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageAuthorizersCacheInputBody: Swift.Equatable {
}

extension FlushStageAuthorizersCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension FlushStageAuthorizersCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct FlushStageAuthorizersCacheOutput: Swift.Equatable {

    public init() { }
}

enum FlushStageAuthorizersCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FlushStageCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/data"
    }
}

/// Requests API Gateway to flush a stage's cache.
public struct FlushStageCacheInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the stage to flush its cache.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageCacheInputBody: Swift.Equatable {
}

extension FlushStageCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension FlushStageCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct FlushStageCacheOutput: Swift.Equatable {

    public init() { }
}

enum FlushStageCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes.GatewayResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultResponse != false {
            try encodeContainer.encode(defaultResponse, forKey: .defaultResponse)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToString0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapOfStringToString0) in responseTemplates {
                try responseTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseType = self.responseType {
            try encodeContainer.encode(responseType.rawValue, forKey: .responseType)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultResponse) ?? false
        defaultResponse = defaultResponseDecoded
    }
}

extension APIGatewayClientTypes {
    /// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
    public struct GatewayResponse: Swift.Equatable {
        /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
        public var defaultResponse: Swift.Bool
        /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
        public var responseParameters: [Swift.String:Swift.String]?
        /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// The response type of the associated GatewayResponse.
        public var responseType: APIGatewayClientTypes.GatewayResponseType?
        /// The HTTP status code for this GatewayResponse.
        public var statusCode: Swift.String?

        public init(
            defaultResponse: Swift.Bool = false,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.defaultResponse = defaultResponse
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.responseType = responseType
            self.statusCode = statusCode
        }
    }

}

extension APIGatewayClientTypes {
    public enum GatewayResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case apiConfigurationError
        case authorizerConfigurationError
        case authorizerFailure
        case badRequestBody
        case badRequestParameters
        case default4xx
        case default5xx
        case expiredToken
        case integrationFailure
        case integrationTimeout
        case invalidApiKey
        case invalidSignature
        case missingAuthenticationToken
        case quotaExceeded
        case requestTooLarge
        case resourceNotFound
        case throttled
        case unauthorized
        case unsupportedMediaType
        case wafFiltered
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayResponseType] {
            return [
                .accessDenied,
                .apiConfigurationError,
                .authorizerConfigurationError,
                .authorizerFailure,
                .badRequestBody,
                .badRequestParameters,
                .default4xx,
                .default5xx,
                .expiredToken,
                .integrationFailure,
                .integrationTimeout,
                .invalidApiKey,
                .invalidSignature,
                .missingAuthenticationToken,
                .quotaExceeded,
                .requestTooLarge,
                .resourceNotFound,
                .throttled,
                .unauthorized,
                .unsupportedMediaType,
                .wafFiltered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .apiConfigurationError: return "API_CONFIGURATION_ERROR"
            case .authorizerConfigurationError: return "AUTHORIZER_CONFIGURATION_ERROR"
            case .authorizerFailure: return "AUTHORIZER_FAILURE"
            case .badRequestBody: return "BAD_REQUEST_BODY"
            case .badRequestParameters: return "BAD_REQUEST_PARAMETERS"
            case .default4xx: return "DEFAULT_4XX"
            case .default5xx: return "DEFAULT_5XX"
            case .expiredToken: return "EXPIRED_TOKEN"
            case .integrationFailure: return "INTEGRATION_FAILURE"
            case .integrationTimeout: return "INTEGRATION_TIMEOUT"
            case .invalidApiKey: return "INVALID_API_KEY"
            case .invalidSignature: return "INVALID_SIGNATURE"
            case .missingAuthenticationToken: return "MISSING_AUTHENTICATION_TOKEN"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case .requestTooLarge: return "REQUEST_TOO_LARGE"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .throttled: return "THROTTLED"
            case .unauthorized: return "UNAUTHORIZED"
            case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
            case .wafFiltered: return "WAF_FILTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayResponseType(rawValue: rawValue) ?? GatewayResponseType.sdkUnknown(rawValue)
        }
    }
}

extension GenerateClientCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GenerateClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/clientcertificates"
    }
}

/// A request to generate a ClientCertificate resource.
public struct GenerateClientCertificateInput: Swift.Equatable {
    /// The description of the ClientCertificate.
    public var description: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct GenerateClientCertificateInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GenerateClientCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GenerateClientCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateClientCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct GenerateClientCertificateOutput: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GenerateClientCertificateOutputBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GenerateClientCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GenerateClientCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account"
    }
}

/// Requests API Gateway to get information about the current Account resource.
public struct GetAccountInput: Swift.Equatable {

    public init() { }
}

struct GetAccountInputBody: Swift.Equatable {
}

extension GetAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// Represents an AWS account that is associated with API Gateway.
public struct GetAccountOutput: Swift.Equatable {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current Account.
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current Account.
    public var throttleSettings: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct GetAccountOutputBody: Swift.Equatable {
    let cloudwatchRoleArn: Swift.String?
    let throttleSettings: APIGatewayClientTypes.ThrottleSettings?
    let features: [Swift.String]?
    let apiKeyVersion: Swift.String?
}

extension GetAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .features)
        var featuresDecoded0:[Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

enum GetAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiKeyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeValue = includeValue {
                let includeValueQueryItem = ClientRuntime.URLQueryItem(name: "includeValue".urlPercentEncoding(), value: Swift.String(includeValue).urlPercentEncoding())
                items.append(includeValueQueryItem)
            }
            return items
        }
    }
}

extension GetApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to get information about the current ApiKey resource.
public struct GetApiKeyInput: Swift.Equatable {
    /// The identifier of the ApiKey resource.
    /// This member is required.
    public var apiKey: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains the key value.
    public var includeValue: Swift.Bool?

    public init(
        apiKey: Swift.String? = nil,
        includeValue: Swift.Bool? = nil
    )
    {
        self.apiKey = apiKey
        self.includeValue = includeValue
    }
}

struct GetApiKeyInputBody: Swift.Equatable {
}

extension GetApiKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct GetApiKeyOutput: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct GetApiKeyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeValues = includeValues {
                let includeValuesQueryItem = ClientRuntime.URLQueryItem(name: "includeValues".urlPercentEncoding(), value: Swift.String(includeValues).urlPercentEncoding())
                items.append(includeValuesQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let customerId = customerId {
                let customerIdQueryItem = ClientRuntime.URLQueryItem(name: "customerId".urlPercentEncoding(), value: Swift.String(customerId).urlPercentEncoding())
                items.append(customerIdQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            if let nameQuery = nameQuery {
                let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
                items.append(nameQueryQueryItem)
            }
            return items
        }
    }
}

extension GetApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// A request to get information about the current ApiKeys resource.
public struct GetApiKeysInput: Swift.Equatable {
    /// The identifier of a customer in Amazon Web Services Marketplace or an external system, such as a developer portal.
    public var customerId: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains key values.
    public var includeValues: Swift.Bool?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The name of queried API keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        customerId: Swift.String? = nil,
        includeValues: Swift.Bool? = nil,
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.includeValues = includeValues
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
    }
}

struct GetApiKeysInputBody: Swift.Equatable {
}

extension GetApiKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.warnings = output.warnings
        } else {
            self.items = nil
            self.warnings = nil
        }
        self.position = nil
    }
}

/// Represents a collection of API keys as represented by an ApiKeys resource.
public struct GetApiKeysOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.ApiKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// A list of warning messages logged during the import of API keys when the failOnWarnings option is set to true.
    public var warnings: [Swift.String]?

    public init(
        items: [APIGatewayClientTypes.ApiKey]? = nil,
        position: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.items = items
        self.position = position
        self.warnings = warnings
    }
}

struct GetApiKeysOutputBody: Swift.Equatable {
    let warnings: [Swift.String]?
    let items: [APIGatewayClientTypes.ApiKey]?
}

extension GetApiKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiKey?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.ApiKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.ApiKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetApiKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to describe an existing Authorizer resource.
public struct GetAuthorizerInput: Swift.Equatable {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct GetAuthorizerInputBody: Swift.Equatable {
}

extension GetAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct GetAuthorizerOutput: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct GetAuthorizerOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: APIGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension GetAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

enum GetAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAuthorizersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetAuthorizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

/// Request to describe an existing Authorizers resource.
public struct GetAuthorizersInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetAuthorizersInputBody: Swift.Equatable {
}

extension GetAuthorizersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of Authorizer resources.
public struct GetAuthorizersOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Authorizer]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Authorizer]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetAuthorizersOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.Authorizer]?
}

extension GetAuthorizersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.Authorizer?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetAuthorizersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// Request to describe a BasePathMapping resource.
public struct GetBasePathMappingInput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify any base path name after the domain name.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to be described.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct GetBasePathMappingInputBody: Swift.Equatable {
}

extension GetBasePathMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBasePathMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBasePathMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct GetBasePathMappingOutput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct GetBasePathMappingOutputBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension GetBasePathMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum GetBasePathMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBasePathMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetBasePathMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

/// A request to get information about a collection of BasePathMapping resources.
public struct GetBasePathMappingsInput: Swift.Equatable {
    /// The domain name of a BasePathMapping resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.limit = limit
        self.position = position
    }
}

struct GetBasePathMappingsInputBody: Swift.Equatable {
}

extension GetBasePathMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBasePathMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBasePathMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of BasePathMapping resources.
public struct GetBasePathMappingsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.BasePathMapping]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.BasePathMapping]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetBasePathMappingsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.BasePathMapping]?
}

extension GetBasePathMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.BasePathMapping?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.BasePathMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.BasePathMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetBasePathMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to get information about the current ClientCertificate resource.
public struct GetClientCertificateInput: Swift.Equatable {
    /// The identifier of the ClientCertificate resource to be described.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init(
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct GetClientCertificateInputBody: Swift.Equatable {
}

extension GetClientCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetClientCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClientCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct GetClientCertificateOutput: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GetClientCertificateOutputBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetClientCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetClientCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClientCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetClientCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/clientcertificates"
    }
}

/// A request to get information about a collection of ClientCertificate resources.
public struct GetClientCertificatesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetClientCertificatesInputBody: Swift.Equatable {
}

extension GetClientCertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetClientCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClientCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of ClientCertificate resources.
public struct GetClientCertificatesOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.ClientCertificate]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.ClientCertificate]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetClientCertificatesOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.ClientCertificate]?
}

extension GetClientCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ClientCertificate?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.ClientCertificate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.ClientCertificate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetClientCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let embed = embed {
                embed.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to get information about a Deployment resource.
public struct GetDeploymentInput: Swift.Equatable {
    /// The identifier of the Deployment resource to get information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// A query parameter to retrieve the specified embedded resources of the returned Deployment resource in the response. In a REST API call, this embed parameter value is a list of comma-separated strings, as in GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2. The SDK and other platform-dependent libraries might use a different format for the list. Currently, this request supports only retrieval of the embedded API summary this way. Hence, the parameter value must be a single-valued list containing only the "apisummary" string. For example, GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary.
    public var embed: [Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        embed: [Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.embed = embed
        self.restApiId = restApiId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct GetDeploymentOutput: Swift.Equatable {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: APIGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: APIGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

/// Requests API Gateway to get information about a Deployments collection.
public struct GetDeploymentsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDeploymentsInputBody: Swift.Equatable {
}

extension GetDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on how to interact with your collection. The collection offers a paginated view of the contained deployments.
public struct GetDeploymentsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Deployment]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Deployment]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDeploymentsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.Deployment]?
}

extension GetDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.Deployment?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Gets a specified documentation part of a given API.
public struct GetDocumentationPartInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct GetDocumentationPartInputBody: Swift.Equatable {
}

extension GetDocumentationPartInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentationPartOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity.
public struct GetDocumentationPartOutput: Swift.Equatable {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct GetDocumentationPartOutputBody: Swift.Equatable {
    let id: Swift.String?
    let location: APIGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension GetDocumentationPartOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

enum GetDocumentationPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentationPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let locationStatus = locationStatus {
                let locationStatusQueryItem = ClientRuntime.URLQueryItem(name: "locationStatus".urlPercentEncoding(), value: Swift.String(locationStatus.rawValue).urlPercentEncoding())
                items.append(locationStatusQueryItem)
            }
            if let path = path {
                let pathQueryItem = ClientRuntime.URLQueryItem(name: "path".urlPercentEncoding(), value: Swift.String(path).urlPercentEncoding())
                items.append(pathQueryItem)
            }
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let nameQuery = nameQuery {
                let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
                items.append(nameQueryQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension GetDocumentationPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Gets the documentation parts of an API. The result may be filtered by the type, name, or path of API entities (targets).
public struct GetDocumentationPartsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The status of the API documentation parts to retrieve. Valid values are DOCUMENTED for retrieving DocumentationPart resources with content and UNDOCUMENTED for DocumentationPart resources without content.
    public var locationStatus: APIGatewayClientTypes.LocationStatusType?
    /// The name of API entities of the to-be-retrieved documentation parts.
    public var nameQuery: Swift.String?
    /// The path of API entities of the to-be-retrieved documentation parts.
    public var path: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The type of API entities of the to-be-retrieved documentation parts.
    public var type: APIGatewayClientTypes.DocumentationPartType?

    public init(
        limit: Swift.Int? = nil,
        locationStatus: APIGatewayClientTypes.LocationStatusType? = nil,
        nameQuery: Swift.String? = nil,
        path: Swift.String? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        type: APIGatewayClientTypes.DocumentationPartType? = nil
    )
    {
        self.limit = limit
        self.locationStatus = locationStatus
        self.nameQuery = nameQuery
        self.path = path
        self.position = position
        self.restApiId = restApiId
        self.type = type
    }
}

struct GetDocumentationPartsInputBody: Swift.Equatable {
}

extension GetDocumentationPartsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationPartsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentationPartsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of documentation parts of an API.
public struct GetDocumentationPartsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DocumentationPart]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DocumentationPart]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationPartsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.DocumentationPart]?
}

extension GetDocumentationPartsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.DocumentationPart?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.DocumentationPart]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.DocumentationPart]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetDocumentationPartsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Gets a documentation snapshot of an API.
public struct GetDocumentationVersionInput: Swift.Equatable {
    /// The version identifier of the to-be-retrieved documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionInputBody: Swift.Equatable {
}

extension GetDocumentationVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API.
public struct GetDocumentationVersionOutput: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct GetDocumentationVersionOutputBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension GetDocumentationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetDocumentationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDocumentationVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetDocumentationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

/// Gets the documentation versions of an API.
public struct GetDocumentationVersionsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionsInputBody: Swift.Equatable {
}

extension GetDocumentationVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDocumentationVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of documentation snapshots of an API.
public struct GetDocumentationVersionsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DocumentationVersion]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DocumentationVersion]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationVersionsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.DocumentationVersion]?
}

extension GetDocumentationVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.DocumentationVersion?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.DocumentationVersion]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.DocumentationVersion]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetDocumentationVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// Request to get the name of a DomainName resource.
public struct GetDomainNameInput: Swift.Equatable {
    /// The name of the DomainName resource.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct GetDomainNameOutput: Swift.Equatable {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct GetDomainNameOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension GetDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

enum GetDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

/// Request to describe a collection of DomainName resources.
public struct GetDomainNamesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetDomainNamesInputBody: Swift.Equatable {
}

extension GetDomainNamesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainNamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of DomainName resources.
public struct GetDomainNamesOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.DomainName]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.DomainName]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDomainNamesOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.DomainName]?
}

extension GetDomainNamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.DomainName?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetDomainNamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExportInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accepts = accepts {
            items.add(Header(name: "Accept", value: Swift.String(accepts)))
        }
        return items
    }
}

extension GetExportInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let parameters = parameters {
                let currentQueryItemNames = items.map({$0.name})
                parameters.forEach { key0, value0 in
                    if !currentQueryItemNames.contains(key0) {
                        let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
            return items
        }
    }
}

extension GetExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let exportType = exportType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/exports/\(exportType.urlPercentEncoding())"
    }
}

/// Request a new export of a RestApi for a particular Stage.
public struct GetExportInput: Swift.Equatable {
    /// The content-type of the export, for example application/json. Currently application/json and application/yaml are supported for exportType ofoas30 and swagger. This should be specified in the Accept header for direct API requests.
    public var accepts: Swift.String?
    /// The type of export. Acceptable values are 'oas30' for OpenAPI 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.
    /// This member is required.
    public var exportType: Swift.String?
    /// A key-value map of query string parameters that specify properties of the export, depending on the requested exportType. For exportTypeoas30 and swagger, any combination of the following parameters are supported: extensions='integrations' or extensions='apigateway' will export the API with x-amazon-apigateway-integration extensions. extensions='authorizers' will export the API with x-amazon-apigateway-authorizer extensions. postman will export the API with Postman extensions, allowing for import to the Postman tool
    public var parameters: [Swift.String:Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage that will be exported.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        accepts: Swift.String? = nil,
        exportType: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.accepts = accepts
        self.exportType = exportType
        self.parameters = parameters
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetExportInputBody: Swift.Equatable {
}

extension GetExportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.body = data
        case .stream(let stream):
            self.body = try stream.readToEnd()
        case .none:
            self.body = nil
        }
    }
}

/// The binary blob response to GetExport, which contains the generated SDK.
public struct GetExportOutput: Swift.Equatable {
    /// The binary blob response to GetExport, which contains the export.
    public var body: ClientRuntime.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response. This will correspond to a valid 'accept' type in the request.
    public var contentType: Swift.String?

    public init(
        body: ClientRuntime.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetExportOutputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

enum GetExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Gets a GatewayResponse of a specified response type on the given RestApi.
public struct GetGatewayResponseInput: Swift.Equatable {
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct GetGatewayResponseInputBody: Swift.Equatable {
}

extension GetGatewayResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGatewayResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGatewayResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct GetGatewayResponseOutput: Swift.Equatable {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct GetGatewayResponseOutputBody: Swift.Equatable {
    let responseType: APIGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension GetGatewayResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultResponse) ?? false
        defaultResponse = defaultResponseDecoded
    }
}

enum GetGatewayResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGatewayResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetGatewayResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses"
    }
}

/// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
public struct GetGatewayResponsesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500. The GatewayResponses collection does not support pagination and the limit does not apply here.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set. The GatewayResponse collection does not support pagination and the position does not apply here.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetGatewayResponsesInputBody: Swift.Equatable {
}

extension GetGatewayResponsesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGatewayResponsesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGatewayResponsesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of the GatewayResponse instances of a RestApi as a responseType-to-GatewayResponse object map of key-value pairs. As such, pagination is not supported for querying this collection.
public struct GetGatewayResponsesOutput: Swift.Equatable {
    /// Returns the entire collection, because of no pagination support.
    public var items: [APIGatewayClientTypes.GatewayResponse]?
    /// The current pagination position in the paged result set. The GatewayResponse collection does not support pagination and the position does not apply here.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.GatewayResponse]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetGatewayResponsesOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.GatewayResponse]?
}

extension GetGatewayResponsesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.GatewayResponse?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.GatewayResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.GatewayResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetGatewayResponsesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents a request to get the integration configuration.
public struct GetIntegrationInput: Swift.Equatable {
    /// Specifies a get integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a get integration request's resource identifier
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetIntegrationInputBody: Swift.Equatable {
}

extension GetIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct GetIntegrationOutput: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct GetIntegrationOutputBody: Swift.Equatable {
    let type: APIGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: APIGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: APIGatewayClientTypes.TlsConfig?
}

extension GetIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis) ?? 0
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum GetIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a get integration response request.
public struct GetIntegrationResponseInput: Swift.Equatable {
    /// Specifies a get integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a get integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies a get integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseInputBody: Swift.Equatable {
}

extension GetIntegrationResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct GetIntegrationResponseOutput: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
}

extension GetIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

enum GetIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to describe an existing Method resource.
public struct GetMethodInput: Swift.Equatable {
    /// Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetMethodInputBody: Swift.Equatable {
}

extension GetMethodInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMethodOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct GetMethodOutput: Swift.Equatable {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct GetMethodOutputBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    let methodIntegration: APIGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension GetMethodOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

enum GetMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Request to describe a MethodResponse resource.
public struct GetMethodResponseInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetMethodResponseInputBody: Swift.Equatable {
}

extension GetMethodResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMethodResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMethodResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct GetMethodResponseOutput: Swift.Equatable {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct GetMethodResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension GetMethodResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

enum GetMethodResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let flatten = flatten {
                let flattenQueryItem = ClientRuntime.URLQueryItem(name: "flatten".urlPercentEncoding(), value: Swift.String(flatten).urlPercentEncoding())
                items.append(flattenQueryItem)
            }
            return items
        }
    }
}

extension GetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to list information about a model in an existing RestApi resource.
public struct GetModelInput: Swift.Equatable {
    /// A query parameter of a Boolean value to resolve (true) all external model references and returns a flattened model schema or not (false) The default is false.
    public var flatten: Swift.Bool?
    /// The name of the model as an identifier.
    /// This member is required.
    public var modelName: Swift.String?
    /// The RestApi identifier under which the Model exists.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        flatten: Swift.Bool? = nil,
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.flatten = flatten
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelInputBody: Swift.Equatable {
}

extension GetModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload.
public struct GetModelOutput: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension GetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

enum GetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())/default_template"
    }
}

/// Request to generate a sample mapping template used to transform the payload.
public struct GetModelTemplateInput: Swift.Equatable {
    /// The name of the model for which to generate a template.
    /// This member is required.
    public var modelName: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelTemplateInputBody: Swift.Equatable {
}

extension GetModelTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

/// Represents a mapping template used to transform a payload.
public struct GetModelTemplateOutput: Swift.Equatable {
    /// The Apache Velocity Template Language (VTL) template content used for the template resource.
    public var value: Swift.String?

    public init(
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputBody: Swift.Equatable {
    let value: Swift.String?
}

extension GetModelTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

enum GetModelTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

/// Request to list existing Models defined for a RestApi resource.
public struct GetModelsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetModelsInputBody: Swift.Equatable {
}

extension GetModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of Model resources.
public struct GetModelsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Model]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Model]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetModelsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.Model]?
}

extension GetModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.Model?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Gets a RequestValidator of a given RestApi.
public struct GetRequestValidatorInput: Swift.Equatable {
    /// The identifier of the RequestValidator to be retrieved.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorInputBody: Swift.Equatable {
}

extension GetRequestValidatorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRequestValidatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRequestValidatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming Method requests.
public struct GetRequestValidatorOutput: Swift.Equatable {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct GetRequestValidatorOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension GetRequestValidatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestBody) ?? false
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestParameters) ?? false
        validateRequestParameters = validateRequestParametersDecoded
    }
}

enum GetRequestValidatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRequestValidatorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetRequestValidatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

/// Gets the RequestValidators collection of a given RestApi.
public struct GetRequestValidatorsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorsInputBody: Swift.Equatable {
}

extension GetRequestValidatorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRequestValidatorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRequestValidatorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// A collection of RequestValidator resources of a given RestApi.
public struct GetRequestValidatorsOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.RequestValidator]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.RequestValidator]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRequestValidatorsOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.RequestValidator]?
}

extension GetRequestValidatorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.RequestValidator?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.RequestValidator]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.RequestValidator]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetRequestValidatorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let embed = embed {
                embed.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to list information about a resource.
public struct GetResourceInput: Swift.Equatable {
    /// A query parameter to retrieve the specified resources embedded in the returned Resource representation in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods.
    public var embed: [Swift.String]?
    /// The identifier for the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        embed: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetResourceInputBody: Swift.Equatable {
}

extension GetResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource.
public struct GetResourceOutput: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct GetResourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?
}

extension GetResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:APIGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:APIGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

enum GetResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            if let embed = embed {
                embed.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources"
    }
}

/// Request to list information about a collection of resources.
public struct GetResourcesInput: Swift.Equatable {
    /// A query parameter used to retrieve the specified resources embedded in the returned Resources resource in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded Method resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources?embed=methods.
    public var embed: [Swift.String]?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        embed: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetResourcesInputBody: Swift.Equatable {
}

extension GetResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of Resource resources.
public struct GetResourcesOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.Resource]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.Resource]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetResourcesOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.Resource]?
}

extension GetResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.Resource?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.Resource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.Resource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// The GET request to list an existing RestApi defined for your collection.
public struct GetRestApiInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct GetRestApiInputBody: Swift.Equatable {
}

extension GetRestApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRestApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.rootResourceId = output.rootResourceId
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.rootResourceId = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API.
public struct GetRestApiOutput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetRestApiOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
    let rootResourceId: Swift.String?
}

extension GetRestApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

enum GetRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRestApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetRestApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// The GET request to list existing RestApis defined for your collection.
public struct GetRestApisInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetRestApisInputBody: Swift.Equatable {
}

extension GetRestApisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRestApisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRestApisOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Contains references to your APIs and links that guide you in how to interact with your collection. A collection offers a paginated view of your APIs.
public struct GetRestApisOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.RestApi]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.RestApi]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRestApisOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.RestApi]?
}

extension GetRestApisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.RestApi?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.RestApi]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.RestApi]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetRestApisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSdkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let parameters = parameters {
                let currentQueryItemNames = items.map({$0.name})
                parameters.forEach { key0, value0 in
                    if !currentQueryItemNames.contains(key0) {
                        let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
            return items
        }
    }
}

extension GetSdkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let sdkType = sdkType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/sdks/\(sdkType.urlPercentEncoding())"
    }
}

/// Request a new generated client SDK for a RestApi and Stage.
public struct GetSdkInput: Swift.Equatable {
    /// A string-to-string key-value map of query parameters sdkType-dependent properties of the SDK. For sdkType of objectivec or swift, a parameter named classPrefix is required. For sdkType of android, parameters named groupId, artifactId, artifactVersion, and invokerPackage are required. For sdkType of java, parameters named serviceName and javaPackageName are required.
    public var parameters: [Swift.String:Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The language for the generated SDK. Currently java, javascript, android, objectivec (for iOS), swift (for iOS), and ruby are supported.
    /// This member is required.
    public var sdkType: Swift.String?
    /// The name of the Stage that the SDK will use.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        sdkType: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.parameters = parameters
        self.restApiId = restApiId
        self.sdkType = sdkType
        self.stageName = stageName
    }
}

struct GetSdkInputBody: Swift.Equatable {
}

extension GetSdkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.body = data
        case .stream(let stream):
            self.body = try stream.readToEnd()
        case .none:
            self.body = nil
        }
    }
}

/// The binary blob response to GetSdk, which contains the generated SDK.
public struct GetSdkOutput: Swift.Equatable {
    /// The binary blob response to GetSdk, which contains the generated SDK.
    public var body: ClientRuntime.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response.
    public var contentType: Swift.String?

    public init(
        body: ClientRuntime.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetSdkOutputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetSdkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

enum GetSdkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSdkTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sdktypes/\(id.urlPercentEncoding())"
    }
}

/// Get an SdkType instance.
public struct GetSdkTypeInput: Swift.Equatable {
    /// The identifier of the queried SdkType instance.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSdkTypeInputBody: Swift.Equatable {
}

extension GetSdkTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSdkTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationProperties = output.configurationProperties
            self.description = output.description
            self.friendlyName = output.friendlyName
            self.id = output.id
        } else {
            self.configurationProperties = nil
            self.description = nil
            self.friendlyName = nil
            self.id = nil
        }
    }
}

/// A type of SDK that API Gateway can generate.
public struct GetSdkTypeOutput: Swift.Equatable {
    /// A list of configuration properties of an SdkType.
    public var configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]?
    /// The description of an SdkType.
    public var description: Swift.String?
    /// The user-friendly name of an SdkType instance.
    public var friendlyName: Swift.String?
    /// The identifier of an SdkType instance.
    public var id: Swift.String?

    public init(
        configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]? = nil,
        description: Swift.String? = nil,
        friendlyName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.configurationProperties = configurationProperties
        self.description = description
        self.friendlyName = friendlyName
        self.id = id
    }
}

struct GetSdkTypeOutputBody: Swift.Equatable {
    let id: Swift.String?
    let friendlyName: Swift.String?
    let description: Swift.String?
    let configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]?
}

extension GetSdkTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[APIGatewayClientTypes.SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [APIGatewayClientTypes.SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

enum GetSdkTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSdkTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetSdkTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdktypes"
    }
}

/// Get the SdkTypes collection.
public struct GetSdkTypesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetSdkTypesInputBody: Swift.Equatable {
}

extension GetSdkTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSdkTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
    }
}

/// The collection of SdkType instances.
public struct GetSdkTypesOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.SdkType]?

    public init(
        items: [APIGatewayClientTypes.SdkType]? = nil
    )
    {
        self.items = items
    }
}

struct GetSdkTypesOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.SdkType]?
}

extension GetSdkTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.SdkType?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.SdkType]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.SdkType]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetSdkTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to get information about a Stage resource.
public struct GetStageInput: Swift.Equatable {
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to get information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct GetStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct GetStageOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    let canarySettings: APIGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled) ?? false
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:APIGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled) ?? false
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum GetStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deploymentId = deploymentId {
                let deploymentIdQueryItem = ClientRuntime.URLQueryItem(name: "deploymentId".urlPercentEncoding(), value: Swift.String(deploymentId).urlPercentEncoding())
                items.append(deploymentIdQueryItem)
            }
            return items
        }
    }
}

extension GetStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

/// Requests API Gateway to get information about one or more Stage resources.
public struct GetStagesInput: Swift.Equatable {
    /// The stages' deployment identifiers.
    public var deploymentId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct GetStagesInputBody: Swift.Equatable {
}

extension GetStagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.item = output.item
        } else {
            self.item = nil
        }
    }
}

/// A list of Stage resources that are associated with the ApiKey resource.
public struct GetStagesOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var item: [APIGatewayClientTypes.Stage]?

    public init(
        item: [APIGatewayClientTypes.Stage]? = nil
    )
    {
        self.item = item
    }
}

struct GetStagesOutputBody: Swift.Equatable {
    let item: [APIGatewayClientTypes.Stage]?
}

extension GetStagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case item
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.Stage?].self, forKey: .item)
        var itemDecoded0:[APIGatewayClientTypes.Stage]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [APIGatewayClientTypes.Stage]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
    }
}

enum GetStagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Gets the Tags collection for a given resource.
public struct GetTagsInput: Swift.Equatable {
    /// (Not currently supported) The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// (Not currently supported) The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Swift.Equatable {
}

extension GetTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// The collection of tags. Each tag element is associated with a given resource.
public struct GetTagsOutput: Swift.Equatable {
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension GetTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let endDate = endDate else {
                let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(endDate).urlPercentEncoding())
            items.append(endDateQueryItem)
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let keyId = keyId {
                let keyIdQueryItem = ClientRuntime.URLQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
                items.append(keyIdQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            guard let startDate = startDate else {
                let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(startDate).urlPercentEncoding())
            items.append(startDateQueryItem)
            return items
        }
    }
}

extension GetUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/usage"
    }
}

/// The GET request to get the usage data of a usage plan in a specified time interval.
public struct GetUsageInput: Swift.Equatable {
    /// The ending date (e.g., 2016-12-31) of the usage data.
    /// This member is required.
    public var endDate: Swift.String?
    /// The Id of the API key associated with the resultant usage data.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date (e.g., 2016-01-01) of the usage data.
    /// This member is required.
    public var startDate: Swift.String?
    /// The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.keyId = keyId
        self.limit = limit
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageInputBody: Swift.Equatable {
}

extension GetUsageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// Represents the usage data of a usage plan.
public struct GetUsageOutput: Swift.Equatable {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String:[[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        items: [Swift.String:[[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageOutputBody: Swift.Equatable {
    let usagePlanId: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let items: [Swift.String:[[Swift.Int]]]?
}

extension GetUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String: [[Swift.Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [Swift.String:[[Swift.Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String:[[Swift.Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Swift.Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Swift.Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Swift.Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

enum GetUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The GET request to get a usage plan of a given plan identifier.
public struct GetUsagePlanInput: Swift.Equatable {
    /// The identifier of the UsagePlan resource to be retrieved.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanInputBody: Swift.Equatable {
}

extension GetUsagePlanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

/// The GET request to get a usage plan key of a given key identifier.
public struct GetUsagePlanKeyInput: Swift.Equatable {
    /// The key Id of the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeyInputBody: Swift.Equatable {
}

extension GetUsagePlanKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsagePlanKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// Represents a usage plan key to identify a plan customer.
public struct GetUsagePlanKeyOutput: Swift.Equatable {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct GetUsagePlanKeyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let type: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
}

extension GetUsagePlanKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum GetUsagePlanKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsagePlanKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            if let nameQuery = nameQuery {
                let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
                items.append(nameQueryQueryItem)
            }
            return items
        }
    }
}

extension GetUsagePlanKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

/// The GET request to get all the usage plan keys representing the API keys added to a specified usage plan.
public struct GetUsagePlanKeysInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// A query parameter specifying the name of the to-be-returned usage plan keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The Id of the UsagePlan resource representing the usage plan containing the to-be-retrieved UsagePlanKey resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeysInputBody: Swift.Equatable {
}

extension GetUsagePlanKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsagePlanKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents the collection of usage plan keys added to usage plans for the associated API keys and, possibly, other types of keys.
public struct GetUsagePlanKeysOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.UsagePlanKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.UsagePlanKey]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlanKeysOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.UsagePlanKey]?
}

extension GetUsagePlanKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.UsagePlanKey?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.UsagePlanKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.UsagePlanKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetUsagePlanKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsagePlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsagePlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Dont rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct GetUsagePlanOutput: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct GetUsagePlanOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [APIGatewayClientTypes.ApiStage]?
    let throttle: APIGatewayClientTypes.ThrottleSettings?
    let quota: APIGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetUsagePlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[APIGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [APIGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetUsagePlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsagePlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let keyId = keyId {
                let keyIdQueryItem = ClientRuntime.URLQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
                items.append(keyIdQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetUsagePlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usageplans"
    }
}

/// The GET request to get all the usage plans of the caller's account.
public struct GetUsagePlansInput: Swift.Equatable {
    /// The identifier of the API key associated with the usage plans.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.position = position
    }
}

struct GetUsagePlansInputBody: Swift.Equatable {
}

extension GetUsagePlansInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsagePlansOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of usage plans for an AWS account.
public struct GetUsagePlansOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.UsagePlan]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.UsagePlan]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlansOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.UsagePlan]?
}

extension GetUsagePlansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.UsagePlan?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.UsagePlan]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.UsagePlan]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetUsagePlansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Gets a specified VPC link under the caller's account in a region.
public struct GetVpcLinkInput: Swift.Equatable {
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Swift.Equatable {
}

extension GetVpcLinkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct GetVpcLinkOutput: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct GetVpcLinkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: APIGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVpcLinksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let limit = limit {
                let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
                items.append(limitQueryItem)
            }
            if let position = position {
                let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
                items.append(positionQueryItem)
            }
            return items
        }
    }
}

extension GetVpcLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vpclinks"
    }
}

/// Gets the VpcLinks collection under the caller's account in a selected region.
public struct GetVpcLinksInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetVpcLinksInputBody: Swift.Equatable {
}

extension GetVpcLinksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVpcLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of VPC links under the caller's account in a region.
public struct GetVpcLinksOutput: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [APIGatewayClientTypes.VpcLink]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init(
        items: [APIGatewayClientTypes.VpcLink]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetVpcLinksOutputBody: Swift.Equatable {
    let items: [APIGatewayClientTypes.VpcLink]?
}

extension GetVpcLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.VpcLink?].self, forKey: .items)
        var itemsDecoded0:[APIGatewayClientTypes.VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [APIGatewayClientTypes.VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum GetVpcLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct ImportApiKeysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportApiKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportApiKeysInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportApiKeysOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodyData = body
            let bodyBody = ClientRuntime.HttpBody.data(bodyData)
            input.builder.withBody(bodyBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportApiKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportApiKeysOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportApiKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "mode", value: "import"))
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            return items
        }
    }
}

extension ImportApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// The POST request to import API keys from an external source, such as a CSV-formatted file.
public struct ImportApiKeysInput: Swift.Equatable {
    /// The payload of the POST request to import API keys. For the payload format, see API Key File Format.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback ApiKey importation (true) or not (false) when error is encountered.
    public var failOnWarnings: Swift.Bool?
    /// A query parameter to specify the input format to imported API keys. Currently, only the csv format is supported.
    /// This member is required.
    public var format: APIGatewayClientTypes.ApiKeysFormat?

    public init(
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool? = nil,
        format: APIGatewayClientTypes.ApiKeysFormat? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.format = format
    }
}

struct ImportApiKeysInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportApiKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportApiKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// The identifier of an ApiKey used in a UsagePlan.
public struct ImportApiKeysOutput: Swift.Equatable {
    /// A list of all the ApiKey identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages.
    public var warnings: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportApiKeysOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let warnings: [Swift.String]?
}

extension ImportApiKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum ImportApiKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct ImportDocumentationPartsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportDocumentationPartsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportDocumentationPartsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportDocumentationPartsOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodyData = body
            let bodyBody = ClientRuntime.HttpBody.data(bodyData)
            input.builder.withBody(bodyBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportDocumentationPartsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportDocumentationPartsOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportDocumentationPartsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportDocumentationPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let mode = mode {
                let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
                items.append(modeQueryItem)
            }
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            return items
        }
    }
}

extension ImportDocumentationPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Import documentation parts from an external (e.g., OpenAPI) definition file.
public struct ImportDocumentationPartsInput: Swift.Equatable {
    /// Raw byte array representing the to-be-imported documentation parts. To import from an OpenAPI file, this is a JSON object.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to specify whether to rollback the documentation importation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// A query parameter to indicate whether to overwrite (overwrite) any existing DocumentationParts definition or to merge (merge) the new definition into the existing one. The default value is merge.
    public var mode: APIGatewayClientTypes.PutMode?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool? = nil,
        mode: APIGatewayClientTypes.PutMode? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.restApiId = restApiId
    }
}

struct ImportDocumentationPartsInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportDocumentationPartsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportDocumentationPartsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportDocumentationPartsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// A collection of the imported DocumentationPart identifiers.
public struct ImportDocumentationPartsOutput: Swift.Equatable {
    /// A list of the returned documentation part identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages reported during import of documentation parts.
    public var warnings: [Swift.String]?

    public init(
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportDocumentationPartsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let warnings: [Swift.String]?
}

extension ImportDocumentationPartsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum ImportDocumentationPartsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct ImportRestApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportRestApiInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportRestApiOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodyData = body
            let bodyBody = ClientRuntime.HttpBody.data(bodyData)
            input.builder.withBody(bodyBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportRestApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportRestApiOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportRestApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "mode", value: "import"))
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            if let parameters = parameters {
                let currentQueryItemNames = items.map({$0.name})
                parameters.forEach { key0, value0 in
                    if !currentQueryItemNames.contains(key0) {
                        let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
            return items
        }
    }
}

extension ImportRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// A POST request to import an API to API Gateway using an input of an API definition file.
public struct ImportRestApiInput: Swift.Equatable {
    /// The POST request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback the API creation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// A key-value map of context-specific query string parameters specifying the behavior of different API importing operations. The following shows operation-specific parameters and their supported values. To exclude DocumentationParts from the import, set parameters as ignore=documentation. To configure the endpoint type, set parameters as endpointConfigurationTypes=EDGE, endpointConfigurationTypes=REGIONAL, or endpointConfigurationTypes=PRIVATE. The default endpoint type is EDGE. To handle imported basepath, set parameters as basepath=ignore, basepath=prepend or basepath=split.
    public var parameters: [Swift.String:Swift.String]?

    public init(
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool? = nil,
        parameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.parameters = parameters
    }
}

struct ImportRestApiInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportRestApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.rootResourceId = output.rootResourceId
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.rootResourceId = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API.
public struct ImportRestApiOutput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportRestApiOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
    let rootResourceId: Swift.String?
}

extension ImportRestApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

enum ImportRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes.Integration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for string0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(string0)
            }
        }
        if let cacheNamespace = self.cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = self.contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = self.credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let integrationResponses = integrationResponses {
            var integrationResponsesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .integrationResponses)
            for (dictKey0, mapOfIntegrationResponse0) in integrationResponses {
                try integrationResponsesContainer.encode(mapOfIntegrationResponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let passthroughBehavior = self.passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapOfStringToString0) in requestParameters {
                try requestParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, mapOfStringToString0) in requestTemplates {
                try requestTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis) ?? 0
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
    public struct Integration: Swift.Equatable {
        /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
        public var cacheKeyParameters: [Swift.String]?
        /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
        public var cacheNamespace: Swift.String?
        /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
        public var connectionType: APIGatewayClientTypes.ConnectionType?
        /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
        public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
        public var credentials: Swift.String?
        /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
        public var httpMethod: Swift.String?
        /// Specifies the integration's responses.
        public var integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
        /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
        public var passthroughBehavior: Swift.String?
        /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
        public var requestParameters: [Swift.String:Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
        public var requestTemplates: [Swift.String:Swift.String]?
        /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
        public var timeoutInMillis: Swift.Int
        /// Specifies the TLS configuration for an integration.
        public var tlsConfig: APIGatewayClientTypes.TlsConfig?
        /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
        public var type: APIGatewayClientTypes.IntegrationType?
        /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
        public var uri: Swift.String?

        public init(
            cacheKeyParameters: [Swift.String]? = nil,
            cacheNamespace: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionType: APIGatewayClientTypes.ConnectionType? = nil,
            contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
            credentials: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil,
            passthroughBehavior: Swift.String? = nil,
            requestParameters: [Swift.String:Swift.String]? = nil,
            requestTemplates: [Swift.String:Swift.String]? = nil,
            timeoutInMillis: Swift.Int = 0,
            tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
            type: APIGatewayClientTypes.IntegrationType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.cacheKeyParameters = cacheKeyParameters
            self.cacheNamespace = cacheNamespace
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandling = contentHandling
            self.credentials = credentials
            self.httpMethod = httpMethod
            self.integrationResponses = integrationResponses
            self.passthroughBehavior = passthroughBehavior
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
            self.type = type
            self.uri = uri
        }
    }

}

extension APIGatewayClientTypes.IntegrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = self.contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToString0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapOfStringToString0) in responseTemplates {
                try responseTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = self.selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
    public struct IntegrationResponse: Swift.Equatable {
        /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
        public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
        /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String:Swift.String]?
        /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
        public var selectionPattern: Swift.String?
        /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
        public var statusCode: Swift.String?

        public init(
            contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            selectionPattern: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.contentHandling = contentHandling
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.selectionPattern = selectionPattern
            self.statusCode = statusCode
        }
    }

}

extension APIGatewayClientTypes {
    /// The integration type. The valid value is HTTP for integrating an API method with an HTTP backend; AWS with any Amazon Web Services service endpoints; MOCK for testing without actually invoking the backend; HTTP_PROXY for integrating with the HTTP proxy integration; AWS_PROXY for integrating with the Lambda proxy integration.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeded the rate limit. Retry after the specified time period.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes {
    public enum LocationStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documented
        case undocumented
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationStatusType] {
            return [
                .documented,
                .undocumented,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documented: return "DOCUMENTED"
            case .undocumented: return "UNDOCUMENTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationStatusType(rawValue: rawValue) ?? LocationStatusType.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.Method: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = self.apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for string0 in authorizationScopes {
                try authorizationScopesContainer.encode(string0)
            }
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let methodIntegration = self.methodIntegration {
            try encodeContainer.encode(methodIntegration, forKey: .methodIntegration)
        }
        if let methodResponses = methodResponses {
            var methodResponsesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .methodResponses)
            for (dictKey0, mapOfMethodResponse0) in methodResponses {
                try methodResponsesContainer.encode(mapOfMethodResponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, mapOfStringToString0) in requestModels {
                try requestModelsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapOfStringToBoolean0) in requestParameters {
                try requestParametersContainer.encode(mapOfStringToBoolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = self.requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension APIGatewayClientTypes {
    /// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
    public struct Method: Swift.Equatable {
        /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?
        /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
        public var authorizerId: Swift.String?
        /// The method's HTTP verb.
        public var httpMethod: Swift.String?
        /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
        public var methodIntegration: APIGatewayClientTypes.Integration?
        /// Gets a method response associated with a given HTTP status code.
        public var methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
        /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
        public var operationName: Swift.String?
        /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
        public var requestModels: [Swift.String:Swift.String]?
        /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
        public var requestParameters: [Swift.String:Swift.Bool]?
        /// The identifier of a RequestValidator for request validation.
        public var requestValidatorId: Swift.String?

        public init(
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            methodIntegration: APIGatewayClientTypes.Integration? = nil,
            methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String:Swift.String]? = nil,
            requestParameters: [Swift.String:Swift.Bool]? = nil,
            requestValidatorId: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.httpMethod = httpMethod
            self.methodIntegration = methodIntegration
            self.methodResponses = methodResponses
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.requestValidatorId = requestValidatorId
        }
    }

}

extension APIGatewayClientTypes.MethodResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, mapOfStringToString0) in responseModels {
                try responseModelsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToBoolean0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToBoolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
    public struct MethodResponse: Swift.Equatable {
        /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
        public var responseModels: [Swift.String:Swift.String]?
        /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
        public var responseParameters: [Swift.String:Swift.Bool]?
        /// The method response's status code.
        public var statusCode: Swift.String?

        public init(
            responseModels: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:Swift.Bool]? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.statusCode = statusCode
        }
    }

}

extension APIGatewayClientTypes.MethodSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheDataEncrypted
        case cacheTtlInSeconds
        case cachingEnabled
        case dataTraceEnabled
        case loggingLevel
        case metricsEnabled
        case requireAuthorizationForCacheControl
        case throttlingBurstLimit
        case throttlingRateLimit
        case unauthorizedCacheControlHeaderStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = self.unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy.rawValue, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .metricsEnabled) ?? false
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTraceEnabled) ?? false
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttlingBurstLimit) ?? 0
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throttlingRateLimit) ?? 0.0
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cachingEnabled) ?? false
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cacheTtlInSeconds) ?? 0
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheDataEncrypted) ?? false
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireAuthorizationForCacheControl) ?? false
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
    }
}

extension APIGatewayClientTypes {
    /// Specifies the method setting properties.
    public struct MethodSetting: Swift.Equatable {
        /// Specifies whether the cached responses are encrypted.
        public var cacheDataEncrypted: Swift.Bool
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
        public var cacheTtlInSeconds: Swift.Int
        /// Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
        public var cachingEnabled: Swift.Bool
        /// Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.
        public var dataTraceEnabled: Swift.Bool
        /// Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are OFF, ERROR, and INFO. Choose ERROR to write only error-level entries to CloudWatch Logs, or choose INFO to include all ERROR events as well as extra informational events.
        public var loggingLevel: Swift.String?
        /// Specifies whether Amazon CloudWatch metrics are enabled for this method.
        public var metricsEnabled: Swift.Bool
        /// Specifies whether authorization is required for a cache invalidation request.
        public var requireAuthorizationForCacheControl: Swift.Bool
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double
        /// Specifies how to handle unauthorized requests for cache invalidation.
        public var unauthorizedCacheControlHeaderStrategy: APIGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy?

        public init(
            cacheDataEncrypted: Swift.Bool = false,
            cacheTtlInSeconds: Swift.Int = 0,
            cachingEnabled: Swift.Bool = false,
            dataTraceEnabled: Swift.Bool = false,
            loggingLevel: Swift.String? = nil,
            metricsEnabled: Swift.Bool = false,
            requireAuthorizationForCacheControl: Swift.Bool = false,
            throttlingBurstLimit: Swift.Int = 0,
            throttlingRateLimit: Swift.Double = 0.0,
            unauthorizedCacheControlHeaderStrategy: APIGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy? = nil
        )
        {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }
    }

}

extension APIGatewayClientTypes.MethodSnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired) ?? false
        apiKeyRequired = apiKeyRequiredDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents a summary of a Method resource, given a particular date and time.
    public struct MethodSnapshot: Swift.Equatable {
        /// Specifies whether the method requires a valid ApiKey.
        public var apiKeyRequired: Swift.Bool
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?

        public init(
            apiKeyRequired: Swift.Bool = false,
            authorizationType: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationType = authorizationType
        }
    }

}

extension APIGatewayClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents the data structure of a method's request or response payload.
    public struct Model: Swift.Equatable {
        /// The content-type for the model.
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The identifier for the model resource.
        public var id: Swift.String?
        /// The name of the model. Must be an alphanumeric string.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
        public var schema: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.id = id
            self.name = name
            self.schema = schema
        }
    }

}

extension APIGatewayClientTypes.MutualTlsAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri
        case truststoreVersion
        case truststoreWarnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = self.truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = self.truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for string0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[Swift.String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [Swift.String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public struct MutualTlsAuthentication: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

extension APIGatewayClientTypes.MutualTlsAuthenticationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri
        case truststoreVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = self.truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = self.truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension APIGatewayClientTypes {
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public struct MutualTlsAuthenticationInput: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket
        public var truststoreVersion: Swift.String?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource is not found. Make sure that the request URI is correct.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes {
    public enum Op: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case copy
        case move
        case remove
        case replace
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [Op] {
            return [
                .add,
                .copy,
                .move,
                .remove,
                .replace,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "add"
            case .copy: return "copy"
            case .move: return "move"
            case .remove: return "remove"
            case .replace: return "replace"
            case .test: return "test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Op(rawValue: rawValue) ?? Op.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.PatchOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case op
        case path
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let op = self.op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.Op.self, forKey: .op)
        op = opDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
    }
}

extension APIGatewayClientTypes {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public struct PatchOperation: Swift.Equatable {
        /// The copy update operation's source as identified by a JSON-Pointer value referencing the location within the targeted resource to copy the value from. For example, to promote a canary deployment, you copy the canary deployment ID to the affiliated deployment ID by calling a PATCH request on a Stage resource with "op":"copy", "from":"/canarySettings/deploymentId" and "path":"/deploymentId".
        public var from: Swift.String?
        /// An update operation to be performed with this PATCH request. The valid value can be add, remove, replace or copy. Not all valid operations are supported for a given resource. Support of the operations depends on specific operational contexts. Attempts to apply an unsupported operation on a resource will return an error message..
        public var op: APIGatewayClientTypes.Op?
        /// The op operation's target, as identified by a JSON Pointer value that references a location within the targeted resource. For example, if the target resource has an updateable property of {"name":"value"}, the path for this property is /name. If the name property value is a JSON object (e.g., {"name": {"child/name": "child-value"}}), the path for the child/name property will be /name/child~1name. Any slash ("/") character appearing in path names must be escaped with "~1", as shown in the example above. Each op operation can have only one path associated with it.
        public var path: Swift.String?
        /// The new target value of the update operation. It is applicable for the add or replace operation. When using AWS CLI to update a property of a JSON value, enclose the JSON object with a pair of single quotes in a Linux shell, e.g., '{"a": ...}'.
        public var value: Swift.String?

        public init(
            from: Swift.String? = nil,
            op: APIGatewayClientTypes.Op? = nil,
            path: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.from = from
            self.op = op
            self.path = path
            self.value = value
        }
    }

}

extension PutGatewayResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToString0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapOfStringToString0) in responseTemplates {
                try responseTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }
}

extension PutGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
public struct PutGatewayResponseInput: Swift.Equatable {
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated GatewayResponse
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The HTTP status code of the GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseInputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
}

extension PutGatewayResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
    }
}

extension PutGatewayResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutGatewayResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct PutGatewayResponseOutput: Swift.Equatable {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseOutputBody: Swift.Equatable {
    let responseType: APIGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension PutGatewayResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultResponse) ?? false
        defaultResponse = defaultResponseDecoded
    }
}

enum PutGatewayResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for string0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(string0)
            }
        }
        if let cacheNamespace = self.cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = self.contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = self.credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let integrationHttpMethod = self.integrationHttpMethod {
            try encodeContainer.encode(integrationHttpMethod, forKey: .integrationHttpMethod)
        }
        if let passthroughBehavior = self.passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapOfStringToString0) in requestParameters {
                try requestParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, mapOfStringToString0) in requestTemplates {
                try requestTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeoutInMillis = self.timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension PutIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Sets up a method's integration.
public struct PutIntegrationInput: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration. Specify this value only if you specify VPC_LINK as the connection type.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies whether credentials are required for a put integration.
    public var credentials: Swift.String?
    /// Specifies the HTTP method for the integration.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The HTTP method for the integration.
    public var integrationHttpMethod: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Specifies a put integration request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int?
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies a put integration input's type.
    /// This member is required.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification, for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationHttpMethod: Swift.String? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationHttpMethod = integrationHttpMethod
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationInputBody: Swift.Equatable {
    let type: APIGatewayClientTypes.IntegrationType?
    let integrationHttpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: APIGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: APIGatewayClientTypes.TlsConfig?
}

extension PutIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let integrationHttpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationHttpMethod)
        integrationHttpMethod = integrationHttpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension PutIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct PutIntegrationOutput: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationOutputBody: Swift.Equatable {
    let type: APIGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: APIGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: APIGatewayClientTypes.TlsConfig?
}

extension PutIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis) ?? 0
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum PutIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = self.contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToString0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapOfStringToString0) in responseTemplates {
                try responseTemplatesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = self.selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
    }
}

extension PutIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a put integration response request.
public struct PutIntegrationResponseInput: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies a put integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a put integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name must be a valid and unique response header name and JSON-expression a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies a put integration response's templates.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies the selection pattern of a put integration response.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.restApiId = restApiId
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseInputBody: Swift.Equatable {
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
}

extension PutIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension PutIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct PutIntegrationResponseOutput: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
}

extension PutIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

enum PutIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = self.apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for string0 in authorizationScopes {
                try authorizationScopesContainer.encode(string0)
            }
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, mapOfStringToString0) in requestModels {
                try requestModelsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapOfStringToBoolean0) in requestParameters {
                try requestParametersContainer.encode(mapOfStringToBoolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = self.requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }
}

extension PutMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to add a method to an existing Resource resource.
public struct PutMethodInput: Swift.Equatable {
    /// Specifies whether the method required a valid ApiKey.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    /// This member is required.
    public var authorizationType: Swift.String?
    /// Specifies the identifier of an Authorizer to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// Specifies the Model resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a Model name as the value.
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or body-mapping templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a RequestValidator for validating the method request.
    public var requestValidatorId: Swift.String?
    /// The Resource identifier for the new Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct PutMethodInputBody: Swift.Equatable {
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let requestValidatorId: Swift.String?
    let authorizationScopes: [Swift.String]?
}

extension PutMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension PutMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutMethodOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct PutMethodOutput: Swift.Equatable {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct PutMethodOutputBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    let methodIntegration: APIGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension PutMethodOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

enum PutMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutMethodResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, mapOfStringToString0) in responseModels {
                try responseModelsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapOfStringToBoolean0) in responseParameters {
                try responseParametersContainer.encode(mapOfStringToBoolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Request to add a MethodResponse to an existing Method resource.
public struct PutMethodResponseInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the Model resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a Model name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The method response's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutMethodResponseInputBody: Swift.Equatable {
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension PutMethodResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension PutMethodResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutMethodResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct PutMethodResponseOutput: Swift.Equatable {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct PutMethodResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension PutMethodResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

enum PutMethodResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes {
    public enum PutMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [PutMode] {
            return [
                .merge,
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .merge: return "merge"
            case .overwrite: return "overwrite"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PutMode(rawValue: rawValue) ?? PutMode.sdkUnknown(rawValue)
        }
    }
}

public struct PutRestApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRestApiInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutRestApiOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodyData = body
            let bodyBody = ClientRuntime.HttpBody.data(bodyData)
            input.builder.withBody(bodyBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRestApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRestApiOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension PutRestApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let mode = mode {
                let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
                items.append(modeQueryItem)
            }
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            if let parameters = parameters {
                let currentQueryItemNames = items.map({$0.name})
                parameters.forEach { key0, value0 in
                    if !currentQueryItemNames.contains(key0) {
                        let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
            return items
        }
    }
}

extension PutRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// A PUT request to update an existing API, with external API definitions specified as the request body.
public struct PutRestApiInput: Swift.Equatable {
    /// The PUT request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback the API update (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool?
    /// The mode query parameter to specify the update mode. Valid values are "merge" and "overwrite". By default, the update mode is "merge".
    public var mode: APIGatewayClientTypes.PutMode?
    /// Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ignore=documentation as a parameters value, as in the AWS CLI command of aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'.
    public var parameters: [Swift.String:Swift.String]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool? = nil,
        mode: APIGatewayClientTypes.PutMode? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.parameters = parameters
        self.restApiId = restApiId
    }
}

struct PutRestApiInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension PutRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRestApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.rootResourceId = output.rootResourceId
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.rootResourceId = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API.
public struct PutRestApiOutput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct PutRestApiOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
    let rootResourceId: Swift.String?
}

extension PutRestApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

enum PutRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes {
    public enum QuotaPeriodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaPeriodType] {
            return [
                .day,
                .month,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuotaPeriodType(rawValue: rawValue) ?? QuotaPeriodType.sdkUnknown(rawValue)
        }
    }
}

extension APIGatewayClientTypes.QuotaSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case offset
        case period
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset) ?? 0
        offset = offsetDecoded
        let periodDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaPeriodType.self, forKey: .period)
        period = periodDecoded
    }
}

extension APIGatewayClientTypes {
    /// Quotas configured for a usage plan.
    public struct QuotaSettings: Swift.Equatable {
        /// The target maximum number of requests that can be made in a given time period.
        public var limit: Swift.Int
        /// The number of requests subtracted from the given limit in the initial time period.
        public var offset: Swift.Int
        /// The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
        public var period: APIGatewayClientTypes.QuotaPeriodType?

        public init(
            limit: Swift.Int = 0,
            offset: Swift.Int = 0,
            period: APIGatewayClientTypes.QuotaPeriodType? = nil
        )
        {
            self.limit = limit
            self.offset = offset
            self.period = period
        }
    }

}

extension APIGatewayClientTypes.RequestValidator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if validateRequestBody != false {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if validateRequestParameters != false {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestBody) ?? false
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestParameters) ?? false
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension APIGatewayClientTypes {
    /// A set of validation rules for incoming Method requests.
    public struct RequestValidator: Swift.Equatable {
        /// The identifier of this RequestValidator.
        public var id: Swift.String?
        /// The name of this RequestValidator
        public var name: Swift.String?
        /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
        public var validateRequestBody: Swift.Bool
        /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
        public var validateRequestParameters: Swift.Bool

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            validateRequestBody: Swift.Bool = false,
            validateRequestParameters: Swift.Bool = false
        )
        {
            self.id = id
            self.name = name
            self.validateRequestBody = validateRequestBody
            self.validateRequestParameters = validateRequestParameters
        }
    }

}

extension APIGatewayClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parentId = self.parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let pathPart = self.pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
        if let resourceMethods = resourceMethods {
            var resourceMethodsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceMethods)
            for (dictKey0, mapOfMethod0) in resourceMethods {
                try resourceMethodsContainer.encode(mapOfMethod0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:APIGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:APIGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// Represents an API resource.
    public struct Resource: Swift.Equatable {
        /// The resource's identifier.
        public var id: Swift.String?
        /// The parent resource's identifier.
        public var parentId: Swift.String?
        /// The full path for this resource.
        public var path: Swift.String?
        /// The last path segment for this resource.
        public var pathPart: Swift.String?
        /// Gets an API resource's method of a given HTTP verb.
        public var resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?

        public init(
            id: Swift.String? = nil,
            parentId: Swift.String? = nil,
            path: Swift.String? = nil,
            pathPart: Swift.String? = nil,
            resourceMethods: [Swift.String:APIGatewayClientTypes.Method]? = nil
        )
        {
            self.id = id
            self.parentId = parentId
            self.path = path
            self.pathPart = pathPart
            self.resourceMethods = resourceMethods
        }
    }

}

extension APIGatewayClientTypes.RestApi: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = self.apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for string0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(string0)
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = self.endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let minimumCompressionSize = self.minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let rootResourceId = self.rootResourceId {
            try encodeContainer.encode(rootResourceId, forKey: .rootResourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for string0 in warnings {
                try warningsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents a REST API.
    public struct RestApi: Swift.Equatable {
        /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
        public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
        /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
        public var binaryMediaTypes: [Swift.String]?
        /// The timestamp when the API was created.
        public var createdDate: ClientRuntime.Date?
        /// The API's description.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool
        /// The endpoint configuration of this RestApi showing the endpoint types of the API.
        public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
        /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
        public var id: Swift.String?
        /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
        public var minimumCompressionSize: Swift.Int?
        /// The API's name.
        public var name: Swift.String?
        /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
        public var policy: Swift.String?
        /// The API's root resource ID.
        public var rootResourceId: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init(
            apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
            binaryMediaTypes: [Swift.String]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool = false,
            endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
            id: Swift.String? = nil,
            minimumCompressionSize: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil,
            rootResourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.policy = policy
            self.rootResourceId = rootResourceId
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

extension APIGatewayClientTypes.SdkConfigurationProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case friendlyName
        case name
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = self.friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required) ?? false
        `required` = requiredDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension APIGatewayClientTypes {
    /// A configuration property of an SDK type.
    public struct SdkConfigurationProperty: Swift.Equatable {
        /// The default value of an SdkType configuration property.
        public var defaultValue: Swift.String?
        /// The description of an SdkType configuration property.
        public var description: Swift.String?
        /// The user-friendly name of an SdkType configuration property.
        public var friendlyName: Swift.String?
        /// The name of a an SdkType configuration property.
        public var name: Swift.String?
        /// A boolean flag of an SdkType configuration property to indicate if the associated SDK configuration property is required (true) or not (false).
        public var `required`: Swift.Bool

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool = false
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.friendlyName = friendlyName
            self.name = name
            self.`required` = `required`
        }
    }

}

extension APIGatewayClientTypes.SdkType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProperties = configurationProperties {
            var configurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationProperties)
            for sdkconfigurationproperty0 in configurationProperties {
                try configurationPropertiesContainer.encode(sdkconfigurationproperty0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = self.friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[APIGatewayClientTypes.SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [APIGatewayClientTypes.SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

extension APIGatewayClientTypes {
    /// A type of SDK that API Gateway can generate.
    public struct SdkType: Swift.Equatable {
        /// A list of configuration properties of an SdkType.
        public var configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]?
        /// The description of an SdkType.
        public var description: Swift.String?
        /// The user-friendly name of an SdkType instance.
        public var friendlyName: Swift.String?
        /// The identifier of an SdkType instance.
        public var id: Swift.String?

        public init(
            configurationProperties: [APIGatewayClientTypes.SdkConfigurationProperty]? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.configurationProperties = configurationProperties
            self.description = description
            self.friendlyName = friendlyName
            self.id = id
        }
    }

}

extension APIGatewayClientTypes {
    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested service is not available. For details see the accompanying error message. Retry after the specified time period.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = self.cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let cacheClusterStatus = self.cacheClusterStatus {
            try encodeContainer.encode(cacheClusterStatus.rawValue, forKey: .cacheClusterStatus)
        }
        if let canarySettings = self.canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = self.documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .epochSeconds, forKey: .lastUpdatedDate)
        }
        if let methodSettings = methodSettings {
            var methodSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .methodSettings)
            for (dictKey0, mapOfMethodSettings0) in methodSettings {
                try methodSettingsContainer.encode(mapOfMethodSettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapOfStringToString0) in variables {
                try variablesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let webAclArn = self.webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled) ?? false
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:APIGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled) ?? false
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
    public struct Stage: Swift.Equatable {
        /// Settings for logging access in this stage.
        public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
        /// Specifies whether a cache cluster is enabled for the stage.
        public var cacheClusterEnabled: Swift.Bool
        /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
        public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
        /// The status of the cache cluster for the stage, if enabled.
        public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
        /// Settings for the canary deployment in this stage.
        public var canarySettings: APIGatewayClientTypes.CanarySettings?
        /// The identifier of a client certificate for an API stage.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier of the Deployment that the stage points to.
        public var deploymentId: Swift.String?
        /// The stage's description.
        public var description: Swift.String?
        /// The version of the associated API documentation.
        public var documentationVersion: Swift.String?
        /// The timestamp when the stage last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
        public var methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
        /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public var stageName: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether active tracing with X-ray is enabled for the Stage.
        public var tracingEnabled: Swift.Bool
        /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var variables: [Swift.String:Swift.String]?
        /// The ARN of the WebAcl associated with the Stage.
        public var webAclArn: Swift.String?

        public init(
            accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
            cacheClusterEnabled: Swift.Bool = false,
            cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
            cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
            canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            documentationVersion: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil,
            stageName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tracingEnabled: Swift.Bool = false,
            variables: [Swift.String:Swift.String]? = nil,
            webAclArn: Swift.String? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tags = tags
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }
    }

}

extension APIGatewayClientTypes.StageKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restApiId
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restApiId = self.restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension APIGatewayClientTypes {
    /// A reference to a unique stage identified in the format {restApiId}/{stage}.
    public struct StageKey: Swift.Equatable {
        /// The string identifier of the associated RestApi.
        public var restApiId: Swift.String?
        /// The stage name associated with the stage key.
        public var stageName: Swift.String?

        public init(
            restApiId: Swift.String? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.restApiId = restApiId
            self.stageName = stageName
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Adds or updates a tag on a given resource.
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestInvokeAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalContext = additionalContext {
            var additionalContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalContext)
            for (dictKey0, mapOfStringToString0) in additionalContext {
                try additionalContextContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headers)
            for (dictKey0, mapOfStringToString0) in headers {
                try headersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapOfStringToList0) in multiValueHeaders {
                var mapOfStringToList0Container = multiValueHeadersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in mapOfStringToList0 {
                    try mapOfStringToList0Container.encode(string1)
                }
            }
        }
        if let pathWithQueryString = self.pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, mapOfStringToString0) in stageVariables {
                try stageVariablesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TestInvokeAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Make a request to simulate the invocation of an Authorizer.
public struct TestInvokeAuthorizerInput: Swift.Equatable {
    /// A key-value map of additional context variables.
    public var additionalContext: [Swift.String:Swift.String]?
    /// Specifies a test invoke authorizer request's Authorizer ID.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// A key-value map of headers to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, should be specified.
    public var headers: [Swift.String:Swift.String]?
    /// The headers as a map from string to list of values to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, may be specified.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed Stage.
    public var stageVariables: [Swift.String:Swift.String]?

    public init(
        additionalContext: [Swift.String:Swift.String]? = nil,
        authorizerId: Swift.String? = nil,
        body: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.additionalContext = additionalContext
        self.authorizerId = authorizerId
        self.body = body
        self.headers = headers
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeAuthorizerInputBody: Swift.Equatable {
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let pathWithQueryString: Swift.String?
    let body: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let additionalContext: [Swift.String:Swift.String]?
}

extension TestInvokeAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let additionalContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalContext)
        var additionalContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalContextContainer = additionalContextContainer {
            additionalContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalContextContainer {
                if let string0 = string0 {
                    additionalContextDecoded0?[key0] = string0
                }
            }
        }
        additionalContext = additionalContextDecoded0
    }
}

extension TestInvokeAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestInvokeAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorization = output.authorization
            self.claims = output.claims
            self.clientStatus = output.clientStatus
            self.latency = output.latency
            self.log = output.log
            self.policy = output.policy
            self.principalId = output.principalId
        } else {
            self.authorization = nil
            self.claims = nil
            self.clientStatus = 0
            self.latency = 0
            self.log = nil
            self.policy = nil
            self.principalId = nil
        }
    }
}

/// Represents the response of the test invoke request for a custom Authorizer
public struct TestInvokeAuthorizerOutput: Swift.Equatable {
    /// The authorization response.
    public var authorization: [Swift.String:[Swift.String]]?
    /// The open identity claims, with any supported custom attributes, returned from the Cognito Your User Pool configured for the API.
    public var claims: [Swift.String:Swift.String]?
    /// The HTTP status code that the client would have received. Value is 0 if the authorizer succeeded.
    public var clientStatus: Swift.Int
    /// The execution latency, in ms, of the test authorizer request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test authorizer request.
    public var log: Swift.String?
    /// The JSON policy document returned by the Authorizer
    public var policy: Swift.String?
    /// The principal identity returned by the Authorizer
    public var principalId: Swift.String?

    public init(
        authorization: [Swift.String:[Swift.String]]? = nil,
        claims: [Swift.String:Swift.String]? = nil,
        clientStatus: Swift.Int = 0,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        policy: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.authorization = authorization
        self.claims = claims
        self.clientStatus = clientStatus
        self.latency = latency
        self.log = log
        self.policy = policy
        self.principalId = principalId
    }
}

struct TestInvokeAuthorizerOutputBody: Swift.Equatable {
    let clientStatus: Swift.Int
    let log: Swift.String?
    let latency: Swift.Int
    let principalId: Swift.String?
    let policy: Swift.String?
    let authorization: [Swift.String:[Swift.String]]?
    let claims: [Swift.String:Swift.String]?
}

extension TestInvokeAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization
        case claims
        case clientStatus
        case latency
        case log
        case policy
        case principalId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientStatusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientStatus) ?? 0
        clientStatus = clientStatusDecoded
        let logDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latency) ?? 0
        latency = latencyDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let authorizationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .authorization)
        var authorizationDecoded0: [Swift.String:[Swift.String]]? = nil
        if let authorizationContainer = authorizationContainer {
            authorizationDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in authorizationContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                authorizationDecoded0?[key0] = listofstring0Decoded0
            }
        }
        authorization = authorizationDecoded0
        let claimsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .claims)
        var claimsDecoded0: [Swift.String:Swift.String]? = nil
        if let claimsContainer = claimsContainer {
            claimsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in claimsContainer {
                if let string0 = string0 {
                    claimsDecoded0?[key0] = string0
                }
            }
        }
        claims = claimsDecoded0
    }
}

enum TestInvokeAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestInvokeMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headers)
            for (dictKey0, mapOfStringToString0) in headers {
                try headersContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapOfStringToList0) in multiValueHeaders {
                var mapOfStringToList0Container = multiValueHeadersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in mapOfStringToList0 {
                    try mapOfStringToList0Container.encode(string1)
                }
            }
        }
        if let pathWithQueryString = self.pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, mapOfStringToString0) in stageVariables {
                try stageVariablesContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TestInvokeMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Make a request to simulate the invocation of a Method.
public struct TestInvokeMethodInput: Swift.Equatable {
    /// The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// A ClientCertificate identifier to use in the test invocation. API Gateway will use the certificate when making the HTTPS request to the defined back-end endpoint.
    public var clientCertificateId: Swift.String?
    /// A key-value map of headers to simulate an incoming invocation request.
    public var headers: [Swift.String:Swift.String]?
    /// Specifies a test invoke method request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The headers as a map from string to list of values to simulate an incoming invocation request.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// Specifies a test invoke method request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed Stage.
    public var stageVariables: [Swift.String:Swift.String]?

    public init(
        body: Swift.String? = nil,
        clientCertificateId: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        httpMethod: Swift.String? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.clientCertificateId = clientCertificateId
        self.headers = headers
        self.httpMethod = httpMethod
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeMethodInputBody: Swift.Equatable {
    let pathWithQueryString: Swift.String?
    let body: Swift.String?
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let clientCertificateId: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
}

extension TestInvokeMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension TestInvokeMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestInvokeMethodOutputBody = try responseDecoder.decode(responseBody: data)
            self.body = output.body
            self.headers = output.headers
            self.latency = output.latency
            self.log = output.log
            self.multiValueHeaders = output.multiValueHeaders
            self.status = output.status
        } else {
            self.body = nil
            self.headers = nil
            self.latency = 0
            self.log = nil
            self.multiValueHeaders = nil
            self.status = 0
        }
    }
}

/// Represents the response of the test invoke request in the HTTP method.
public struct TestInvokeMethodOutput: Swift.Equatable {
    /// The body of the HTTP response.
    public var body: Swift.String?
    /// The headers of the HTTP response.
    public var headers: [Swift.String:Swift.String]?
    /// The execution latency, in ms, of the test invoke request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test invoke request.
    public var log: Swift.String?
    /// The headers of the HTTP response as a map from string to list of values.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// The HTTP status code.
    public var status: Swift.Int

    public init(
        body: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        status: Swift.Int = 0
    )
    {
        self.body = body
        self.headers = headers
        self.latency = latency
        self.log = log
        self.multiValueHeaders = multiValueHeaders
        self.status = status
    }
}

struct TestInvokeMethodOutputBody: Swift.Equatable {
    let status: Swift.Int
    let body: Swift.String?
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let log: Swift.String?
    let latency: Swift.Int
}

extension TestInvokeMethodOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case headers
        case latency
        case log
        case multiValueHeaders
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let logDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latency) ?? 0
        latency = latencyDecoded
    }
}

enum TestInvokeMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes.ThrottleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case burstLimit
        case rateLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if burstLimit != 0 {
            try encodeContainer.encode(burstLimit, forKey: .burstLimit)
        }
        if rateLimit != 0.0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let burstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .burstLimit) ?? 0
        burstLimit = burstLimitDecoded
        let rateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rateLimit) ?? 0.0
        rateLimit = rateLimitDecoded
    }
}

extension APIGatewayClientTypes {
    /// The API request rate limits.
    public struct ThrottleSettings: Swift.Equatable {
        /// The API target request burst rate limit. This allows more requests through for a period of time than the target rate limit.
        public var burstLimit: Swift.Int
        /// The API target request rate limit.
        public var rateLimit: Swift.Double

        public init(
            burstLimit: Swift.Int = 0,
            rateLimit: Swift.Double = 0.0
        )
        {
            self.burstLimit = burstLimit
            self.rateLimit = rateLimit
        }
    }

}

extension APIGatewayClientTypes.TlsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insecureSkipVerification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if insecureSkipVerification != false {
            try encodeContainer.encode(insecureSkipVerification, forKey: .insecureSkipVerification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insecureSkipVerificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureSkipVerification) ?? false
        insecureSkipVerification = insecureSkipVerificationDecoded
    }
}

extension APIGatewayClientTypes {
    /// Specifies the TLS configuration for an integration.
    public struct TlsConfig: Swift.Equatable {
        /// Specifies whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isnt recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations. Enabling insecureSkipVerification isn't recommended, especially for integrations with public HTTPS endpoints. If you enable insecureSkipVerification, you increase the risk of man-in-the-middle attacks.
        public var insecureSkipVerification: Swift.Bool

        public init(
            insecureSkipVerification: Swift.Bool = false
        )
        {
            self.insecureSkipVerification = insecureSkipVerification
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has reached its throttling limit. Retry after the specified time period.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension APIGatewayClientTypes {
    public enum UnauthorizedCacheControlHeaderStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failWith403
        case succeedWithoutResponseHeader
        case succeedWithResponseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [UnauthorizedCacheControlHeaderStrategy] {
            return [
                .failWith403,
                .succeedWithoutResponseHeader,
                .succeedWithResponseHeader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failWith403: return "FAIL_WITH_403"
            case .succeedWithoutResponseHeader: return "SUCCEED_WITHOUT_RESPONSE_HEADER"
            case .succeedWithResponseHeader: return "SUCCEED_WITH_RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnauthorizedCacheControlHeaderStrategy(rawValue: rawValue) ?? UnauthorizedCacheControlHeaderStrategy.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is denied because the caller has insufficient permissions.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Removes a tag from a given resource.
public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account"
    }
}

/// Requests API Gateway to change information about the current Account resource.
public struct UpdateAccountInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.patchOperations = patchOperations
    }
}

struct UpdateAccountInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// Represents an AWS account that is associated with API Gateway.
public struct UpdateAccountOutput: Swift.Equatable {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current Account.
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current Account.
    public var throttleSettings: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct UpdateAccountOutputBody: Swift.Equatable {
    let cloudwatchRoleArn: Swift.String?
    let throttleSettings: APIGatewayClientTypes.ThrottleSettings?
    let features: [Swift.String]?
    let apiKeyVersion: Swift.String?
}

extension UpdateAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .features)
        var featuresDecoded0:[Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

enum UpdateAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to change information about an ApiKey resource.
public struct UpdateApiKeyInput: Swift.Equatable {
    /// The identifier of the ApiKey resource to be updated.
    /// This member is required.
    public var apiKey: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        apiKey: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.apiKey = apiKey
        self.patchOperations = patchOperations
    }
}

struct UpdateApiKeyInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateApiKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApiKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing Method resources that require an API key. API keys can be mapped to any Stage on any RestApi, which indicates that the callers with the API key can make requests to that stage.
public struct UpdateApiKeyOutput: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An Amazon Web Services Marketplace customer identifier, when integrating with the Amazon Web Services SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of Stage resources that are associated with the ApiKey resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct UpdateApiKeyOutputBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateApiKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateApiKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to update an existing Authorizer resource.
public struct UpdateAuthorizerInput: Swift.Equatable {
    /// The identifier of the Authorizer resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        authorizerId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateAuthorizerInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method.
public struct UpdateAuthorizerOutput: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested. For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth. For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: APIGatewayClientTypes.AuthorizerType?

    public init(
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: APIGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct UpdateAuthorizerOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: APIGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension UpdateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

enum UpdateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBasePathMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// A request to change information about the BasePathMapping resource.
public struct UpdateBasePathMappingInput: Swift.Equatable {
    /// The base path of the BasePathMapping resource to change. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// The domain name of the BasePathMapping resource to change.
    /// This member is required.
    public var domainName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateBasePathMappingInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateBasePathMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateBasePathMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBasePathMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name.
public struct UpdateBasePathMappingOutput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated RestApi.
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init(
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct UpdateBasePathMappingOutputBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension UpdateBasePathMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum UpdateBasePathMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClientCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to change information about an ClientCertificate resource.
public struct UpdateClientCertificateInput: Swift.Equatable {
    /// The identifier of the ClientCertificate resource to be updated.
    /// This member is required.
    public var clientCertificateId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        clientCertificateId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.patchOperations = patchOperations
    }
}

struct UpdateClientCertificateInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateClientCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateClientCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateClientCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint.
public struct UpdateClientCertificateOutput: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct UpdateClientCertificateOutputBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateClientCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateClientCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to change information about a Deployment resource.
public struct UpdateDeploymentInput: Swift.Equatable {
    /// The replacement identifier for the Deployment resource to change information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDeploymentInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a RestApi resource that can be called by users using Stages. A deployment must be associated with a Stage for it to be callable over the Internet.
public struct UpdateDeploymentOutput: Swift.Equatable {
    /// A summary of the RestApi at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init(
        apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct UpdateDeploymentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]?
}

extension UpdateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: APIGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:APIGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: APIGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: APIGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

enum UpdateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDocumentationPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Updates an existing documentation part of a given API.
public struct UpdateDocumentationPartInput: Swift.Equatable {
    /// The identifier of the to-be-updated documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationPartId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationPartInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateDocumentationPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDocumentationPartOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity.
public struct UpdateDocumentationPartOutput: Swift.Equatable {
    /// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: APIGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init(
        id: Swift.String? = nil,
        location: APIGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct UpdateDocumentationPartOutputBody: Swift.Equatable {
    let id: Swift.String?
    let location: APIGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension UpdateDocumentationPartOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

enum UpdateDocumentationPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDocumentationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Updates an existing documentation version of an API.
public struct UpdateDocumentationVersionInput: Swift.Equatable {
    /// The version identifier of the to-be-updated documentation version.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        documentationVersion: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationVersionInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateDocumentationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDocumentationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API.
public struct UpdateDocumentationVersionOutput: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct UpdateDocumentationVersionOutputBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension UpdateDocumentationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateDocumentationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// A request to change information about the DomainName resource.
public struct UpdateDomainNameInput: Swift.Equatable {
    /// The name of the DomainName resource to be changed.
    /// This member is required.
    public var domainName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?

    public init(
        domainName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API (RestApi).
public struct UpdateDomainNameOutput: Swift.Equatable {
    /// The reference to an Amazon Web Services-managed certificate that will be used by edge-optimized endpoint for this domain name. Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the Amazon CloudFront documentation.
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the DomainName migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the DomainName migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this DomainName showing the endpoint types of the domain name.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an Amazon Web Services-managed certificate that will be used for validating the regional domain name. Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see Set up a Regional Custom Domain Name and AWS Regions and Endpoints for API Gateway.
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this DomainName. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: APIGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: APIGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct UpdateDomainNameOutputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: APIGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: APIGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: APIGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension UpdateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

enum UpdateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewayResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Updates a GatewayResponse of a specified response type on the given RestApi.
public struct UpdateGatewayResponseInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The response type of the associated GatewayResponse.
    /// This member is required.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct UpdateGatewayResponseInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateGatewayResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateGatewayResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGatewayResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates.
public struct UpdateGatewayResponseOutput: Swift.Equatable {
    /// A Boolean flag to indicate whether this GatewayResponse is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the GatewayResponse as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated GatewayResponse.
    public var responseType: APIGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this GatewayResponse.
    public var statusCode: Swift.String?

    public init(
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: APIGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct UpdateGatewayResponseOutputBody: Swift.Equatable {
    let responseType: APIGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension UpdateGatewayResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultResponse) ?? false
        defaultResponse = defaultResponseDecoded
    }
}

enum UpdateGatewayResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents an update integration request.
public struct UpdateIntegrationInput: Swift.Equatable {
    /// Represents an update integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// Represents an update integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateIntegrationInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
public struct UpdateIntegrationOutput: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for Method requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ID of the VpcLink used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: APIGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported Amazon Web Services services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type. For the Type property, if you specify MOCK, this property is optional. For Lambda integrations, you must set the integration method to POST. For all other types, you must specify this property.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    public var integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following: WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: APIGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following: For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    public var type: APIGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint. For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If connectionType is VPC_LINK specify the Network Load Balancer DNS name. For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated Amazon Web Services service (e.g., s3); and {subdomain} is a designated subdomain supported by certain Amazon Web Services service for fast host-name lookup. action can be used for an Amazon Web Services service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an Amazon Web Services service path-based API. The ensuing service_api refers to the path to an Amazon Web Services service resource, including the region of the integrated Amazon Web Services service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init(
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: APIGatewayClientTypes.ConnectionType? = nil,
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: APIGatewayClientTypes.TlsConfig? = nil,
        type: APIGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct UpdateIntegrationOutputBody: Swift.Equatable {
    let type: APIGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: APIGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:APIGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: APIGatewayClientTypes.TlsConfig?
}

extension UpdateIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis) ?? 0
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:APIGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum UpdateIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents an update integration response request.
public struct UpdateIntegrationResponseInput: Swift.Equatable {
    /// Specifies an update integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// Specifies an update integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies an update integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing MethodResponse, and parameters and templates can be used to transform the back-end response.
public struct UpdateIntegrationResponseOutput: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an Lambda function, the Lambda function error header is matched. For all other HTTP and Amazon Web Services back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing MethodResponse.
    public var statusCode: Swift.String?

    public init(
        contentHandling: APIGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: APIGatewayClientTypes.ContentHandlingStrategy?
}

extension UpdateIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

enum UpdateIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to update an existing Method resource.
public struct UpdateMethodInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Resource identifier for the Method resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateMethodInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMethodOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an Integration resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an Integration resource. On the other hand, a method response is represented by a MethodResponse resource, whereas an integration response is represented by an IntegrationResponse resource.
public struct UpdateMethodOutput: Swift.Equatable {
    /// A boolean flag specifying whether a valid ApiKey is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an Authorizer to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    public var methodIntegration: APIGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code.
    public var methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by Model resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in Integration to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a RequestValidator for request validation.
    public var requestValidatorId: Swift.String?

    public init(
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: APIGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct UpdateMethodOutputBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:APIGatewayClientTypes.MethodResponse]?
    let methodIntegration: APIGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension UpdateMethodOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:APIGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:APIGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

enum UpdateMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMethodResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// A request to update an existing MethodResponse resource.
public struct UpdateMethodResponseInput: Swift.Equatable {
    /// The HTTP verb of the Method resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Resource identifier for the MethodResponse resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The status code for the MethodResponse resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init(
        httpMethod: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateMethodResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMethodResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
public struct UpdateMethodResponseOutput: Swift.Equatable {
    /// Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init(
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseOutputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension UpdateMethodResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

enum UpdateMethodResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to update an existing model in an existing RestApi resource.
public struct UpdateModelInput: Swift.Equatable {
    /// The name of the model to update.
    /// This member is required.
    public var modelName: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        modelName: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload.
public struct UpdateModelOutput: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension UpdateModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

enum UpdateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRequestValidatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Updates a RequestValidator of a given RestApi.
public struct UpdateRequestValidatorInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of RequestValidator to be updated.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct UpdateRequestValidatorInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateRequestValidatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRequestValidatorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRequestValidatorOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming Method requests.
public struct UpdateRequestValidatorOutput: Swift.Equatable {
    /// The identifier of this RequestValidator.
    public var id: Swift.String?
    /// The name of this RequestValidator
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured Model schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct UpdateRequestValidatorOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension UpdateRequestValidatorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestBody) ?? false
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .validateRequestParameters) ?? false
        validateRequestParameters = validateRequestParametersDecoded
    }
}

enum UpdateRequestValidatorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to change information about a Resource resource.
public struct UpdateResourceInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of the Resource resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource.
public struct UpdateResourceOutput: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb.
    public var resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?

    public init(
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:APIGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct UpdateResourceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:APIGatewayClientTypes.Method]?
}

extension UpdateResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:APIGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:APIGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

enum UpdateResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// Request to update an existing RestApi resource in your collection.
public struct UpdateRestApiInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateRestApiInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRestApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRestApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.rootResourceId = output.rootResourceId
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.rootResourceId = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API.
public struct UpdateRestApiOutput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are: >HEADER to read the API key from the X-API-Key header of a request. AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this RestApi showing the endpoint types of the API.
    public var endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and Method configuration.
    public var policy: Swift.String?
    /// The API's root resource ID.
    public var rootResourceId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiKeySource: APIGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        rootResourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.rootResourceId = rootResourceId
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateRestApiOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: APIGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: APIGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
    let rootResourceId: Swift.String?
}

extension UpdateRestApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case rootResourceId
        case tags
        case version
        case warnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint) ?? false
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let rootResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootResourceId)
        rootResourceId = rootResourceIdDecoded
    }
}

enum UpdateRestApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to change information about a Stage resource.
public struct UpdateStageInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The string identifier of the associated RestApi.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the Stage resource to change information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed RestApi that is callable by users.
public struct UpdateStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
    public var cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: APIGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the Deployment that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a Stage resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the Stage.
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a Stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the Stage.
    public var webAclArn: Swift.String?

    public init(
        accessLogSettings: APIGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: APIGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: APIGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct UpdateStageOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: APIGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: APIGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:APIGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: APIGatewayClientTypes.AccessLogSettings?
    let canarySettings: APIGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension UpdateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled) ?? false
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: APIGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:APIGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:APIGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled) ?? false
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum UpdateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())/usage"
    }
}

/// The PATCH request to grant a temporary extension to the remaining quota of a usage plan associated with a specified API key.
public struct UpdateUsageInput: Swift.Equatable {
    /// The identifier of the API key associated with the usage plan in which a temporary extension is granted to the remaining quota.
    /// This member is required.
    public var keyId: Swift.String?
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        keyId: Swift.String? = nil,
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// Represents the usage data of a usage plan.
public struct UpdateUsageOutput: Swift.Equatable {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String:[[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init(
        endDate: Swift.String? = nil,
        items: [Swift.String:[[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageOutputBody: Swift.Equatable {
    let usagePlanId: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let items: [Swift.String:[[Swift.Int]]]?
}

extension UpdateUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String: [[Swift.Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [Swift.String:[[Swift.Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String:[[Swift.Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Swift.Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Swift.Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Swift.Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

enum UpdateUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUsagePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The PATCH request to update a usage plan of a given plan Id.
public struct UpdateUsagePlanInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The Id of the to-be-updated usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsagePlanInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateUsagePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsagePlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUsagePlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Dont rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
public struct UpdateUsagePlanOutput: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [APIGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a UsagePlan resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
    public var productCode: Swift.String?
    /// The target maximum number of permitted requests per a given unit time interval.
    public var quota: APIGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A map containing method level throttling information for API stage in a usage plan.
    public var throttle: APIGatewayClientTypes.ThrottleSettings?

    public init(
        apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: APIGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: APIGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct UpdateUsagePlanOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [APIGatewayClientTypes.ApiStage]?
    let throttle: APIGatewayClientTypes.ThrottleSettings?
    let quota: APIGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateUsagePlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[APIGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [APIGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateUsagePlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for patchoperation0 in patchOperations {
                try patchOperationsContainer.encode(patchoperation0)
            }
        }
    }
}

extension UpdateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Updates an existing VpcLink of a specified identifier.
public struct UpdateVpcLinkInput: Swift.Equatable {
    /// For more information about supported patch operations, see [Patch Operations](https://docs.aws.amazon.com/apigateway/latest/api/patch-operations.html).
    public var patchOperations: [APIGatewayClientTypes.PatchOperation]?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        patchOperations: [APIGatewayClientTypes.PatchOperation]? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Swift.Equatable {
    let patchOperations: [APIGatewayClientTypes.PatchOperation]?
}

extension UpdateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[APIGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [APIGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
public struct UpdateVpcLinkOutput: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: APIGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
    public var targetArns: [Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: APIGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct UpdateVpcLinkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: APIGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension APIGatewayClientTypes.UsagePlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for apistage0 in apiStages {
                try apiStagesContainer.encode(apistage0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let quota = self.quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let throttle = self.throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([APIGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[APIGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [APIGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// Represents a usage plan used to specify who can assess associated API stages. Optionally, target request rate and quota limits can be set. In some cases clients can exceed the targets that you set. Dont rely on usage plans to control costs. Consider using [Amazon Web Services Budgets](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
    public struct UsagePlan: Swift.Equatable {
        /// The associated API stages of a usage plan.
        public var apiStages: [APIGatewayClientTypes.ApiStage]?
        /// The description of a usage plan.
        public var description: Swift.String?
        /// The identifier of a UsagePlan resource.
        public var id: Swift.String?
        /// The name of a usage plan.
        public var name: Swift.String?
        /// The Amazon Web Services Marketplace product identifier to associate with the usage plan as a SaaS product on the Amazon Web Services Marketplace.
        public var productCode: Swift.String?
        /// The target maximum number of permitted requests per a given unit time interval.
        public var quota: APIGatewayClientTypes.QuotaSettings?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// A map containing method level throttling information for API stage in a usage plan.
        public var throttle: APIGatewayClientTypes.ThrottleSettings?

        public init(
            apiStages: [APIGatewayClientTypes.ApiStage]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            quota: APIGatewayClientTypes.QuotaSettings? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            throttle: APIGatewayClientTypes.ThrottleSettings? = nil
        )
        {
            self.apiStages = apiStages
            self.description = description
            self.id = id
            self.name = name
            self.productCode = productCode
            self.quota = quota
            self.tags = tags
            self.throttle = throttle
        }
    }

}

extension APIGatewayClientTypes.UsagePlanKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension APIGatewayClientTypes {
    /// Represents a usage plan key to identify a plan customer.
    public struct UsagePlanKey: Swift.Equatable {
        /// The Id of a usage plan key.
        public var id: Swift.String?
        /// The name of a usage plan key.
        public var name: Swift.String?
        /// The type of a usage plan key. Currently, the valid key type is API_KEY.
        public var type: Swift.String?
        /// The value of a usage plan key.
        public var value: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension APIGatewayClientTypes.VpcLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOfStringToString0) in tags {
                try tagsContainer.encode(mapOfStringToString0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for string0 in targetArns {
                try targetArnsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(APIGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension APIGatewayClientTypes {
    /// An API Gateway VPC link for a RestApi to access resources in an Amazon Virtual Private Cloud (VPC).
    public struct VpcLink: Swift.Equatable {
        /// The description of the VPC link.
        public var description: Swift.String?
        /// The identifier of the VpcLink. It is used in an Integration to reference this VpcLink.
        public var id: Swift.String?
        /// The name used to label and identify the VPC link.
        public var name: Swift.String?
        /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
        public var status: APIGatewayClientTypes.VpcLinkStatus?
        /// A description about the VPC link status.
        public var statusMessage: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same Amazon Web Services account of the API owner.
        public var targetArns: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: APIGatewayClientTypes.VpcLinkStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetArns: [Swift.String]? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.targetArns = targetArns
        }
    }

}

extension APIGatewayClientTypes {
    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
        }
    }
}
