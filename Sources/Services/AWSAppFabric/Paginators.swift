// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AppFabricClient {
    /// Paginate over `[ListAppAuthorizationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppAuthorizationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppAuthorizationsOutputResponse`
    public func listAppAuthorizationsPaginated(input: ListAppAuthorizationsInput) -> ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutputResponse>(input: input, inputKey: \ListAppAuthorizationsInput.nextToken, outputKey: \ListAppAuthorizationsOutputResponse.nextToken, paginationFunction: self.listAppAuthorizations(input:))
    }
}

extension ListAppAuthorizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppAuthorizationsInput {
        return ListAppAuthorizationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAppAuthorizationsInput, Output == ListAppAuthorizationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAppAuthorizationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppAuthorizationSummary]`
    /// - Returns: `[AppFabricClientTypes.AppAuthorizationSummary]`
    public func appAuthorizationSummaryList() async throws -> [AppFabricClientTypes.AppAuthorizationSummary] {
        return try await self.asyncCompactMap { item in item.appAuthorizationSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListAppBundlesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppBundlesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppBundlesOutputResponse`
    public func listAppBundlesPaginated(input: ListAppBundlesInput) -> ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutputResponse>(input: input, inputKey: \ListAppBundlesInput.nextToken, outputKey: \ListAppBundlesOutputResponse.nextToken, paginationFunction: self.listAppBundles(input:))
    }
}

extension ListAppBundlesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppBundlesInput {
        return ListAppBundlesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAppBundlesInput, Output == ListAppBundlesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAppBundlesPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppBundleSummary]`
    /// - Returns: `[AppFabricClientTypes.AppBundleSummary]`
    public func appBundleSummaryList() async throws -> [AppFabricClientTypes.AppBundleSummary] {
        return try await self.asyncCompactMap { item in item.appBundleSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionDestinationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionDestinationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionDestinationsOutputResponse`
    public func listIngestionDestinationsPaginated(input: ListIngestionDestinationsInput) -> ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutputResponse>(input: input, inputKey: \ListIngestionDestinationsInput.nextToken, outputKey: \ListIngestionDestinationsOutputResponse.nextToken, paginationFunction: self.listIngestionDestinations(input:))
    }
}

extension ListIngestionDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionDestinationsInput {
        return ListIngestionDestinationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            ingestionIdentifier: self.ingestionIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionDestinationsInput, Output == ListIngestionDestinationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionDestinationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionDestinationSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionDestinationSummary]`
    public func ingestionDestinations() async throws -> [AppFabricClientTypes.IngestionDestinationSummary] {
        return try await self.asyncCompactMap { item in item.ingestionDestinations }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutputResponse`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse>(input: input, inputKey: \ListIngestionsInput.nextToken, outputKey: \ListIngestionsOutputResponse.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionsInput, Output == ListIngestionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionSummary]`
    public func ingestions() async throws -> [AppFabricClientTypes.IngestionSummary] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
