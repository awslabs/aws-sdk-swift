// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AppFabricClient {
    /// Paginate over `[ListAppAuthorizationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppAuthorizationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppAuthorizationsOutput`
    public func listAppAuthorizationsPaginated(input: ListAppAuthorizationsInput) -> ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutput>(input: input, inputKey: \ListAppAuthorizationsInput.nextToken, outputKey: \ListAppAuthorizationsOutput.nextToken, paginationFunction: self.listAppAuthorizations(input:))
    }
}

extension ListAppAuthorizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppAuthorizationsInput {
        return ListAppAuthorizationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAppAuthorizationsInput, Output == ListAppAuthorizationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppAuthorizationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppAuthorizationSummary]`
    /// - Returns: `[AppFabricClientTypes.AppAuthorizationSummary]`
    public func appAuthorizationSummaryList() async throws -> [AppFabricClientTypes.AppAuthorizationSummary] {
        return try await self.asyncCompactMap { item in item.appAuthorizationSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListAppBundlesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppBundlesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppBundlesOutput`
    public func listAppBundlesPaginated(input: ListAppBundlesInput) -> ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutput> {
        return ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutput>(input: input, inputKey: \ListAppBundlesInput.nextToken, outputKey: \ListAppBundlesOutput.nextToken, paginationFunction: self.listAppBundles(input:))
    }
}

extension ListAppBundlesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppBundlesInput {
        return ListAppBundlesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAppBundlesInput, Output == ListAppBundlesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppBundlesPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppBundleSummary]`
    /// - Returns: `[AppFabricClientTypes.AppBundleSummary]`
    public func appBundleSummaryList() async throws -> [AppFabricClientTypes.AppBundleSummary] {
        return try await self.asyncCompactMap { item in item.appBundleSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionDestinationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionDestinationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionDestinationsOutput`
    public func listIngestionDestinationsPaginated(input: ListIngestionDestinationsInput) -> ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutput> {
        return ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutput>(input: input, inputKey: \ListIngestionDestinationsInput.nextToken, outputKey: \ListIngestionDestinationsOutput.nextToken, paginationFunction: self.listIngestionDestinations(input:))
    }
}

extension ListIngestionDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionDestinationsInput {
        return ListIngestionDestinationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            ingestionIdentifier: self.ingestionIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionDestinationsInput, Output == ListIngestionDestinationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionDestinationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionDestinationSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionDestinationSummary]`
    public func ingestionDestinations() async throws -> [AppFabricClientTypes.IngestionDestinationSummary] {
        return try await self.asyncCompactMap { item in item.ingestionDestinations }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutput`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput>(input: input, inputKey: \ListIngestionsInput.nextToken, outputKey: \ListIngestionsOutput.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionsInput, Output == ListIngestionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionSummary]`
    public func ingestions() async throws -> [AppFabricClientTypes.IngestionSummary] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
